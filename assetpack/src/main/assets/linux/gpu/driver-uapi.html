<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>DRM Driver uAPI &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Kernel clients" href="drm-client.html" />
    <link rel="prev" title="DRM client usage stats" href="drm-usage-stats.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.14.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../input/index.html">Input Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gpu/driver-uapi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="drm-driver-uapi">
<h1>DRM Driver uAPI<a class="headerlink" href="#drm-driver-uapi" title="Link to this heading">¶</a></h1>
<section id="drm-i915-uapi">
<h2>drm/i915 uAPI<a class="headerlink" href="#drm-i915-uapi" title="Link to this heading">¶</a></h2>
<p id="uevents-generated-by-i915-on-its-device-node"><strong>uevents generated by i915 on its device node</strong></p>
<dl class="simple">
<dt>I915_L3_PARITY_UEVENT - Generated when the driver receives a parity mismatch</dt><dd><p>event from the GPU L3 cache. Additional information supplied is ROW,
BANK, SUBBANK, SLICE of the affected cacheline. Userspace should keep
track of these events, and if a specific cache-line seems to have a
persistent error, remap it with the L3 remapping tool supplied in
intel-gpu-tools.  The value supplied with the event is always 1.</p>
</dd>
<dt>I915_ERROR_UEVENT - Generated upon error detection, currently only via</dt><dd><p>hangcheck. The error detection event is a good indicator of when things
began to go badly. The value supplied with the event is a 1 upon error
detection, and a 0 upon reset completion, signifying no more error
exists. NOTE: Disabling hangcheck or reset via module parameter will
cause the related events to not be seen.</p>
</dd>
<dt>I915_RESET_UEVENT - Event is generated just before an attempt to reset the</dt><dd><p>GPU. The value supplied with the event is always 1. NOTE: Disable
reset via module parameter will cause this event to not be seen.</p>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.i915_user_extension">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i915_user_extension</span></span></span><a class="headerlink" href="#c.i915_user_extension" title="Link to this definition">¶</a><br /></dt>
<dd><p>Base class for defining a chain of extensions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_user_extension {
    __u64 next_extension;
    __u32 name;
    __u32 flags;
    __u32 rsvd[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">next_extension</span></code></dt><dd><p>Pointer to the next <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>, or zero if the end.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the extension.</p>
<p>Note that the name here is just some integer.</p>
<p>Also note that the name space for this is not global for the whole
driver, but rather its scope/meaning is limited to the specific piece
of uAPI which has embedded the <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>MBZ</p>
<p>All undefined bits must be zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt><dd><p>MBZ</p>
<p>Reserved for future use; must be zero.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Many interfaces need to grow over time. In most cases we can simply
extend the struct and have userspace pass in more data. Another option,
as demonstrated by Vulkan’s approach to providing extensions for forward
and backward compatibility, is to use a list of optional structs to
provide those extra details.</p>
<p>The key advantage to using an extension chain is that it allows us to
redefine the interface more easily than an ever growing struct of
increasing complexity, and for large parts of that interface to be
entirely optional. The downside is more pointer chasing; chasing across
the __user boundary with pointers encapsulated inside u64.</p>
<p>Example chaining:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">i915_user_extension</span><span class="w"> </span><span class="n">ext3</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// end</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">i915_user_extension</span><span class="w"> </span><span class="n">ext2</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext3</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">i915_user_extension</span><span class="w"> </span><span class="n">ext1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext2</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Typically the <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a> would be embedded in some uAPI
struct, and in this case we would feed it the head of the chain(i.e ext1),
which would then apply all of the above extensions.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_i915_gem_engine_class">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_engine_class</span></span></span><a class="headerlink" href="#c.drm_i915_gem_engine_class" title="Link to this definition">¶</a><br /></dt>
<dd><p>uapi engine type enumeration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_RENDER</span></code></dt><dd><p>Render engines support instructions used for 3D, Compute (GPGPU),
and programmable media workloads.  These instructions fetch data and
dispatch individual work items to threads that operate in parallel.
The threads run small programs (called “kernels” or “shaders”) on
the GPU’s execution units (EUs).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_COPY</span></code></dt><dd><p>Copy engines (also referred to as “blitters”) support instructions
that move blocks of data from one location in memory to another,
or that fill a specified location of memory with fixed data.
Copy engines can perform pre-defined logical or bitwise operations
on the source, destination, or pattern data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_VIDEO</span></code></dt><dd><p>Video engines (also referred to as “bit stream decode” (BSD) or
“vdbox”) support instructions that perform fixed-function media
decode and encode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_VIDEO_ENHANCE</span></code></dt><dd><p>Video enhancement engines (also referred to as “vebox”) support
instructions related to image enhancement.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_COMPUTE</span></code></dt><dd><p>Compute engines support a subset of the instructions available
on render engines:  compute engines support Compute (GPGPU) and
programmable media workloads, but do not support the 3D pipeline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_INVALID</span></code></dt><dd><p>Placeholder value to represent an invalid engine class assignment.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Different engines serve different roles, and there may be more than one
engine serving each role.  This enum provides a classification of the role
of the engine, which may be used when requesting operations to be performed
on a certain subset of engines, or for providing information about that
group.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.i915_engine_class_instance">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i915_engine_class_instance</span></span></span><a class="headerlink" href="#c.i915_engine_class_instance" title="Link to this definition">¶</a><br /></dt>
<dd><p>Engine class/instance identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_engine_class_instance {
    __u16 engine_class;
#define I915_ENGINE_CLASS_INVALID_NONE -1;
#define I915_ENGINE_CLASS_INVALID_VIRTUAL -2;
    __u16 engine_instance;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">engine_class</span></code></dt><dd><p>Engine class from <a class="reference internal" href="#c.drm_i915_gem_engine_class" title="drm_i915_gem_engine_class"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_i915_gem_engine_class</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine_instance</span></code></dt><dd><p>Engine instance.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>There may be more than one engine fulfilling any role within the system.
Each engine of a class is given a unique instance number and therefore
any engine can be specified by its class:instance tuplet. APIs that allow
access to any engine in the system will use <a class="reference internal" href="#c.i915_engine_class_instance" title="i915_engine_class_instance"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_engine_class_instance</span></code></a>
for this identification.</p>
<p id="perf-events-exposed-by-i915-through-sys-bus-event-sources-drivers-i915"><strong>perf_events exposed by i915 through /sys/bus/event_sources/drivers/i915</strong></p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_getparam">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_getparam</span></span></span><a class="headerlink" href="#c.drm_i915_getparam" title="Link to this definition">¶</a><br /></dt>
<dd><p>Driver parameter query structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_getparam {
    __s32 param;
    int __user *value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>Driver parameter to query.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>Address of memory where queried value should be put.</p>
<p>WARNING: Using pointers instead of fixed-size u64 means we need to write
compat32 code. Don’t repeat this mistake.</p>
</dd>
</dl>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.drm_i915_getparam_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_getparam_t</span></span></span><a class="headerlink" href="#c.drm_i915_getparam_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>Driver parameter query structure. See <a class="reference internal" href="#c.drm_i915_getparam" title="drm_i915_getparam"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_getparam</span></code></a>.</p>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_mmap_offset">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_mmap_offset</span></span></span><a class="headerlink" href="#c.drm_i915_gem_mmap_offset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Retrieve an offset so we can mmap this buffer object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_mmap_offset {
    __u32 handle;
    __u32 pad;
    __u64 offset;
    __u64 flags;
#define I915_MMAP_OFFSET_GTT    0;
#define I915_MMAP_OFFSET_WC     1;
#define I915_MMAP_OFFSET_WB     2;
#define I915_MMAP_OFFSET_UC     3;
#define I915_MMAP_OFFSET_FIXED  4;
    __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle for the object being mapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Must be zero</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>The fake offset to use for subsequent mmap call</p>
<p>This is a fixed-size type for 32/64 compatibility.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags for extended behaviour.</p>
<p>It is mandatory that one of the <cite>MMAP_OFFSET</cite> types
should be included:</p>
<ul class="simple">
<li><p><cite>I915_MMAP_OFFSET_GTT</cite>: Use mmap with the object bound to GTT. (Write-Combined)</p></li>
<li><p><cite>I915_MMAP_OFFSET_WC</cite>: Use Write-Combined caching.</p></li>
<li><p><cite>I915_MMAP_OFFSET_WB</cite>: Use Write-Back caching.</p></li>
<li><p><cite>I915_MMAP_OFFSET_FIXED</cite>: Use object placement to determine caching.</p></li>
</ul>
<p>On devices with local memory <cite>I915_MMAP_OFFSET_FIXED</cite> is the only valid
type. On devices without local memory, this caching mode is invalid.</p>
<p>As caching mode when specifying <cite>I915_MMAP_OFFSET_FIXED</cite>, WC or WB will
be used, depending on the object placement on creation. WB will be used
when the object can only exist in system memory, WC otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
<p>No current extensions defined; mbz.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct is passed as argument to the <cite>DRM_IOCTL_I915_GEM_MMAP_OFFSET</cite> ioctl,
and is used to retrieve the fake offset to mmap an object specified by <code class="xref c c-type docutils literal notranslate"><span class="pre">handle</span></code>.</p>
<p>The legacy way of using <cite>DRM_IOCTL_I915_GEM_MMAP</cite> is removed on gen12+.
<cite>DRM_IOCTL_I915_GEM_MMAP_GTT</cite> is an older supported alias to this struct, but will behave
as setting the <code class="xref c c-type docutils literal notranslate"><span class="pre">extensions</span></code> to 0, and <code class="xref c c-type docutils literal notranslate"><span class="pre">flags</span></code> to <cite>I915_MMAP_OFFSET_GTT</cite>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_set_domain">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_set_domain</span></span></span><a class="headerlink" href="#c.drm_i915_gem_set_domain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Adjust the objects write or read domain, in preparation for accessing the pages via some CPU domain.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_set_domain {
    __u32 handle;
    __u32 read_domains;
    __u32 write_domain;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle for the object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_domains</span></code></dt><dd><p>New read domains.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_domain</span></code></dt><dd><p>New write domain.</p>
<p>Note that having something in the write domain implies it’s in the
read domain, and only that read domain.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Specifying a new write or read domain will flush the object out of the
previous domain(if required), before then updating the objects domain
tracking with the new domain.</p>
<p>Note this might involve waiting for the object first if it is still active on
the GPU.</p>
<p>Supported values for <strong>read_domains</strong> and <strong>write_domain</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>I915_GEM_DOMAIN_WC: Uncached write-combined domain</p></li>
<li><p>I915_GEM_DOMAIN_CPU: CPU cache domain</p></li>
<li><p>I915_GEM_DOMAIN_GTT: Mappable aperture domain</p></li>
</ul>
</div></blockquote>
<p>All other domains are rejected.</p>
<p>Note that for discrete, starting from DG1, this is no longer supported, and
is instead rejected. On such platforms the CPU domain is effectively static,
where we also only support a single <a class="reference internal" href="#c.drm_i915_gem_mmap_offset" title="drm_i915_gem_mmap_offset"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_mmap_offset</span></code></a> cache mode,
which can’t be set explicitly and instead depends on the object placements,
as per the below.</p>
<p>Implicit caching rules, starting from DG1:</p>
<blockquote>
<div><ul class="simple">
<li><p>If any of the object placements (see <a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>)
contain I915_MEMORY_CLASS_DEVICE then the object will be allocated and
mapped as write-combined only.</p></li>
<li><p>Everything else is always allocated and mapped as write-back, with the
guarantee that everything is also coherent with the GPU.</p></li>
</ul>
</div></blockquote>
<p>Note that this is likely to change in the future again, where we might need
more flexibility on future devices, so making this all explicit as part of a
new <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext</span></code></a> extension is probable.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_exec_fence">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_exec_fence</span></span></span><a class="headerlink" href="#c.drm_i915_gem_exec_fence" title="Link to this definition">¶</a><br /></dt>
<dd><p>An input or output fence for the execbuf ioctl.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_exec_fence {
    __u32 handle;
    __u32 flags;
#define I915_EXEC_FENCE_WAIT            (1&lt;&lt;0);
#define I915_EXEC_FENCE_SIGNAL          (1&lt;&lt;1);
#define __I915_EXEC_FENCE_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_SIGNAL &lt;&lt; 1));
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>User’s handle for a drm_syncobj to wait on or signal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Supported flags are:</p>
<p>I915_EXEC_FENCE_WAIT:
Wait for the input fence before request submission.</p>
<p>I915_EXEC_FENCE_SIGNAL:
Return request completion fence as output</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The request will wait for input fence to signal before submission.</p>
<p>The returned output fence will be signaled after the completion of the
request.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_execbuffer_ext_timeline_fences">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_execbuffer_ext_timeline_fences</span></span></span><a class="headerlink" href="#c.drm_i915_gem_execbuffer_ext_timeline_fences" title="Link to this definition">¶</a><br /></dt>
<dd><p>Timeline fences for execbuf ioctl.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_execbuffer_ext_timeline_fences {
#define DRM_I915_GEM_EXECBUFFER_EXT_TIMELINE_FENCES 0;
    struct i915_user_extension base;
    __u64 fence_count;
    __u64 handles_ptr;
    __u64 values_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_count</span></code></dt><dd><p>Number of elements in the <strong>handles_ptr</strong> &amp; <strong>value_ptr</strong>
arrays.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handles_ptr</span></code></dt><dd><p>Pointer to an array of <a class="reference internal" href="#c.drm_i915_gem_exec_fence" title="drm_i915_gem_exec_fence"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_exec_fence</span></code></a>
of length <strong>fence_count</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">values_ptr</span></code></dt><dd><p>Pointer to an array of u64 values of length
<strong>fence_count</strong>.
Values must be 0 for a binary drm_syncobj. A Value of 0 for a
timeline drm_syncobj is invalid as it turns a drm_syncobj into a
binary one.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure describes an array of drm_syncobj and associated points for
timeline variants of drm_syncobj. It is invalid to append this structure to
the execbuf if I915_EXEC_FENCE_ARRAY is set.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_execbuffer2">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_execbuffer2</span></span></span><a class="headerlink" href="#c.drm_i915_gem_execbuffer2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Structure for DRM_I915_GEM_EXECBUFFER2 ioctl.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_execbuffer2 {
    __u64 buffers_ptr;
    __u32 buffer_count;
    __u32 batch_start_offset;
    __u32 batch_len;
    __u32 DR1;
    __u32 DR4;
    __u32 num_cliprects;
    __u64 cliprects_ptr;
    __u64 flags;
#define I915_EXEC_RING_MASK              (0x3f);
#define I915_EXEC_DEFAULT                (0&lt;&lt;0);
#define I915_EXEC_RENDER                 (1&lt;&lt;0);
#define I915_EXEC_BSD                    (2&lt;&lt;0);
#define I915_EXEC_BLT                    (3&lt;&lt;0);
#define I915_EXEC_VEBOX                  (4&lt;&lt;0);
#define I915_EXEC_CONSTANTS_MASK        (3&lt;&lt;6);
#define I915_EXEC_CONSTANTS_REL_GENERAL (0&lt;&lt;6) ;
#define I915_EXEC_CONSTANTS_ABSOLUTE    (1&lt;&lt;6);
#define I915_EXEC_CONSTANTS_REL_SURFACE (2&lt;&lt;6) ;
#define I915_EXEC_GEN7_SOL_RESET        (1&lt;&lt;8);
#define I915_EXEC_SECURE                (1&lt;&lt;9);
#define I915_EXEC_IS_PINNED             (1&lt;&lt;10);
#define I915_EXEC_NO_RELOC              (1&lt;&lt;11);
#define I915_EXEC_HANDLE_LUT            (1&lt;&lt;12);
#define I915_EXEC_BSD_SHIFT      (13);
#define I915_EXEC_BSD_MASK       (3 &lt;&lt; I915_EXEC_BSD_SHIFT);
#define I915_EXEC_BSD_DEFAULT    (0 &lt;&lt; I915_EXEC_BSD_SHIFT);
#define I915_EXEC_BSD_RING1      (1 &lt;&lt; I915_EXEC_BSD_SHIFT);
#define I915_EXEC_BSD_RING2      (2 &lt;&lt; I915_EXEC_BSD_SHIFT);
#define I915_EXEC_RESOURCE_STREAMER     (1&lt;&lt;15);
#define I915_EXEC_FENCE_IN              (1&lt;&lt;16);
#define I915_EXEC_FENCE_OUT             (1&lt;&lt;17);
#define I915_EXEC_BATCH_FIRST           (1&lt;&lt;18);
#define I915_EXEC_FENCE_ARRAY   (1&lt;&lt;19);
#define I915_EXEC_FENCE_SUBMIT          (1 &lt;&lt; 20);
#define I915_EXEC_USE_EXTENSIONS        (1 &lt;&lt; 21);
#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_USE_EXTENSIONS &lt;&lt; 1));
    __u64 rsvd1;
    __u64 rsvd2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">buffers_ptr</span></code></dt><dd><p>Pointer to a list of gem_exec_object2 structs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer_count</span></code></dt><dd><p>Number of elements in <strong>buffers_ptr</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">batch_start_offset</span></code></dt><dd><p>Offset in the batchbuffer to start execution
from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">batch_len</span></code></dt><dd><p>Length in bytes of the batch buffer, starting from the
<strong>batch_start_offset</strong>. If 0, length is assumed to be the batch buffer
object size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DR1</span></code></dt><dd><p>deprecated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DR4</span></code></dt><dd><p>deprecated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_cliprects</span></code></dt><dd><p>See <strong>cliprects_ptr</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cliprects_ptr</span></code></dt><dd><p>Kernel clipping was a DRI1 misfeature.</p>
<p>It is invalid to use this field if I915_EXEC_FENCE_ARRAY or
I915_EXEC_USE_EXTENSIONS flags are not set.</p>
<p>If I915_EXEC_FENCE_ARRAY is set, then this is a pointer to an array
of <a class="reference internal" href="#c.drm_i915_gem_exec_fence" title="drm_i915_gem_exec_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_exec_fence</span></code></a> and <strong>num_cliprects</strong> is the length of the
array.</p>
<p>If I915_EXEC_USE_EXTENSIONS is set, then this is a pointer to a
single <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">i915_user_extension</span></code></a> and num_cliprects is 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Execbuf flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt><dd><p>Context id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd2</span></code></dt><dd><p>in and out sync_file file descriptors.</p>
<p>When I915_EXEC_FENCE_IN or I915_EXEC_FENCE_SUBMIT flag is set, the
lower 32 bits of this field will have the in sync_file fd (input).</p>
<p>When I915_EXEC_FENCE_OUT flag is set, the upper 32 bits of this
field will have the out sync_file fd (output).</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_caching">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_caching</span></span></span><a class="headerlink" href="#c.drm_i915_gem_caching" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set or get the caching for given object handle.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_caching {
    __u32 handle;
#define I915_CACHING_NONE               0;
#define I915_CACHING_CACHED             1;
#define I915_CACHING_DISPLAY            2;
    __u32 caching;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle of the buffer to set/get the caching level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caching</span></code></dt><dd><p>The GTT caching level to apply or possible return value.</p>
<p>The supported <strong>caching</strong> values:</p>
<p>I915_CACHING_NONE:</p>
<p>GPU access is not coherent with CPU caches.  Default for machines
without an LLC. This means manual flushing might be needed, if we
want GPU access to be coherent.</p>
<p>I915_CACHING_CACHED:</p>
<p>GPU access is coherent with CPU caches and furthermore the data is
cached in last-level caches shared between CPU cores and the GPU GT.</p>
<p>I915_CACHING_DISPLAY:</p>
<p>Special GPU caching mode which is coherent with the scanout engines.
Transparently falls back to I915_CACHING_NONE on platforms where no
special cache mode (like write-through or gfdt flushing) is
available. The kernel automatically sets this mode when using a
buffer as a scanout target.  Userspace can manually set this mode to
avoid a costly stall and clflush in the hotpath of drawing the first
frame.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Allow userspace to control the GTT caching bits for a given object when the
object is later mapped through the ppGTT(or GGTT on older platforms lacking
ppGTT support, or if the object is used for scanout). Note that this might
require unbinding the object from the GTT first, if its current caching value
doesn’t match.</p>
<p>Note that this all changes on discrete platforms, starting from DG1, the
set/get caching is no longer supported, and is now rejected.  Instead the CPU
caching attributes(WB vs WC) will become an immutable creation time property
for the object, along with the GTT caching level. For now we don’t expose any
new uAPI for this, instead on DG1 this is all implicit, although this largely
shouldn’t matter since DG1 is coherent by default(without any way of
controlling it).</p>
<p>Implicit caching rules, starting from DG1:</p>
<blockquote>
<div><ul class="simple">
<li><p>If any of the object placements (see <a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>)
contain I915_MEMORY_CLASS_DEVICE then the object will be allocated and
mapped as write-combined only.</p></li>
<li><p>Everything else is always allocated and mapped as write-back, with the
guarantee that everything is also coherent with the GPU.</p></li>
</ul>
</div></blockquote>
<p>Note that this is likely to change in the future again, where we might need
more flexibility on future devices, so making this all explicit as part of a
new <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext</span></code></a> extension is probable.</p>
<p>Side note: Part of the reason for this is that changing the at-allocation-time CPU
caching attributes for the pages might be required(and is expensive) if we
need to then CPU map the pages later with different caching attributes. This
inconsistent caching behaviour, while supported on x86, is not universally
supported on other architectures. So for simplicity we opt for setting
everything at creation time, whilst also making it immutable, on discrete
platforms.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_context_create_ext">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_context_create_ext</span></span></span><a class="headerlink" href="#c.drm_i915_gem_context_create_ext" title="Link to this definition">¶</a><br /></dt>
<dd><p>Structure for creating contexts.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_context_create_ext {
    __u32 ctx_id;
    __u32 flags;
#define I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS        (1u &lt;&lt; 0);
#define I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE       (1u &lt;&lt; 1);
#define I915_CONTEXT_CREATE_FLAGS_UNKNOWN       (-(I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE &lt;&lt; 1));
    __u64 extensions;
#define I915_CONTEXT_CREATE_EXT_SETPARAM 0;
#define I915_CONTEXT_CREATE_EXT_CLONE 1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ctx_id</span></code></dt><dd><p>Id of the created context (output)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Supported flags are:</p>
<p>I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS:</p>
<p>Extensions may be appended to this structure and driver must check
for those. See <strong>extensions</strong>.</p>
<p>I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE</p>
<p>Created context will have single timeline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
<p>I915_CONTEXT_CREATE_EXT_SETPARAM:
Context parameter to set or query during context creation.
See <a class="reference internal" href="#c.drm_i915_gem_context_create_ext_setparam" title="drm_i915_gem_context_create_ext_setparam"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_context_create_ext_setparam</span></code></a>.</p>
<p>I915_CONTEXT_CREATE_EXT_CLONE:
This extension has been removed. On the off chance someone somewhere
has attempted to use it, never re-use this extension number.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_context_param">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_context_param</span></span></span><a class="headerlink" href="#c.drm_i915_gem_context_param" title="Link to this definition">¶</a><br /></dt>
<dd><p>Context parameter to set or query.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_context_param {
    __u32 ctx_id;
    __u32 size;
    __u64 param;
#define I915_CONTEXT_PARAM_BAN_PERIOD   0x1;
#define I915_CONTEXT_PARAM_NO_ZEROMAP   0x2;
#define I915_CONTEXT_PARAM_GTT_SIZE     0x3;
#define I915_CONTEXT_PARAM_NO_ERROR_CAPTURE     0x4;
#define I915_CONTEXT_PARAM_BANNABLE     0x5;
#define I915_CONTEXT_PARAM_PRIORITY     0x6;
#define I915_CONTEXT_MAX_USER_PRIORITY        1023 ;
#define I915_CONTEXT_DEFAULT_PRIORITY         0;
#define I915_CONTEXT_MIN_USER_PRIORITY        -1023 ;
#define I915_CONTEXT_PARAM_SSEU         0x7;
#define I915_CONTEXT_PARAM_RECOVERABLE  0x8;
#define I915_CONTEXT_PARAM_VM           0x9;
#define I915_CONTEXT_PARAM_ENGINES      0xa;
#define I915_CONTEXT_PARAM_PERSISTENCE  0xb;
#define I915_CONTEXT_PARAM_RINGSIZE     0xc;
#define I915_CONTEXT_PARAM_PROTECTED_CONTENT    0xd;
#define I915_CONTEXT_PARAM_LOW_LATENCY          0xe;
#define I915_CONTEXT_PARAM_CONTEXT_IMAGE        0xf;
    __u64 value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ctx_id</span></code></dt><dd><p>Context id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the parameter <strong>value</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>Parameter to set or query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>Context parameter value to be set or queried</p>
</dd>
</dl>
</div>
<p id="virtual-engine-uapi"><strong>Virtual Engine uAPI</strong></p>
<p>Virtual engine is a concept where userspace is able to configure a set of
physical engines, submit a batch buffer, and let the driver execute it on any
engine from the set as it sees fit.</p>
<p>This is primarily useful on parts which have multiple instances of a same
class engine, like for example GT3+ Skylake parts with their two VCS engines.</p>
<p>For instance userspace can enumerate all engines of a certain class using the
previously described <a class="reference internal" href="#engine-discovery-uapi">Engine Discovery uAPI</a>. After that userspace can
create a GEM context with a placeholder slot for the virtual engine (using
<cite>I915_ENGINE_CLASS_INVALID</cite> and <cite>I915_ENGINE_CLASS_INVALID_NONE</cite> for class
and instance respectively) and finally using the
<cite>I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE</cite> extension place a virtual engine in
the same reserved slot.</p>
<p>Example of creating a virtual engine and submitting a batch buffer to it:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">I915_DEFINE_CONTEXT_ENGINES_LOAD_BALANCE</span><span class="p">(</span><span class="n">virtual</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">engine_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// Place this virtual engine into engine map slot 0</span>
<span class="w">        </span><span class="p">.</span><span class="n">num_siblings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_VIDEO</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">                     </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_VIDEO</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>
<span class="n">I915_DEFINE_CONTEXT_PARAM_ENGINES</span><span class="p">(</span><span class="n">engines</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_INVALID</span><span class="p">,</span>
<span class="w">                       </span><span class="n">I915_ENGINE_CLASS_INVALID_NONE</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virtual</span><span class="p">),</span><span class="w"> </span><span class="c1">// Chains after load_balance extension</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_context_create_ext_setparam</span><span class="w"> </span><span class="n">p_engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_CREATE_EXT_SETPARAM</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_PARAM_ENGINES</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engines</span><span class="p">),</span>
<span class="w">                </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">engines</span><span class="p">),</span>
<span class="w">        </span><span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_context_create_ext</span><span class="w"> </span><span class="n">create</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_engines</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">ctx_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gem_context_create_ext</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create</span><span class="p">);</span>

<span class="c1">// Now we have created a GEM context with its engine map containing a</span>
<span class="c1">// single virtual engine. Submissions to this slot can go either to</span>
<span class="c1">// vcs0 or vcs1, depending on the load balancing algorithm used inside</span>
<span class="c1">// the driver. The load balancing is dynamic from one batch buffer to</span>
<span class="c1">// another and transparent to userspace.</span>

<span class="p">...</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx_id</span><span class="p">;</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Submits to index 0 which is the virtual engine</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.i915_context_engines_parallel_submit">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i915_context_engines_parallel_submit</span></span></span><a class="headerlink" href="#c.i915_context_engines_parallel_submit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Configure engine for parallel submission.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_context_engines_parallel_submit {
    struct i915_user_extension base;
    __u16 engine_index;
    __u16 width;
    __u16 num_siblings;
    __u16 mbz16;
    __u64 flags;
    __u64 mbz64[3];
    struct i915_engine_class_instance engines[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base user extension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine_index</span></code></dt><dd><p>slot for parallel engine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>number of contexts per parallel engine or in other words the
number of batches in each submission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_siblings</span></code></dt><dd><p>number of siblings per context or in other words the
number of possible placements for each submission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mbz16</span></code></dt><dd><p>reserved for future use; must be zero</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>all undefined flags must be zero, currently not defined flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mbz64</span></code></dt><dd><p>reserved for future use; must be zero</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engines</span></code></dt><dd><p>2-d array of engine instances to configure parallel engine</p>
<p>length = width (i) * num_siblings (j)
index = j + i * num_siblings</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Setup a slot in the context engine map to allow multiple BBs to be submitted
in a single execbuf IOCTL. Those BBs will then be scheduled to run on the GPU
in parallel. Multiple hardware contexts are created internally in the i915 to
run these BBs. Once a slot is configured for N BBs only N BBs can be
submitted in each execbuf IOCTL and this is implicit behavior e.g. The user
doesn’t tell the execbuf IOCTL there are N BBs, the execbuf IOCTL knows how
many BBs there are based on the slot’s configuration. The N BBs are the last
N buffer objects or first N if I915_EXEC_BATCH_FIRST is set.</p>
<p>The default placement behavior is to create implicit bonds between each
context if each context maps to more than 1 physical engine (e.g. context is
a virtual engine). Also we only allow contexts of same engine class and these
contexts must be in logically contiguous order. Examples of the placement
behavior are described below. Lastly, the default is to not allow BBs to be
preempted mid-batch. Rather insert coordinated preemption points on all
hardware contexts between each set of BBs. Flags could be added in the future
to change both of these default behaviors.</p>
<p>Returns -EINVAL if hardware context placement configuration is invalid or if
the placement configuration isn’t supported on the platform / submission
interface.
Returns -ENODEV if extension isn’t supported on the platform / submission
interface.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Examples syntax:
CS[X] = generic engine of same class, logical instance X
INVALID = I915_ENGINE_CLASS_INVALID, I915_ENGINE_CLASS_INVALID_NONE

Example 1 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=1,
             engines=CS[0],CS[1])

Results in the following valid placement:
CS[0], CS[1]

Example 2 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=2,
             engines=CS[0],CS[2],CS[1],CS[3])

Results in the following valid placements:
CS[0], CS[1]
CS[2], CS[3]

This can be thought of as two virtual engines, each containing two
engines thereby making a 2D array. However, there are bonds tying the
entries together and placing restrictions on how they can be scheduled.
Specifically, the scheduler can choose only vertical columns from the 2D
array. That is, CS[0] is bonded to CS[1] and CS[2] to CS[3]. So if the
scheduler wants to submit to CS[0], it must also choose CS[1] and vice
versa. Same for CS[2] requires also using CS[3].
VE[0] = CS[0], CS[2]
VE[1] = CS[1], CS[3]

Example 3 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=2,
             engines=CS[0],CS[1],CS[1],CS[3])

Results in the following valid and invalid placements:
CS[0], CS[1]
CS[1], CS[3] - Not logically contiguous, return -EINVAL
</pre></div>
</div>
<p id="context-engine-map-uapi"><strong>Context Engine Map uAPI</strong></p>
<p>Context engine map is a new way of addressing engines when submitting batch-
buffers, replacing the existing way of using identifiers like <cite>I915_EXEC_BLT</cite>
inside the flags field of <cite><a class="reference internal" href="#c.drm_i915_gem_execbuffer2" title="drm_i915_gem_execbuffer2"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_execbuffer2</span></code></a></cite>.</p>
<p>To use it created GEM contexts need to be configured with a list of engines
the user is intending to submit to. This is accomplished using the
<cite>I915_CONTEXT_PARAM_ENGINES</cite> parameter and <cite>struct
i915_context_param_engines</cite>.</p>
<p>For such contexts the <cite>I915_EXEC_RING_MASK</cite> field becomes an index into the
configured map.</p>
<p>Example of creating such context and submitting against it:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">I915_DEFINE_CONTEXT_PARAM_ENGINES</span><span class="p">(</span><span class="n">engines</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_RENDER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">                     </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_COPY</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_context_create_ext_setparam</span><span class="w"> </span><span class="n">p_engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_CREATE_EXT_SETPARAM</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_PARAM_ENGINES</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engines</span><span class="p">),</span>
<span class="w">                </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">engines</span><span class="p">),</span>
<span class="w">        </span><span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_context_create_ext</span><span class="w"> </span><span class="n">create</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_engines</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">ctx_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gem_context_create_ext</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create</span><span class="p">);</span>

<span class="c1">// We have now created a GEM context with two engines in the map:</span>
<span class="c1">// Index 0 points to rcs0 while index 1 points to bcs0. Other engines</span>
<span class="c1">// will not be accessible from this context.</span>

<span class="p">...</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx_id</span><span class="p">;</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Submits to index 0, which is rcs0 for this context</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span>

<span class="p">...</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx_id</span><span class="p">;</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Submits to index 0, which is bcs0 for this context</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_context_create_ext_setparam">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_context_create_ext_setparam</span></span></span><a class="headerlink" href="#c.drm_i915_gem_context_create_ext_setparam" title="Link to this definition">¶</a><br /></dt>
<dd><p>Context parameter to set or query during context creation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_context_create_ext_setparam {
    struct i915_user_extension base;
    struct drm_i915_gem_context_param param;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>Context parameter to set or query.
See <a class="reference internal" href="#c.drm_i915_gem_context_param" title="drm_i915_gem_context_param"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_context_param</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_vm_control">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_vm_control</span></span></span><a class="headerlink" href="#c.drm_i915_gem_vm_control" title="Link to this definition">¶</a><br /></dt>
<dd><p>Structure to create or destroy VM.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_vm_control {
    __u64 extensions;
    __u32 flags;
    __u32 vm_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>reserved for future usage, currently MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>Id of the VM created or to be destroyed</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>DRM_I915_GEM_VM_CREATE -</p>
<p>Create a new virtual memory address space (ppGTT) for use within a context
on the same file. Extensions can be provided to configure exactly how the
address space is setup upon creation.</p>
<p>The id of new VM (bound to the fd) for use with I915_CONTEXT_PARAM_VM is
returned in the outparam <strong>id</strong>.</p>
<p>An extension chain maybe provided, starting with <strong>extensions</strong>, and terminated
by the <strong>next_extension</strong> being 0. Currently, no extensions are defined.</p>
<p>DRM_I915_GEM_VM_DESTROY -</p>
<p>Destroys a previously created VM id, specified in <strong>vm_id</strong>.</p>
<p>No extensions or flags are allowed currently, and so must be zero.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_userptr">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_userptr</span></span></span><a class="headerlink" href="#c.drm_i915_gem_userptr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create GEM object from user allocated memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_userptr {
    __u64 user_ptr;
    __u64 user_size;
    __u32 flags;
#define I915_USERPTR_READ_ONLY 0x1;
#define I915_USERPTR_PROBE 0x2;
#define I915_USERPTR_UNSYNCHRONIZED 0x80000000;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">user_ptr</span></code></dt><dd><p>The pointer to the allocated memory.</p>
<p>Needs to be aligned to PAGE_SIZE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user_size</span></code></dt><dd><p>The size in bytes for the allocated memory. This will also become the
object size.</p>
<p>Needs to be aligned to PAGE_SIZE, and should be at least PAGE_SIZE,
or larger.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Supported flags:</p>
<p>I915_USERPTR_READ_ONLY:</p>
<p>Mark the object as readonly, this also means GPU access can only be
readonly. This is only supported on HW which supports readonly access
through the GTT. If the HW can’t support readonly access, an error is
returned.</p>
<p>I915_USERPTR_PROBE:</p>
<p>Probe the provided <strong>user_ptr</strong> range and validate that the <strong>user_ptr</strong> is
indeed pointing to normal memory and that the range is also valid.
For example if some garbage address is given to the kernel, then this
should complain.</p>
<p>Returns -EFAULT if the probe failed.</p>
<p>Note that this doesn’t populate the backing pages, and also doesn’t
guarantee that the object will remain valid when the object is
eventually used.</p>
<p>The kernel supports this feature if I915_PARAM_HAS_USERPTR_PROBE
returns a non-zero value.</p>
<p>I915_USERPTR_UNSYNCHRONIZED:</p>
<p>NOT USED. Setting this flag will result in an error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Returned handle for the object.</p>
<p>Object handles are nonzero.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Userptr objects have several restrictions on what ioctls can be used with the
object handle.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_perf_oa_config">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_perf_oa_config</span></span></span><a class="headerlink" href="#c.drm_i915_perf_oa_config" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_perf_oa_config {
    char uuid[36];
    __u32 n_mux_regs;
    __u32 n_boolean_regs;
    __u32 n_flex_regs;
    __u64 mux_regs_ptr;
    __u64 boolean_regs_ptr;
    __u64 flex_regs_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>String formatted like “%08x-%04x-%04x-%04x-%012x”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_mux_regs</span></code></dt><dd><p>Number of mux regs in <code class="xref c c-type docutils literal notranslate"><span class="pre">mux_regs_ptr</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_boolean_regs</span></code></dt><dd><p>Number of boolean regs in <code class="xref c c-type docutils literal notranslate"><span class="pre">boolean_regs_ptr</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_flex_regs</span></code></dt><dd><p>Number of flex regs in <code class="xref c c-type docutils literal notranslate"><span class="pre">flex_regs_ptr</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_regs_ptr</span></code></dt><dd><p>Pointer to tuples of u32 values (register address, value) for mux
registers.  Expected length of buffer is (2 * sizeof(u32) *
<code class="xref c c-type docutils literal notranslate"><span class="pre">n_mux_regs</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boolean_regs_ptr</span></code></dt><dd><p>Pointer to tuples of u32 values (register address, value) for mux
registers.  Expected length of buffer is (2 * sizeof(u32) *
<code class="xref c c-type docutils literal notranslate"><span class="pre">n_boolean_regs</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flex_regs_ptr</span></code></dt><dd><p>Pointer to tuples of u32 values (register address, value) for mux
registers.  Expected length of buffer is (2 * sizeof(u32) *
<code class="xref c c-type docutils literal notranslate"><span class="pre">n_flex_regs</span></code>).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure to upload perf dynamic configuration into the kernel.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_query_item">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_query_item</span></span></span><a class="headerlink" href="#c.drm_i915_query_item" title="Link to this definition">¶</a><br /></dt>
<dd><p>An individual query for the kernel to process.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_item {
    __u64 query_id;
#define DRM_I915_QUERY_TOPOLOGY_INFO            1;
#define DRM_I915_QUERY_ENGINE_INFO              2;
#define DRM_I915_QUERY_PERF_CONFIG              3;
#define DRM_I915_QUERY_MEMORY_REGIONS           4;
#define DRM_I915_QUERY_HWCONFIG_BLOB            5;
#define DRM_I915_QUERY_GEOMETRY_SUBSLICES       6;
#define DRM_I915_QUERY_GUC_SUBMISSION_VERSION   7;
    __s32 length;
    __u32 flags;
#define DRM_I915_QUERY_PERF_CONFIG_LIST          1;
#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID 2;
#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID   3;
    __u64 data_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">query_id</span></code></dt><dd><dl class="simple">
<dt>The id for this query.  Currently accepted query IDs are:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_TOPOLOGY_INFO</span></code> (see <a class="reference internal" href="#c.drm_i915_query_topology_info" title="drm_i915_query_topology_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_topology_info</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_ENGINE_INFO</span></code> (see <a class="reference internal" href="#c.drm_i915_engine_info" title="drm_i915_engine_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_engine_info</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG</span></code> (see <a class="reference internal" href="#c.drm_i915_query_perf_config" title="drm_i915_query_perf_config"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_perf_config</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_MEMORY_REGIONS</span></code> (see <a class="reference internal" href="#c.drm_i915_query_memory_regions" title="drm_i915_query_memory_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_memory_regions</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_HWCONFIG_BLOB</span></code> (see <cite>GuC HWCONFIG blob uAPI</cite>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_GEOMETRY_SUBSLICES</span></code> (see <a class="reference internal" href="#c.drm_i915_query_topology_info" title="drm_i915_query_topology_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_topology_info</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_GUC_SUBMISSION_VERSION</span></code> (see <a class="reference internal" href="#c.drm_i915_query_guc_submission_version" title="drm_i915_query_guc_submission_version"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_guc_submission_version</span></code></a>)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>When set to zero by userspace, this is filled with the size of the
data to be written at the <strong>data_ptr</strong> pointer. The kernel sets this
value to a negative value to signal an error on a particular query
item.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>When <code class="xref c c-type docutils literal notranslate"><span class="pre">query_id</span></code> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_TOPOLOGY_INFO</span></code>, must be 0.</p>
<p>When <code class="xref c c-type docutils literal notranslate"><span class="pre">query_id</span></code> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG</span></code>, must be one of the
following:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_LIST</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_FOR_UUID</span></code></p></li>
</ul>
</div></blockquote>
<p>When <code class="xref c c-type docutils literal notranslate"><span class="pre">query_id</span></code> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_GEOMETRY_SUBSLICES</span></code> must contain
a <a class="reference internal" href="#c.i915_engine_class_instance" title="i915_engine_class_instance"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_engine_class_instance</span></code></a> that references a render engine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_ptr</span></code></dt><dd><p>Data will be written at the location pointed by <strong>data_ptr</strong> when the
value of <strong>length</strong> matches the length of the data to be written by the
kernel.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The behaviour is determined by the <strong>query_id</strong>. Note that exactly what
<strong>data_ptr</strong> is also depends on the specific <strong>query_id</strong>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_query">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_query</span></span></span><a class="headerlink" href="#c.drm_i915_query" title="Link to this definition">¶</a><br /></dt>
<dd><p>Supply an array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a> for the kernel to fill out.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query {
    __u32 num_items;
    __u32 flags;
    __u64 items_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_items</span></code></dt><dd><p>The number of elements in the <strong>items_ptr</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Unused for now. Must be cleared to zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">items_ptr</span></code></dt><dd><p>Pointer to an array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a>. The number of
array elements is <strong>num_items</strong>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that this is generally a two step process for each <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_item</span></code></a> in the array:</p>
<ol class="arabic simple">
<li><p>Call the DRM_IOCTL_I915_QUERY, giving it our array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_item</span></code></a>, with <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.length</span></code></a> set to zero. The
kernel will then fill in the size, in bytes, which tells userspace how
memory it needs to allocate for the blob(say for an array of properties).</p></li>
<li><p>Next we call DRM_IOCTL_I915_QUERY again, this time with the
<a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.data_ptr</span></code></a> equal to our newly allocated blob. Note that
the <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.length</span></code></a> should still be the same as what the
kernel previously set. At this point the kernel can fill in the blob.</p></li>
</ol>
<p>Note that for some query items it can make sense for userspace to just pass
in a buffer/blob equal to or larger than the required size. In this case only
a single ioctl call is needed. For some smaller query items this can work
quite well.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_query_topology_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_query_topology_info</span></span></span><a class="headerlink" href="#c.drm_i915_query_topology_info" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_topology_info {
    __u16 flags;
    __u16 max_slices;
    __u16 max_subslices;
    __u16 max_eus_per_subslice;
    __u16 subslice_offset;
    __u16 subslice_stride;
    __u16 eu_offset;
    __u16 eu_stride;
    __u8 data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Unused for now. Must be cleared to zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_slices</span></code></dt><dd><p>The number of bits used to express the slice mask.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_subslices</span></code></dt><dd><p>The number of bits used to express the subslice mask.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_eus_per_subslice</span></code></dt><dd><p>The number of bits in the EU mask that correspond to a single
subslice’s EUs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subslice_offset</span></code></dt><dd><p>Offset in data[] at which the subslice masks are stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subslice_stride</span></code></dt><dd><p>Stride at which each of the subslice masks for each slice are
stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eu_offset</span></code></dt><dd><p>Offset in data[] at which the EU masks are stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eu_stride</span></code></dt><dd><p>Stride at which each of the EU masks for each subslice are stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Contains 3 pieces of information :</p>
<ul>
<li><p>The slice mask with one bit per slice telling whether a slice is
available. The availability of slice X can be queried with the
following formula :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">X</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>Starting with Xe_HP platforms, Intel hardware no longer has
traditional slices so i915 will always report a single slice
(hardcoded slicemask = 0x1) which contains all of the platform’s
subslices.  I.e., the mask here does not reflect any of the newer
hardware concepts such as “gslices” or “cslices” since userspace
is capable of inferring those from the subslice mask.</p>
</li>
<li><p>The subslice mask for each slice with one bit per subslice telling
whether a subslice is available.  Starting with Gen12 we use the
term “subslice” to refer to what the hardware documentation
describes as a “dual-subslices.”  The availability of subslice Y
in slice X can be queried with the following formula :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">subslice_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">subslice_stride</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Y</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p>The EU mask for each subslice in each slice, with one bit per EU
telling whether an EU is available. The availability of EU Z in
subslice Y in slice X can be queried with the following formula :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">eu_offset</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">max_subslices</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">eu_stride</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="n">Z</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span>
<span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Z</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Describes slice/subslice/EU information queried by
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_TOPOLOGY_INFO</span></code></p>
<p id="engine-discovery-uapi"><strong>Engine Discovery uAPI</strong></p>
<p>Engine discovery uAPI is a way of enumerating physical engines present in a
GPU associated with an open i915 DRM file descriptor. This supersedes the old
way of using <cite>DRM_IOCTL_I915_GETPARAM</cite> and engine identifiers like
<cite>I915_PARAM_HAS_BLT</cite>.</p>
<p>The need for this interface came starting with Icelake and newer GPUs, which
started to establish a pattern of having multiple engines of a same class,
where not all instances were always completely functionally equivalent.</p>
<p>Entry point for this uapi is <cite>DRM_IOCTL_I915_QUERY</cite> with the
<cite>DRM_I915_QUERY_ENGINE_INFO</cite> as the queried item id.</p>
<p>Example for getting the list of engines:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_query_engine_info</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_query_item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">query_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_I915_QUERY_ENGINE_INFO</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_query</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">num_items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">items_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="c1">// First query the size of the blob we need, this needs to be large</span>
<span class="c1">// enough to hold our array of engines. The kernel will fill out the</span>
<span class="c1">// item.length for us, which is the number of bytes we need.</span>
<span class="c1">//</span>
<span class="c1">// Alternatively a large buffer can be allocated straightaway enabling</span>
<span class="c1">// querying in one pass, in which case item.length should contain the</span>
<span class="c1">// length of the provided buffer.</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>

<span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="c1">// Now that we allocated the required number of bytes, we call the ioctl</span>
<span class="c1">// again, this time with the data_ptr pointing to our newly allocated</span>
<span class="c1">// blob, which the kernel can then populate with info on all engines.</span>
<span class="n">item</span><span class="p">.</span><span class="n">data_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="p">;</span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>

<span class="c1">// We can now access each engine in the array</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_engines</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_engine_info</span><span class="w"> </span><span class="n">einfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">engines</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">u16</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">einfo</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
<span class="w">        </span><span class="n">u16</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">einfo</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>
<span class="w">        </span><span class="p">....</span>
<span class="p">}</span>

<span class="n">free</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
</pre></div>
</div>
<p>Each of the enumerated engines, apart from being defined by its class and
instance (see <cite><a class="reference internal" href="#c.i915_engine_class_instance" title="i915_engine_class_instance"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_engine_class_instance</span></code></a></cite>), also can have flags and
capabilities defined as documented in i915_drm.h.</p>
<p>For instance video engines which support HEVC encoding will have the
<cite>I915_VIDEO_CLASS_CAPABILITY_HEVC</cite> capability bit set.</p>
<p>Engine discovery only fully comes to its own when combined with the new way
of addressing engines when submitting batch buffers using contexts with
engine maps configured.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_engine_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_engine_info</span></span></span><a class="headerlink" href="#c.drm_i915_engine_info" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_engine_info {
    struct i915_engine_class_instance engine;
    __u32 rsvd0;
    __u64 flags;
#define I915_ENGINE_INFO_HAS_LOGICAL_INSTANCE           (1 &lt;&lt; 0);
    __u64 capabilities;
#define I915_VIDEO_CLASS_CAPABILITY_HEVC                (1 &lt;&lt; 0);
#define I915_VIDEO_AND_ENHANCE_CLASS_CAPABILITY_SFC     (1 &lt;&lt; 1);
    __u16 logical_instance;
    __u16 rsvd1[3];
    __u64 rsvd2[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">engine</span></code></dt><dd><p>Engine class and instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd0</span></code></dt><dd><p>Reserved field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Engine flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capabilities</span></code></dt><dd><p>Capabilities of this engine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">logical_instance</span></code></dt><dd><p>Logical instance of engine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt><dd><p>Reserved fields.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd2</span></code></dt><dd><p>Reserved fields.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Describes one engine and its capabilities as known to the driver.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_query_engine_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_query_engine_info</span></span></span><a class="headerlink" href="#c.drm_i915_query_engine_info" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_engine_info {
    __u32 num_engines;
    __u32 rsvd[3];
    struct drm_i915_engine_info engines[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_engines</span></code></dt><dd><p>Number of <a class="reference internal" href="#c.drm_i915_engine_info" title="drm_i915_engine_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_engine_info</span></code></a> structs following.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engines</span></code></dt><dd><p>Marker for drm_i915_engine_info structures.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Engine info query enumerates all engines known to the driver by filling in
an array of <a class="reference internal" href="#c.drm_i915_engine_info" title="drm_i915_engine_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_engine_info</span></code></a> structures.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_query_perf_config">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_query_perf_config</span></span></span><a class="headerlink" href="#c.drm_i915_query_perf_config" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_perf_config {
    union {
        __u64 n_configs;
        __u64 config;
        char uuid[36];
    };
    __u32 flags;
    __u8 data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_configs</span></code></dt><dd><p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> ==
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_LIST</span></code>, i915 sets this fields to
the number of configurations available.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt><dd><p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> ==
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID</span></code>, i915 will use the
value in this field as configuration identifier to decide
what data to write into config_ptr.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> ==
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID</span></code>, i915 will use the
value in this field as configuration identifier to decide
what data to write into config_ptr.</p>
<p>String formatted like “<code class="docutils literal notranslate"><span class="pre">08x-````04x-````04x-````04x-````012x</span></code>”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Unused for now. Must be cleared to zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_LIST</span></code>,
i915 will write an array of __u64 of configuration identifiers.</p>
<p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_DATA</span></code>,
i915 will write a <a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_perf_oa_config</span></code></a>. If the following
fields of <a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_perf_oa_config</span></code></a> are not set to 0, i915 will
write into the associated pointers the values of submitted when the
configuration was created :</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_perf_oa_config.n_mux_regs</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_perf_oa_config.n_boolean_regs</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_perf_oa_config.n_flex_regs</span></code></a></p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Data written by the kernel with query <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG</span></code> and
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_GEOMETRY_SUBSLICES</span></code>.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_i915_gem_memory_class">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_memory_class</span></span></span><a class="headerlink" href="#c.drm_i915_gem_memory_class" title="Link to this definition">¶</a><br /></dt>
<dd><p>Supported memory classes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">I915_MEMORY_CLASS_SYSTEM</span></code></dt><dd><p>System memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_MEMORY_CLASS_DEVICE</span></code></dt><dd><p>Device local-memory</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_memory_class_instance">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_memory_class_instance</span></span></span><a class="headerlink" href="#c.drm_i915_gem_memory_class_instance" title="Link to this definition">¶</a><br /></dt>
<dd><p>Identify particular memory region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_memory_class_instance {
    __u16 memory_class;
    __u16 memory_instance;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">memory_class</span></code></dt><dd><p>See <a class="reference internal" href="#c.drm_i915_gem_memory_class" title="drm_i915_gem_memory_class"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_i915_gem_memory_class</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory_instance</span></code></dt><dd><p>Which instance</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_memory_region_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_memory_region_info</span></span></span><a class="headerlink" href="#c.drm_i915_memory_region_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Describes one region as known to the driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_memory_region_info {
    struct drm_i915_gem_memory_class_instance region;
    __u32 rsvd0;
    __u64 probed_size;
    __u64 unallocated_size;
    union {
        __u64 rsvd1[8];
        struct {
            __u64 probed_cpu_visible_size;
            __u64 unallocated_cpu_visible_size;
        };
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">region</span></code></dt><dd><p>The class:instance pair encoding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd0</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probed_size</span></code></dt><dd><p>Memory probed by the driver</p>
<p>Note that it should not be possible to ever encounter a zero value
here, also note that no current region type will ever return -1 here.
Although for future region types, this might be a possibility. The
same applies to the other size fields.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unallocated_size</span></code></dt><dd><p>Estimate of memory remaining</p>
<p>Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable accounting.
Without this (or if this is an older kernel) the value here will
always equal the <strong>probed_size</strong>. Note this is only currently tracked
for I915_MEMORY_CLASS_DEVICE regions (for other types the value here
will always equal the <strong>probed_size</strong>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probed_cpu_visible_size</span></code></dt><dd><p>Memory probed by the driver
that is CPU accessible.</p>
<p>This will be always be &lt;= <strong>probed_size</strong>, and the
remainder (if there is any) will not be CPU
accessible.</p>
<p>On systems without small BAR, the <strong>probed_size</strong> will
always equal the <strong>probed_cpu_visible_size</strong>, since all
of it will be CPU accessible.</p>
<p>Note this is only tracked for
I915_MEMORY_CLASS_DEVICE regions (for other types the
value here will always equal the <strong>probed_size</strong>).</p>
<p>Note that if the value returned here is zero, then
this must be an old kernel which lacks the relevant
small-bar uAPI support (including
I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS), but on
such systems we should never actually end up with a
small BAR configuration, assuming we are able to load
the kernel module. Hence it should be safe to treat
this the same as when <strong>probed_cpu_visible_size</strong> ==
<strong>probed_size</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unallocated_cpu_visible_size</span></code></dt><dd><p>Estimate of CPU
visible memory remaining.</p>
<p>Note this is only tracked for
I915_MEMORY_CLASS_DEVICE regions (for other types the
value here will always equal the
<strong>probed_cpu_visible_size</strong>).</p>
<p>Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable
accounting.  Without this the value here will always
equal the <strong>probed_cpu_visible_size</strong>. Note this is only
currently tracked for I915_MEMORY_CLASS_DEVICE
regions (for other types the value here will also
always equal the <strong>probed_cpu_visible_size</strong>).</p>
<p>If this is an older kernel the value here will be
zero, see also <strong>probed_cpu_visible_size</strong>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note this is using both <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a> and <a class="reference internal" href="#c.drm_i915_query" title="drm_i915_query"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query</span></code></a>.
For this new query we are adding the new query id DRM_I915_QUERY_MEMORY_REGIONS
at <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.query_id</span></code></a>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_query_memory_regions">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_query_memory_regions</span></span></span><a class="headerlink" href="#c.drm_i915_query_memory_regions" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_memory_regions {
    __u32 num_regions;
    __u32 rsvd[3];
    struct drm_i915_memory_region_info regions[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_regions</span></code></dt><dd><p>Number of supported regions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regions</span></code></dt><dd><p>Info about each supported region</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The region info query enumerates all regions known to the driver by filling
in an array of <a class="reference internal" href="#c.drm_i915_memory_region_info" title="drm_i915_memory_region_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_memory_region_info</span></code></a> structures.</p>
<p>Example for getting the list of supported regions:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_query_memory_regions</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_query_item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">query_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_I915_QUERY_MEMORY_REGIONS</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_query</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">num_items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">items_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="c1">// First query the size of the blob we need, this needs to be large</span>
<span class="c1">// enough to hold our array of regions. The kernel will fill out the</span>
<span class="c1">// item.length for us, which is the number of bytes we need.</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>

<span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="c1">// Now that we allocated the required number of bytes, we call the ioctl</span>
<span class="c1">// again, this time with the data_ptr pointing to our newly allocated</span>
<span class="c1">// blob, which the kernel can then populate with the all the region info.</span>
<span class="n">item</span><span class="p">.</span><span class="n">data_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>

<span class="c1">// We can now access each region in the array</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_regions</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_memory_region_info</span><span class="w"> </span><span class="n">mr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">u16</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr</span><span class="p">.</span><span class="n">region</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
<span class="w">        </span><span class="n">u16</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr</span><span class="p">.</span><span class="n">region</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>

<span class="w">        </span><span class="p">....</span>
<span class="p">}</span>

<span class="n">free</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_query_guc_submission_version">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_query_guc_submission_version</span></span></span><a class="headerlink" href="#c.drm_i915_query_guc_submission_version" title="Link to this definition">¶</a><br /></dt>
<dd><p>query GuC submission interface version</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_guc_submission_version {
    __u32 branch;
    __u32 major;
    __u32 minor;
    __u32 patch;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">branch</span></code></dt><dd><p>Firmware branch version.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">major</span></code></dt><dd><p>Firmware major version.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>Firmware minor version.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">patch</span></code></dt><dd><p>Firmware patch version.</p>
</dd>
</dl>
</div>
<p id="guc-hwconfig-blob-uapi"><strong>GuC HWCONFIG blob uAPI</strong></p>
<p>The GuC produces a blob with information about the current device.
i915 reads this blob from GuC and makes it available via this uAPI.</p>
<p>The format and meaning of the blob content are documented in the
Programmer’s Reference Manual.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_create_ext">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_create_ext</span></span></span><a class="headerlink" href="#c.drm_i915_gem_create_ext" title="Link to this definition">¶</a><br /></dt>
<dd><p>Existing gem_create behaviour, with added extension support using <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext {
    __u64 size;
    __u32 handle;
#define I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS (1 &lt;&lt; 0);
    __u32 flags;
#define I915_GEM_CREATE_EXT_MEMORY_REGIONS 0;
#define I915_GEM_CREATE_EXT_PROTECTED_CONTENT 1;
#define I915_GEM_CREATE_EXT_SET_PAT 2;
    __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Requested size for the object.</p>
<p>The (page-aligned) allocated size for the object will be returned.</p>
<p>On platforms like DG2/ATS the kernel will always use 64K or larger
pages for I915_MEMORY_CLASS_DEVICE. The kernel also requires a
minimum of 64K GTT alignment for such objects.</p>
<p>NOTE: Previously the ABI here required a minimum GTT alignment of 2M
on DG2/ATS, due to how the hardware implemented 64K GTT page support,
where we had the following complications:</p>
<blockquote>
<div><p>1) The entire PDE (which covers a 2MB virtual address range), must
contain only 64K PTEs, i.e mixing 4K and 64K PTEs in the same
PDE is forbidden by the hardware.</p>
<p>2) We still need to support 4K PTEs for I915_MEMORY_CLASS_SYSTEM
objects.</p>
</div></blockquote>
<p>However on actual production HW this was completely changed to now
allow setting a TLB hint at the PTE level (see PS64), which is a lot
more flexible than the above. With this the 2M restriction was
dropped where we now only require 64K.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Returned handle for the object.</p>
<p>Object handles are nonzero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Optional flags.</p>
<p>Supported values:</p>
<p>I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS - Signal to the kernel that
the object will need to be accessed via the CPU.</p>
<p>Only valid when placing objects in I915_MEMORY_CLASS_DEVICE, and only
strictly required on configurations where some subset of the device
memory is directly visible/mappable through the CPU (which we also
call small BAR), like on some DG2+ systems. Note that this is quite
undesirable, but due to various factors like the client CPU, BIOS etc
it’s something we can expect to see in the wild. See
<a class="reference internal" href="#c.drm_i915_memory_region_info" title="drm_i915_memory_region_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_memory_region_info.probed_cpu_visible_size</span></code></a> for how to
determine if this system applies.</p>
<p>Note that one of the placements MUST be I915_MEMORY_CLASS_SYSTEM, to
ensure the kernel can always spill the allocation to system memory,
if the object can’t be allocated in the mappable part of
I915_MEMORY_CLASS_DEVICE.</p>
<p>Also note that since the kernel only supports flat-CCS on objects
that can <em>only</em> be placed in I915_MEMORY_CLASS_DEVICE, we therefore
don’t support I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS together with
flat-CCS.</p>
<p>Without this hint, the kernel will assume that non-mappable
I915_MEMORY_CLASS_DEVICE is preferred for this object. Note that the
kernel can still migrate the object to the mappable part, as a last
resort, if userspace ever CPU faults this object, but this might be
expensive, and so ideally should be avoided.</p>
<p>On older kernels which lack the relevant small-bar uAPI support (see
also <a class="reference internal" href="#c.drm_i915_memory_region_info" title="drm_i915_memory_region_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_memory_region_info.probed_cpu_visible_size</span></code></a>),
usage of the flag will result in an error, but it should NEVER be
possible to end up with a small BAR configuration, assuming we can
also successfully load the i915 kernel module. In such cases the
entire I915_MEMORY_CLASS_DEVICE region will be CPU accessible, and as
such there are zero restrictions on where the object can be placed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>The chain of extensions to apply to this object.</p>
<p>This will be useful in the future when we need to support several
different extensions, and we need to apply more than one when
creating the object. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
<p>If we don’t supply any extensions then we get the same old gem_create
behaviour.</p>
<p>For I915_GEM_CREATE_EXT_MEMORY_REGIONS usage see
<a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>.</p>
<p>For I915_GEM_CREATE_EXT_PROTECTED_CONTENT usage see
<a class="reference internal" href="#c.drm_i915_gem_create_ext_protected_content" title="drm_i915_gem_create_ext_protected_content"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_create_ext_protected_content</span></code></a>.</p>
<p>For I915_GEM_CREATE_EXT_SET_PAT usage see
<a class="reference internal" href="#c.drm_i915_gem_create_ext_set_pat" title="drm_i915_gem_create_ext_set_pat"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_create_ext_set_pat</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that new buffer flags should be added here, at least for the stuff that
is immutable. Previously we would have two ioctls, one to create the object
with gem_create, and another to apply various parameters, however this
creates some ambiguity for the params which are considered immutable. Also in
general we’re phasing out the various SET/GET ioctls.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_create_ext_memory_regions">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_create_ext_memory_regions</span></span></span><a class="headerlink" href="#c.drm_i915_gem_create_ext_memory_regions" title="Link to this definition">¶</a><br /></dt>
<dd><p>The I915_GEM_CREATE_EXT_MEMORY_REGIONS extension.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext_memory_regions {
    struct i915_user_extension base;
    __u32 pad;
    __u32 num_regions;
    __u64 regions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_regions</span></code></dt><dd><p>Number of elements in the <strong>regions</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regions</span></code></dt><dd><p>The regions/placements array.</p>
<p>An array of <a class="reference internal" href="#c.drm_i915_gem_memory_class_instance" title="drm_i915_gem_memory_class_instance"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_memory_class_instance</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Set the object with the desired set of placements/regions in priority
order. Each entry must be unique and supported by the device.</p>
<p>This is provided as an array of <a class="reference internal" href="#c.drm_i915_gem_memory_class_instance" title="drm_i915_gem_memory_class_instance"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_memory_class_instance</span></code></a>, or
an equivalent layout of class:instance pair encodings. See <a class="reference internal" href="#c.drm_i915_query_memory_regions" title="drm_i915_query_memory_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_memory_regions</span></code></a> and DRM_I915_QUERY_MEMORY_REGIONS for how to
query the supported regions for a device.</p>
<p>As an example, on discrete devices, if we wish to set the placement as
device local-memory we can do something like:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_memory_class_instance</span><span class="w"> </span><span class="n">region_lmem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">memory_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_MEMORY_CLASS_DEVICE</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">memory_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_create_ext_memory_regions</span><span class="w"> </span><span class="n">regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_GEM_CREATE_EXT_MEMORY_REGIONS</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">region_lmem</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">num_regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_create_ext</span><span class="w"> </span><span class="n">create_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regions</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_GEM_CREATE_EXT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create_ext</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>At which point we get the object handle in <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext.handle</span></code></a>,
along with the final object size in <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext.size</span></code></a>, which
should account for any rounding up, if required.</p>
<p>Note that userspace has no means of knowing the current backing region
for objects where <strong>num_regions</strong> is larger than one. The kernel will only
ensure that the priority order of the <strong>regions</strong> array is honoured, either
when initially placing the object, or when moving memory around due to
memory pressure</p>
<p>On Flat-CCS capable HW, compression is supported for the objects residing
in I915_MEMORY_CLASS_DEVICE. When such objects (compressed) have other
memory class in <strong>regions</strong> and migrated (by i915, due to memory
constraints) to the non I915_MEMORY_CLASS_DEVICE region, then i915 needs to
decompress the content. But i915 doesn’t have the required information to
decompress the userspace compressed objects.</p>
<p>So i915 supports Flat-CCS, on the objects which can reside only on
I915_MEMORY_CLASS_DEVICE regions.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_create_ext_protected_content">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_create_ext_protected_content</span></span></span><a class="headerlink" href="#c.drm_i915_gem_create_ext_protected_content" title="Link to this definition">¶</a><br /></dt>
<dd><p>The I915_OBJECT_PARAM_PROTECTED_CONTENT extension.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext_protected_content {
    struct i915_user_extension base;
    __u32 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>reserved for future usage, currently MBZ</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If this extension is provided, buffer contents are expected to be protected
by PXP encryption and require decryption for scan out and processing. This
is only possible on platforms that have PXP enabled, on all other scenarios
using this extension will cause the ioctl to fail and return -ENODEV. The
flags parameter is reserved for future expansion and must currently be set
to zero.</p>
<p>The buffer contents are considered invalid after a PXP session teardown.</p>
<p>The encryption is guaranteed to be processed correctly only if the object
is submitted with a context created using the
I915_CONTEXT_PARAM_PROTECTED_CONTENT flag. This will also enable extra checks
at submission time on the validity of the objects involved.</p>
<p>Below is an example on how to create a protected object:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_create_ext_protected_content</span><span class="w"> </span><span class="n">protected_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_GEM_CREATE_EXT_PROTECTED_CONTENT</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_create_ext</span><span class="w"> </span><span class="n">create_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">protected_ext</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_GEM_CREATE_EXT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create_ext</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_i915_gem_create_ext_set_pat">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_i915_gem_create_ext_set_pat</span></span></span><a class="headerlink" href="#c.drm_i915_gem_create_ext_set_pat" title="Link to this definition">¶</a><br /></dt>
<dd><p>The I915_GEM_CREATE_EXT_SET_PAT extension.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext_set_pat {
    struct i915_user_extension base;
    __u32 pat_index;
    __u32 rsvd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pat_index</span></code></dt><dd><p>PAT index to be set
PAT index is a bit field in Page Table Entry to control caching
behaviors for GPU accesses. The definition of PAT index is
platform dependent and can be found in hardware specifications,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt><dd><p>reserved for future use</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If this extension is provided, the specified caching policy (PAT index) is
applied to the buffer object.</p>
<p>Below is an example on how to create an object with specific caching policy:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_create_ext_set_pat</span><span class="w"> </span><span class="n">set_pat_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_GEM_CREATE_EXT_SET_PAT</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">pat_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_i915_gem_create_ext</span><span class="w"> </span><span class="n">create_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">set_pat_ext</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_GEM_CREATE_EXT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create_ext</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
</section>
<section id="drm-nouveau-uapi">
<h2>drm/nouveau uAPI<a class="headerlink" href="#drm-nouveau-uapi" title="Link to this heading">¶</a></h2>
<section id="vm-bind-exec-uapi">
<h3>VM_BIND / EXEC uAPI<a class="headerlink" href="#vm-bind-exec-uapi" title="Link to this heading">¶</a></h3>
<p>Nouveau’s VM_BIND / EXEC UAPI consists of three ioctls: DRM_NOUVEAU_VM_INIT,
DRM_NOUVEAU_VM_BIND and DRM_NOUVEAU_EXEC.</p>
<p>In order to use the UAPI firstly a user client must initialize the VA space
using the DRM_NOUVEAU_VM_INIT ioctl specifying which region of the VA space
should be managed by the kernel and which by the UMD.</p>
<p>The DRM_NOUVEAU_VM_BIND ioctl provides clients an interface to manage the
userspace-managable portion of the VA space. It provides operations to map
and unmap memory. Mappings may be flagged as sparse. Sparse mappings are not
backed by a GEM object and the kernel will ignore GEM handles provided
alongside a sparse mapping.</p>
<p>Userspace may request memory backed mappings either within or outside of the
bounds (but not crossing those bounds) of a previously mapped sparse
mapping. Subsequently requested memory backed mappings within a sparse
mapping will take precedence over the corresponding range of the sparse
mapping. If such memory backed mappings are unmapped the kernel will make
sure that the corresponding sparse mapping will take their place again.
Requests to unmap a sparse mapping that still contains memory backed mappings
will result in those memory backed mappings being unmapped first.</p>
<p>Unmap requests are not bound to the range of existing mappings and can even
overlap the bounds of sparse mappings. For such a request the kernel will
make sure to unmap all memory backed mappings within the given range,
splitting up memory backed mappings which are only partially contained
within the given range. Unmap requests with the sparse flag set must match
the range of a previously mapped sparse mapping exactly though.</p>
<p>While the kernel generally permits arbitrary sequences and ranges of memory
backed mappings being mapped and unmapped, either within a single or multiple
VM_BIND ioctl calls, there are some restrictions for sparse mappings.</p>
<dl class="simple">
<dt>The kernel does not permit to:</dt><dd><ul class="simple">
<li><p>unmap non-existent sparse mappings</p></li>
<li><p>unmap a sparse mapping and map a new sparse mapping overlapping the range
of the previously unmapped sparse mapping within the same VM_BIND ioctl</p></li>
<li><p>unmap a sparse mapping and map new memory backed mappings overlapping the
range of the previously unmapped sparse mapping within the same VM_BIND
ioctl</p></li>
</ul>
</dd>
</dl>
<p>When using the VM_BIND ioctl to request the kernel to map memory to a given
virtual address in the GPU’s VA space there is no guarantee that the actual
mappings are created in the GPU’s MMU. If the given memory is swapped out
at the time the bind operation is executed the kernel will stash the mapping
details into it’s internal alloctor and create the actual MMU mappings once
the memory is swapped back in. While this is transparent for userspace, it is
guaranteed that all the backing memory is swapped back in and all the memory
mappings, as requested by userspace previously, are actually mapped once the
DRM_NOUVEAU_EXEC ioctl is called to submit an exec job.</p>
<p>A VM_BIND job can be executed either synchronously or asynchronously. If
exectued asynchronously, userspace may provide a list of syncobjs this job
will wait for and/or a list of syncobj the kernel will signal once the
VM_BIND job finished execution. If executed synchronously the ioctl will
block until the bind job is finished. For synchronous jobs the kernel will
not permit any syncobjs submitted to the kernel.</p>
<p>To execute a push buffer the UAPI provides the DRM_NOUVEAU_EXEC ioctl. EXEC
jobs are always executed asynchronously, and, equal to VM_BIND jobs, provide
the option to synchronize them with syncobjs.</p>
<p>Besides that, EXEC jobs can be scheduled for a specified channel to execute on.</p>
<p>Since VM_BIND jobs update the GPU’s VA space on job submit, EXEC jobs do have
an up to date view of the VA space. However, the actual mappings might still
be pending. Hence, EXEC jobs require to have the particular fences - of
the corresponding VM_BIND jobs they depent on - attached to them.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_nouveau_sync">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_nouveau_sync</span></span></span><a class="headerlink" href="#c.drm_nouveau_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>sync object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_nouveau_sync {
    __u32 flags;
#define DRM_NOUVEAU_SYNC_SYNCOBJ 0x0;
#define DRM_NOUVEAU_SYNC_TIMELINE_SYNCOBJ 0x1;
#define DRM_NOUVEAU_SYNC_TYPE_MASK 0xf;
    __u32 handle;
    __u64 timeline_value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the flags for a sync object</p>
<p>The first 8 bits are used to determine the type of the sync object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>the handle of the sync object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeline_value</span></code></dt><dd><p>The timeline point of the sync object in case the syncobj is of
type DRM_NOUVEAU_SYNC_TIMELINE_SYNCOBJ.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure serves as synchronization mechanism for (potentially)
asynchronous operations such as EXEC or VM_BIND.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_nouveau_vm_init">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_nouveau_vm_init</span></span></span><a class="headerlink" href="#c.drm_nouveau_vm_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>GPU VA space init structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_nouveau_vm_init {
    __u64 kernel_managed_addr;
    __u64 kernel_managed_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kernel_managed_addr</span></code></dt><dd><p>start address of the kernel managed VA space
region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_managed_size</span></code></dt><dd><p>size of the kernel managed VA space region in
bytes</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Used to initialize the GPU’s VA space for a user client, telling the kernel
which portion of the VA space is managed by the UMD and kernel respectively.</p>
<p>For the UMD to use the VM_BIND uAPI, this must be called before any BOs or
channels are created; if called afterwards DRM_IOCTL_NOUVEAU_VM_INIT fails
with -ENOSYS.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_nouveau_vm_bind_op">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_nouveau_vm_bind_op</span></span></span><a class="headerlink" href="#c.drm_nouveau_vm_bind_op" title="Link to this definition">¶</a><br /></dt>
<dd><p>VM_BIND operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_nouveau_vm_bind_op {
    __u32 op;
#define DRM_NOUVEAU_VM_BIND_OP_MAP 0x0;
#define DRM_NOUVEAU_VM_BIND_OP_UNMAP 0x1;
    __u32 flags;
#define DRM_NOUVEAU_VM_BIND_SPARSE (1 &lt;&lt; 8);
    __u32 handle;
    __u32 pad;
    __u64 addr;
    __u64 bo_offset;
    __u64 range;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p>the operation type</p>
<p>Supported values:</p>
<p><code class="docutils literal notranslate"><span class="pre">DRM_NOUVEAU_VM_BIND_OP_MAP</span></code> - Map a GEM object to the GPU’s VA
space. Optionally, the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_NOUVEAU_VM_BIND_SPARSE</span></code> flag can be
passed to instruct the kernel to create sparse mappings for the
given range.</p>
<p><code class="docutils literal notranslate"><span class="pre">DRM_NOUVEAU_VM_BIND_OP_UNMAP</span></code> - Unmap an existing mapping in the
GPU’s VA space. If the region the mapping is located in is a
sparse region, new sparse mappings are created where the unmapped
(memory backed) mapping was mapped previously. To remove a sparse
region the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_NOUVEAU_VM_BIND_SPARSE</span></code> must be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the flags for a <a class="reference internal" href="#c.drm_nouveau_vm_bind_op" title="drm_nouveau_vm_bind_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_vm_bind_op</span></code></a></p>
<p>Supported values:</p>
<p><code class="docutils literal notranslate"><span class="pre">DRM_NOUVEAU_VM_BIND_SPARSE</span></code> - Indicates that an allocated VA
space region should be sparse.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>the handle of the DRM GEM object to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>32 bit padding, should be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>the address the VA space region or (memory backed) mapping should be mapped to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bo_offset</span></code></dt><dd><p>the offset within the BO backing the mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">range</span></code></dt><dd><p>the size of the requested mapping in bytes</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a single VM_BIND operation. UMDs should pass
an array of this structure via <a class="reference internal" href="#c.drm_nouveau_vm_bind" title="drm_nouveau_vm_bind"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_nouveau_vm_bind</span></code></a>’s <code class="xref c c-type docutils literal notranslate"><span class="pre">op_ptr</span></code> field.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_nouveau_vm_bind">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_nouveau_vm_bind</span></span></span><a class="headerlink" href="#c.drm_nouveau_vm_bind" title="Link to this definition">¶</a><br /></dt>
<dd><p>structure for DRM_IOCTL_NOUVEAU_VM_BIND</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_nouveau_vm_bind {
    __u32 op_count;
    __u32 flags;
#define DRM_NOUVEAU_VM_BIND_RUN_ASYNC 0x1;
    __u32 wait_count;
    __u32 sig_count;
    __u64 wait_ptr;
    __u64 sig_ptr;
    __u64 op_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">op_count</span></code></dt><dd><p>the number of <a class="reference internal" href="#c.drm_nouveau_vm_bind_op" title="drm_nouveau_vm_bind_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_vm_bind_op</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the flags for a <a class="reference internal" href="#c.drm_nouveau_vm_bind" title="drm_nouveau_vm_bind"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_vm_bind</span></code></a> ioctl</p>
<p>Supported values:</p>
<p><code class="docutils literal notranslate"><span class="pre">DRM_NOUVEAU_VM_BIND_RUN_ASYNC</span></code> - Indicates that the given VM_BIND
operation should be executed asynchronously by the kernel.</p>
<p>If this flag is not supplied the kernel executes the associated
operations synchronously and doesn’t accept any <a class="reference internal" href="#c.drm_nouveau_sync" title="drm_nouveau_sync"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_sync</span></code></a>
objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_count</span></code></dt><dd><p>the number of wait <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_syncs</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sig_count</span></code></dt><dd><p>the number of <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_syncs</span></code> to signal when finished</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_ptr</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_syncs</span></code> to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sig_ptr</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_syncs</span></code> to signal when finished</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op_ptr</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_vm_bind_ops</span></code> to execute</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_nouveau_exec_push">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_nouveau_exec_push</span></span></span><a class="headerlink" href="#c.drm_nouveau_exec_push" title="Link to this definition">¶</a><br /></dt>
<dd><p>EXEC push operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_nouveau_exec_push {
    __u64 va;
    __u32 va_len;
    __u32 flags;
#define DRM_NOUVEAU_EXEC_PUSH_NO_PREFETCH 0x1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va</span></code></dt><dd><p>the virtual address of the push buffer mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_len</span></code></dt><dd><p>the length of the push buffer mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the flags for this push buffer mapping</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a single EXEC push operation. UMDs should pass an
array of this structure via <a class="reference internal" href="#c.drm_nouveau_exec" title="drm_nouveau_exec"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_nouveau_exec</span></code></a>’s <code class="xref c c-type docutils literal notranslate"><span class="pre">push_ptr</span></code> field.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_nouveau_exec">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_nouveau_exec</span></span></span><a class="headerlink" href="#c.drm_nouveau_exec" title="Link to this definition">¶</a><br /></dt>
<dd><p>structure for DRM_IOCTL_NOUVEAU_EXEC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_nouveau_exec {
    __u32 channel;
    __u32 push_count;
    __u32 wait_count;
    __u32 sig_count;
    __u64 wait_ptr;
    __u64 sig_ptr;
    __u64 push_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>the channel to execute the push buffer in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">push_count</span></code></dt><dd><p>the number of <a class="reference internal" href="#c.drm_nouveau_exec_push" title="drm_nouveau_exec_push"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_exec_push</span></code></a> ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_count</span></code></dt><dd><p>the number of wait <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_syncs</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sig_count</span></code></dt><dd><p>the number of <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_syncs</span></code> to signal when finished</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_ptr</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_syncs</span></code> to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sig_ptr</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_syncs</span></code> to signal when finished</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">push_ptr</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.drm_nouveau_exec_push" title="drm_nouveau_exec_push"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_nouveau_exec_push</span></code></a> ops</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="drm-panthor-uapi">
<h2>drm/panthor uAPI<a class="headerlink" href="#drm-panthor-uapi" title="Link to this heading">¶</a></h2>
<p id="introduction"><strong>Introduction</strong></p>
<p>This documentation describes the Panthor IOCTLs.</p>
<p>Just a few generic rules about the data passed to the Panthor IOCTLs:</p>
<ul class="simple">
<li><p>Structures must be aligned on 64-bit/8-byte. If the object is not
naturally aligned, a padding field must be added.</p></li>
<li><p>Fields must be explicitly aligned to their natural type alignment with
pad[0..N] fields.</p></li>
<li><p>All padding fields will be checked by the driver to make sure they are
zeroed.</p></li>
<li><p>Flags can be added, but not removed/replaced.</p></li>
<li><p>New fields can be added to the main structures (the structures
directly passed to the ioctl). Those fields can be added at the end of
the structure, or replace existing padding fields. Any new field being
added must preserve the behavior that existed before those fields were
added when a value of zero is passed.</p></li>
<li><p>New fields can be added to indirect objects (objects pointed by the
main structure), iff those objects are passed a size to reflect the
size known by the userspace driver (see drm_panthor_obj_array::stride
or drm_panthor_dev_query::size).</p></li>
<li><p>If the kernel driver is too old to know some fields, those will be
ignored if zero, and otherwise rejected (and so will be zero on output).</p></li>
<li><p>If userspace is too old to know some fields, those will be zeroed
(input) before the structure is parsed by the kernel driver.</p></li>
<li><p>Each new flag/field addition must come with a driver version update so
the userspace driver doesn’t have to trial and error to know which
flags are supported.</p></li>
<li><p>Structures should not contain unions, as this would defeat the
extensibility of such structures.</p></li>
<li><p>IOCTLs can’t be removed or replaced. New IOCTL IDs should be placed
at the end of the drm_panthor_ioctl_id enum.</p></li>
</ul>
<p id="mmio-regions-exposed-to-userspace"><strong>MMIO regions exposed to userspace.</strong></p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PANTHOR_USER_MMIO_OFFSET">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PANTHOR_USER_MMIO_OFFSET</span></span></span><a class="headerlink" href="#c.DRM_PANTHOR_USER_MMIO_OFFSET" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>File offset for all MMIO regions being exposed to userspace. Don’t use
this value directly, use DRM_PANTHOR_USER_&lt;name&gt;_OFFSET values instead.
pgoffset passed to mmap2() is an unsigned long, which forces us to use a
different offset on 32-bit and 64-bit systems.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PANTHOR_USER_FLUSH_ID_MMIO_OFFSET">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PANTHOR_USER_FLUSH_ID_MMIO_OFFSET</span></span></span><a class="headerlink" href="#c.DRM_PANTHOR_USER_FLUSH_ID_MMIO_OFFSET" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>File offset for the LATEST_FLUSH_ID register. The Userspace driver controls
GPU cache flushing through CS instructions, but the flush reduction
mechanism requires a flush_id. This flush_id could be queried with an
ioctl, but Arm provides a well-isolated register page containing only this
read-only register, so let’s expose this page through a static mmap offset
and allow direct mapping of this MMIO region so we can avoid the
user &lt;-&gt; kernel round-trip.</p>
<p id="ioctl-ids"><strong>IOCTL IDs</strong></p>
<p>enum drm_panthor_ioctl_id - IOCTL IDs</p>
<p>Place new ioctls at the end, don’t re-order, don’t replace or remove entries.</p>
<p>These IDs are not meant to be used directly. Use the DRM_IOCTL_PANTHOR_xxx
definitions instead.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_IOCTL_PANTHOR">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_IOCTL_PANTHOR</span></span></span><a class="headerlink" href="#c.DRM_IOCTL_PANTHOR" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PANTHOR</span> <span class="pre">(__access,</span> <span class="pre">__id,</span> <span class="pre">__type)</span></code></p>
<blockquote>
<div><p>Build a Panthor IOCTL number</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__access</span></code></dt><dd><p>Access type. Must be R, W or RW.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__id</span></code></dt><dd><p>One of the DRM_PANTHOR_xxx id.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__type</span></code></dt><dd><p>Suffix of the type being passed to the IOCTL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Don’t use this macro directly, use the DRM_IOCTL_PANTHOR_xxx
values instead.</p>
<p><strong>Return</strong></p>
<p>An IOCTL number to be passed to ioctl() from userspace.</p>
</div>
<p id="ioctl-arguments"><strong>IOCTL arguments</strong></p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_obj_array">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_obj_array</span></span></span><a class="headerlink" href="#c.drm_panthor_obj_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>Object array.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_obj_array {
    __u32 stride;
    __u32 count;
    __u64 array;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">stride</span></code></dt><dd><p>Stride of object struct. Used for versioning.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Number of objects in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code></dt><dd><p>User pointer to an array of objects.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This object is used to pass an array of objects whose size is subject to changes in
future versions of the driver. In order to support this mutability, we pass a stride
describing the size of the object as known by userspace.</p>
<p>You shouldn’t fill drm_panthor_obj_array fields directly. You should instead use
the <a class="reference internal" href="#c.DRM_PANTHOR_OBJ_ARRAY" title="DRM_PANTHOR_OBJ_ARRAY"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_PANTHOR_OBJ_ARRAY()</span></code></a> macro that takes care of initializing the stride to
the object size.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PANTHOR_OBJ_ARRAY">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PANTHOR_OBJ_ARRAY</span></span></span><a class="headerlink" href="#c.DRM_PANTHOR_OBJ_ARRAY" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_OBJ_ARRAY</span> <span class="pre">(cnt,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Initialize a drm_panthor_obj_array field.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cnt</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Pointer to the array to pass to the kernel.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Macro initializing a drm_panthor_obj_array based on the object size as known
by userspace.</p>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_panthor_sync_op_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_sync_op_flags</span></span></span><a class="headerlink" href="#c.drm_panthor_sync_op_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Synchronization operation flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_MASK</span></code></dt><dd><p>Synchronization handle type mask.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_SYNCOBJ</span></code></dt><dd><p>Synchronization object type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_TIMELINE_SYNCOBJ</span></code></dt><dd><p>Timeline synchronization
object type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_SYNC_OP_WAIT</span></code></dt><dd><p>Wait operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_SYNC_OP_SIGNAL</span></code></dt><dd><p>Signal operation.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_sync_op">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_sync_op</span></span></span><a class="headerlink" href="#c.drm_panthor_sync_op" title="Link to this definition">¶</a><br /></dt>
<dd><p>Synchronization operation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_sync_op {
    __u32 flags;
    __u32 handle;
    __u64 timeline_value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Synchronization operation flags. Combination of DRM_PANTHOR_SYNC_OP values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Sync handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeline_value</span></code></dt><dd><p>MBZ if
(flags &amp; DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_MASK) !=
DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_TIMELINE_SYNCOBJ.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_panthor_dev_query_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_dev_query_type</span></span></span><a class="headerlink" href="#c.drm_panthor_dev_query_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_DEV_QUERY_GPU_INFO</span></code></dt><dd><p>Query GPU information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_DEV_QUERY_CSIF_INFO</span></code></dt><dd><p>Query command-stream interface information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_DEV_QUERY_TIMESTAMP_INFO</span></code></dt><dd><p>Query timestamp information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_DEV_QUERY_GROUP_PRIORITIES_INFO</span></code></dt><dd><p>Query allowed group priorities information.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Place new types at the end, don’t re-order, don’t remove or replace.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_gpu_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_gpu_info</span></span></span><a class="headerlink" href="#c.drm_panthor_gpu_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>GPU information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_gpu_info {
    __u32 gpu_id;
#define DRM_PANTHOR_ARCH_MAJOR(x)               ((x) &gt;&gt; 28);
#define DRM_PANTHOR_ARCH_MINOR(x)               (((x) &gt;&gt; 24) &amp; 0xf);
#define DRM_PANTHOR_ARCH_REV(x)                 (((x) &gt;&gt; 20) &amp; 0xf);
#define DRM_PANTHOR_PRODUCT_MAJOR(x)            (((x) &gt;&gt; 16) &amp; 0xf);
#define DRM_PANTHOR_VERSION_MAJOR(x)            (((x) &gt;&gt; 12) &amp; 0xf);
#define DRM_PANTHOR_VERSION_MINOR(x)            (((x) &gt;&gt; 4) &amp; 0xff);
#define DRM_PANTHOR_VERSION_STATUS(x)           ((x) &amp; 0xf);
    __u32 gpu_rev;
    __u32 csf_id;
#define DRM_PANTHOR_CSHW_MAJOR(x)               (((x) &gt;&gt; 26) &amp; 0x3f);
#define DRM_PANTHOR_CSHW_MINOR(x)               (((x) &gt;&gt; 20) &amp; 0x3f);
#define DRM_PANTHOR_CSHW_REV(x)                 (((x) &gt;&gt; 16) &amp; 0xf);
#define DRM_PANTHOR_MCU_MAJOR(x)                (((x) &gt;&gt; 10) &amp; 0x3f);
#define DRM_PANTHOR_MCU_MINOR(x)                (((x) &gt;&gt; 4) &amp; 0x3f);
#define DRM_PANTHOR_MCU_REV(x)                  ((x) &amp; 0xf);
    __u32 l2_features;
    __u32 tiler_features;
    __u32 mem_features;
    __u32 mmu_features;
#define DRM_PANTHOR_MMU_VA_BITS(x)              ((x) &amp; 0xff);
    __u32 thread_features;
    __u32 max_threads;
    __u32 thread_max_workgroup_size;
    __u32 thread_max_barrier_size;
    __u32 coherency_features;
    __u32 texture_features[4];
    __u32 as_present;
    __u64 shader_present;
    __u64 l2_present;
    __u64 tiler_present;
    __u32 core_features;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gpu_id</span></code></dt><dd><p>GPU ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpu_rev</span></code></dt><dd><p>GPU revision.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csf_id</span></code></dt><dd><p>Command stream frontend ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l2_features</span></code></dt><dd><p>L2-cache features.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tiler_features</span></code></dt><dd><p>Tiler features.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_features</span></code></dt><dd><p>Memory features.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmu_features</span></code></dt><dd><p>MMU features.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thread_features</span></code></dt><dd><p>Thread features.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_threads</span></code></dt><dd><p>Maximum number of threads.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thread_max_workgroup_size</span></code></dt><dd><p>Maximum workgroup size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">thread_max_barrier_size</span></code></dt><dd><p>Maximum number of threads that can wait
simultaneously on a barrier.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coherency_features</span></code></dt><dd><p>Coherency features.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">texture_features</span></code></dt><dd><p>Texture features.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">as_present</span></code></dt><dd><p>Bitmask encoding the number of address-space exposed by the MMU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shader_present</span></code></dt><dd><p>Bitmask encoding the shader cores exposed by the GPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l2_present</span></code></dt><dd><p>Bitmask encoding the L2 caches exposed by the GPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tiler_present</span></code></dt><dd><p>Bitmask encoding the tiler units exposed by the GPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">core_features</span></code></dt><dd><p>Used to discriminate core variants when they exist.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure grouping all queryable information relating to the GPU.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_csif_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_csif_info</span></span></span><a class="headerlink" href="#c.drm_panthor_csif_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Command stream interface information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_csif_info {
    __u32 csg_slot_count;
    __u32 cs_slot_count;
    __u32 cs_reg_count;
    __u32 scoreboard_slot_count;
    __u32 unpreserved_cs_reg_count;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">csg_slot_count</span></code></dt><dd><p>Number of command stream group slots exposed by the firmware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_slot_count</span></code></dt><dd><p>Number of command stream slots per group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_reg_count</span></code></dt><dd><p>Number of command stream registers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scoreboard_slot_count</span></code></dt><dd><p>Number of scoreboard slots.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unpreserved_cs_reg_count</span></code></dt><dd><p>Number of command stream registers reserved by
the kernel driver to call a userspace command stream.</p>
<p>All registers can be used by a userspace command stream, but the
[cs_slot_count - unpreserved_cs_reg_count .. cs_slot_count] registers are
used by the kernel when DRM_PANTHOR_IOCTL_GROUP_SUBMIT is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding field, set to zero.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure grouping all queryable information relating to the command stream interface.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_timestamp_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_timestamp_info</span></span></span><a class="headerlink" href="#c.drm_panthor_timestamp_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Timestamp information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_timestamp_info {
    __u64 timestamp_frequency;
    __u64 current_timestamp;
    __u64 timestamp_offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">timestamp_frequency</span></code></dt><dd><p>The frequency of the timestamp timer or 0 if
unknown.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">current_timestamp</span></code></dt><dd><p>The current timestamp.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamp_offset</span></code></dt><dd><p>The offset of the timestamp timer.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure grouping all queryable information relating to the GPU timestamp.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_group_priorities_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_group_priorities_info</span></span></span><a class="headerlink" href="#c.drm_panthor_group_priorities_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Group priorities information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_group_priorities_info {
    __u8 allowed_mask;
    __u8 pad[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">allowed_mask</span></code></dt><dd><p>Bitmask of the allowed group priorities.</p>
<p>Each bit represents a variant of the <a class="reference internal" href="#c.drm_panthor_group_priority" title="drm_panthor_group_priority"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_panthor_group_priority</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding fields, MBZ.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure grouping all queryable information relating to the allowed group priorities.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_dev_query">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_dev_query</span></span></span><a class="headerlink" href="#c.drm_panthor_dev_query" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_PANTHOR_IOCTL_DEV_QUERY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_dev_query {
    __u32 type;
    __u32 size;
    __u64 pointer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the query type (see drm_panthor_dev_query_type).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size of the type being queried.</p>
<p>If pointer is NULL, size is updated by the driver to provide the
output structure size. If pointer is not NULL, the driver will
only copy min(size, actual_structure_size) bytes to the pointer,
and update the size accordingly. This allows us to extend query
types without breaking userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pointer</span></code></dt><dd><p>user pointer to a query type struct.</p>
<p>Pointer can be NULL, in which case, nothing is copied, but the
actual structure size is returned. If not NULL, it must point to
a location that’s large enough to hold size bytes.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_vm_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_vm_create</span></span></span><a class="headerlink" href="#c.drm_panthor_vm_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_PANTHOR_IOCTL_VM_CREATE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_vm_create {
    __u32 flags;
    __u32 id;
    __u64 user_va_range;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>VM flags, MBZ.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Returned VM ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user_va_range</span></code></dt><dd><p>Size of the VA space reserved for user objects.</p>
<p>The kernel will pick the remaining space to map kernel-only objects to the
VM (heap chunks, heap context, ring buffers, kernel synchronization objects,
...). If the space left for kernel objects is too small, kernel object
allocation will fail further down the road. One can use
drm_panthor_gpu_info::mmu_features to extract the total virtual address
range, and chose a user_va_range that leaves some space to the kernel.</p>
<p>If user_va_range is zero, the kernel will pick a sensible value based on
TASK_SIZE and the virtual range supported by the GPU MMU (the kernel/user
split should leave enough VA space for userspace processes to support SVM,
while still allowing the kernel to map some amount of kernel objects in
the kernel VA range). The value chosen by the driver will be returned in
<strong>user_va_range</strong>.</p>
<p>User VA space always starts at 0x0, kernel VA space is always placed after
the user VA range.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_vm_destroy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_vm_destroy</span></span></span><a class="headerlink" href="#c.drm_panthor_vm_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_PANTHOR_IOCTL_VM_DESTROY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_vm_destroy {
    __u32 id;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>ID of the VM to destroy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_panthor_vm_bind_op_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_vm_bind_op_flags</span></span></span><a class="headerlink" href="#c.drm_panthor_vm_bind_op_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>VM bind operation flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_OP_MAP_READONLY</span></code></dt><dd><p>Map the memory read-only.</p>
<p>Only valid with DRM_PANTHOR_VM_BIND_OP_TYPE_MAP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_OP_MAP_NOEXEC</span></code></dt><dd><p>Map the memory not-executable.</p>
<p>Only valid with DRM_PANTHOR_VM_BIND_OP_TYPE_MAP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_OP_MAP_UNCACHED</span></code></dt><dd><p>Map the memory uncached.</p>
<p>Only valid with DRM_PANTHOR_VM_BIND_OP_TYPE_MAP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_OP_TYPE_MASK</span></code></dt><dd><p>Mask used to determine the type of operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_OP_TYPE_MAP</span></code></dt><dd><p>Map operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_OP_TYPE_UNMAP</span></code></dt><dd><p>Unmap operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_OP_TYPE_SYNC_ONLY</span></code></dt><dd><p>No VM operation.</p>
<p>Just serves as a synchronization point on a VM queue.</p>
<p>Only valid if <code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_ASYNC</span></code> is set in drm_panthor_vm_bind::flags,
and drm_panthor_vm_bind_op::syncs contains at least one element.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_vm_bind_op">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_vm_bind_op</span></span></span><a class="headerlink" href="#c.drm_panthor_vm_bind_op" title="Link to this definition">¶</a><br /></dt>
<dd><p>VM bind operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_vm_bind_op {
    __u32 flags;
    __u32 bo_handle;
    __u64 bo_offset;
    __u64 va;
    __u64 size;
    struct drm_panthor_obj_array syncs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of drm_panthor_vm_bind_op_flags flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bo_handle</span></code></dt><dd><p>Handle of the buffer object to map.
MBZ for unmap or sync-only operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bo_offset</span></code></dt><dd><p>Buffer object offset.
MBZ for unmap or sync-only operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va</span></code></dt><dd><p>Virtual address to map/unmap.
MBZ for sync-only operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size to map/unmap.
MBZ for sync-only operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syncs</span></code></dt><dd><p>Array of <a class="reference internal" href="#c.drm_panthor_sync_op" title="drm_panthor_sync_op"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panthor_sync_op</span></code></a> synchronization
operations.</p>
<p>This array must be empty if <code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_ASYNC</span></code> is not set on
the drm_panthor_vm_bind object containing this VM bind operation.</p>
<p>This array shall not be empty for sync-only operations.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_panthor_vm_bind_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_vm_bind_flags</span></span></span><a class="headerlink" href="#c.drm_panthor_vm_bind_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>VM bind flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_BIND_ASYNC</span></code></dt><dd><p>VM bind operations are queued to the VM
queue instead of being executed synchronously.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_vm_bind">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_vm_bind</span></span></span><a class="headerlink" href="#c.drm_panthor_vm_bind" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_VM_BIND</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_vm_bind {
    __u32 vm_id;
    __u32 flags;
    struct drm_panthor_obj_array ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>VM targeted by the bind request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of drm_panthor_vm_bind_flags flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Array of <a class="reference internal" href="#c.drm_panthor_vm_bind_op" title="drm_panthor_vm_bind_op"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panthor_vm_bind_op</span></code></a> bind operations.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_panthor_vm_state">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_vm_state</span></span></span><a class="headerlink" href="#c.drm_panthor_vm_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>VM states.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_STATE_USABLE</span></code></dt><dd><p>VM is usable.</p>
<p>New VM operations will be accepted on this VM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_VM_STATE_UNUSABLE</span></code></dt><dd><p>VM is unusable.</p>
<p>Something put the VM in an unusable state (like an asynchronous
VM_BIND request failing for any reason).</p>
<p>Once the VM is in this state, all new MAP operations will be
rejected, and any GPU job targeting this VM will fail.
UNMAP operations are still accepted.</p>
<p>The only way to recover from an unusable VM is to create a new
VM, and destroy the old one.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_vm_get_state">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_vm_get_state</span></span></span><a class="headerlink" href="#c.drm_panthor_vm_get_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get VM state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_vm_get_state {
    __u32 vm_id;
    __u32 state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>VM targeted by the get_state request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>state returned by the driver.</p>
<p>Must be one of the <a class="reference internal" href="#c.drm_panthor_vm_state" title="drm_panthor_vm_state"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_panthor_vm_state</span></code></a> values.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_panthor_bo_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_bo_flags</span></span></span><a class="headerlink" href="#c.drm_panthor_bo_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Buffer object flags, passed at creation time.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_BO_NO_MMAP</span></code></dt><dd><p>The buffer object will never be CPU-mapped in userspace.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_bo_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_bo_create</span></span></span><a class="headerlink" href="#c.drm_panthor_bo_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_BO_CREATE.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_bo_create {
    __u64 size;
    __u32 flags;
    __u32 exclusive_vm_id;
    __u32 handle;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Requested size for the object</p>
<p>The (page-aligned) allocated size for the object will be returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags. Must be a combination of drm_panthor_bo_flags flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exclusive_vm_id</span></code></dt><dd><p>Exclusive VM this buffer object will be mapped to.</p>
<dl class="simple">
<dt>If not zero, the field must refer to a valid VM ID, and implies that:</dt><dd><ul class="simple">
<li><p>the buffer object will only ever be bound to that VM</p></li>
<li><p>cannot be exported as a PRIME fd</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Returned handle for the object.</p>
<p>Object handles are nonzero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_bo_mmap_offset">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_bo_mmap_offset</span></span></span><a class="headerlink" href="#c.drm_panthor_bo_mmap_offset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_BO_MMAP_OFFSET.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_bo_mmap_offset {
    __u32 handle;
    __u32 pad;
    __u64 offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle of the object we want an mmap offset for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>The fake offset to use for subsequent mmap calls.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_queue_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_queue_create</span></span></span><a class="headerlink" href="#c.drm_panthor_queue_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Queue creation arguments.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_queue_create {
    __u8 priority;
    __u8 pad[3];
    __u32 ringbuf_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt><dd><p>Defines the priority of queues inside a group. Goes from 0 to 15,
15 being the highest priority.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding fields, MBZ.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ringbuf_size</span></code></dt><dd><p>Size of the ring buffer to allocate to this queue.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_panthor_group_priority">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_group_priority</span></span></span><a class="headerlink" href="#c.drm_panthor_group_priority" title="Link to this definition">¶</a><br /></dt>
<dd><p>Scheduling group priority</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">PANTHOR_GROUP_PRIORITY_LOW</span></code></dt><dd><p>Low priority group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PANTHOR_GROUP_PRIORITY_MEDIUM</span></code></dt><dd><p>Medium priority group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PANTHOR_GROUP_PRIORITY_HIGH</span></code></dt><dd><p>High priority group.</p>
<p>Requires CAP_SYS_NICE or DRM_MASTER.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PANTHOR_GROUP_PRIORITY_REALTIME</span></code></dt><dd><p>Realtime priority group.</p>
<p>Requires CAP_SYS_NICE or DRM_MASTER.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_group_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_group_create</span></span></span><a class="headerlink" href="#c.drm_panthor_group_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_GROUP_CREATE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_group_create {
    struct drm_panthor_obj_array queues;
    __u8 max_compute_cores;
    __u8 max_fragment_cores;
    __u8 max_tiler_cores;
    __u8 priority;
    __u32 pad;
    __u64 compute_core_mask;
    __u64 fragment_core_mask;
    __u64 tiler_core_mask;
    __u32 vm_id;
    __u32 group_handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">queues</span></code></dt><dd><p>Array of drm_panthor_queue_create elements.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_compute_cores</span></code></dt><dd><p>Maximum number of cores that can be used by compute
jobs across CS queues bound to this group.</p>
<p>Must be less or equal to the number of bits set in <strong>compute_core_mask</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_fragment_cores</span></code></dt><dd><p>Maximum number of cores that can be used by fragment
jobs across CS queues bound to this group.</p>
<p>Must be less or equal to the number of bits set in <strong>fragment_core_mask</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_tiler_cores</span></code></dt><dd><p>Maximum number of tilers that can be used by tiler jobs
across CS queues bound to this group.</p>
<p>Must be less or equal to the number of bits set in <strong>tiler_core_mask</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt><dd><p>Group priority (see <a class="reference internal" href="#c.drm_panthor_group_priority" title="drm_panthor_group_priority"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_panthor_group_priority</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding field, MBZ.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compute_core_mask</span></code></dt><dd><p>Mask encoding cores that can be used for compute jobs.</p>
<p>This field must have at least <strong>max_compute_cores</strong> bits set.</p>
<p>The bits set here should also be set in drm_panthor_gpu_info::shader_present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fragment_core_mask</span></code></dt><dd><p>Mask encoding cores that can be used for fragment jobs.</p>
<p>This field must have at least <strong>max_fragment_cores</strong> bits set.</p>
<p>The bits set here should also be set in drm_panthor_gpu_info::shader_present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tiler_core_mask</span></code></dt><dd><p>Mask encoding cores that can be used for tiler jobs.</p>
<p>This field must have at least <strong>max_tiler_cores</strong> bits set.</p>
<p>The bits set here should also be set in drm_panthor_gpu_info::tiler_present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>VM ID to bind this group to.</p>
<p>All submission to queues bound to this group will use this VM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">group_handle</span></code></dt><dd><p>Returned group handle. Passed back when submitting jobs or
destroying a group.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_group_destroy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_group_destroy</span></span></span><a class="headerlink" href="#c.drm_panthor_group_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_GROUP_DESTROY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_group_destroy {
    __u32 group_handle;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">group_handle</span></code></dt><dd><p>Group to destroy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding field, MBZ.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_queue_submit">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_queue_submit</span></span></span><a class="headerlink" href="#c.drm_panthor_queue_submit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Job submission arguments.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_queue_submit {
    __u32 queue_index;
    __u32 stream_size;
    __u64 stream_addr;
    __u32 latest_flush;
    __u32 pad;
    struct drm_panthor_obj_array syncs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">queue_index</span></code></dt><dd><p>Index of the queue inside a group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_size</span></code></dt><dd><p>Size of the command stream to execute.</p>
<p>Must be 64-bit/8-byte aligned (the size of a CS instruction)</p>
<p>Can be zero if stream_addr is zero too.</p>
<p>When the stream size is zero, the queue submit serves as a
synchronization point.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_addr</span></code></dt><dd><p>GPU address of the command stream to execute.</p>
<p>Must be aligned on 64-byte.</p>
<p>Can be zero is stream_size is zero too.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">latest_flush</span></code></dt><dd><p>FLUSH_ID read at the time the stream was built.</p>
<p>This allows cache flush elimination for the automatic
flush+invalidate(all) done at submission time, which is needed to
ensure the GPU doesn’t get garbage when reading the indirect command
stream buffers. If you want the cache flush to happen
unconditionally, pass a zero here.</p>
<p>Ignored when stream_size is zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syncs</span></code></dt><dd><p>Array of <a class="reference internal" href="#c.drm_panthor_sync_op" title="drm_panthor_sync_op"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panthor_sync_op</span></code></a> sync operations.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is describing the userspace command stream to call from the kernel
command stream ring-buffer. Queue submission is always part of a group
submission, taking one or more jobs to submit to the underlying queues.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_group_submit">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_group_submit</span></span></span><a class="headerlink" href="#c.drm_panthor_group_submit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_GROUP_SUBMIT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_group_submit {
    __u32 group_handle;
    __u32 pad;
    struct drm_panthor_obj_array queue_submits;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">group_handle</span></code></dt><dd><p>Handle of the group to queue jobs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue_submits</span></code></dt><dd><p>Array of drm_panthor_queue_submit objects.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_panthor_group_state_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_group_state_flags</span></span></span><a class="headerlink" href="#c.drm_panthor_group_state_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Group state flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_GROUP_STATE_TIMEDOUT</span></code></dt><dd><p>Group had unfinished jobs.</p>
<p>When a group ends up with this flag set, no jobs can be submitted to its queues.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_GROUP_STATE_FATAL_FAULT</span></code></dt><dd><p>Group had fatal faults.</p>
<p>When a group ends up with this flag set, no jobs can be submitted to its queues.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PANTHOR_GROUP_STATE_INNOCENT</span></code></dt><dd><p>Group was killed during a reset caused by other
groups.</p>
<p>This flag can only be set if DRM_PANTHOR_GROUP_STATE_TIMEDOUT is set and
DRM_PANTHOR_GROUP_STATE_FATAL_FAULT is not.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_group_get_state">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_group_get_state</span></span></span><a class="headerlink" href="#c.drm_panthor_group_get_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_GROUP_GET_STATE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_group_get_state {
    __u32 group_handle;
    __u32 state;
    __u32 fatal_queues;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">group_handle</span></code></dt><dd><p>Handle of the group to query state on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>Combination of DRM_PANTHOR_GROUP_STATE_* flags encoding the
group state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fatal_queues</span></code></dt><dd><p>Bitmask of queues that faced fatal faults.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Used to query the state of a group and decide whether a new group should be created to
replace it.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_tiler_heap_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_tiler_heap_create</span></span></span><a class="headerlink" href="#c.drm_panthor_tiler_heap_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_TILER_HEAP_CREATE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_tiler_heap_create {
    __u32 vm_id;
    __u32 initial_chunk_count;
    __u32 chunk_size;
    __u32 max_chunks;
    __u32 target_in_flight;
    __u32 handle;
    __u64 tiler_heap_ctx_gpu_va;
    __u64 first_heap_chunk_gpu_va;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>VM ID the tiler heap should be mapped to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_chunk_count</span></code></dt><dd><p>Initial number of chunks to allocate. Must be at least one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chunk_size</span></code></dt><dd><p>Chunk size.</p>
<p>Must be page-aligned and lie in the [128k:8M] range.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_chunks</span></code></dt><dd><p>Maximum number of chunks that can be allocated.</p>
<p>Must be at least <strong>initial_chunk_count</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target_in_flight</span></code></dt><dd><p>Maximum number of in-flight render passes.</p>
<p>If the heap has more than tiler jobs in-flight, the FW will wait for render
passes to finish before queuing new tiler jobs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Returned heap handle. Passed back to DESTROY_TILER_HEAP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tiler_heap_ctx_gpu_va</span></code></dt><dd><p>Returned heap GPU virtual address returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first_heap_chunk_gpu_va</span></code></dt><dd><p>First heap chunk.</p>
<p>The tiler heap is formed of heap chunks forming a single-link list. This
is the first element in the list.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_panthor_tiler_heap_destroy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_panthor_tiler_heap_destroy</span></span></span><a class="headerlink" href="#c.drm_panthor_tiler_heap_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments passed to DRM_IOCTL_PANTHOR_TILER_HEAP_DESTROY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panthor_tiler_heap_destroy {
    __u32 handle;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle of the tiler heap to destroy.</p>
<p>Must be a valid heap handle returned by DRM_IOCTL_PANTHOR_TILER_HEAP_CREATE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding field, MBZ.</p>
</dd>
</dl>
</div>
</section>
<section id="drm-xe-uapi">
<h2>drm/xe uAPI<a class="headerlink" href="#drm-xe-uapi" title="Link to this heading">¶</a></h2>
<p id="xe-device-block-diagram"><strong>Xe Device Block Diagram</strong></p>
<p>The diagram below represents a high-level simplification of a discrete
GPU supported by the Xe driver. It shows some device components which
are necessary to understand this API, as well as how their relations
to each other. This diagram does not represent real hardware:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>┌──────────────────────────────────────────────────────────────────┐
│ ┌──────────────────────────────────────────────────┐ ┌─────────┐ │
│ │        ┌───────────────────────┐   ┌─────┐       │ │ ┌─────┐ │ │
│ │        │         VRAM0         ├───┤ ... │       │ │ │VRAM1│ │ │
│ │        └───────────┬───────────┘   └─GT1─┘       │ │ └──┬──┘ │ │
│ │ ┌──────────────────┴───────────────────────────┐ │ │ ┌──┴──┐ │ │
│ │ │ ┌─────────────────────┐  ┌─────────────────┐ │ │ │ │     │ │ │
│ │ │ │ ┌──┐ ┌──┐ ┌──┐ ┌──┐ │  │ ┌─────┐ ┌─────┐ │ │ │ │ │     │ │ │
│ │ │ │ │EU│ │EU│ │EU│ │EU│ │  │ │RCS0 │ │BCS0 │ │ │ │ │ │     │ │ │
│ │ │ │ └──┘ └──┘ └──┘ └──┘ │  │ └─────┘ └─────┘ │ │ │ │ │     │ │ │
│ │ │ │ ┌──┐ ┌──┐ ┌──┐ ┌──┐ │  │ ┌─────┐ ┌─────┐ │ │ │ │ │     │ │ │
│ │ │ │ │EU│ │EU│ │EU│ │EU│ │  │ │VCS0 │ │VCS1 │ │ │ │ │ │     │ │ │
│ │ │ │ └──┘ └──┘ └──┘ └──┘ │  │ └─────┘ └─────┘ │ │ │ │ │     │ │ │
│ │ │ │ ┌──┐ ┌──┐ ┌──┐ ┌──┐ │  │ ┌─────┐ ┌─────┐ │ │ │ │ │     │ │ │
│ │ │ │ │EU│ │EU│ │EU│ │EU│ │  │ │VECS0│ │VECS1│ │ │ │ │ │ ... │ │ │
│ │ │ │ └──┘ └──┘ └──┘ └──┘ │  │ └─────┘ └─────┘ │ │ │ │ │     │ │ │
│ │ │ │ ┌──┐ ┌──┐ ┌──┐ ┌──┐ │  │ ┌─────┐ ┌─────┐ │ │ │ │ │     │ │ │
│ │ │ │ │EU│ │EU│ │EU│ │EU│ │  │ │CCS0 │ │CCS1 │ │ │ │ │ │     │ │ │
│ │ │ │ └──┘ └──┘ └──┘ └──┘ │  │ └─────┘ └─────┘ │ │ │ │ │     │ │ │
│ │ │ └─────────DSS─────────┘  │ ┌─────┐ ┌─────┐ │ │ │ │ │     │ │ │
│ │ │                          │ │CCS2 │ │CCS3 │ │ │ │ │ │     │ │ │
│ │ │ ┌─────┐ ┌─────┐ ┌─────┐  │ └─────┘ └─────┘ │ │ │ │ │     │ │ │
│ │ │ │ ... │ │ ... │ │ ... │  │                 │ │ │ │ │     │ │ │
│ │ │ └─DSS─┘ └─DSS─┘ └─DSS─┘  └─────Engines─────┘ │ │ │ │     │ │ │
│ │ └───────────────────────────GT0────────────────┘ │ │ └─GT2─┘ │ │
│ └────────────────────────────Tile0─────────────────┘ └─ Tile1──┘ │
└─────────────────────────────Device0───────┬──────────────────────┘
                                            │
                     ───────────────────────┴────────── PCI bus
</pre></div>
</div>
<p id="xe-uapi-overview"><strong>Xe uAPI Overview</strong></p>
<p>This section aims to describe the Xe’s IOCTL entries, its structs, and other
Xe related uAPI such as uevents and PMU (Platform Monitoring Unit) related
entries and usage.</p>
<dl class="simple">
<dt>List of supported IOCTLs:</dt><dd><ul class="simple">
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_DEVICE_QUERY</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_GEM_CREATE</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_GEM_MMAP_OFFSET</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_VM_CREATE</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_VM_DESTROY</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_VM_BIND</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_EXEC_QUEUE_CREATE</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_EXEC_QUEUE_DESTROY</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_EXEC_QUEUE_GET_PROPERTY</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_EXEC</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_WAIT_USER_FENCE</span></code></p></li>
<li><p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_OBSERVATION</span></code></p></li>
</ul>
</dd>
</dl>
<p id="xe-ioctl-extensions"><strong>Xe IOCTL Extensions</strong></p>
<p>Before detailing the IOCTLs and its structs, it is important to highlight
that every IOCTL in Xe is extensible.</p>
<p>Many interfaces need to grow over time. In most cases we can simply
extend the struct and have userspace pass in more data. Another option,
as demonstrated by Vulkan’s approach to providing extensions for forward
and backward compatibility, is to use a list of optional structs to
provide those extra details.</p>
<p>The key advantage to using an extension chain is that it allows us to
redefine the interface more easily than an ever growing struct of
increasing complexity, and for large parts of that interface to be
entirely optional. The downside is more pointer chasing; chasing across
the __user boundary with pointers encapsulated inside u64.</p>
<p>Example chaining:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_user_extension</span><span class="w"> </span><span class="n">ext3</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// end</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_user_extension</span><span class="w"> </span><span class="n">ext2</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext3</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_user_extension</span><span class="w"> </span><span class="n">ext1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext2</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Typically the <a class="reference internal" href="#c.drm_xe_user_extension" title="drm_xe_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_user_extension</span></code></a> would be embedded in some uAPI
struct, and in this case we would feed it the head of the chain(i.e ext1),
which would then apply all of the above extensions.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_user_extension">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_user_extension</span></span></span><a class="headerlink" href="#c.drm_xe_user_extension" title="Link to this definition">¶</a><br /></dt>
<dd><p>Base class for defining a chain of extensions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_user_extension {
    __u64 next_extension;
    __u32 name;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">next_extension</span></code></dt><dd><p>Pointer to the next <a class="reference internal" href="#c.drm_xe_user_extension" title="drm_xe_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_user_extension</span></code></a>, or zero if the end.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the extension.</p>
<p>Note that the name here is just some integer.</p>
<p>Also note that the name space for this is not global for the whole
driver, but rather its scope/meaning is limited to the specific piece
of uAPI which has embedded the <a class="reference internal" href="#c.drm_xe_user_extension" title="drm_xe_user_extension"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
<p>All undefined bits must be zero.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_ext_set_property">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_ext_set_property</span></span></span><a class="headerlink" href="#c.drm_xe_ext_set_property" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic set property extension</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_ext_set_property {
    struct drm_xe_user_extension base;
    __u32 property;
    __u32 pad;
    __u64 value;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base user extension</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">property</span></code></dt><dd><p>property to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>property value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A generic struct that allows any of the Xe’s IOCTL to be extended
with a set_property operation.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_engine_class_instance">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_engine_class_instance</span></span></span><a class="headerlink" href="#c.drm_xe_engine_class_instance" title="Link to this definition">¶</a><br /></dt>
<dd><p>instance of an engine class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_engine_class_instance {
#define DRM_XE_ENGINE_CLASS_RENDER              0;
#define DRM_XE_ENGINE_CLASS_COPY                1;
#define DRM_XE_ENGINE_CLASS_VIDEO_DECODE        2;
#define DRM_XE_ENGINE_CLASS_VIDEO_ENHANCE       3;
#define DRM_XE_ENGINE_CLASS_COMPUTE             4;
#define DRM_XE_ENGINE_CLASS_VM_BIND             5;
    __u16 engine_class;
    __u16 engine_instance;
    __u16 gt_id;
    __u16 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">engine_class</span></code></dt><dd><p>engine class id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine_instance</span></code></dt><dd><p>engine instance id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gt_id</span></code></dt><dd><p>Unique ID of this GT within the PCI Device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>It is returned as part of the <strong>drm_xe_engine</strong>, but it also is used as
the input of engine selection for both <strong>drm_xe_exec_queue_create</strong> and
<strong>drm_xe_query_engine_cycles</strong></p>
<dl class="simple">
<dt>The <strong>engine_class</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_ENGINE_CLASS_RENDER</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_ENGINE_CLASS_COPY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_ENGINE_CLASS_VIDEO_DECODE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_ENGINE_CLASS_VIDEO_ENHANCE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_ENGINE_CLASS_COMPUTE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_ENGINE_CLASS_VM_BIND</span></code> - Kernel only classes (not actual
hardware engine class). Used for creating ordered queues of VM
bind operations.</p></li>
</ul>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_engine">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_engine</span></span></span><a class="headerlink" href="#c.drm_xe_engine" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe hardware engine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_engine {
    struct drm_xe_engine_class_instance instance;
    __u64 reserved[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">instance</span></code></dt><dd><p>The <strong>drm_xe_engine_class_instance</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_query_engines">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_query_engines</span></span></span><a class="headerlink" href="#c.drm_xe_query_engines" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe engines</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_query_engines {
    __u32 num_engines;
    __u32 pad;
    struct drm_xe_engine engines[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_engines</span></code></dt><dd><p>number of engines returned in <strong>engines</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engines</span></code></dt><dd><p>The returned engines for this device</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If a query is made with a struct <strong>drm_xe_device_query</strong> where .query
is equal to <code class="docutils literal notranslate"><span class="pre">DRM_XE_DEVICE_QUERY_ENGINES</span></code>, then the reply uses an array of
struct <strong>drm_xe_query_engines</strong> in .data.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_xe_memory_class">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_memory_class</span></span></span><a class="headerlink" href="#c.drm_xe_memory_class" title="Link to this definition">¶</a><br /></dt>
<dd><p>Supported memory classes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_MEM_REGION_CLASS_SYSMEM</span></code></dt><dd><p>Represents system memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_MEM_REGION_CLASS_VRAM</span></code></dt><dd><p>On discrete platforms, this
represents the memory that is local to the device, which we
call VRAM. Not valid on integrated platforms.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_mem_region">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_mem_region</span></span></span><a class="headerlink" href="#c.drm_xe_mem_region" title="Link to this definition">¶</a><br /></dt>
<dd><p>Describes some region as known to the driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_mem_region {
    __u16 mem_class;
    __u16 instance;
    __u32 min_page_size;
    __u64 total_size;
    __u64 used;
    __u64 cpu_visible_size;
    __u64 cpu_visible_used;
    __u64 reserved[6];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">mem_class</span></code></dt><dd><p>The memory class describing this region.</p>
<p>See <a class="reference internal" href="#c.drm_xe_memory_class" title="drm_xe_memory_class"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_xe_memory_class</span></code></a> for supported values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">instance</span></code></dt><dd><p>The unique ID for this region, which serves as the
index in the placement bitmask used as argument for
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_GEM_CREATE</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_page_size</span></code></dt><dd><p>Min page-size in bytes for this region.</p>
<p>When the kernel allocates memory for this region, the
underlying pages will be at least <strong>min_page_size</strong> in size.
Buffer objects with an allowable placement in this region must be
created with a size aligned to this value.
GPU virtual address mappings of (parts of) buffer objects that
may be placed in this region must also have their GPU virtual
address and range aligned to this value.
Affected IOCTLS will return <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> if alignment restrictions are
not met.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_size</span></code></dt><dd><p>The usable size in bytes for this region.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">used</span></code></dt><dd><p>Estimate of the memory used in bytes for this region.</p>
<p>Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable
accounting.  Without this the value here will always equal
zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu_visible_size</span></code></dt><dd><p>How much of this region can be CPU
accessed, in bytes.</p>
<p>This will always be &lt;= <strong>total_size</strong>, and the remainder (if
any) will not be CPU accessible. If the CPU accessible part
is smaller than <strong>total_size</strong> then this is referred to as a
small BAR system.</p>
<p>On systems without small BAR (full BAR), the probed_size will
always equal the <strong>total_size</strong>, since all of it will be CPU
accessible.</p>
<p>Note this is only tracked for DRM_XE_MEM_REGION_CLASS_VRAM
regions (for other types the value here will always equal
zero).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu_visible_used</span></code></dt><dd><p>Estimate of CPU visible memory used, in
bytes.</p>
<p>Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable
accounting. Without this the value here will always equal
zero.  Note this is only currently tracked for
DRM_XE_MEM_REGION_CLASS_VRAM regions (for other types the value
here will always be zero).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_query_mem_regions">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_query_mem_regions</span></span></span><a class="headerlink" href="#c.drm_xe_query_mem_regions" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe memory regions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_query_mem_regions {
    __u32 num_mem_regions;
    __u32 pad;
    struct drm_xe_mem_region mem_regions[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_mem_regions</span></code></dt><dd><p>number of memory regions returned in <strong>mem_regions</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_regions</span></code></dt><dd><p>The returned memory regions for this device</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If a query is made with a <a class="reference internal" href="#c.drm_xe_device_query" title="drm_xe_device_query"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_device_query</span></code></a> where .query
is equal to DRM_XE_DEVICE_QUERY_MEM_REGIONS, then the reply uses
<a class="reference internal" href="#c.drm_xe_query_mem_regions" title="drm_xe_query_mem_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_query_mem_regions</span></code></a> in .data.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_query_config">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_query_config</span></span></span><a class="headerlink" href="#c.drm_xe_query_config" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe the device configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_query_config {
    __u32 num_params;
    __u32 pad;
#define DRM_XE_QUERY_CONFIG_REV_AND_DEVICE_ID   0;
#define DRM_XE_QUERY_CONFIG_FLAGS                       1;
#define DRM_XE_QUERY_CONFIG_FLAG_HAS_VRAM       (1 &lt;&lt; 0);
#define DRM_XE_QUERY_CONFIG_MIN_ALIGNMENT               2;
#define DRM_XE_QUERY_CONFIG_VA_BITS                     3;
#define DRM_XE_QUERY_CONFIG_MAX_EXEC_QUEUE_PRIORITY     4;
    __u64 info[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_params</span></code></dt><dd><p>number of parameters returned in info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>array of elements containing the config info</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If a query is made with a <a class="reference internal" href="#c.drm_xe_device_query" title="drm_xe_device_query"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_device_query</span></code></a> where .query
is equal to DRM_XE_DEVICE_QUERY_CONFIG, then the reply uses
<a class="reference internal" href="#c.drm_xe_query_config" title="drm_xe_query_config"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_query_config</span></code></a> in .data.</p>
<dl class="simple">
<dt>The index in <strong>info</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_QUERY_CONFIG_REV_AND_DEVICE_ID</span></code> - Device ID (lower 16 bits)
and the device revision (next 8 bits)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_QUERY_CONFIG_FLAGS</span></code> - Flags describing the device
configuration, see list below</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_QUERY_CONFIG_FLAG_HAS_VRAM</span></code> - Flag is set if the device
has usable VRAM</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_QUERY_CONFIG_MIN_ALIGNMENT</span></code> - Minimal memory alignment
required by this device, typically SZ_4K or SZ_64K</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_QUERY_CONFIG_VA_BITS</span></code> - Maximum bits of a virtual address</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_QUERY_CONFIG_MAX_EXEC_QUEUE_PRIORITY</span></code> - Value of the highest
available exec queue priority</p></li>
</ul>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_gt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_gt</span></span></span><a class="headerlink" href="#c.drm_xe_gt" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe an individual GT.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_gt {
#define DRM_XE_QUERY_GT_TYPE_MAIN               0;
#define DRM_XE_QUERY_GT_TYPE_MEDIA              1;
    __u16 type;
    __u16 tile_id;
    __u16 gt_id;
    __u16 pad[3];
    __u32 reference_clock;
    __u64 near_mem_regions;
    __u64 far_mem_regions;
    __u16 ip_ver_major;
    __u16 ip_ver_minor;
    __u16 ip_ver_rev;
    __u16 pad2;
    __u64 reserved[7];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>GT type: Main or Media</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tile_id</span></code></dt><dd><p>Tile ID where this GT lives (Information only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gt_id</span></code></dt><dd><p>Unique ID of this GT within the PCI Device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reference_clock</span></code></dt><dd><p>A clock frequency for timestamp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">near_mem_regions</span></code></dt><dd><p>Bit mask of instances from
drm_xe_query_mem_regions that are nearest to the current engines
of this GT.
Each index in this mask refers directly to the <a class="reference internal" href="#c.drm_xe_query_mem_regions" title="drm_xe_query_mem_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_xe_query_mem_regions</span></code></a>’ instance, no assumptions should
be made about order. The type of each region is described
by <a class="reference internal" href="#c.drm_xe_query_mem_regions" title="drm_xe_query_mem_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_query_mem_regions</span></code></a>’ mem_class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">far_mem_regions</span></code></dt><dd><p>Bit mask of instances from
drm_xe_query_mem_regions that are far from the engines of this GT.
In general, they have extra indirections when compared to the
<strong>near_mem_regions</strong>. For a discrete device this could mean system
memory and memory living in a different tile.
Each index in this mask refers directly to the <a class="reference internal" href="#c.drm_xe_query_mem_regions" title="drm_xe_query_mem_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_xe_query_mem_regions</span></code></a>’ instance, no assumptions should
be made about order. The type of each region is described
by <a class="reference internal" href="#c.drm_xe_query_mem_regions" title="drm_xe_query_mem_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_query_mem_regions</span></code></a>’ mem_class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_ver_major</span></code></dt><dd><p>Graphics/media IP major version on GMD_ID platforms</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_ver_minor</span></code></dt><dd><p>Graphics/media IP minor version on GMD_ID platforms</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_ver_rev</span></code></dt><dd><p>Graphics/media IP revision version on GMD_ID platforms</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad2</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>To be used with drm_xe_query_gt_list, which will return a list with all the
existing GT individual descriptions.
Graphics Technology (GT) is a subset of a GPU/tile that is responsible for
implementing graphics and/or media operations.</p>
<dl class="simple">
<dt>The index in <strong>type</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_QUERY_GT_TYPE_MAIN</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_QUERY_GT_TYPE_MEDIA</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_query_gt_list">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_query_gt_list</span></span></span><a class="headerlink" href="#c.drm_xe_query_gt_list" title="Link to this definition">¶</a><br /></dt>
<dd><p>A list with GT description items.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_query_gt_list {
    __u32 num_gt;
    __u32 pad;
    struct drm_xe_gt gt_list[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_gt</span></code></dt><dd><p>number of GT items returned in gt_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gt_list</span></code></dt><dd><p>The GT list returned for this device</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If a query is made with a <a class="reference internal" href="#c.drm_xe_device_query" title="drm_xe_device_query"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_device_query</span></code></a> where .query
is equal to DRM_XE_DEVICE_QUERY_GT_LIST, then the reply uses <a class="reference internal" href="#c.drm_xe_query_gt_list" title="drm_xe_query_gt_list"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_xe_query_gt_list</span></code></a> in .data.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_query_topology_mask">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_query_topology_mask</span></span></span><a class="headerlink" href="#c.drm_xe_query_topology_mask" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe the topology mask of a GT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_query_topology_mask {
    __u16 gt_id;
#define DRM_XE_TOPO_DSS_GEOMETRY        1;
#define DRM_XE_TOPO_DSS_COMPUTE         2;
#define DRM_XE_TOPO_L3_BANK             3;
#define DRM_XE_TOPO_EU_PER_DSS          4;
#define DRM_XE_TOPO_SIMD16_EU_PER_DSS   5;
    __u16 type;
    __u32 num_bytes;
    __u8 mask[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gt_id</span></code></dt><dd><p>GT ID the mask is associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_bytes</span></code></dt><dd><p>number of bytes in requested mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>little-endian mask of <strong>num_bytes</strong></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is the hardware topology which reflects the internal physical
structure of the GPU.</p>
<p>If a query is made with a <a class="reference internal" href="#c.drm_xe_device_query" title="drm_xe_device_query"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_device_query</span></code></a> where .query
is equal to DRM_XE_DEVICE_QUERY_GT_TOPOLOGY, then the reply uses
<a class="reference internal" href="#c.drm_xe_query_topology_mask" title="drm_xe_query_topology_mask"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_query_topology_mask</span></code></a> in .data.</p>
<dl class="simple">
<dt>The <strong>type</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_TOPO_DSS_GEOMETRY</span></code> - To query the mask of Dual Sub Slices
(DSS) available for geometry operations. For example a query response
containing the following in mask:
<code class="docutils literal notranslate"><span class="pre">DSS_GEOMETRY</span>&#160;&#160;&#160; <span class="pre">ff</span> <span class="pre">ff</span> <span class="pre">ff</span> <span class="pre">ff</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span></code>
means 32 DSS are available for geometry.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_TOPO_DSS_COMPUTE</span></code> - To query the mask of Dual Sub Slices
(DSS) available for compute operations. For example a query response
containing the following in mask:
<code class="docutils literal notranslate"><span class="pre">DSS_COMPUTE</span>&#160;&#160;&#160; <span class="pre">ff</span> <span class="pre">ff</span> <span class="pre">ff</span> <span class="pre">ff</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span></code>
means 32 DSS are available for compute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_TOPO_L3_BANK</span></code> - To query the mask of enabled L3 banks.  This type
may be omitted if the driver is unable to query the mask from the
hardware.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_TOPO_EU_PER_DSS</span></code> - To query the mask of Execution Units (EU)
available per Dual Sub Slices (DSS). For example a query response
containing the following in mask:
<code class="docutils literal notranslate"><span class="pre">EU_PER_DSS</span>&#160;&#160;&#160; <span class="pre">ff</span> <span class="pre">ff</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span></code>
means each DSS has 16 SIMD8 EUs. This type may be omitted if device
doesn’t have SIMD8 EUs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_TOPO_SIMD16_EU_PER_DSS</span></code> - To query the mask of SIMD16 Execution
Units (EU) available per Dual Sub Slices (DSS). For example a query
response containing the following in mask:
<code class="docutils literal notranslate"><span class="pre">SIMD16_EU_PER_DSS</span>&#160;&#160;&#160; <span class="pre">ff</span> <span class="pre">ff</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span></code>
means each DSS has 16 SIMD16 EUs. This type may be omitted if device
doesn’t have SIMD16 EUs.</p></li>
</ul>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_query_engine_cycles">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_query_engine_cycles</span></span></span><a class="headerlink" href="#c.drm_xe_query_engine_cycles" title="Link to this definition">¶</a><br /></dt>
<dd><p>correlate CPU and GPU timestamps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_query_engine_cycles {
    struct drm_xe_engine_class_instance eci;
    __s32 clockid;
    __u32 width;
    __u64 engine_cycles;
    __u64 cpu_timestamp;
    __u64 cpu_delta;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">eci</span></code></dt><dd><p>This is input by the user and is the engine for which command
streamer cycles is queried.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid</span></code></dt><dd><p>This is input by the user and is the reference clock id for
CPU timestamp. For definition, see clock_gettime(2) and
perf_event_open(2). Supported clock ids are CLOCK_MONOTONIC,
CLOCK_MONOTONIC_RAW, CLOCK_REALTIME, CLOCK_BOOTTIME, CLOCK_TAI.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>Width of the engine cycle counter in bits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine_cycles</span></code></dt><dd><p>Engine cycles as read from its register
at 0x358 offset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu_timestamp</span></code></dt><dd><p>CPU timestamp in ns. The timestamp is captured before
reading the engine_cycles register using the reference clockid set by the
user.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu_delta</span></code></dt><dd><p>Time delta in ns captured around reading the lower dword
of the engine_cycles register.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If a query is made with a <a class="reference internal" href="#c.drm_xe_device_query" title="drm_xe_device_query"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_device_query</span></code></a> where .query is equal to
DRM_XE_DEVICE_QUERY_ENGINE_CYCLES, then the reply uses <a class="reference internal" href="#c.drm_xe_query_engine_cycles" title="drm_xe_query_engine_cycles"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_query_engine_cycles</span></code></a>
in .data. <a class="reference internal" href="#c.drm_xe_query_engine_cycles" title="drm_xe_query_engine_cycles"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_query_engine_cycles</span></code></a> is allocated by the user and
.data points to this allocated structure.</p>
<p>The query returns the engine cycles, which along with GT’s <strong>reference_clock</strong>,
can be used to calculate the engine timestamp. In addition the
query returns a set of cpu timestamps that indicate when the command
streamer cycle count was captured.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_query_uc_fw_version">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_query_uc_fw_version</span></span></span><a class="headerlink" href="#c.drm_xe_query_uc_fw_version" title="Link to this definition">¶</a><br /></dt>
<dd><p>query a micro-controller firmware version</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_query_uc_fw_version {
#define XE_QUERY_UC_TYPE_GUC_SUBMISSION 0;
#define XE_QUERY_UC_TYPE_HUC 1;
    __u16 uc_type;
    __u16 pad;
    __u32 branch_ver;
    __u32 major_ver;
    __u32 minor_ver;
    __u32 patch_ver;
    __u32 pad2;
    __u64 reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uc_type</span></code></dt><dd><p>The micro-controller type to query firmware version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">branch_ver</span></code></dt><dd><p>branch uc fw version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">major_ver</span></code></dt><dd><p>major uc fw version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor_ver</span></code></dt><dd><p>minor uc fw version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">patch_ver</span></code></dt><dd><p>patch uc fw version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad2</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Given a uc_type this will return the branch, major, minor and patch version
of the micro-controller firmware.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_device_query">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_device_query</span></span></span><a class="headerlink" href="#c.drm_xe_device_query" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_DEVICE_QUERY</span></code> - main structure to query device information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_device_query {
    __u64 extensions;
#define DRM_XE_DEVICE_QUERY_ENGINES             0;
#define DRM_XE_DEVICE_QUERY_MEM_REGIONS         1;
#define DRM_XE_DEVICE_QUERY_CONFIG              2;
#define DRM_XE_DEVICE_QUERY_GT_LIST             3;
#define DRM_XE_DEVICE_QUERY_HWCONFIG            4;
#define DRM_XE_DEVICE_QUERY_GT_TOPOLOGY         5;
#define DRM_XE_DEVICE_QUERY_ENGINE_CYCLES       6;
#define DRM_XE_DEVICE_QUERY_UC_FW_VERSION       7;
#define DRM_XE_DEVICE_QUERY_OA_UNITS            8;
    __u32 query;
    __u32 size;
    __u64 data;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">query</span></code></dt><dd><p>The type of data to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the queried data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Queried data is placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The user selects the type of data to query among DRM_XE_DEVICE_QUERY_*
and sets the value in the query member. This determines the type of
the structure provided by the driver in data, among struct drm_xe_query_*.</p>
<dl class="simple">
<dt>The <strong>query</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_DEVICE_QUERY_ENGINES</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_DEVICE_QUERY_MEM_REGIONS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_DEVICE_QUERY_CONFIG</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_DEVICE_QUERY_GT_LIST</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_DEVICE_QUERY_HWCONFIG</span></code> - Query type to retrieve the hardware
configuration of the device such as information on slices, memory,
caches, and so on. It is provided as a table of key / value
attributes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_DEVICE_QUERY_GT_TOPOLOGY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_DEVICE_QUERY_ENGINE_CYCLES</span></code></p></li>
</ul>
</dd>
</dl>
<p>If size is set to 0, the driver fills it with the required size for
the requested type of data to query. If size is equal to the required
size, the queried information is copied into data. If size is set to
a value different from 0 and different from the required size, the
IOCTL call returns -EINVAL.</p>
<p>For example the following code snippet allows retrieving and printing
information about the device engines with DRM_XE_DEVICE_QUERY_ENGINES:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_query_engines</span><span class="w"> </span><span class="o">*</span><span class="n">engines</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_device_query</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_XE_DEVICE_QUERY_ENGINES</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_XE_DEVICE_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="n">engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
<span class="n">query</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">engines</span><span class="p">;</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_XE_DEVICE_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">engines</span><span class="o">-&gt;</span><span class="n">num_engines</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Engine %d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span>
<span class="w">        </span><span class="n">engines</span><span class="o">-&gt;</span><span class="n">engines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">instance</span><span class="p">.</span><span class="n">engine_class</span><span class="w"> </span><span class="o">==</span>
<span class="w">            </span><span class="n">DRM_XE_ENGINE_CLASS_RENDER</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;RENDER&quot;</span><span class="o">:</span>
<span class="w">        </span><span class="n">engines</span><span class="o">-&gt;</span><span class="n">engines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">instance</span><span class="p">.</span><span class="n">engine_class</span><span class="w"> </span><span class="o">==</span>
<span class="w">            </span><span class="n">DRM_XE_ENGINE_CLASS_COPY</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;COPY&quot;</span><span class="o">:</span>
<span class="w">        </span><span class="n">engines</span><span class="o">-&gt;</span><span class="n">engines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">instance</span><span class="p">.</span><span class="n">engine_class</span><span class="w"> </span><span class="o">==</span>
<span class="w">            </span><span class="n">DRM_XE_ENGINE_CLASS_VIDEO_DECODE</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;VIDEO_DECODE&quot;</span><span class="o">:</span>
<span class="w">        </span><span class="n">engines</span><span class="o">-&gt;</span><span class="n">engines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">instance</span><span class="p">.</span><span class="n">engine_class</span><span class="w"> </span><span class="o">==</span>
<span class="w">            </span><span class="n">DRM_XE_ENGINE_CLASS_VIDEO_ENHANCE</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;VIDEO_ENHANCE&quot;</span><span class="o">:</span>
<span class="w">        </span><span class="n">engines</span><span class="o">-&gt;</span><span class="n">engines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">instance</span><span class="p">.</span><span class="n">engine_class</span><span class="w"> </span><span class="o">==</span>
<span class="w">            </span><span class="n">DRM_XE_ENGINE_CLASS_COMPUTE</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;COMPUTE&quot;</span><span class="o">:</span>
<span class="w">        </span><span class="s">&quot;UNKNOWN&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">free</span><span class="p">(</span><span class="n">engines</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_gem_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_gem_create</span></span></span><a class="headerlink" href="#c.drm_xe_gem_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_GEM_CREATE</span></code> - A structure for gem creation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_gem_create {
    __u64 extensions;
    __u64 size;
    __u32 placement;
#define DRM_XE_GEM_CREATE_FLAG_DEFER_BACKING            (1 &lt;&lt; 0);
#define DRM_XE_GEM_CREATE_FLAG_SCANOUT                  (1 &lt;&lt; 1);
#define DRM_XE_GEM_CREATE_FLAG_NEEDS_VISIBLE_VRAM       (1 &lt;&lt; 2);
    __u32 flags;
    __u32 vm_id;
    __u32 handle;
#define DRM_XE_GEM_CPU_CACHING_WB                      1;
#define DRM_XE_GEM_CPU_CACHING_WC                      2;
    __u16 cpu_caching;
    __u16 pad[3];
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the object to be created, must match region
(system or vram) minimum alignment (<code class="xref c c-type docutils literal notranslate"><span class="pre">min_page_size</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">placement</span></code></dt><dd><p>A mask of memory instances of where BO can be placed.
Each index in this mask refers directly to the <a class="reference internal" href="#c.drm_xe_query_mem_regions" title="drm_xe_query_mem_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_xe_query_mem_regions</span></code></a>’ instance, no assumptions should
be made about order. The type of each region is described
by <a class="reference internal" href="#c.drm_xe_query_mem_regions" title="drm_xe_query_mem_regions"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_query_mem_regions</span></code></a>’ mem_class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags, currently a mask of memory instances of where BO can
be placed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>Attached VM, if any</p>
<p>If a VM is specified, this BO must:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Only ever be bound to that VM.</p></li>
<li><p>Cannot be exported as a PRIME fd.</p></li>
</ol>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Returned handle for the object.</p>
<p>Object handles are nonzero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu_caching</span></code></dt><dd><p>The CPU caching mode to select for this object. If
mmaping the object the mode selected here will also be used. The
exception is when mapping system memory (including data evicted
to system) on discrete GPUs. The caching mode selected will
then be overridden to DRM_XE_GEM_CPU_CACHING_WB, and coherency
between GPU- and CPU is guaranteed. The caching mode of
existing CPU-mappings will be updated transparently to
user-space clients.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The <strong>flags</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_GEM_CREATE_FLAG_DEFER_BACKING</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_GEM_CREATE_FLAG_SCANOUT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_GEM_CREATE_FLAG_NEEDS_VISIBLE_VRAM</span></code> - When using VRAM as a
possible placement, ensure that the corresponding VRAM allocation
will always use the CPU accessible part of VRAM. This is important
for small-bar systems (on full-bar systems this gets turned into a
noop).
Note1: System memory can be used as an extra placement if the kernel
should spill the allocation to system memory, if space can’t be made
available in the CPU accessible part of VRAM (giving the same
behaviour as the i915 interface, see
I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS).
Note2: For clear-color CCS surfaces the kernel needs to read the
clear-color value stored in the buffer, and on discrete platforms we
need to use VRAM for display surfaces, therefore the kernel requires
setting this flag for such objects, otherwise an error is thrown on
small-bar systems.</p></li>
</ul>
</dd>
<dt><strong>cpu_caching</strong> supports the following values:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_GEM_CPU_CACHING_WB</span></code> - Allocate the pages with write-back
caching. On iGPU this can’t be used for scanout surfaces. Currently
not allowed for objects placed in VRAM.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_GEM_CPU_CACHING_WC</span></code> - Allocate the pages as write-combined. This
is uncached. Scanout surfaces should likely use this. All objects
that can be placed in VRAM must use this.</p></li>
</ul>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_gem_mmap_offset">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_gem_mmap_offset</span></span></span><a class="headerlink" href="#c.drm_xe_gem_mmap_offset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_GEM_MMAP_OFFSET</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_gem_mmap_offset {
    __u64 extensions;
    __u32 handle;
    __u32 flags;
    __u64 offset;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle for the object being mapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Must be zero</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>The fake offset to use for subsequent mmap call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_vm_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_vm_create</span></span></span><a class="headerlink" href="#c.drm_xe_vm_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_VM_CREATE</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_vm_create {
    __u64 extensions;
#define DRM_XE_VM_CREATE_FLAG_SCRATCH_PAGE      (1 &lt;&lt; 0);
#define DRM_XE_VM_CREATE_FLAG_LR_MODE           (1 &lt;&lt; 1);
#define DRM_XE_VM_CREATE_FLAG_FAULT_MODE        (1 &lt;&lt; 2);
    __u32 flags;
    __u32 vm_id;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>Returned VM ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The <strong>flags</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_CREATE_FLAG_SCRATCH_PAGE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_CREATE_FLAG_LR_MODE</span></code> - An LR, or Long Running VM accepts
exec submissions to its exec_queues that don’t have an upper time
limit on the job execution time. But exec submissions to these
don’t allow any of the flags DRM_XE_SYNC_FLAG_SYNCOBJ,
DRM_XE_SYNC_FLAG_TIMELINE_SYNCOBJ, DRM_XE_SYNC_FLAG_DMA_BUF,
used as out-syncobjs, that is, together with DRM_XE_SYNC_FLAG_SIGNAL.
LR VMs can be created in recoverable page-fault mode using
DRM_XE_VM_CREATE_FLAG_FAULT_MODE, if the device supports it.
If that flag is omitted, the UMD can not rely on the slightly
different per-VM overcommit semantics that are enabled by
DRM_XE_VM_CREATE_FLAG_FAULT_MODE (see below), but KMD may
still enable recoverable pagefaults if supported by the device.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_CREATE_FLAG_FAULT_MODE</span></code> - Requires also
DRM_XE_VM_CREATE_FLAG_LR_MODE. It allows memory to be allocated on
demand when accessed, and also allows per-VM overcommit of memory.
The xe driver internally uses recoverable pagefaults to implement
this.</p></li>
</ul>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_vm_destroy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_vm_destroy</span></span></span><a class="headerlink" href="#c.drm_xe_vm_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_VM_DESTROY</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_vm_destroy {
    __u32 vm_id;
    __u32 pad;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>VM ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_vm_bind_op">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_vm_bind_op</span></span></span><a class="headerlink" href="#c.drm_xe_vm_bind_op" title="Link to this definition">¶</a><br /></dt>
<dd><p>run bind operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_vm_bind_op {
    __u64 extensions;
    __u32 obj;
    __u16 pat_index;
    __u16 pad;
    union {
        __u64 obj_offset;
        __u64 userptr;
    };
    __u64 range;
    __u64 addr;
#define DRM_XE_VM_BIND_OP_MAP           0x0;
#define DRM_XE_VM_BIND_OP_UNMAP         0x1;
#define DRM_XE_VM_BIND_OP_MAP_USERPTR   0x2;
#define DRM_XE_VM_BIND_OP_UNMAP_ALL     0x3;
#define DRM_XE_VM_BIND_OP_PREFETCH      0x4;
    __u32 op;
#define DRM_XE_VM_BIND_FLAG_READONLY    (1 &lt;&lt; 0);
#define DRM_XE_VM_BIND_FLAG_IMMEDIATE   (1 &lt;&lt; 1);
#define DRM_XE_VM_BIND_FLAG_NULL        (1 &lt;&lt; 2);
#define DRM_XE_VM_BIND_FLAG_DUMPABLE    (1 &lt;&lt; 3);
    __u32 flags;
    __u32 prefetch_mem_region_instance;
    __u32 pad2;
    __u64 reserved[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>GEM object to operate on, MBZ for MAP_USERPTR, MBZ for UNMAP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pat_index</span></code></dt><dd><p>The platform defined <strong>pat_index</strong> to use for this mapping.
The index basically maps to some predefined memory attributes,
including things like caching, coherency, compression etc.  The exact
meaning of the pat_index is platform specific and defined in the
Bspec and PRMs.  When the KMD sets up the binding the index here is
encoded into the ppGTT PTE.</p>
<p>For coherency the <strong>pat_index</strong> needs to be at least 1way coherent when
drm_xe_gem_create.cpu_caching is DRM_XE_GEM_CPU_CACHING_WB. The KMD
will extract the coherency mode from the <strong>pat_index</strong> and reject if
there is a mismatch (see note below for pre-MTL platforms).</p>
<p>Note: On pre-MTL platforms there is only a caching mode and no
explicit coherency mode, but on such hardware there is always a
shared-LLC (or is dgpu) so all GT memory accesses are coherent with
CPU caches even with the caching mode set as uncached.  It’s only the
display engine that is incoherent (on dgpu it must be in VRAM which
is always mapped as WC on the CPU). However to keep the uapi somewhat
consistent with newer platforms the KMD groups the different cache
levels into the following coherency buckets on all pre-MTL platforms:</p>
<blockquote>
<div><p>ppGTT UC -&gt; COH_NONE
ppGTT WC -&gt; COH_NONE
ppGTT WT -&gt; COH_NONE
ppGTT WB -&gt; COH_AT_LEAST_1WAY</p>
</div></blockquote>
<p>In practice UC/WC/WT should only ever used for scanout surfaces on
such platforms (or perhaps in general for dma-buf if shared with
another device) since it is only the display engine that is actually
incoherent.  Everything else should typically use WB given that we
have a shared-LLC.  On MTL+ this completely changes and the HW
defines the coherency mode as part of the <strong>pat_index</strong>, where
incoherent GT access is possible.</p>
<p>Note: For userptr and externally imported dma-buf the kernel expects
either 1WAY or 2WAY for the <strong>pat_index</strong>.</p>
<p>For DRM_XE_VM_BIND_FLAG_NULL bindings there are no KMD restrictions
on the <strong>pat_index</strong>. For such mappings there is no actual memory being
mapped (the address in the PTE is invalid), so the various PAT memory
attributes likely do not apply.  Simply leaving as zero is one
option (still a valid pat_index).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj_offset</span></code></dt><dd><p>Offset into the object, MBZ for CLEAR_RANGE,
ignored for unbind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">userptr</span></code></dt><dd><p>user pointer to bind on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">range</span></code></dt><dd><p>Number of bytes from the object to bind to addr, MBZ for UNMAP_ALL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>Address to operate on, MBZ for UNMAP_ALL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p>Bind operation to perform</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Bind flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prefetch_mem_region_instance</span></code></dt><dd><p>Memory region to prefetch VMA to.
It is a region instance, not a mask.
To be used only with <code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_OP_PREFETCH</span></code> operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad2</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The <strong>op</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_OP_MAP</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_OP_UNMAP</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_OP_MAP_USERPTR</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_OP_UNMAP_ALL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_OP_PREFETCH</span></code></p></li>
</ul>
</dd>
<dt>and the <strong>flags</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_FLAG_READONLY</span></code> - Setup the page tables as read-only
to ensure write protection</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_FLAG_IMMEDIATE</span></code> - On a faulting VM, do the
MAP operation immediately rather than deferring the MAP to the page
fault handler. This is implied on a non-faulting VM as there is no
fault handler to defer to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_VM_BIND_FLAG_NULL</span></code> - When the NULL flag is set, the page
tables are setup with a special bit which indicates writes are
dropped and all reads return zero. In the future, the NULL flags
will only be valid for DRM_XE_VM_BIND_OP_MAP operations, the BO
handle MBZ, and the BO offset MBZ. This flag is intended to
implement VK sparse bindings.</p></li>
</ul>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_vm_bind">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_vm_bind</span></span></span><a class="headerlink" href="#c.drm_xe_vm_bind" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_VM_BIND</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_vm_bind {
    __u64 extensions;
    __u32 vm_id;
    __u32 exec_queue_id;
    __u32 pad;
    __u32 num_binds;
    union {
        struct drm_xe_vm_bind_op bind;
        __u64 vector_of_binds;
    };
    __u32 pad2;
    __u32 num_syncs;
    __u64 syncs;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>The ID of the VM to bind to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exec_queue_id</span></code></dt><dd><p>exec_queue_id, must be of class DRM_XE_ENGINE_CLASS_VM_BIND
and exec queue must have same vm_id. If zero, the default VM bind engine
is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_binds</span></code></dt><dd><p>number of binds in this IOCTL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bind</span></code></dt><dd><p>used if num_binds == 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vector_of_binds</span></code></dt><dd><p>userptr to array of <a class="reference internal" href="#c.drm_xe_vm_bind_op" title="drm_xe_vm_bind_op"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_xe_vm_bind_op</span></code></a> if num_binds &gt; 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad2</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_syncs</span></code></dt><dd><p>amount of syncs to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syncs</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.drm_xe_sync" title="drm_xe_sync"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_sync</span></code></a> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Below is an example of a minimal use of <strong>drm_xe_vm_bind</strong> to
asynchronously bind the buffer <cite>data</cite> at address <cite>BIND_ADDRESS</cite> to
illustrate <cite>userptr</cite>. It can be synchronized by using the example
provided for <strong>drm_xe_sync</strong>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aligned_alloc</span><span class="p">(</span><span class="n">ALIGNMENT</span><span class="p">,</span><span class="w"> </span><span class="n">BO_SIZE</span><span class="p">);</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_vm_bind</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">vm_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vm</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">num_binds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">bind</span><span class="p">.</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">bind</span><span class="p">.</span><span class="n">obj_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">bind</span><span class="p">.</span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BO_SIZE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">bind</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BIND_ADDRESS</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">bind</span><span class="p">.</span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_XE_VM_BIND_OP_MAP_USERPTR</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">bind</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">num_syncs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">syncs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sync</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">exec_queue_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_XE_VM_BIND</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bind</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_exec_queue_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_exec_queue_create</span></span></span><a class="headerlink" href="#c.drm_xe_exec_queue_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_EXEC_QUEUE_CREATE</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_exec_queue_create {
#define DRM_XE_EXEC_QUEUE_EXTENSION_SET_PROPERTY                0;
#define DRM_XE_EXEC_QUEUE_SET_PROPERTY_PRIORITY               0;
#define DRM_XE_EXEC_QUEUE_SET_PROPERTY_TIMESLICE              1;
    __u64 extensions;
    __u16 width;
    __u16 num_placements;
    __u32 vm_id;
    __u32 flags;
    __u32 exec_queue_id;
    __u64 instances;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>submission width (number BB per exec) for this exec queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_placements</span></code></dt><dd><p>number of valid placements for this exec queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>VM to use for this exec queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exec_queue_id</span></code></dt><dd><p>Returned exec queue ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">instances</span></code></dt><dd><p>user pointer to a 2-d array of <a class="reference internal" href="#c.drm_xe_engine_class_instance" title="drm_xe_engine_class_instance"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_xe_engine_class_instance</span></code></a></p>
<p>length = width (i) * num_placements (j)
index = j + i * width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The example below shows how to use <strong>drm_xe_exec_queue_create</strong> to create
a simple exec_queue (no parallel submission) of class
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_XE_ENGINE_CLASS_RENDER</span></code>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_engine_class_instance</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">engine_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_XE_ENGINE_CLASS_RENDER</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_exec_queue_create</span><span class="w"> </span><span class="n">exec_queue_create</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">vm_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vm</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">num_bb_per_exec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">num_eng_per_bb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">instances</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="p">),</span>
<span class="p">};</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_XE_EXEC_QUEUE_CREATE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">exec_queue_create</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_exec_queue_destroy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_exec_queue_destroy</span></span></span><a class="headerlink" href="#c.drm_xe_exec_queue_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_EXEC_QUEUE_DESTROY</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_exec_queue_destroy {
    __u32 exec_queue_id;
    __u32 pad;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">exec_queue_id</span></code></dt><dd><p>Exec queue ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_exec_queue_get_property">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_exec_queue_get_property</span></span></span><a class="headerlink" href="#c.drm_xe_exec_queue_get_property" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_EXEC_QUEUE_GET_PROPERTY</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_exec_queue_get_property {
    __u64 extensions;
    __u32 exec_queue_id;
#define DRM_XE_EXEC_QUEUE_GET_PROPERTY_BAN      0;
    __u32 property;
    __u64 value;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exec_queue_id</span></code></dt><dd><p>Exec queue ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">property</span></code></dt><dd><p>property to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>property value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The <strong>property</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_EXEC_QUEUE_GET_PROPERTY_BAN</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_sync">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_sync</span></span></span><a class="headerlink" href="#c.drm_xe_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>sync object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_sync {
    __u64 extensions;
#define DRM_XE_SYNC_TYPE_SYNCOBJ                0x0;
#define DRM_XE_SYNC_TYPE_TIMELINE_SYNCOBJ       0x1;
#define DRM_XE_SYNC_TYPE_USER_FENCE             0x2;
    __u32 type;
#define DRM_XE_SYNC_FLAG_SIGNAL (1 &lt;&lt; 0);
    __u32 flags;
    union {
        __u32 handle;
        __u64 addr;
    };
    __u64 timeline_value;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of the this sync object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Sync Flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle for the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>Address of user fence. When sync is passed in via exec
IOCTL this is a GPU address in the VM. When sync passed in via
VM bind IOCTL this is a user pointer. In either case, it is
the users responsibility that this address is present and
mapped when the user fence is signalled. Must be qword
aligned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeline_value</span></code></dt><dd><p>Input for the timeline sync object. Needs to be
different than 0 when used with <code class="docutils literal notranslate"><span class="pre">DRM_XE_SYNC_FLAG_TIMELINE_SYNCOBJ</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The <strong>type</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_SYNC_TYPE_SYNCOBJ</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_SYNC_TYPE_TIMELINE_SYNCOBJ</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_SYNC_TYPE_USER_FENCE</span></code></p></li>
</ul>
</dd>
<dt>and the <strong>flags</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_SYNC_FLAG_SIGNAL</span></code></p></li>
</ul>
</dd>
</dl>
<p>A minimal use of <strong>drm_xe_sync</strong> looks like this:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_sync</span><span class="w"> </span><span class="n">sync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_XE_SYNC_FLAG_SIGNAL</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_XE_SYNC_TYPE_SYNCOBJ</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_syncobj_create</span><span class="w"> </span><span class="n">syncobj_create</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_SYNCOBJ_CREATE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">syncobj_create</span><span class="p">);</span>
<span class="n">sync</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syncobj_create</span><span class="p">.</span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">use</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sync</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">drm_xe_exec</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">drm_xe_vm_bind</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_syncobj_wait</span><span class="w"> </span><span class="n">wait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">handles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sync</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">timeout_nsec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT64_MAX</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">count_handles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">first_signaled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">pad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_SYNCOBJ_WAIT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_exec">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_exec</span></span></span><a class="headerlink" href="#c.drm_xe_exec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_EXEC</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_exec {
    __u64 extensions;
    __u32 exec_queue_id;
    __u32 num_syncs;
    __u64 syncs;
    __u64 address;
    __u16 num_batch_buffer;
    __u16 pad[3];
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exec_queue_id</span></code></dt><dd><p>Exec queue ID for the batch buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_syncs</span></code></dt><dd><p>Amount of <a class="reference internal" href="#c.drm_xe_sync" title="drm_xe_sync"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_sync</span></code></a> in array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syncs</span></code></dt><dd><p>Pointer to <a class="reference internal" href="#c.drm_xe_sync" title="drm_xe_sync"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_sync</span></code></a> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">address</span></code></dt><dd><p>address of batch buffer if num_batch_buffer == 1 or an
array of batch buffer addresses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_batch_buffer</span></code></dt><dd><p>number of batch buffer in this exec, must match
the width of the engine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is an example to use <strong>drm_xe_exec</strong> for execution of the object
at BIND_ADDRESS (see example in <strong>drm_xe_vm_bind</strong>) by an exec_queue
(see example in <strong>drm_xe_exec_queue_create</strong>). It can be synchronized
by using the example provided for <strong>drm_xe_sync</strong>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_exec</span><span class="w"> </span><span class="n">exec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">exec_queue_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exec_queue</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">syncs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sync</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">num_syncs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BIND_ADDRESS</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">num_batch_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_XE_EXEC</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">exec</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_wait_user_fence">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_wait_user_fence</span></span></span><a class="headerlink" href="#c.drm_xe_wait_user_fence" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_XE_WAIT_USER_FENCE</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_wait_user_fence {
    __u64 extensions;
    __u64 addr;
#define DRM_XE_UFENCE_WAIT_OP_EQ        0x0;
#define DRM_XE_UFENCE_WAIT_OP_NEQ       0x1;
#define DRM_XE_UFENCE_WAIT_OP_GT        0x2;
#define DRM_XE_UFENCE_WAIT_OP_GTE       0x3;
#define DRM_XE_UFENCE_WAIT_OP_LT        0x4;
#define DRM_XE_UFENCE_WAIT_OP_LTE       0x5;
    __u16 op;
#define DRM_XE_UFENCE_WAIT_FLAG_ABSTIME (1 &lt;&lt; 0);
    __u16 flags;
    __u32 pad;
    __u64 value;
    __u64 mask;
    __s64 timeout;
    __u32 exec_queue_id;
    __u32 pad2;
    __u64 reserved[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>user pointer address to wait on, must qword aligned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p>wait operation (type of comparison)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>wait flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>compare value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>comparison mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>how long to wait before bailing, value in nanoseconds.
Without DRM_XE_UFENCE_WAIT_FLAG_ABSTIME flag set (relative timeout)
it contains timeout expressed in nanoseconds to wait (fence will
expire at now() + timeout).
When DRM_XE_UFENCE_WAIT_FLAG_ABSTIME flat is set (absolute timeout) wait
will end at timeout (uses system MONOTONIC_CLOCK).
Passing negative timeout leads to neverending wait.</p>
<p>On relative timeout this value is updated with timeout left
(for restarting the call in case of signal delivery).
On absolute timeout this value stays intact (restarted call still
expire at the same point of time).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exec_queue_id</span></code></dt><dd><p>exec_queue_id returned from xe_exec_queue_create_ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad2</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>Reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Wait on user fence, XE will wake-up on every HW engine interrupt in the
instances list and check if user fence is complete:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(*addr &amp; MASK) OP (VALUE &amp; MASK)
</pre></div>
</div>
<p>Returns to user on user fence completion or timeout.</p>
<dl class="simple">
<dt>The <strong>op</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_UFENCE_WAIT_OP_EQ</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_UFENCE_WAIT_OP_NEQ</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_UFENCE_WAIT_OP_GT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_UFENCE_WAIT_OP_GTE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_UFENCE_WAIT_OP_LT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_UFENCE_WAIT_OP_LTE</span></code></p></li>
</ul>
</dd>
<dt>and the <strong>flags</strong> can be:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_UFENCE_WAIT_FLAG_ABSTIME</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_XE_UFENCE_WAIT_FLAG_SOFT_OP</span></code></p></li>
</ul>
</dd>
<dt>The <strong>mask</strong> values can be for example:</dt><dd><ul class="simple">
<li><p>0xffu for u8</p></li>
<li><p>0xffffu for u16</p></li>
<li><p>0xffffffffu for u32</p></li>
<li><p>0xffffffffffffffffu for u64</p></li>
</ul>
</dd>
</dl>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_xe_observation_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_observation_type</span></span></span><a class="headerlink" href="#c.drm_xe_observation_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Observation stream types</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_TYPE_OA</span></code></dt><dd><p>OA observation stream type</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_xe_observation_op">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_observation_op</span></span></span><a class="headerlink" href="#c.drm_xe_observation_op" title="Link to this definition">¶</a><br /></dt>
<dd><p>Observation stream ops</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_OP_STREAM_OPEN</span></code></dt><dd><p>Open an observation stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_OP_ADD_CONFIG</span></code></dt><dd><p>Add observation stream config</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_OP_REMOVE_CONFIG</span></code></dt><dd><p>Remove observation stream config</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_observation_param">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_observation_param</span></span></span><a class="headerlink" href="#c.drm_xe_observation_param" title="Link to this definition">¶</a><br /></dt>
<dd><p>Input of <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_observation_param {
    __u64 extensions;
    __u64 observation_type;
    __u64 observation_op;
    __u64 param;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">observation_type</span></code></dt><dd><p>observation stream type, of enum <strong>drm_xe_observation_type</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">observation_op</span></code></dt><dd><p>observation stream op, of enum <strong>drm_xe_observation_op</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>Pointer to actual stream params</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The observation layer enables multiplexing observation streams of
multiple types. The actual params for a particular stream operation are
supplied via the <strong>param</strong> pointer (use __copy_from_user to get these
params).</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_xe_observation_ioctls">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_observation_ioctls</span></span></span><a class="headerlink" href="#c.drm_xe_observation_ioctls" title="Link to this definition">¶</a><br /></dt>
<dd><p>Observation stream fd ioctl’s</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_IOCTL_ENABLE</span></code></dt><dd><p>Enable data capture for an observation stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_IOCTL_DISABLE</span></code></dt><dd><p>Disable data capture for a observation stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_IOCTL_CONFIG</span></code></dt><dd><p>Change observation stream configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_IOCTL_STATUS</span></code></dt><dd><p>Return observation stream status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OBSERVATION_IOCTL_INFO</span></code></dt><dd><p>Return observation stream info</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Information exchanged between userspace and kernel for observation fd
ioctl’s is stream type specific</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_xe_oa_unit_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_oa_unit_type</span></span></span><a class="headerlink" href="#c.drm_xe_oa_unit_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>OA unit types</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_UNIT_TYPE_OAG</span></code></dt><dd><p>OAG OA unit. OAR/OAC are considered
sub-types of OAG. For OAR/OAC, use OAG.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_UNIT_TYPE_OAM</span></code></dt><dd><p>OAM OA unit</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_oa_unit">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_oa_unit</span></span></span><a class="headerlink" href="#c.drm_xe_oa_unit" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe OA unit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_oa_unit {
    __u64 extensions;
    __u32 oa_unit_id;
    __u32 oa_unit_type;
    __u64 capabilities;
#define DRM_XE_OA_CAPS_BASE             (1 &lt;&lt; 0);
#define DRM_XE_OA_CAPS_SYNCS            (1 &lt;&lt; 1);
#define DRM_XE_OA_CAPS_OA_BUFFER_SIZE   (1 &lt;&lt; 2);
#define DRM_XE_OA_CAPS_WAIT_NUM_REPORTS (1 &lt;&lt; 3);
    __u64 oa_timestamp_freq;
    __u64 reserved[4];
    __u64 num_engines;
    struct drm_xe_engine_class_instance eci[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_unit_id</span></code></dt><dd><p>OA unit ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_unit_type</span></code></dt><dd><p>OA unit type of <strong>drm_xe_oa_unit_type</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capabilities</span></code></dt><dd><p>OA capabilities bit-mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_timestamp_freq</span></code></dt><dd><p>OA timestamp freq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_engines</span></code></dt><dd><p>number of engines in <strong>eci</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eci</span></code></dt><dd><p>engines attached to this OA unit</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_query_oa_units">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_query_oa_units</span></span></span><a class="headerlink" href="#c.drm_xe_query_oa_units" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe OA units</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_query_oa_units {
    __u64 extensions;
    __u32 num_oa_units;
    __u32 pad;
    __u64 oa_units[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_oa_units</span></code></dt><dd><p>number of OA units returned in oau[]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_units</span></code></dt><dd><p>struct <strong>drm_xe_oa_unit</strong> array returned for this device.
Written below as a u64 array to avoid problems with nested flexible
arrays with some compilers</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If a query is made with a <a class="reference internal" href="#c.drm_xe_device_query" title="drm_xe_device_query"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_xe_device_query</span></code></a> where .query
is equal to DRM_XE_DEVICE_QUERY_OA_UNITS, then the reply uses <a class="reference internal" href="#c.drm_xe_query_oa_units" title="drm_xe_query_oa_units"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_xe_query_oa_units</span></code></a> in .data.</p>
<p>OA unit properties for all OA units can be accessed using a code block
such as the one below:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_query_oa_units</span><span class="w"> </span><span class="o">*</span><span class="n">qoa</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_oa_unit</span><span class="w"> </span><span class="o">*</span><span class="n">oau</span><span class="p">;</span>
<span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">poau</span><span class="p">;</span>

<span class="c1">// malloc qoa and issue DRM_XE_DEVICE_QUERY_OA_UNITS. Then:</span>
<span class="n">poau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">qoa</span><span class="o">-&gt;</span><span class="n">oa_units</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">qoa</span><span class="o">-&gt;</span><span class="n">num_oa_units</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">oau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_xe_oa_unit</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">poau</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Access &#39;struct drm_xe_oa_unit&#39; fields here</span>
<span class="w">        </span><span class="n">poau</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">oau</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">oau</span><span class="o">-&gt;</span><span class="n">num_engines</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">oau</span><span class="o">-&gt;</span><span class="n">eci</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_xe_oa_format_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_oa_format_type</span></span></span><a class="headerlink" href="#c.drm_xe_oa_format_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>OA format types as specified in PRM/Bspec 52198/60942</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_FMT_TYPE_OAG</span></code></dt><dd><p>OAG report format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_FMT_TYPE_OAR</span></code></dt><dd><p>OAR report format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_FMT_TYPE_OAM</span></code></dt><dd><p>OAM report format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_FMT_TYPE_OAC</span></code></dt><dd><p>OAC report format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_FMT_TYPE_OAM_MPEC</span></code></dt><dd><p>OAM SAMEDIA or OAM MPEC report format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_FMT_TYPE_PEC</span></code></dt><dd><p>PEC report format</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_xe_oa_property_id">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_oa_property_id</span></span></span><a class="headerlink" href="#c.drm_xe_oa_property_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>OA stream property id’s</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_OA_UNIT_ID</span></code></dt><dd><p>ID of the OA unit on which to open
the OA stream, see <strong>oa_unit_id</strong> in ‘<a class="reference internal" href="#c.drm_xe_query_oa_units" title="drm_xe_query_oa_units"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_xe_query_oa_units</span></code></a>’. Defaults to 0 if not provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_SAMPLE_OA</span></code></dt><dd><p>A value of 1 requests inclusion of raw
OA unit reports or stream samples in a global buffer attached to an
OA unit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_OA_METRIC_SET</span></code></dt><dd><p>OA metrics defining contents of OA
reports, previously added via <strong>DRM_XE_OBSERVATION_OP_ADD_CONFIG</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_OA_FORMAT</span></code></dt><dd><p>OA counter report format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_OA_PERIOD_EXPONENT</span></code></dt><dd><p>Requests periodic OA unit
sampling with sampling frequency proportional to 2^(period_exponent + 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_OA_DISABLED</span></code></dt><dd><p>A value of 1 will open the OA
stream in a DISABLED state (see <strong>DRM_XE_OBSERVATION_IOCTL_ENABLE</strong>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_EXEC_QUEUE_ID</span></code></dt><dd><p>Open the stream for a specific
<strong>exec_queue_id</strong>. OA queries can be executed on this exec queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_OA_ENGINE_INSTANCE</span></code></dt><dd><p>Optional engine instance to
pass along with <strong>DRM_XE_OA_PROPERTY_EXEC_QUEUE_ID</strong> or will default to 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_NO_PREEMPT</span></code></dt><dd><p>Allow preemption and timeslicing
to be disabled for the stream exec queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_NUM_SYNCS</span></code></dt><dd><p>Number of syncs in the sync array
specified in <strong>DRM_XE_OA_PROPERTY_SYNCS</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_SYNCS</span></code></dt><dd><p>Pointer to struct <strong>drm_xe_sync</strong> array
with array size specified via <strong>DRM_XE_OA_PROPERTY_NUM_SYNCS</strong>. OA
configuration will wait till input fences signal. Output fences
will signal after the new OA configuration takes effect. For
<strong>DRM_XE_SYNC_TYPE_USER_FENCE</strong>, <strong>addr</strong> is a user pointer, similar
to the VM bind case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_OA_BUFFER_SIZE</span></code></dt><dd><p>Size of OA buffer to be
allocated by the driver in bytes. Supported sizes are powers of
2 from 128 KiB to 128 MiB. When not specified, a 16 MiB OA
buffer is allocated by default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_XE_OA_PROPERTY_WAIT_NUM_REPORTS</span></code></dt><dd><p>Number of reports to wait
for before unblocking poll or read</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Stream params are specified as a chain of <strong>drm_xe_ext_set_property</strong>
struct’s, with <strong>property</strong> values from enum <strong>drm_xe_oa_property_id</strong> and
<strong>drm_xe_user_extension</strong> base.name set to <strong>DRM_XE_OA_EXTENSION_SET_PROPERTY</strong>.
<strong>param</strong> field in struct <strong>drm_xe_observation_param</strong> points to the first
<strong>drm_xe_ext_set_property</strong> struct.</p>
<p>Exactly the same mechanism is also used for stream reconfiguration using the
<strong>DRM_XE_OBSERVATION_IOCTL_CONFIG</strong> observation stream fd ioctl, though only a
subset of properties below can be specified for stream reconfiguration.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_oa_config">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_oa_config</span></span></span><a class="headerlink" href="#c.drm_xe_oa_config" title="Link to this definition">¶</a><br /></dt>
<dd><p>OA metric configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_oa_config {
    __u64 extensions;
    char uuid[36];
    __u32 n_regs;
    __u64 regs_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>String formatted like “%08x-%04x-%04x-%04x-%012x”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_regs</span></code></dt><dd><p>Number of regs in <strong>regs_ptr</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regs_ptr</span></code></dt><dd><p>Pointer to (register address, value) pairs for OA config
registers. Expected length of buffer is: (2 * sizeof(u32) * <strong>n_regs</strong>).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Multiple OA configs can be added using <strong>DRM_XE_OBSERVATION_OP_ADD_CONFIG</strong>. A
particular config can be specified when opening an OA stream using
<strong>DRM_XE_OA_PROPERTY_OA_METRIC_SET</strong> property.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_oa_stream_status">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_oa_stream_status</span></span></span><a class="headerlink" href="#c.drm_xe_oa_stream_status" title="Link to this definition">¶</a><br /></dt>
<dd><p>OA stream status returned from <strong>DRM_XE_OBSERVATION_IOCTL_STATUS</strong> observation stream fd ioctl. Userspace can call the ioctl to query stream status in response to EIO errno from observation fd read().</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_oa_stream_status {
    __u64 extensions;
    __u64 oa_status;
#define DRM_XE_OASTATUS_MMIO_TRG_Q_FULL         (1 &lt;&lt; 3);
#define DRM_XE_OASTATUS_COUNTER_OVERFLOW        (1 &lt;&lt; 2);
#define DRM_XE_OASTATUS_BUFFER_OVERFLOW         (1 &lt;&lt; 1);
#define DRM_XE_OASTATUS_REPORT_LOST             (1 &lt;&lt; 0);
    __u64 reserved[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_status</span></code></dt><dd><p>OA stream status (see Bspec 46717/61226)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>reserved for future use</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_xe_oa_stream_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_xe_oa_stream_info</span></span></span><a class="headerlink" href="#c.drm_xe_oa_stream_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>OA stream info returned from <strong>DRM_XE_OBSERVATION_IOCTL_INFO</strong> observation stream fd ioctl</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_xe_oa_stream_info {
    __u64 extensions;
    __u64 oa_buf_size;
    __u64 reserved[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Pointer to the first extension struct, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oa_buf_size</span></code></dt><dd><p>OA buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>reserved for future use</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/gpu/driver-uapi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>