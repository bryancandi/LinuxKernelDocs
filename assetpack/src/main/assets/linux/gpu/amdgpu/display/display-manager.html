<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>AMDgpu Display Manager &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Display Core Next (DCN)" href="dcn-overview.html" />
    <link rel="prev" title="drm/amd/display - Display Core (DC)" href="index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../../input/index.html">Input Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../../index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/gpu/amdgpu/display/display-manager.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="amdgpu-display-manager">
<h1><a class="toc-backref" href="#id1" role="doc-backlink">AMDgpu Display Manager</a><a class="headerlink" href="#amdgpu-display-manager" title="Link to this heading">¶</a></h1>
<nav class="contents" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#amdgpu-display-manager" id="id1">AMDgpu Display Manager</a></p>
<ul>
<li><p><a class="reference internal" href="#lifecycle" id="id2">Lifecycle</a></p></li>
<li><p><a class="reference internal" href="#interrupts" id="id3">Interrupts</a></p></li>
<li><p><a class="reference internal" href="#atomic-implementation" id="id4">Atomic Implementation</a></p></li>
<li><p><a class="reference internal" href="#color-management-properties" id="id5">Color Management Properties</a></p>
<ul>
<li><p><a class="reference internal" href="#dc-color-capabilities-between-dcn-generations" id="id6">DC Color Capabilities between DCN generations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#blend-mode-properties" id="id7">Blend Mode Properties</a></p>
<ul>
<li><p><a class="reference internal" href="#blend-configuration-flow" id="id8">Blend configuration flow</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<p>The AMDgpu display manager, <strong>amdgpu_dm</strong> (or even simpler,
<strong>dm</strong>) sits between DRM and DC. It acts as a liaison, converting DRM
requests into DC requests, and DC responses into DRM responses.</p>
<p>The root control structure is <a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_display_manager</span></code></a>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dm_compressor_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dm_compressor_info</span></span></span><a class="headerlink" href="#c.dm_compressor_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Buffer info used by frame buffer compression</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dm_compressor_info {
    void *cpu_addr;
    struct amdgpu_bo *bo_ptr;
    uint64_t gpu_addr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cpu_addr</span></code></dt><dd><p>MMIO cpu addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bo_ptr</span></code></dt><dd><p>Pointer to the buffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpu_addr</span></code></dt><dd><p>MMIO gpu addr</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dmub_hpd_work">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dmub_hpd_work</span></span></span><a class="headerlink" href="#c.dmub_hpd_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Handle time consuming work in low priority outbox IRQ</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dmub_hpd_work {
    struct work_struct handle_hpd_work;
    struct dmub_notification *dmub_notify;
    struct amdgpu_device *adev;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle_hpd_work</span></code></dt><dd><p>Work to be executed in a separate thread to handle hpd_low_irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_notify</span></code></dt><dd><p>notification for callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adev</span></code></dt><dd><p>amdgpu_device pointer</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.vblank_control_work">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vblank_control_work</span></span></span><a class="headerlink" href="#c.vblank_control_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Work data for vblank control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vblank_control_work {
    struct work_struct work;
    struct amdgpu_display_manager *dm;
    struct amdgpu_crtc *acrtc;
    struct dc_stream_state *stream;
    bool enable;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>Kernel work data for the work event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dm</span></code></dt><dd><p>amdgpu display manager device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acrtc</span></code></dt><dd><p>amdgpu CRTC instance for which the event has occurred</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream</span></code></dt><dd><p>DC stream for which the event has occurred</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>true if enabling vblank</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.idle_workqueue">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idle_workqueue</span></span></span><a class="headerlink" href="#c.idle_workqueue" title="Link to this definition">¶</a><br /></dt>
<dd><p>Work data for periodic action in idle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct idle_workqueue {
    struct work_struct work;
    struct amdgpu_display_manager *dm;
    bool enable;
    bool running;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>Kernel work data for the work event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dm</span></code></dt><dd><p>amdgpu display manager device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>true if idle worker is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">running</span></code></dt><dd><p>true if idle worker is running</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.amdgpu_dm_luminance_data">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_luminance_data</span></span></span><a class="headerlink" href="#c.amdgpu_dm_luminance_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>Custom luminance data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_dm_luminance_data {
    u8 luminance;
    u8 input_signal;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">luminance</span></code></dt><dd><p>Luminance in percent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_signal</span></code></dt><dd><p>Input signal in range 0-255</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.amdgpu_dm_backlight_caps">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_backlight_caps</span></span></span><a class="headerlink" href="#c.amdgpu_dm_backlight_caps" title="Link to this definition">¶</a><br /></dt>
<dd><p>Information about backlight</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_dm_backlight_caps {
    union dpcd_sink_ext_caps *ext_caps;
    u32 aux_min_input_signal;
    u32 aux_max_input_signal;
    int min_input_signal;
    int max_input_signal;
    bool caps_valid;
    bool aux_support;
    u8 ac_level;
    u8 dc_level;
    u8 data_points;
    struct amdgpu_dm_luminance_data luminance_data[MAX_LUMINANCE_DATA_POINTS];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ext_caps</span></code></dt><dd><p>Keep the data struct with all the information about the
display support for HDR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux_min_input_signal</span></code></dt><dd><p>Min brightness value supported by the display</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux_max_input_signal</span></code></dt><dd><p>Max brightness value supported by the display
in nits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_input_signal</span></code></dt><dd><p>minimum possible input in range 0-255.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_input_signal</span></code></dt><dd><p>maximum possible input in range 0-255.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caps_valid</span></code></dt><dd><p>true if these values are from the ACPI interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux_support</span></code></dt><dd><p>Describes if the display supports AUX backlight.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ac_level</span></code></dt><dd><p>the default brightness if booted on AC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dc_level</span></code></dt><dd><p>the default brightness if booted on DC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_points</span></code></dt><dd><p>the number of custom luminance data points</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">luminance_data</span></code></dt><dd><p>custom luminance data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Describe the backlight support for ACPI or eDP AUX.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dal_allocation">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dal_allocation</span></span></span><a class="headerlink" href="#c.dal_allocation" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tracks mapped FB memory for SMU communication</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dal_allocation {
    struct list_head list;
    struct amdgpu_bo *bo;
    void *cpu_ptr;
    u64 gpu_addr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list of dal allocations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bo</span></code></dt><dd><p>GPU buffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu_ptr</span></code></dt><dd><p>CPU virtual address of the GPU buffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpu_addr</span></code></dt><dd><p>GPU virtual address of the GPU buffer object</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.hpd_rx_irq_offload_work_queue">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hpd_rx_irq_offload_work_queue</span></span></span><a class="headerlink" href="#c.hpd_rx_irq_offload_work_queue" title="Link to this definition">¶</a><br /></dt>
<dd><p>Work queue to handle hpd_rx_irq offload work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hpd_rx_irq_offload_work_queue {
    struct workqueue_struct *wq;
    spinlock_t offload_lock;
    bool is_handling_link_loss;
    bool is_handling_mst_msg_rdy_event;
    struct amdgpu_dm_connector *aconnector;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>workqueue structure to queue offload work.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offload_lock</span></code></dt><dd><p>To protect fields of offload work queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_handling_link_loss</span></code></dt><dd><p>Used to prevent inserting link loss event when
we’re handling link loss</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_handling_mst_msg_rdy_event</span></code></dt><dd><p>Used to prevent inserting mst message
ready event when we’re already handling mst message ready event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aconnector</span></code></dt><dd><p>The aconnector that this work queue is attached to</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.hpd_rx_irq_offload_work">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hpd_rx_irq_offload_work</span></span></span><a class="headerlink" href="#c.hpd_rx_irq_offload_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>hpd_rx_irq offload work structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hpd_rx_irq_offload_work {
    struct work_struct work;
    union hpd_irq_data data;
    struct hpd_rx_irq_offload_work_queue *offload_wq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>offload work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>reference irq data which is used while handling offload work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offload_wq</span></code></dt><dd><p>offload work queue that this work is queued to</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.amdgpu_display_manager">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_display_manager</span></span></span><a class="headerlink" href="#c.amdgpu_display_manager" title="Link to this definition">¶</a><br /></dt>
<dd><p>Central amdgpu display manager device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_display_manager {
    struct dc *dc;
    struct dmub_srv *dmub_srv;
    struct dmub_notification *dmub_notify;
    dmub_notify_interrupt_callback_t dmub_callback[AMDGPU_DMUB_NOTIFICATION_MAX];
    bool dmub_thread_offload[AMDGPU_DMUB_NOTIFICATION_MAX];
    struct dmub_srv_fb_info *dmub_fb_info;
    const struct firmware *dmub_fw;
    struct amdgpu_bo *dmub_bo;
    u64 dmub_bo_gpu_addr;
    void *dmub_bo_cpu_addr;
    uint32_t dmcub_fw_version;
    struct cgs_device *cgs_device;
    struct amdgpu_device *adev;
    struct drm_device *ddev;
    u16 display_indexes_num;
    struct drm_private_obj atomic_obj;
    struct mutex dc_lock;
    struct mutex audio_lock;
    struct drm_audio_component *audio_component;
    bool audio_registered;
    struct list_head irq_handler_list_low_tab[DAL_IRQ_SOURCES_NUMBER];
    struct list_head irq_handler_list_high_tab[DAL_IRQ_SOURCES_NUMBER];
    struct common_irq_params pflip_params[DC_IRQ_SOURCE_PFLIP_LAST - DC_IRQ_SOURCE_PFLIP_FIRST + 1];
    struct common_irq_params vblank_params[DC_IRQ_SOURCE_VBLANK6 - DC_IRQ_SOURCE_VBLANK1 + 1];
    struct common_irq_params vline0_params[DC_IRQ_SOURCE_DC6_VLINE0 - DC_IRQ_SOURCE_DC1_VLINE0 + 1];
    struct common_irq_params vupdate_params[DC_IRQ_SOURCE_VUPDATE6 - DC_IRQ_SOURCE_VUPDATE1 + 1];
    struct common_irq_params dmub_trace_params[1];
    struct common_irq_params dmub_outbox_params[1];
    spinlock_t irq_handler_list_table_lock;
    struct backlight_device *backlight_dev[AMDGPU_DM_MAX_NUM_EDP];
    const struct dc_link *backlight_link[AMDGPU_DM_MAX_NUM_EDP];
    uint8_t num_of_edps;
    struct amdgpu_dm_backlight_caps backlight_caps[AMDGPU_DM_MAX_NUM_EDP];
    struct mod_freesync *freesync_module;
    struct hdcp_workqueue *hdcp_workqueue;
    struct workqueue_struct *vblank_control_workqueue;
    struct idle_workqueue *idle_workqueue;
    struct drm_atomic_state *cached_state;
    struct dc_state *cached_dc_state;
    struct dm_compressor_info compressor;
    const struct firmware *fw_dmcu;
    uint32_t dmcu_fw_version;
    const struct gpu_info_soc_bounding_box_v1_0 *soc_bounding_box;
    uint32_t active_vblank_irq_count;
#if defined(CONFIG_DRM_AMD_SECURE_DISPLAY);
    struct secure_display_context secure_display_ctx;
#endif;
    struct hpd_rx_irq_offload_work_queue *hpd_rx_offload_wq;
    struct amdgpu_encoder mst_encoders[AMDGPU_DM_MAX_CRTC];
    bool force_timing_sync;
    bool disable_hpd_irq;
    bool dmcub_trace_event_en;
    struct list_head da_list;
    struct completion dmub_aux_transfer_done;
    struct workqueue_struct *delayed_hpd_wq;
    u32 brightness[AMDGPU_DM_MAX_NUM_EDP];
    u32 actual_brightness[AMDGPU_DM_MAX_NUM_EDP];
    bool aux_hpd_discon_quirk;
    struct mutex dpia_aux_lock;
    struct dml2_soc_bb *bb_from_dmub;
    struct amdgpu_i2c_adapter *oem_i2c;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dc</span></code></dt><dd><p>Display Core control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_srv</span></code></dt><dd><p>DMUB service, used for controlling the DMUB on hardware
that supports it. The pointer to the dmub_srv will be
NULL on hardware that does not support it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_notify</span></code></dt><dd><p>Notification from DMUB.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_callback</span></code></dt><dd><p>Callback functions to handle notification from DMUB.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_thread_offload</span></code></dt><dd><p>Flag to indicate if callback is offload.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_fb_info</span></code></dt><dd><p>Framebuffer regions for the DMUB.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_fw</span></code></dt><dd><p>DMUB firmware, required on hardware that has DMUB support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_bo</span></code></dt><dd><p>Buffer object for the DMUB.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_bo_gpu_addr</span></code></dt><dd><p>GPU virtual address for the DMUB buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_bo_cpu_addr</span></code></dt><dd><p>CPU address for the DMUB buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmcub_fw_version</span></code></dt><dd><p>DMCUB firmware version.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cgs_device</span></code></dt><dd><p>The Common Graphics Services device. It provides an interface for
accessing registers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adev</span></code></dt><dd><p>AMDGPU base driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddev</span></code></dt><dd><p>DRM base driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">display_indexes_num</span></code></dt><dd><p>Max number of display streams supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_obj</span></code></dt><dd><p>In combination with <code class="xref c c-type docutils literal notranslate"><span class="pre">dm_atomic_state</span></code> it helps manage
global atomic state that doesn’t map cleanly into existing
drm resources, like <code class="xref c c-type docutils literal notranslate"><span class="pre">dc_context</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dc_lock</span></code></dt><dd><p>Guards access to DC functions that can issue register write
sequences.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio_lock</span></code></dt><dd><p>Guards access to audio instance changes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio_component</span></code></dt><dd><p>Used to notify ELD changes to sound driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio_registered</span></code></dt><dd><p>True if the audio component has been registered
successfully, false otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_list_low_tab</span></code></dt><dd><p>Low priority IRQ handler table.</p>
<p>It is a n*m table consisting of n IRQ sources, and m handlers per IRQ
source. Low priority IRQ handlers are deferred to a workqueue to be
processed. Hence, they can sleep.</p>
<p>Note that handlers are called in the same order as they were
registered (FIFO).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_list_high_tab</span></code></dt><dd><p>High priority IRQ handler table.</p>
<p>It is a n*m table, same as <code class="xref c c-type docutils literal notranslate"><span class="pre">irq_handler_list_low_tab</span></code>. However,
handlers in this table are not deferred and are called immediately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pflip_params</span></code></dt><dd><p>Page flip IRQ parameters, passed to registered handlers when
triggered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vblank_params</span></code></dt><dd><p>Vertical blanking IRQ parameters, passed to registered handlers when
triggered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vline0_params</span></code></dt><dd><p>OTG vertical interrupt0 IRQ parameters, passed to registered
handlers when triggered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vupdate_params</span></code></dt><dd><p>Vertical update IRQ parameters, passed to registered handlers when
triggered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_trace_params</span></code></dt><dd><p>DMUB trace event IRQ parameters, passed to registered handlers when
triggered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_outbox_params</span></code></dt><dd><p>DMUB Outbox parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_list_table_lock</span></code></dt><dd><p>Synchronizes access to IRQ tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight_dev</span></code></dt><dd><p>Backlight control device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight_link</span></code></dt><dd><p>Link on which to control backlight</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_of_edps</span></code></dt><dd><p>number of backlight eDPs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight_caps</span></code></dt><dd><p>Capabilities of the backlight device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freesync_module</span></code></dt><dd><p>Module handling freesync calculations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdcp_workqueue</span></code></dt><dd><p>AMDGPU content protection queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vblank_control_workqueue</span></code></dt><dd><p>Deferred work for vblank control events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idle_workqueue</span></code></dt><dd><p>Periodic work for idle events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cached_state</span></code></dt><dd><p>Caches device atomic state for suspend/resume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cached_dc_state</span></code></dt><dd><p>Cached state of content streams</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compressor</span></code></dt><dd><p>Frame buffer compression buffer. See <a class="reference internal" href="#c.dm_compressor_info" title="dm_compressor_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dm_compressor_info</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fw_dmcu</span></code></dt><dd><p>Reference to DMCU firmware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmcu_fw_version</span></code></dt><dd><p>Version of the DMCU firmware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soc_bounding_box</span></code></dt><dd><p>gpu_info FW provided soc bounding box struct or 0 if not
available in FW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_vblank_irq_count</span></code></dt><dd><p>number of currently active vblank irqs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secure_display_ctx</span></code></dt><dd><p>Store secure display relevant info. e.g. the ROI information
, the work_struct to command dmub, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_rx_offload_wq</span></code></dt><dd><p>Work queue to offload works of hpd_rx_irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mst_encoders</span></code></dt><dd><p>fake encoders used for DP MST.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">force_timing_sync</span></code></dt><dd><p>set via debugfs. When set, indicates that all connected
displays will be forced to synchronize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_hpd_irq</span></code></dt><dd><p>disables all HPD and HPD RX interrupt handling in the
driver when true</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmcub_trace_event_en</span></code></dt><dd><p>enable dmcub trace events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">da_list</span></code></dt><dd><p>DAL fb memory allocation list, for communication with SMU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmub_aux_transfer_done</span></code></dt><dd><p>struct completion used to indicate when DMUB
transfers are done</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_hpd_wq</span></code></dt><dd><p>work queue used to delay DMUB HPD work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">brightness</span></code></dt><dd><p>cached backlight values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">actual_brightness</span></code></dt><dd><p>last successfully applied backlight values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux_hpd_discon_quirk</span></code></dt><dd><p>quirk for hpd discon while aux is on-going.
occurred on certain intel platform</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpia_aux_lock</span></code></dt><dd><p>Guards access to DPIA AUX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bb_from_dmub</span></code></dt><dd><p>Bounding box data read from dmub during early initialization for DCN4+</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oem_i2c</span></code></dt><dd><p>OEM i2c bus</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.amdgpu_hdmi_vsdb_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_hdmi_vsdb_info</span></span></span><a class="headerlink" href="#c.amdgpu_hdmi_vsdb_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Keep track of the VSDB info</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_hdmi_vsdb_info {
    unsigned int amd_vsdb_version;
    bool freesync_supported;
    unsigned int min_refresh_rate_hz;
    unsigned int max_refresh_rate_hz;
    bool replay_mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amd_vsdb_version</span></code></dt><dd><p>Vendor Specific Data Block Version, should be
used to determine which Vendor Specific InfoFrame (VSIF) to send.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freesync_supported</span></code></dt><dd><p>FreeSync Supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_refresh_rate_hz</span></code></dt><dd><p>FreeSync Minimum Refresh Rate in Hz.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_refresh_rate_hz</span></code></dt><dd><p>FreeSync Maximum Refresh Rate in Hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">replay_mode</span></code></dt><dd><p>Replay supported</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>AMDGPU supports FreeSync over HDMI by using the VSDB section, and this
struct is useful to keep track of the display-specific information about
FreeSync.</p>
<section id="lifecycle">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Lifecycle</a><a class="headerlink" href="#lifecycle" title="Link to this heading">¶</a></h2>
<p>DM (and consequently DC) is registered in the amdgpu base driver as a IP
block. When CONFIG_DRM_AMD_DC is enabled, the DM device IP block is added to
the base driver’s device list to be initialized and torn down accordingly.</p>
<p>The functions to do so are provided as hooks in <a class="reference internal" href="../driver-core.html#c.amd_ip_funcs" title="amd_ip_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amd_ip_funcs</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.dm_hw_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dm_hw_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_ip_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ip_block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_hw_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize DC device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_ip_block</span> <span class="pre">*ip_block</span></code></dt><dd><p>Pointer to the amdgpu_ip_block for this hw instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the <a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_display_manager</span></code></a> device. This involves calling
the initializers of each DM component, then populating the struct with them.</p>
<p>Although the function implies hardware initialization, both hardware and
software are initialized here. Splitting them out to their relevant init
hooks is a future TODO item.</p>
<p>Some notable things that are initialized here:</p>
<ul class="simple">
<li><p>Display Core, both software and hardware</p></li>
<li><p>DC modules that we need (freesync and color management)</p></li>
<li><p>DRM software states</p></li>
<li><p>Interrupt sources and handlers</p></li>
<li><p>Vblank support</p></li>
<li><p>Debug FS entries, if enabled</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dm_hw_fini">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dm_hw_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_ip_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ip_block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_hw_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>Teardown DC device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_ip_block</span> <span class="pre">*ip_block</span></code></dt><dd><p>Pointer to the amdgpu_ip_block for this hw instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Teardown components within <a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_display_manager</span></code></a> that require
cleanup. This involves cleaning up the DRM device, DC, and any modules that
were loaded. Also flush IRQ workqueues and disable them.</p>
</div>
</section>
<section id="interrupts">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Interrupts</a><a class="headerlink" href="#interrupts" title="Link to this heading">¶</a></h2>
<p>DM provides another layer of IRQ management on top of what the base driver
already provides. This is something that could be cleaned up, and is a
future TODO item.</p>
<p>The base driver provides IRQ source registration with DRM, handler
registration into the base driver’s IRQ table, and a handler callback
<a class="reference internal" href="../driver-core.html#c.amdgpu_irq_handler" title="amdgpu_irq_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_irq_handler()</span></code></a>, with which DRM calls on interrupts. This generic
handler looks up the IRQ table, and calls the respective
<code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_irq_src_funcs.process</span></code> hookups.</p>
<p>What DM provides on top are two IRQ tables specifically for top-half and
bottom-half IRQ handling, with the bottom-half implementing workqueues:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_display_manager.irq_handler_list_high_tab</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.amdgpu_display_manager" title="amdgpu_display_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_display_manager.irq_handler_list_low_tab</span></code></a></p></li>
</ul>
<p>They override the base driver’s IRQ table, and the effect can be seen
in the hooks that DM provides for <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_irq_src_funcs.process</span></code>. They
are all set to the DM generic handler <a class="reference internal" href="#c.amdgpu_dm_irq_handler" title="amdgpu_dm_irq_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_dm_irq_handler()</span></code></a>, which looks up
DM’s IRQ tables. However, in order for base driver to recognize this hook, DM
still needs to register the IRQ with the base driver. See
dce110_register_irq_handlers() and dcn10_register_irq_handlers().</p>
<p>To expose DC’s hardware interrupt toggle to the base driver, DM implements
<code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_irq_src_funcs.set</span></code> hooks. Base driver calls it through
<a class="reference internal" href="../driver-core.html#c.amdgpu_irq_update" title="amdgpu_irq_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_irq_update()</span></code></a> to enable or disable the interrupt.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.amdgpu_dm_irq_handler_data">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_irq_handler_data</span></span></span><a class="headerlink" href="#c.amdgpu_dm_irq_handler_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>Data for DM interrupt handlers.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_dm_irq_handler_data {
    struct list_head list;
    interrupt_handler handler;
    void *handler_arg;
    struct amdgpu_display_manager *dm;
    enum dc_irq_source irq_source;
    struct work_struct work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>Linked list entry referencing the next/previous handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>Handler function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler_arg</span></code></dt><dd><p>Argument passed to the handler when triggered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dm</span></code></dt><dd><p>DM which this handler belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_source</span></code></dt><dd><p>DC interrupt source that this handler is registered for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>work struct</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dm_irq_work_func">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dm_irq_work_func</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_irq_work_func" title="Link to this definition">¶</a><br /></dt>
<dd><p>Handle an IRQ outside of the interrupt handler proper.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work struct</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unregister_all_irq_handlers">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unregister_all_irq_handlers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_all_irq_handlers" title="Link to this definition">¶</a><br /></dt>
<dd><p>Cleans up handlers from the DM IRQ table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>The base driver device containing the DM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Go through low and high context IRQ tables and deallocate handlers.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_irq_register_interrupt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_irq_register_interrupt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dc_interrupt_params</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">int_params</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ih</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handler_args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_register_interrupt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register a handler within DM.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>The base driver device containing the DM device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_interrupt_params</span> <span class="pre">*int_params</span></code></dt><dd><p>Interrupt parameters containing the source, and handler context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*ih)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function pointer to the interrupt handler to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*handler_args</span></code></dt><dd><p>Arguments passed to the handler when the interrupt occurs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register an interrupt handler for the given IRQ source, under the given
context. The context can either be high or low. High context handlers are
executed directly within ISR context, while low context is executed within a
workqueue, thereby allowing operations that sleep.</p>
<p>Registered handlers are called in a FIFO manner, i.e. the most recently
registered handler will be called first.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Handler data <a class="reference internal" href="#c.amdgpu_dm_irq_handler_data" title="amdgpu_dm_irq_handler_data"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_dm_irq_handler_data</span></code></a> containing the IRQ</dt><dd><p>source, handler function, and args</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_irq_unregister_interrupt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_irq_unregister_interrupt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">dc_irq_source</span></span><span class="w"> </span><span class="n"><span class="pre">irq_source</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ih</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_unregister_interrupt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove a handler from the DM IRQ table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>The base driver device containing the DM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dc_irq_source</span> <span class="pre">irq_source</span></code></dt><dd><p>IRQ source to remove the given handler from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ih</span></code></dt><dd><p>Function pointer to the interrupt handler to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Go through both low and high context IRQ tables, and find the given handler
for the given irq source. If found, remove it. Otherwise, do nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_irq_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_irq_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize DM IRQ management</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>The base driver device containing the DM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize DM’s high and low context IRQ tables.</p>
<p>The N by M table contains N IRQ sources, with M
<a class="reference internal" href="#c.amdgpu_dm_irq_handler_data" title="amdgpu_dm_irq_handler_data"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_dm_irq_handler_data</span></code></a> hooked together in a linked list. The
list_heads are initialized here. When an interrupt n is triggered, all m
handlers are called in sequence, FIFO according to registration order.</p>
<p>The low context table requires special steps to initialize, since handlers
will be deferred to a workqueue. See <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_list_head</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_irq_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_irq_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tear down DM IRQ management</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>The base driver device containing the DM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush all work within the low context IRQ table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_irq_handler">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_irq_handler</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_irq_src</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">source</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_iv_entry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_irq_handler" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic DM IRQ handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>amdgpu base driver device containing the DM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*source</span></code></dt><dd><p>Unused</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_iv_entry</span> <span class="pre">*entry</span></code></dt><dd><p>Data about the triggered interrupt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls all registered high irq work immediately, and schedules work for low
irq. The DM IRQ table is used to find the corresponding handlers.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_hpd_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_hpd_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_hpd_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>hpd setup callback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>amdgpu_device pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the hpd pins used by the card (evergreen+).
Enable the pin, set the polarity, and enable the hpd interrupts.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_hpd_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_hpd_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_hpd_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>hpd tear down callback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>amdgpu_device pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down the hpd pins used by the card (evergreen+).
Disable the hpd interrupts.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dm_pflip_high_irq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dm_pflip_high_irq</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interrupt_params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_pflip_high_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Handle pageflip interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*interrupt_params</span></code></dt><dd><p>ignored</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handles the pageflip interrupt by notifying all interested parties
that the pageflip has been completed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dm_crtc_high_irq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dm_crtc_high_irq</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interrupt_params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dm_crtc_high_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Handles CRTC interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*interrupt_params</span></code></dt><dd><p>used for determining the CRTC instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handles the CRTC/VSYNC interrupt by notfying DRM’s VBLANK
event handler.</p>
</div>
</section>
<section id="atomic-implementation">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Atomic Implementation</a><a class="headerlink" href="#atomic-implementation" title="Link to this heading">¶</a></h2>
<p><em>WIP</em></p>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_atomic_commit_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_atomic_commit_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><span class="n"><span class="pre">drm_atomic_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_atomic_commit_tail" title="Link to this definition">¶</a><br /></dt>
<dd><p>AMDgpu DM’s commit tail implementation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>The atomic state to commit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will tell DC to commit the constructed DC state from atomic_check,
programming the hardware. Any failures here implies a hardware failure, since
atomic check should have filtered anything non-kosher.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_atomic_check">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_atomic_check</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><span class="n"><span class="pre">drm_atomic_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_atomic_check" title="Link to this definition">¶</a><br /></dt>
<dd><p>Atomic check implementation for AMDgpu DM.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>The DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>The atomic state to commit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate that the given atomic state is programmable by DC into hardware.
This involves constructing a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_state</span></code> reflecting the new hardware
state we wish to commit, then querying DC to see if it is programmable. It’s
important not to modify the existing DC state. Otherwise, atomic_check
may unexpectedly commit hardware changes.</p>
<p>When validating the DC state, it’s important that the right locks are
acquired. For full updates case which removes/adds/updates streams on one
CRTC while flipping on another CRTC, acquiring global lock will guarantee
that any such full update commit will wait for completion of any outstanding
flip using DRMs synchronization events.</p>
<p>Note that DM adds the affected connectors for all CRTCs in state, when that
might not seem necessary. This is because DC stream creation requires the
DC sink, which is tied to the DRM connector state. Cleaning this up should
be possible but non-trivial - a possible TODO item.</p>
<p><strong>Return</strong></p>
<p>-Error code if validation failed.</p>
</div>
</section>
<section id="color-management-properties">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Color Management Properties</a><a class="headerlink" href="#color-management-properties" title="Link to this heading">¶</a></h2>
<p>The DC interface to HW gives us the following color management blocks
per pipe (surface):</p>
<ul class="simple">
<li><p>Input gamma LUT (de-normalized)</p></li>
<li><p>Input CSC (normalized)</p></li>
<li><p>Surface degamma LUT (normalized)</p></li>
<li><p>Surface CSC (normalized)</p></li>
<li><p>Surface regamma LUT (normalized)</p></li>
<li><p>Output CSC (normalized)</p></li>
</ul>
<p>But these aren’t a direct mapping to DRM color properties. The current DRM
interface exposes CRTC degamma, CRTC CTM and CRTC regamma while our hardware
is essentially giving:</p>
<p>Plane CTM -&gt; Plane degamma -&gt; Plane CTM -&gt; Plane regamma -&gt; Plane CTM</p>
<p>The input gamma LUT block isn’t really applicable here since it operates
on the actual input data itself rather than the HW fp representation. The
input and output CSC blocks are technically available to use as part of
the DC interface but are typically used internally by DC for conversions
between color spaces. These could be blended together with user
adjustments in the future but for now these should remain untouched.</p>
<p>The pipe blending also happens after these blocks so we don’t actually
support any CRTC props with correct blending with multiple planes - but we
can still support CRTC color management properties in DM in most single
plane cases correctly with clever management of the DC interface in DM.</p>
<p>As per DRM documentation, blocks should be in hardware bypass when their
respective property is set to NULL. A linear DGM/RGM LUT should also
considered as putting the respective block into bypass mode.</p>
<p>This means that the following
configuration is assumed to be the default:</p>
<p>Plane DGM Bypass -&gt; Plane CTM Bypass -&gt; Plane RGM Bypass -&gt; ...
CRTC DGM Bypass -&gt; CRTC CTM Bypass -&gt; CRTC RGM Bypass</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_init_color_mod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_init_color_mod</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_init_color_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize the color module.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We’re not using the full color module, only certain components.
Only call setup functions for components that we need.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__extract_blob_lut">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_color_lut</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__extract_blob_lut</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../drm-kms.html#c.drm_property_blob" title="drm_property_blob"><span class="n"><span class="pre">drm_property_blob</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">blob</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__extract_blob_lut" title="Link to this definition">¶</a><br /></dt>
<dd><p>Extracts the DRM lut and lut size from a blob.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*blob</span></code></dt><dd><p>DRM color mgmt property blob</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*size</span></code></dt><dd><p>lut size</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>DRM LUT or NULL</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__is_lut_linear">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__is_lut_linear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_color_lut</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lut</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__is_lut_linear" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if the given lut is a linear mapping of values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_color_lut</span> <span class="pre">*lut</span></code></dt><dd><p>given lut to check values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">size</span></code></dt><dd><p>lut size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is considered linear if the lut represents:
f(a) = (0xFF00/MAX_COLOR_LUT_ENTRIES-1)a; for integer a in [0,
MAX_COLOR_LUT_ENTRIES)</p>
<p><strong>Return</strong></p>
<p>True if the given lut is a linear mapping of values, i.e. it acts like a
bypass LUT. Otherwise, false.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__drm_lut_to_dc_gamma">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__drm_lut_to_dc_gamma</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_color_lut</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lut</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dc_gamma</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gamma</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">is_legacy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_lut_to_dc_gamma" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert the drm_color_lut to dc_gamma.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_color_lut</span> <span class="pre">*lut</span></code></dt><dd><p>DRM lookup table for color conversion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_gamma</span> <span class="pre">*gamma</span></code></dt><dd><p>DC gamma to set entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_legacy</span></code></dt><dd><p>legacy or atomic gamma</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The conversion depends on the size of the lut - whether or not it’s legacy.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__drm_ctm_to_dc_matrix">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__drm_ctm_to_dc_matrix</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_color_ctm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fixed31_32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">matrix</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_ctm_to_dc_matrix" title="Link to this definition">¶</a><br /></dt>
<dd><p>converts a DRM CTM to a DC CSC float matrix</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_color_ctm</span> <span class="pre">*ctm</span></code></dt><dd><p>DRM color transformation matrix</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fixed31_32</span> <span class="pre">*matrix</span></code></dt><dd><p>DC CSC float matrix</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The matrix needs to be a 3x4 (12 entry) matrix.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__drm_ctm_3x4_to_dc_matrix">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__drm_ctm_3x4_to_dc_matrix</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_color_ctm_3x4</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fixed31_32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">matrix</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_ctm_3x4_to_dc_matrix" title="Link to this definition">¶</a><br /></dt>
<dd><p>converts a DRM CTM 3x4 to a DC CSC float matrix</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_color_ctm_3x4</span> <span class="pre">*ctm</span></code></dt><dd><p>DRM color transformation matrix with 3x4 dimensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fixed31_32</span> <span class="pre">*matrix</span></code></dt><dd><p>DC CSC float matrix</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The matrix needs to be a 3x4 (12 entry) matrix.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__set_legacy_tf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__set_legacy_tf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dc_transfer_func</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">func</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_color_lut</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lut</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">lut_size</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">has_rom</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__set_legacy_tf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Calculates the legacy transfer function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_transfer_func</span> <span class="pre">*func</span></code></dt><dd><p>transfer function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_color_lut</span> <span class="pre">*lut</span></code></dt><dd><p>lookup table that defines the color space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">lut_size</span></code></dt><dd><p>size of respective lut</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">has_rom</span></code></dt><dd><p>if ROM can be used for hardcoded curve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only for sRGB input space</p>
<p><strong>Return</strong></p>
<p>0 in case of success, -ENOMEM if fails</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__set_output_tf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__set_output_tf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dc_transfer_func</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">func</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_color_lut</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lut</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">lut_size</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">has_rom</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__set_output_tf" title="Link to this definition">¶</a><br /></dt>
<dd><p>calculates the output transfer function based on expected input space.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_transfer_func</span> <span class="pre">*func</span></code></dt><dd><p>transfer function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_color_lut</span> <span class="pre">*lut</span></code></dt><dd><p>lookup table that defines the color space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">lut_size</span></code></dt><dd><p>size of respective lut</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">has_rom</span></code></dt><dd><p>if ROM can be used for hardcoded curve</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 in case of success. -ENOMEM if fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__set_input_tf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__set_input_tf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dc_color_caps" title="dc_color_caps"><span class="n"><span class="pre">dc_color_caps</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">caps</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dc_transfer_func</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">func</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_color_lut</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lut</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">lut_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__set_input_tf" title="Link to this definition">¶</a><br /></dt>
<dd><p>calculates the input transfer function based on expected input space.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_color_caps</span> <span class="pre">*caps</span></code></dt><dd><p>dc color capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_transfer_func</span> <span class="pre">*func</span></code></dt><dd><p>transfer function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_color_lut</span> <span class="pre">*lut</span></code></dt><dd><p>lookup table that defines the color space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">lut_size</span></code></dt><dd><p>size of respective lut.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 in case of success. -ENOMEM if fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_verify_lut3d_size">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_verify_lut3d_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">amdgpu_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../drm-kms.html#c.drm_plane_state" title="drm_plane_state"><span class="n"><span class="pre">drm_plane_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">plane_state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_verify_lut3d_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>verifies if 3D LUT is supported and if user shaper and 3D LUTs match the hw supported size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt><dd><p>amdgpu device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>the DRM plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Verifies if pre-blending (DPP) 3D LUT is supported by the HW (DCN 2.0 or
newer) and if the user shaper and 3D LUTs match the supported size.</p>
<p><strong>Return</strong></p>
<p>0 on success. -EINVAL if lut size are invalid.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_verify_lut_sizes">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_verify_lut_sizes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><span class="n"><span class="pre">drm_crtc_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">crtc_state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_verify_lut_sizes" title="Link to this definition">¶</a><br /></dt>
<dd><p>verifies if DRM luts match the hw supported sizes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>the DRM CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Verifies that the Degamma and Gamma LUTs attached to the <code class="xref c c-type docutils literal notranslate"><span class="pre">crtc_state</span></code>
are of the expected size.</p>
<p><strong>Return</strong></p>
<p>0 on success. -EINVAL if any lut sizes are invalid.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_update_crtc_color_mgmt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_update_crtc_color_mgmt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dm_crtc_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">crtc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_update_crtc_color_mgmt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Maps DRM color management to DC stream.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dm_crtc_state</span> <span class="pre">*crtc</span></code></dt><dd><p>amdgpu_dm crtc state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>With no plane level color management properties we’re free to use any
of the HW blocks as long as the CRTC CTM always comes before the
CRTC RGM and after the CRTC DGM.</p>
<ul class="simple">
<li><p>The CRTC RGM block will be placed in the RGM LUT block if it is non-linear.</p></li>
<li><p>The CRTC DGM block will be placed in the DGM LUT block if it is non-linear.</p></li>
<li><p>The CRTC CTM will be placed in the gamut remap block if it is non-linear.</p></li>
</ul>
<p>The RGM block is typically more fully featured and accurate across
all ASICs - DCE can’t support a custom non-linear CRTC DGM.</p>
<p>For supporting both plane level color management and CRTC level color
management at once we have to either restrict the usage of CRTC properties
or blend adjustments together.</p>
<p><strong>Return</strong></p>
<p>0 on success. Error code if setup fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.amdgpu_dm_update_plane_color_mgmt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amdgpu_dm_update_plane_color_mgmt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dm_crtc_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">crtc</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../../drm-kms.html#c.drm_plane_state" title="drm_plane_state"><span class="n"><span class="pre">drm_plane_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">plane_state</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.amdgpu_dm_update_plane_color_mgmt" title="dc_plane_state"><span class="n"><span class="pre">dc_plane_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dc_plane_state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dm_update_plane_color_mgmt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Maps DRM color management to DC plane.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dm_crtc_state</span> <span class="pre">*crtc</span></code></dt><dd><p>amdgpu_dm crtc state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>DRM plane state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dc_plane_state</span> <span class="pre">*dc_plane_state</span></code></dt><dd><p>target DC surface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the underlying dc_stream_state’s input transfer function (ITF) in
preparation for hardware commit. The transfer function used depends on
the preparation done on the stream for color management.</p>
<p><strong>Return</strong></p>
<p>0 on success. -ENOMEM if mem allocation fails.</p>
</div>
<section id="dc-color-capabilities-between-dcn-generations">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">DC Color Capabilities between DCN generations</a><a class="headerlink" href="#dc-color-capabilities-between-dcn-generations" title="Link to this heading">¶</a></h3>
<p>DRM/KMS framework defines three CRTC color correction properties: degamma,
color transformation matrix (CTM) and gamma, and two properties for degamma and
gamma LUT sizes. AMD DC programs some of the color correction features
pre-blending but DRM/KMS has not per-plane color correction properties.</p>
<p>In general, the DRM CRTC color properties are programmed to DC, as follows:
CRTC gamma after blending, and CRTC degamma pre-blending. Although CTM is
programmed after blending, it is mapped to DPP hw blocks (pre-blending). Other
color caps available in the hw is not currently exposed by DRM interface and
are bypassed.</p>
<p><strong>Color management caps (DPP and MPC)</strong></p>
<p>Modules/color calculates various color operations which are translated to
abstracted HW. DCE 5-12 had almost no important changes, but starting with
DCN1, every new generation comes with fairly major differences in color
pipeline. Therefore, we abstract color pipe capabilities so modules/DM can
decide mapping to HW block based on logical capabilities.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.MAX_SURFACES">
<span class="sig-name descname"><span class="n"><span class="pre">MAX_SURFACES</span></span></span><a class="headerlink" href="#c.MAX_SURFACES" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">MAX_SURFACES</span></code></p>
<blockquote>
<div><p>representative of the upper bound of surfaces that can be piped to a single CRTC</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.MAX_PLANES">
<span class="sig-name descname"><span class="n"><span class="pre">MAX_PLANES</span></span></span><a class="headerlink" href="#c.MAX_PLANES" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">MAX_PLANES</span></code></p>
<blockquote>
<div><p>representative of the upper bound of planes that are supported by the HW</p>
</div></blockquote>
<dl class="c struct">
<dt class="sig sig-object c" id="c.rom_curve_caps">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rom_curve_caps</span></span></span><a class="headerlink" href="#c.rom_curve_caps" title="Link to this definition">¶</a><br /></dt>
<dd><p>predefined transfer function caps for degamma and regamma</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rom_curve_caps {
    uint16_t srgb : 1;
    uint16_t bt2020 : 1;
    uint16_t gamma2_2 : 1;
    uint16_t pq : 1;
    uint16_t hlg : 1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">srgb</span></code></dt><dd><p>RGB color space transfer func</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bt2020</span></code></dt><dd><p>BT.2020 transfer func</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma2_2</span></code></dt><dd><p>standard gamma</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pq</span></code></dt><dd><p>perceptual quantizer transfer function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hlg</span></code></dt><dd><p>hybrid log–gamma transfer function</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dpp_color_caps">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dpp_color_caps</span></span></span><a class="headerlink" href="#c.dpp_color_caps" title="Link to this definition">¶</a><br /></dt>
<dd><p>color pipeline capabilities for display pipe and plane blocks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dpp_color_caps {
    uint16_t dcn_arch : 1;
    uint16_t input_lut_shared : 1;
    uint16_t icsc : 1;
    uint16_t dgam_ram : 1;
    uint16_t post_csc : 1;
    uint16_t gamma_corr : 1;
    uint16_t hw_3d_lut : 1;
    uint16_t ogam_ram : 1;
    uint16_t ocsc : 1;
    uint16_t dgam_rom_for_yuv : 1;
    struct rom_curve_caps dgam_rom_caps;
    struct rom_curve_caps ogam_rom_caps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dcn_arch</span></code></dt><dd><p>all DCE generations treated the same</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_lut_shared</span></code></dt><dd><p>shared with DGAM. Input LUT is different than most LUTs,
just plain 256-entry lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">icsc</span></code></dt><dd><p>input color space conversion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dgam_ram</span></code></dt><dd><p>programmable degamma LUT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_csc</span></code></dt><dd><p>post color space conversion, before gamut remap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma_corr</span></code></dt><dd><p>degamma correction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_3d_lut</span></code></dt><dd><p>3D LUT support. It implies a shaper LUT before. It may be shared
with MPC by setting mpc:shared_3d_lut flag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ogam_ram</span></code></dt><dd><p>programmable out/blend gamma LUT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ocsc</span></code></dt><dd><p>output color space conversion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dgam_rom_for_yuv</span></code></dt><dd><p>pre-defined degamma LUT for YUV planes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dgam_rom_caps</span></code></dt><dd><p>pre-definied curve caps for degamma 1D LUT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ogam_rom_caps</span></code></dt><dd><p>pre-definied curve caps for regamma 1D LUT</p>
</dd>
</dl>
</div>
<p><strong>Note</strong></p>
<p>hdr_mult and gamut remap (CTM) are always available in DPP (in that order)</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.mpc_color_caps">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpc_color_caps</span></span></span><a class="headerlink" href="#c.mpc_color_caps" title="Link to this definition">¶</a><br /></dt>
<dd><p>color pipeline capabilities for multiple pipe and plane combined blocks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mpc_color_caps {
    uint16_t gamut_remap : 1;
    uint16_t ogam_ram : 1;
    uint16_t ocsc : 1;
    uint16_t num_3dluts : 3;
    uint16_t shared_3d_lut:1;
    struct rom_curve_caps ogam_rom_caps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gamut_remap</span></code></dt><dd><p>color transformation matrix</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ogam_ram</span></code></dt><dd><p>programmable out gamma LUT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ocsc</span></code></dt><dd><p>output color space conversion matrix</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_3dluts</span></code></dt><dd><p>MPC 3D LUT; always assumes a preceding shaper LUT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared_3d_lut</span></code></dt><dd><p>shared 3D LUT flag. Can be either DPP or MPC, but single
instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ogam_rom_caps</span></code></dt><dd><p>pre-definied curve caps for regamma 1D LUT</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dc_color_caps">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dc_color_caps</span></span></span><a class="headerlink" href="#c.dc_color_caps" title="Link to this definition">¶</a><br /></dt>
<dd><p>color pipes capabilities for DPP and MPC hw blocks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dc_color_caps {
    struct dpp_color_caps dpp;
    struct mpc_color_caps mpc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dpp</span></code></dt><dd><p>color pipes caps for DPP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mpc</span></code></dt><dd><p>color pipes caps for MPC</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.pipe_split_policy">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pipe_split_policy</span></span></span><a class="headerlink" href="#c.pipe_split_policy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pipe split strategy supported by DCN</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MPC_SPLIT_DYNAMIC</span></code></dt><dd><p>DC will automatically decide how to split the
pipe in order to bring the best trade-off between performance and
power consumption. This is the recommended option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPC_SPLIT_AVOID</span></code></dt><dd><p>Avoid pipe split, which means that DC will not
try any sort of split optimization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPC_SPLIT_AVOID_MULT_DISP</span></code></dt><dd><p>With this option, DC will only try to
optimize the pipe utilization when using a single display; if the
user connects to a second display, DC will avoid pipe split.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This enum is used to define the pipe split policy supported by DCN. By
default, DC favors MPC_SPLIT_DYNAMIC.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dc_validation_set">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dc_validation_set</span></span></span><a class="headerlink" href="#c.dc_validation_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Struct to store surface/stream associations for validation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dc_validation_set {
    struct dc_stream_state *stream;
    struct dc_plane_state *plane_states[MAX_SURFACES];
    uint8_t plane_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">stream</span></code></dt><dd><p>Stream state properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane_states</span></code></dt><dd><p>Surface state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane_count</span></code></dt><dd><p>Total of active planes</p>
</dd>
</dl>
</div>
<p>The color pipeline has undergone major changes between DCN hardware
generations. What’s possible to do before and after blending depends on
hardware capabilities, as illustrated below by the DCN 2.0 and DCN 3.0 families
schemas.</p>
<p><strong>DCN 2.0 family color caps and mapping</strong></p>
<figure class="align-default">
<img alt="../../../_images/dcn2_cm_drm_current.svg" src="../../../_images/dcn2_cm_drm_current.svg" /></figure>
<p><strong>DCN 3.0 family color caps and mapping</strong></p>
<figure class="align-default">
<img alt="../../../_images/dcn3_cm_drm_current.svg" src="../../../_images/dcn3_cm_drm_current.svg" /></figure>
</section>
</section>
<section id="blend-mode-properties">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Blend Mode Properties</a><a class="headerlink" href="#blend-mode-properties" title="Link to this heading">¶</a></h2>
<p>Pixel blend mode is a DRM plane composition property of <a class="reference internal" href="../../drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a> used to
describes how pixels from a foreground plane (fg) are composited with the
background plane (bg). Here, we present main concepts of DRM blend mode to help
to understand how this property is mapped to AMD DC interface. See more about
this DRM property and the alpha blending equations in <a class="reference internal" href="../../drm-kms.html#plane-composition-properties"><span class="std std-ref">DRM Plane
Composition Properties</span></a>.</p>
<p>Basically, a blend mode sets the alpha blending equation for plane
composition that fits the mode in which the alpha channel affects the state of
pixel color values and, therefore, the resulted pixel color. For
example, consider the following elements of the alpha blending equation:</p>
<ul class="simple">
<li><p><em>fg.rgb</em>: Each of the RGB component values from the foreground’s pixel.</p></li>
<li><p><em>fg.alpha</em>: Alpha component value from the foreground’s pixel.</p></li>
<li><p><em>bg.rgb</em>: Each of the RGB component values from the background.</p></li>
<li><p><em>plane_alpha</em>: Plane alpha value set by the <strong>plane “alpha” property</strong>, see
more in <a class="reference internal" href="../../drm-kms.html#plane-composition-properties"><span class="std std-ref">DRM Plane Composition Properties</span></a>.</p></li>
</ul>
<p>in the basic alpha blending equation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>out.rgb = alpha * fg.rgb + (1 - alpha) * bg.rgb
</pre></div>
</div>
<p>the alpha channel value of each pixel in a plane is ignored and only the plane
alpha affects the resulted pixel color values.</p>
<p>DRM has three blend mode to define the blend formula in the plane composition:</p>
<ul class="simple">
<li><p><strong>None</strong>: Blend formula that ignores the pixel alpha.</p></li>
<li><p><strong>Pre-multiplied</strong>: Blend formula that assumes the pixel color values in a
plane was already pre-multiplied by its own alpha channel before storage.</p></li>
<li><p><strong>Coverage</strong>: Blend formula that assumes the pixel color values were not
pre-multiplied with the alpha channel values.</p></li>
</ul>
<p>and pre-multiplied is the default pixel blend mode, that means, when no blend
mode property is created or defined, DRM considers the plane’s pixels has
pre-multiplied color values. On IGT GPU tools, the kms_plane_alpha_blend test
provides a set of subtests to verify plane alpha and blend mode properties.</p>
<p>The DRM blend mode and its elements are then mapped by AMDGPU display manager
(DM) to program the blending configuration of the Multiple Pipe/Plane Combined
(MPC), as follows:</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.mpcc_blnd_cfg">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpcc_blnd_cfg</span></span></span><a class="headerlink" href="#c.mpcc_blnd_cfg" title="Link to this definition">¶</a><br /></dt>
<dd><p>MPCC blending configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mpcc_blnd_cfg {
    struct tg_color black_color;
    enum mpcc_alpha_blend_mode alpha_mode;
    bool pre_multiplied_alpha;
    int global_gain;
    int global_alpha;
    bool overlap_only;
    int bottom_gain_mode;
    int background_color_bpc;
    int top_gain;
    int bottom_inside_gain;
    int bottom_outside_gain;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">black_color</span></code></dt><dd><p>background color.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alpha_mode</span></code></dt><dd><p>alpha blend mode (MPCC_ALPHA_BLND_MODE).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_multiplied_alpha</span></code></dt><dd><p>Whether pixel color values were pre-multiplied by the alpha channel
(MPCC_ALPHA_MULTIPLIED_MODE).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">global_gain</span></code></dt><dd><p>Used when blend mode considers both pixel alpha and plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">global_alpha</span></code></dt><dd><p>Plane alpha value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">overlap_only</span></code></dt><dd><p>Whether overlapping of different planes is allowed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bottom_gain_mode</span></code></dt><dd><p>Blend mode for bottom gain setting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">background_color_bpc</span></code></dt><dd><p>Background color for bpc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">top_gain</span></code></dt><dd><p>Top gain setting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bottom_inside_gain</span></code></dt><dd><p>Blend mode for bottom inside.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bottom_outside_gain</span></code></dt><dd><p>Blend mode for bottom outside.</p>
</dd>
</dl>
</div>
<p>Therefore, the blending configuration for a single MPCC instance on the MPC
tree is defined by <a class="reference internal" href="#c.mpcc_blnd_cfg" title="mpcc_blnd_cfg"><code class="xref c c-type docutils literal notranslate"><span class="pre">mpcc_blnd_cfg</span></code></a>, where
<code class="xref c c-type docutils literal notranslate"><span class="pre">pre_multiplied_alpha</span></code> is the alpha pre-multiplied mode flag used to
set <code class="xref c c-type docutils literal notranslate"><span class="pre">MPCC_ALPHA_MULTIPLIED_MODE</span></code>. It controls whether alpha is
multiplied (true/false), being only true for DRM pre-multiplied blend mode.
<a class="reference internal" href="#c.mpcc_alpha_blend_mode" title="mpcc_alpha_blend_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">mpcc_alpha_blend_mode</span></code></a> defines the alpha blend mode regarding pixel
alpha and plane alpha values. It sets one of the three modes for
<code class="xref c c-type docutils literal notranslate"><span class="pre">MPCC_ALPHA_BLND_MODE</span></code>, as described below.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.mpcc_alpha_blend_mode">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpcc_alpha_blend_mode</span></span></span><a class="headerlink" href="#c.mpcc_alpha_blend_mode" title="Link to this definition">¶</a><br /></dt>
<dd><p>define the alpha blend mode regarding pixel alpha and plane alpha values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA</span></code></dt><dd><p>per pixel alpha using DPP
alpha value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA_COMBINED_GLOBAL_GAIN</span></code></dt><dd><p>per
pixel alpha using DPP alpha value multiplied by a global gain (plane
alpha)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MPCC_ALPHA_BLEND_MODE_GLOBAL_ALPHA</span></code></dt><dd><p>global alpha value, ignores
pixel alpha and consider only plane alpha</p>
</dd>
</dl>
</div>
<p>DM then maps the elements of <cite><a class="reference internal" href="#c.mpcc_alpha_blend_mode" title="mpcc_alpha_blend_mode"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mpcc_alpha_blend_mode</span></code></a></cite> to those in the DRM
blend formula, as follows:</p>
<ul class="simple">
<li><p><em>MPC pixel alpha</em> matches <em>DRM fg.alpha</em> as the alpha component value
from the plane’s pixel</p></li>
<li><p><em>MPC global alpha</em> matches <em>DRM plane_alpha</em> when the pixel alpha should
be ignored and, therefore, pixel values are not pre-multiplied</p></li>
<li><p><em>MPC global gain</em> assumes <em>MPC global alpha</em> value when both <em>DRM
fg.alpha</em> and <em>DRM plane_alpha</em> participate in the blend equation</p></li>
</ul>
<p>In short, <em>fg.alpha</em> is ignored by selecting
<code class="xref c c-type docutils literal notranslate"><span class="pre">MPCC_ALPHA_BLEND_MODE_GLOBAL_ALPHA</span></code>. On the other hand, (plane_alpha *
fg.alpha) component becomes available by selecting
<code class="xref c c-type docutils literal notranslate"><span class="pre">MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA_COMBINED_GLOBAL_GAIN</span></code>. And the
<code class="xref c c-type docutils literal notranslate"><span class="pre">MPCC_ALPHA_MULTIPLIED_MODE</span></code> defines if the pixel color values are
pre-multiplied by alpha or not.</p>
<section id="blend-configuration-flow">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Blend configuration flow</a><a class="headerlink" href="#blend-configuration-flow" title="Link to this heading">¶</a></h3>
<p>The alpha blending equation is configured from DRM to DC interface by the
following path:</p>
<ol class="arabic simple">
<li><p>When updating a <a class="reference internal" href="../../drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a>, DM calls
<code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_dm_plane_fill_blending_from_plane_state()</span></code> that maps
<a class="reference internal" href="../../drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a> attributes to
<code class="xref c c-type docutils literal notranslate"><span class="pre">dc_plane_info</span></code> struct to be handled in the
OS-agnostic component (DC).</p></li>
<li><p>On DC interface, <a class="reference internal" href="#c.mpcc_blnd_cfg" title="mpcc_blnd_cfg"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mpcc_blnd_cfg</span></code></a> programs the
MPCC blend configuration considering the <code class="xref c c-type docutils literal notranslate"><span class="pre">dc_plane_info</span></code> input from DPP.</p></li>
</ol>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/gpu/amdgpu/display/display-manager.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>