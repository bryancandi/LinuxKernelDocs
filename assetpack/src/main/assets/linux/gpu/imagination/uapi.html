<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>UAPI &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="drm/mcde ST-Ericsson MCDE Multi-channel display engine" href="../mcde.html" />
    <link rel="prev" title="drm/imagination PowerVR Graphics Driver" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../input/index.html">Input Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/gpu/imagination/uapi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="uapi">
<h1>UAPI<a class="headerlink" href="#uapi" title="Link to this heading">¶</a></h1>
<p>The sources associated with this section can be found in <code class="docutils literal notranslate"><span class="pre">pvr_drm.h</span></code>.</p>
<p>The PowerVR IOCTL argument structs have a few limitations in place, in
addition to the standard kernel restrictions:</p>
<blockquote>
<div><ul class="simple">
<li><p>All members must be type-aligned.</p></li>
<li><p>The overall struct must be padded to 64-bit alignment.</p></li>
<li><p>Explicit padding is almost always required. This takes the form of
<code class="docutils literal notranslate"><span class="pre">_padding_[x]</span></code> members of sufficient size to pad to the next power-of-two
alignment, where [x] is the offset into the struct in hexadecimal. Arrays
are never used for alignment. Padding fields must be zeroed; this is
always checked.</p></li>
<li><p>Unions may only appear as the last member of a struct.</p></li>
<li><p>Individual union members may grow in the future. The space between the
end of a union member and the end of its containing union is considered
“implicit padding” and must be zeroed. This is always checked.</p></li>
</ul>
</div></blockquote>
<p>In addition to the IOCTL argument structs, the PowerVR UAPI makes use of
DEV_QUERY argument structs. These are used to fetch information about the
device and runtime. These structs are subject to the same rules set out
above.</p>
<section id="object-arrays">
<h2>OBJECT ARRAYS<a class="headerlink" href="#object-arrays" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_obj_array">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_obj_array</span></span></span><a class="headerlink" href="#c.drm_pvr_obj_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container used to pass arrays of objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_obj_array {
    __u32 stride;
    __u32 count;
    __u64 array;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">stride</span></code></dt><dd><p>Stride of object struct. Used for versioning.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Number of objects in the array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code></dt><dd><p>User pointer to an array of objects.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>It is not unusual to have to extend objects to pass new parameters, and the DRM
ioctl infrastructure is supporting that by padding ioctl arguments with zeros
when the data passed by userspace is smaller than the struct defined in the
drm_ioctl_desc, thus keeping things backward compatible. This type is just
applying the same concepts to indirect objects passed through arrays referenced
from the main ioctl arguments structure: the stride basically defines the size
of the object passed by userspace, which allows the kernel driver to pad with
zeros when it’s smaller than the size of the object it expects.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">DRM_PVR_OBJ_ARRAY()</span></code> to fill object array fields, unless you
have a very good reason not to.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_OBJ_ARRAY">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_OBJ_ARRAY</span></span></span><a class="headerlink" href="#c.DRM_PVR_OBJ_ARRAY" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_PVR_OBJ_ARRAY</span> <span class="pre">(cnt,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Helper macro for filling <a class="reference internal" href="#c.drm_pvr_obj_array" title="drm_pvr_obj_array"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_obj_array</span></code></a>.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cnt</span></code></dt><dd><p>Number of elements pointed to py <strong>ptr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Pointer to start of a C array.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Literal of type <a class="reference internal" href="#c.drm_pvr_obj_array" title="drm_pvr_obj_array"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_obj_array</span></code></a>.</p>
</div>
</section>
<section id="ioctls">
<h2>IOCTLS<a class="headerlink" href="#ioctls" title="Link to this heading">¶</a></h2>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PVR_IOCTL">
<span class="sig-name descname"><span class="n"><span class="pre">PVR_IOCTL</span></span></span><a class="headerlink" href="#c.PVR_IOCTL" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">PVR_IOCTL</span> <span class="pre">(_ioctl,</span> <span class="pre">_mode,</span> <span class="pre">_data)</span></code></p>
<blockquote>
<div><p>Build a PowerVR IOCTL number</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_ioctl</span></code></dt><dd><p>An incrementing id for this IOCTL. Added to <code class="docutils literal notranslate"><span class="pre">DRM_COMMAND_BASE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mode</span></code></dt><dd><p>Must be one of <code class="docutils literal notranslate"><span class="pre">DRM_IOR</span></code>, <code class="docutils literal notranslate"><span class="pre">DRM_IOW</span></code> or <code class="docutils literal notranslate"><span class="pre">DRM_IOWR</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_data</span></code></dt><dd><p>The type of the args struct passed by this IOCTL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The struct referred to by <strong>_data</strong> must have a <code class="docutils literal notranslate"><span class="pre">drm_pvr_ioctl_</span></code> prefix and an
<code class="docutils literal notranslate"><span class="pre">_args</span> <span class="pre">suffix</span></code>. They are therefore omitted from <strong>_data</strong>.</p>
<p>This should only be used to build the constants described below; it should
never be used to call an IOCTL directly.</p>
<p><strong>Return</strong></p>
<p>An IOCTL number to be passed to ioctl() from userspace.</p>
</div>
<section id="dev-query">
<h3>DEV_QUERY<a class="headerlink" href="#dev-query" title="Link to this heading">¶</a></h3>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_pvr_dev_query">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_dev_query</span></span></span><a class="headerlink" href="#c.drm_pvr_dev_query" title="Link to this definition">¶</a><br /></dt>
<dd><p>For use with <a class="reference internal" href="#c.drm_pvr_ioctl_dev_query_args" title="drm_pvr_ioctl_dev_query_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_pvr_ioctl_dev_query_args.type</span></code></a> to indicate the type of the receiving container.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_GPU_INFO_GET</span></code></dt><dd><p>The dev query args contain a pointer
to <a class="reference internal" href="#c.drm_pvr_dev_query_gpu_info" title="drm_pvr_dev_query_gpu_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_dev_query_gpu_info</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_RUNTIME_INFO_GET</span></code></dt><dd><p>The dev query args contain a
pointer to <a class="reference internal" href="#c.drm_pvr_dev_query_runtime_info" title="drm_pvr_dev_query_runtime_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_dev_query_runtime_info</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_QUIRKS_GET</span></code></dt><dd><p>The dev query args contain a pointer
to <a class="reference internal" href="#c.drm_pvr_dev_query_quirks" title="drm_pvr_dev_query_quirks"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_dev_query_quirks</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_ENHANCEMENTS_GET</span></code></dt><dd><p>The dev query args contain a
pointer to <a class="reference internal" href="#c.drm_pvr_dev_query_enhancements" title="drm_pvr_dev_query_enhancements"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_dev_query_enhancements</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_HEAP_INFO_GET</span></code></dt><dd><p>The dev query args contain a
pointer to <a class="reference internal" href="#c.drm_pvr_dev_query_heap_info" title="drm_pvr_dev_query_heap_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_dev_query_heap_info</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_STATIC_DATA_AREAS_GET</span></code></dt><dd><p>The dev query args contain
a pointer to <a class="reference internal" href="#c.drm_pvr_dev_query_static_data_areas" title="drm_pvr_dev_query_static_data_areas"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_dev_query_static_data_areas</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Append only. Do not reorder.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_dev_query_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_dev_query_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_dev_query_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_DEV_QUERY</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_dev_query_args {
    __u32 type;
    __u32 size;
    __u64 pointer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of query and output struct. See <a class="reference internal" href="#c.drm_pvr_dev_query" title="drm_pvr_dev_query"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_pvr_dev_query</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the receiving struct, see <strong>type</strong>.</p>
<p>After a successful call this will be updated to the written byte
length.
Can also be used to get the minimum byte length (see <strong>pointer</strong>).
This allows additional fields to be appended to the structs in
future.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pointer</span></code></dt><dd><p>Pointer to struct <strong>type</strong>.</p>
<p>Must be large enough to contain <strong>size</strong> bytes.
If pointer is NULL, the expected size will be returned in the <strong>size</strong>
field, but no other data will be written.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_dev_query_gpu_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_dev_query_gpu_info</span></span></span><a class="headerlink" href="#c.drm_pvr_dev_query_gpu_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container used to fetch information about the graphics processor.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_dev_query_gpu_info {
    __u64 gpu_id;
    __u32 num_phantoms;
    __u32 _padding_c;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">gpu_id</span></code></dt><dd><p>GPU identifier.</p>
<p>For all currently supported GPUs this is the BVNC encoded as a 64-bit
value as follows:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>63..48</p></th>
<th class="head"><p>47..32</p></th>
<th class="head"><p>31..16</p></th>
<th class="head"><p>15..0</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>B</p></td>
<td><p>V</p></td>
<td><p>N</p></td>
<td><p>C</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_phantoms</span></code></dt><dd><p>Number of Phantoms present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_c</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>When fetching this type <a class="reference internal" href="#c.drm_pvr_ioctl_dev_query_args" title="drm_pvr_ioctl_dev_query_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_dev_query_args</span></code></a>.type must be set
to <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_GPU_INFO_GET</span></code>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_dev_query_runtime_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_dev_query_runtime_info</span></span></span><a class="headerlink" href="#c.drm_pvr_dev_query_runtime_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container used to fetch information about the graphics runtime.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_dev_query_runtime_info {
    __u64 free_list_min_pages;
    __u64 free_list_max_pages;
    __u32 common_store_alloc_region_size;
    __u32 common_store_partition_space_size;
    __u32 max_coeffs;
    __u32 cdm_max_local_mem_size_regs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">free_list_min_pages</span></code></dt><dd><p>Minimum allowed free list size,
in PM physical pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_list_max_pages</span></code></dt><dd><p>Maximum allowed free list size,
in PM physical pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">common_store_alloc_region_size</span></code></dt><dd><p>Size of the Allocation
Region within the Common Store used for coefficient and shared
registers, in dwords.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">common_store_partition_space_size</span></code></dt><dd><p>Size of the
Partition Space within the Common Store for output buffers, in
dwords.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_coeffs</span></code></dt><dd><p>Maximum coefficients, in dwords.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cdm_max_local_mem_size_regs</span></code></dt><dd><p>Maximum amount of local
memory available to a compute kernel, in dwords.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>When fetching this type <a class="reference internal" href="#c.drm_pvr_ioctl_dev_query_args" title="drm_pvr_ioctl_dev_query_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_dev_query_args</span></code></a>.type must be set
to <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_RUNTIME_INFO_GET</span></code>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_dev_query_quirks">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_dev_query_quirks</span></span></span><a class="headerlink" href="#c.drm_pvr_dev_query_quirks" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container used to fetch information about hardware fixes for which the device may require support in the user mode driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_dev_query_quirks {
    __u64 quirks;
    __u16 count;
    __u16 musthave_count;
    __u32 _padding_c;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">quirks</span></code></dt><dd><p>A userspace address for the hardware quirks __u32 array.</p>
<p>The first <strong>musthave_count</strong> items in the list are quirks that the
client must support for this device. If userspace does not support
all these quirks then functionality is not guaranteed and client
initialisation must fail.
The remaining quirks in the list affect userspace and the kernel or
firmware. They are disabled by default and require userspace to
opt-in. The opt-in mechanism depends on the quirk.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Length of <strong>quirks</strong> (number of __u32).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">musthave_count</span></code></dt><dd><p>The number of entries in <strong>quirks</strong> that are
mandatory, starting at index 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_c</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>When fetching this type <a class="reference internal" href="#c.drm_pvr_ioctl_dev_query_args" title="drm_pvr_ioctl_dev_query_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_dev_query_args</span></code></a>.type must be set
to <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_QUIRKS_GET</span></code>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_dev_query_enhancements">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_dev_query_enhancements</span></span></span><a class="headerlink" href="#c.drm_pvr_dev_query_enhancements" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container used to fetch information about optional enhancements supported by the device that require support in the user mode driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_dev_query_enhancements {
    __u64 enhancements;
    __u16 count;
    __u16 _padding_a;
    __u32 _padding_c;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">enhancements</span></code></dt><dd><p>A userspace address for the hardware enhancements
__u32 array.</p>
<p>These enhancements affect userspace and the kernel or firmware. They
are disabled by default and require userspace to opt-in. The opt-in
mechanism depends on the enhancement.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Length of <strong>enhancements</strong> (number of __u32).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_a</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_c</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>When fetching this type <a class="reference internal" href="#c.drm_pvr_ioctl_dev_query_args" title="drm_pvr_ioctl_dev_query_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_dev_query_args</span></code></a>.type must be set
to <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_ENHANCEMENTS_GET</span></code>.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_pvr_heap_id">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_heap_id</span></span></span><a class="headerlink" href="#c.drm_pvr_heap_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>Array index for heap info data returned by <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_HEAP_INFO_GET</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_HEAP_GENERAL</span></code></dt><dd><p>General purpose heap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_HEAP_PDS_CODE_DATA</span></code></dt><dd><p>PDS code and data heap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_HEAP_USC_CODE</span></code></dt><dd><p>USC code heap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_HEAP_RGNHDR</span></code></dt><dd><p>Region header heap. Only used if GPU has BRN63142.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_HEAP_VIS_TEST</span></code></dt><dd><p>Visibility test heap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_HEAP_TRANSFER_FRAG</span></code></dt><dd><p>Transfer fragment heap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_HEAP_COUNT</span></code></dt><dd><p>The number of heaps returned by
<code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_HEAP_INFO_GET</span></code>.</p>
<p>More heaps may be added, so this also serves as the copy limit when
sent by the caller.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>For compatibility reasons all indices will be present in the returned array,
however some heaps may not be present. These are indicated where
<a class="reference internal" href="#c.drm_pvr_heap" title="drm_pvr_heap"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_heap</span></code></a>.size is set to zero.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_heap">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_heap</span></span></span><a class="headerlink" href="#c.drm_pvr_heap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container holding information about a single heap.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_heap {
    __u64 base;
    __u64 size;
    __u32 flags;
    __u32 page_size_log2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base address of heap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of heap, in bytes. Will be 0 if the heap is not present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags for this heap. Currently always 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_size_log2</span></code></dt><dd><p>Log2 of page size.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This will always be fetched as an array.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_dev_query_heap_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_dev_query_heap_info</span></span></span><a class="headerlink" href="#c.drm_pvr_dev_query_heap_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container used to fetch information about heaps supported by the device driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_dev_query_heap_info {
    struct drm_pvr_obj_array heaps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">heaps</span></code></dt><dd><p>Array of <a class="reference internal" href="#c.drm_pvr_heap" title="drm_pvr_heap"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_heap</span></code></a>. If pointer is NULL, the count
and stride will be updated with those known to the driver version, to
facilitate allocation by the caller.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Please note all driver-supported heaps will be returned up to <code class="xref c c-type docutils literal notranslate"><span class="pre">heaps.count</span></code>.
Some heaps will not be present in all devices, which will be indicated by
<a class="reference internal" href="#c.drm_pvr_heap" title="drm_pvr_heap"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_heap</span></code></a>.size being set to zero.</p>
<p>When fetching this type <a class="reference internal" href="#c.drm_pvr_ioctl_dev_query_args" title="drm_pvr_ioctl_dev_query_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_dev_query_args</span></code></a>.type must be set
to <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_HEAP_INFO_GET</span></code>.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_pvr_static_data_area_usage">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_static_data_area_usage</span></span></span><a class="headerlink" href="#c.drm_pvr_static_data_area_usage" title="Link to this definition">¶</a><br /></dt>
<dd><p>Array index for static data area info returned by <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_STATIC_DATA_AREAS_GET</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_STATIC_DATA_AREA_EOT</span></code></dt><dd><p>End of Tile PDS program code segment.</p>
<p>The End of Tile PDS task runs at completion of a tile during a fragment job, and is
responsible for emitting the tile to the Pixel Back End.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_STATIC_DATA_AREA_FENCE</span></code></dt><dd><p>MCU fence area, used during cache flush and
invalidation.</p>
<p>This must point to valid physical memory but the contents otherwise are not used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_STATIC_DATA_AREA_VDM_SYNC</span></code></dt><dd><p>VDM sync program.</p>
<p>The VDM sync program is used to synchronise multiple areas of the GPU hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_STATIC_DATA_AREA_YUV_CSC</span></code></dt><dd><p>YUV coefficients.</p>
<p>Area contains up to 16 slots with stride of 64 bytes. Each is a 3x4 matrix of u16 fixed
point numbers, with 1 sign bit, 2 integer bits and 13 fractional bits.</p>
<p>The slots are :
0 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR
1 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR (full range)
2 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR (conformant range)
3 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR (full range)
4 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR (conformant range)
5 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR (full range)
6 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR (conformant range)
7 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR (full range)
8 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR (conformant range)
9 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR (conformant range, 10 bit)
10 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR (conformant range, 10 bit)
11 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR (conformant range, 10 bit)
14 = Identity (biased)
15 = Identity</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>For compatibility reasons all indices will be present in the returned array,
however some areas may not be present. These are indicated where
<a class="reference internal" href="#c.drm_pvr_static_data_area" title="drm_pvr_static_data_area"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_static_data_area</span></code></a>.size is set to zero.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_static_data_area">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_static_data_area</span></span></span><a class="headerlink" href="#c.drm_pvr_static_data_area" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container holding information about a single static data area.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_static_data_area {
    __u16 area_usage;
    __u16 location_heap_id;
    __u32 size;
    __u64 offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">area_usage</span></code></dt><dd><p>Usage of static data area.
See <a class="reference internal" href="#c.drm_pvr_static_data_area_usage" title="drm_pvr_static_data_area_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_pvr_static_data_area_usage</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">location_heap_id</span></code></dt><dd><p>Array index of heap where this of static data
area is located. This array is fetched using
<code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_HEAP_INFO_GET</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of static data area. Not present if set to zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>Offset of static data area from start of heap.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This will always be fetched as an array.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_dev_query_static_data_areas">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_dev_query_static_data_areas</span></span></span><a class="headerlink" href="#c.drm_pvr_dev_query_static_data_areas" title="Link to this definition">¶</a><br /></dt>
<dd><p>Container used to fetch information about the static data areas in heaps supported by the device driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_dev_query_static_data_areas {
    struct drm_pvr_obj_array static_data_areas;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">static_data_areas</span></code></dt><dd><p>Array of <a class="reference internal" href="#c.drm_pvr_static_data_area" title="drm_pvr_static_data_area"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_static_data_area</span></code></a>. If
pointer is NULL, the count and stride will be updated with those
known to the driver version, to facilitate allocation by the caller.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Please note all driver-supported static data areas will be returned up to
<code class="xref c c-type docutils literal notranslate"><span class="pre">static_data_areas.count</span></code>. Some will not be present for all devices which,
will be indicated by <a class="reference internal" href="#c.drm_pvr_static_data_area" title="drm_pvr_static_data_area"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_static_data_area</span></code></a>.size being set to zero.</p>
<p>Further, some heaps will not be present either. See <a class="reference internal" href="#c.drm_pvr_dev_query_heap_info" title="drm_pvr_dev_query_heap_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_pvr_dev_query_heap_info</span></code></a>.</p>
<p>When fetching this type <a class="reference internal" href="#c.drm_pvr_ioctl_dev_query_args" title="drm_pvr_ioctl_dev_query_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_dev_query_args</span></code></a>.type must be set
to <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_STATIC_DATA_AREAS_GET</span></code>.</p>
</section>
<section id="create-bo">
<h3>CREATE_BO<a class="headerlink" href="#create-bo" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_create_bo_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_create_bo_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_create_bo_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_CREATE_BO</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_create_bo_args {
    __u64 size;
    __u32 handle;
    __u32 _padding_c;
    __u64 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>[IN] Size of buffer object to create. This must be page size
aligned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[OUT] GEM handle of the new buffer object for use in
userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_c</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>[IN] Options which will affect the behaviour of this
creation operation and future mapping operations on the created
object. This field must be a valid combination of <code class="docutils literal notranslate"><span class="pre">DRM_PVR_BO_*</span></code>
values, with all bits marked as reserved set to zero.</p>
</dd>
</dl>
</div>
<p>We use “device” to refer to the GPU here because of the ambiguity between CPU and GPU in some
fonts.</p>
<dl class="simple">
<dt>Device mapping options</dt><dd><dl class="field-list simple">
<dt class="field-odd">DRM_PVR_BO_BYPASS_DEVICE_CACHE<span class="colon">:</span></dt>
<dd class="field-odd"><p>Specify that device accesses to this memory will bypass the
cache. This is used for buffers that will either be regularly updated by the CPU (eg free
lists) or will be accessed only once and therefore isn’t worth caching (eg partial render
buffers).
By default, the device flushes its memory caches after every job, so this is not normally
required for coherency.</p>
</dd>
<dt class="field-even">DRM_PVR_BO_PM_FW_PROTECT<span class="colon">:</span></dt>
<dd class="field-even"><p>Specify that only the Parameter Manager (PM) and/or firmware
processor should be allowed to access this memory when mapped to the device. It is not
valid to specify this flag with DRM_PVR_BO_ALLOW_CPU_USERSPACE_ACCESS.</p>
</dd>
</dl>
</dd>
<dt>CPU mapping options</dt><dd><dl class="field-list simple">
<dt class="field-odd">DRM_PVR_BO_ALLOW_CPU_USERSPACE_ACCESS<span class="colon">:</span></dt>
<dd class="field-odd"><p>Allow userspace to map and access the contents of this
memory. It is not valid to specify this flag with DRM_PVR_BO_PM_FW_PROTECT.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="get-bo-mmap-offset">
<h3>GET_BO_MMAP_OFFSET<a class="headerlink" href="#get-bo-mmap-offset" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_get_bo_mmap_offset_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_get_bo_mmap_offset_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_get_bo_mmap_offset_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_GET_BO_MMAP_OFFSET</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_get_bo_mmap_offset_args {
    __u32 handle;
    __u32 _padding_4;
    __u64 offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[IN] GEM handle of the buffer object to be mapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_4</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>[OUT] Fake offset to use in the real mmap call.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Like other DRM drivers, the “mmap” IOCTL doesn’t actually map any memory.
Instead, it allocates a fake offset which refers to the specified buffer
object. This offset can be used with a real mmap call on the DRM device
itself.</p>
</section>
<section id="create-vm-context-and-destroy-vm-context">
<h3>CREATE_VM_CONTEXT and DESTROY_VM_CONTEXT<a class="headerlink" href="#create-vm-context-and-destroy-vm-context" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_create_vm_context_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_create_vm_context_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_create_vm_context_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_CREATE_VM_CONTEXT</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_create_vm_context_args {
    __u32 handle;
    __u32 _padding_4;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[OUT] Handle for new VM context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_4</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_destroy_vm_context_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_destroy_vm_context_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_destroy_vm_context_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_DESTROY_VM_CONTEXT</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_destroy_vm_context_args {
    __u32 handle;
    __u32 _padding_4;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[IN] Handle for VM context to be destroyed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_4</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
</dl>
</div>
</section>
<section id="vm-map-and-vm-unmap">
<h3>VM_MAP and VM_UNMAP<a class="headerlink" href="#vm-map-and-vm-unmap" title="Link to this heading">¶</a></h3>
<p>The VM UAPI allows userspace to create buffer object mappings in GPU virtual address space.</p>
<p>The client is responsible for managing GPU address space. It should allocate mappings within
the heaps returned by <code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_HEAP_INFO_GET</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_VM_MAP</span></code> creates a new mapping. The client provides the target virtual address for
the mapping. Size and offset within the mapped buffer object can be specified, so the client can
partially map a buffer.</p>
<p><code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_VM_UNMAP</span></code> removes a mapping. The entire mapping will be removed from GPU address
space only if the size of the mapping matches that known to the driver.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_vm_map_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_vm_map_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_vm_map_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_VM_MAP</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_vm_map_args {
    __u32 vm_context_handle;
    __u32 flags;
    __u64 device_addr;
    __u32 handle;
    __u32 _padding_14;
    __u64 offset;
    __u64 size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vm_context_handle</span></code></dt><dd><p>[IN] Handle for VM context for this mapping to
exist in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>[IN] Flags which affect this mapping. Currently always 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_addr</span></code></dt><dd><p>[IN] Requested device-virtual address for the mapping.
This must be non-zero and aligned to the device page size for the
heap containing the requested address. It is an error to specify an
address which is not contained within one of the heaps returned by
<code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_HEAP_INFO_GET</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[IN] Handle of the target buffer object. This must be a
valid handle returned by <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_CREATE_BO</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_14</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>[IN] Offset into the target bo from which to begin the
mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>[IN] Size of the requested mapping. Must be aligned to
the device page size for the heap containing the requested address,
as well as the host page size. When added to <strong>device_addr</strong>, the
result must not overflow the heap which contains <strong>device_addr</strong> (i.e.
the range specified by <strong>device_addr</strong> and <strong>size</strong> must be completely
contained within a single heap specified by
<code class="docutils literal notranslate"><span class="pre">DRM_PVR_DEV_QUERY_HEAP_INFO_GET</span></code>).</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_vm_unmap_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_vm_unmap_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_vm_unmap_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_VM_UNMAP</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_vm_unmap_args {
    __u32 vm_context_handle;
    __u32 _padding_4;
    __u64 device_addr;
    __u64 size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vm_context_handle</span></code></dt><dd><p>[IN] Handle for VM context that this mapping
exists in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_4</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_addr</span></code></dt><dd><p>[IN] Device-virtual address at the start of the target
mapping. This must be non-zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size in bytes of the target mapping. This must be non-zero.</p>
</dd>
</dl>
</div>
</section>
<section id="create-context-and-destroy-context">
<h3>CREATE_CONTEXT and DESTROY_CONTEXT<a class="headerlink" href="#create-context-and-destroy-context" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_create_context_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_create_context_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_create_context_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_CREATE_CONTEXT</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_create_context_args {
    __u32 type;
    __u32 flags;
    __s32 priority;
    __u32 handle;
    __u64 static_context_state;
    __u32 static_context_state_len;
    __u32 vm_context_handle;
    __u64 callstack_addr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>[IN] Type of context to create.</p>
<p>This must be one of the values defined by <a class="reference internal" href="#c.drm_pvr_ctx_type" title="drm_pvr_ctx_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_pvr_ctx_type</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>[IN] Flags for context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt><dd><p>[IN] Priority of new context.</p>
<p>This must be one of the values defined by <a class="reference internal" href="#c.drm_pvr_ctx_priority" title="drm_pvr_ctx_priority"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_pvr_ctx_priority</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[OUT] Handle for new context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static_context_state</span></code></dt><dd><p>[IN] Pointer to static context state stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static_context_state_len</span></code></dt><dd><p>[IN] Length of static context state, in bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_context_handle</span></code></dt><dd><p>[IN] Handle for VM context that this context is
associated with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">callstack_addr</span></code></dt><dd><p>[IN] Address for initial call stack pointer. Only valid
if <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">DRM_PVR_CTX_TYPE_RENDER</span></code>, otherwise must be 0.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_pvr_ctx_priority">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ctx_priority</span></span></span><a class="headerlink" href="#c.drm_pvr_ctx_priority" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <a class="reference internal" href="#c.drm_pvr_ioctl_create_context_args" title="drm_pvr_ioctl_create_context_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_pvr_ioctl_create_context_args.priority</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_CTX_PRIORITY_LOW</span></code></dt><dd><p>Priority below normal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_CTX_PRIORITY_NORMAL</span></code></dt><dd><p>Normal priority.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_CTX_PRIORITY_HIGH</span></code></dt><dd><p>Priority above normal.
Note this requires <code class="docutils literal notranslate"><span class="pre">CAP_SYS_NICE</span></code> or <code class="docutils literal notranslate"><span class="pre">DRM_MASTER</span></code>.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_pvr_ctx_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ctx_type</span></span></span><a class="headerlink" href="#c.drm_pvr_ctx_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <a class="reference internal" href="#c.drm_pvr_ioctl_create_context_args" title="drm_pvr_ioctl_create_context_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_create_context_args</span></code></a>.type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_CTX_TYPE_RENDER</span></code></dt><dd><p>Render context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_CTX_TYPE_COMPUTE</span></code></dt><dd><p>Compute context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_CTX_TYPE_TRANSFER_FRAG</span></code></dt><dd><p>Transfer context for fragment data
master.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_destroy_context_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_destroy_context_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_destroy_context_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_DESTROY_CONTEXT</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_destroy_context_args {
    __u32 handle;
    __u32 _padding_4;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[IN] Handle for context to be destroyed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_4</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
</dl>
</div>
</section>
<section id="create-free-list-and-destroy-free-list">
<h3>CREATE_FREE_LIST and DESTROY_FREE_LIST<a class="headerlink" href="#create-free-list-and-destroy-free-list" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_create_free_list_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_create_free_list_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_create_free_list_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_CREATE_FREE_LIST</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_create_free_list_args {
    __u64 free_list_gpu_addr;
    __u32 initial_num_pages;
    __u32 max_num_pages;
    __u32 grow_num_pages;
    __u32 grow_threshold;
    __u32 vm_context_handle;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">free_list_gpu_addr</span></code></dt><dd><p>[IN] Address of GPU mapping of buffer object
containing memory to be used by free list.</p>
<p>The mapped region of the buffer object must be at least
<strong>max_num_pages</strong> * <code class="docutils literal notranslate"><span class="pre">sizeof(__u32)</span></code>.</p>
<p>The buffer object must have been created with
<code class="docutils literal notranslate"><span class="pre">DRM_PVR_BO_DEVICE_PM_FW_PROTECT</span></code> set and
<code class="docutils literal notranslate"><span class="pre">DRM_PVR_BO_CPU_ALLOW_USERSPACE_ACCESS</span></code> not set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_num_pages</span></code></dt><dd><p>[IN] Pages initially allocated to free list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_num_pages</span></code></dt><dd><p>[IN] Maximum number of pages in free list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grow_num_pages</span></code></dt><dd><p>[IN] Pages to grow free list by per request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grow_threshold</span></code></dt><dd><p>[IN] Percentage of FL memory used that should
trigger a new grow request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_context_handle</span></code></dt><dd><p>[IN] Handle for VM context that the free list buffer
object is mapped in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[OUT] Handle for created free list.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Free list arguments have the following constraints :</p>
<ul class="simple">
<li><p><strong>max_num_pages</strong> must be greater than zero.</p></li>
<li><p><strong>grow_threshold</strong> must be between 0 and 100.</p></li>
<li><p><strong>grow_num_pages</strong> must be less than or equal to <code class="xref c c-type docutils literal notranslate"><span class="pre">max_num_pages</span></code>.</p></li>
<li><p><strong>initial_num_pages</strong>, <strong>max_num_pages</strong> and <strong>grow_num_pages</strong> must be multiples
of 4.</p></li>
<li><p>When <code class="xref c c-type docutils literal notranslate"><span class="pre">grow_num_pages</span></code> is 0, <strong>initial_num_pages</strong> must be equal to
<strong>max_num_pages</strong>.</p></li>
<li><p>When <code class="xref c c-type docutils literal notranslate"><span class="pre">grow_num_pages</span></code> is non-zero, <strong>initial_num_pages</strong> must be less than
<strong>max_num_pages</strong>.</p></li>
</ul>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_destroy_free_list_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_destroy_free_list_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_destroy_free_list_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_DESTROY_FREE_LIST</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_destroy_free_list_args {
    __u32 handle;
    __u32 _padding_4;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[IN] Handle for free list to be destroyed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_4</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
</dl>
</div>
</section>
<section id="create-hwrt-dataset-and-destroy-hwrt-dataset">
<h3>CREATE_HWRT_DATASET and DESTROY_HWRT_DATASET<a class="headerlink" href="#create-hwrt-dataset-and-destroy-hwrt-dataset" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_create_hwrt_dataset_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_create_hwrt_dataset_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_create_hwrt_dataset_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_CREATE_HWRT_DATASET</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_create_hwrt_dataset_args {
    struct drm_pvr_create_hwrt_geom_data_args geom_data_args;
    struct drm_pvr_create_hwrt_rt_data_args rt_data_args[2];
    __u32 free_list_handles[2];
    __u32 width;
    __u32 height;
    __u32 samples;
    __u32 layers;
    __u32 isp_merge_lower_x;
    __u32 isp_merge_lower_y;
    __u32 isp_merge_scale_x;
    __u32 isp_merge_scale_y;
    __u32 isp_merge_upper_x;
    __u32 isp_merge_upper_y;
    __u32 region_header_size;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">geom_data_args</span></code></dt><dd><p>[IN] Geometry data arguments.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rt_data_args</span></code></dt><dd><p>[IN] Array of render target arguments.</p>
<p>Each entry in this array represents a render target in a double buffered
setup.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_list_handles</span></code></dt><dd><p>[IN] Array of free list handles.</p>
<p>free_list_handles[PVR_DRM_HWRT_FREE_LIST_LOCAL] must have initial
size of at least that reported by
<a class="reference internal" href="#c.drm_pvr_dev_query_runtime_info" title="drm_pvr_dev_query_runtime_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_pvr_dev_query_runtime_info.free_list_min_pages</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>[IN] Width in pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>[IN] Height in pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">samples</span></code></dt><dd><p>[IN] Number of samples.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layers</span></code></dt><dd><p>[IN] Number of layers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isp_merge_lower_x</span></code></dt><dd><p>[IN] Lower X coefficient for triangle merging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isp_merge_lower_y</span></code></dt><dd><p>[IN] Lower Y coefficient for triangle merging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isp_merge_scale_x</span></code></dt><dd><p>[IN] Scale X coefficient for triangle merging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isp_merge_scale_y</span></code></dt><dd><p>[IN] Scale Y coefficient for triangle merging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isp_merge_upper_x</span></code></dt><dd><p>[IN] Upper X coefficient for triangle merging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isp_merge_upper_y</span></code></dt><dd><p>[IN] Upper Y coefficient for triangle merging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">region_header_size</span></code></dt><dd><p>[IN] Size of region header array. This common field is used by
both render targets in this data set.</p>
<p>The units for this field differ depending on what version of the simple internal
parameter format the device uses. If format 2 is in use then this is interpreted as the
number of region headers. For other formats it is interpreted as the size in dwords.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[OUT] Handle for created HWRT dataset.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_create_hwrt_geom_data_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_create_hwrt_geom_data_args</span></span></span><a class="headerlink" href="#c.drm_pvr_create_hwrt_geom_data_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Geometry data arguments used for <a class="reference internal" href="#c.drm_pvr_ioctl_create_hwrt_dataset_args" title="drm_pvr_ioctl_create_hwrt_dataset_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_create_hwrt_dataset_args</span></code></a>.geom_data_args.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_create_hwrt_geom_data_args {
    __u64 tpc_dev_addr;
    __u32 tpc_size;
    __u32 tpc_stride;
    __u64 vheap_table_dev_addr;
    __u64 rtc_dev_addr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpc_dev_addr</span></code></dt><dd><p>[IN] Tail pointer cache GPU virtual address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tpc_size</span></code></dt><dd><p>[IN] Size of TPC, in bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tpc_stride</span></code></dt><dd><p>[IN] Stride between layers in TPC, in pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vheap_table_dev_addr</span></code></dt><dd><p>[IN] VHEAP table GPU virtual address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtc_dev_addr</span></code></dt><dd><p>[IN] Render Target Cache virtual address.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_create_hwrt_rt_data_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_create_hwrt_rt_data_args</span></span></span><a class="headerlink" href="#c.drm_pvr_create_hwrt_rt_data_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Render target arguments used for <a class="reference internal" href="#c.drm_pvr_ioctl_create_hwrt_dataset_args" title="drm_pvr_ioctl_create_hwrt_dataset_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_ioctl_create_hwrt_dataset_args</span></code></a>.rt_data_args.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_create_hwrt_rt_data_args {
    __u64 pm_mlist_dev_addr;
    __u64 macrotile_array_dev_addr;
    __u64 region_header_dev_addr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pm_mlist_dev_addr</span></code></dt><dd><p>[IN] PM MLIST GPU virtual address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">macrotile_array_dev_addr</span></code></dt><dd><p>[IN] Macrotile array GPU virtual address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">region_header_dev_addr</span></code></dt><dd><p>[IN] Region header array GPU virtual address.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_destroy_hwrt_dataset_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_destroy_hwrt_dataset_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_destroy_hwrt_dataset_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_DESTROY_HWRT_DATASET</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_destroy_hwrt_dataset_args {
    __u32 handle;
    __u32 _padding_4;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>[IN] Handle for HWRT dataset to be destroyed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_padding_4</span></code></dt><dd><p>Reserved. This field must be zeroed.</p>
</dd>
</dl>
</div>
</section>
<section id="submit-jobs">
<h3>SUBMIT_JOBS<a class="headerlink" href="#submit-jobs" title="Link to this heading">¶</a></h3>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SYNC_OP_HANDLE_TYPE_MASK">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SYNC_OP_HANDLE_TYPE_MASK</span></span></span><a class="headerlink" href="#c.DRM_PVR_SYNC_OP_HANDLE_TYPE_MASK" title="Link to this definition">¶</a><br /></dt>
<dd><p>Handle type mask for the drm_pvr_sync_op::flags field.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SYNC_OP_FLAG_HANDLE_TYPE_SYNCOBJ">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SYNC_OP_FLAG_HANDLE_TYPE_SYNCOBJ</span></span></span><a class="headerlink" href="#c.DRM_PVR_SYNC_OP_FLAG_HANDLE_TYPE_SYNCOBJ" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicates the handle passed in drm_pvr_sync_op::handle is a syncobj handle.
This is the default type.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SYNC_OP_FLAG_HANDLE_TYPE_TIMELINE_SYNCOBJ">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SYNC_OP_FLAG_HANDLE_TYPE_TIMELINE_SYNCOBJ</span></span></span><a class="headerlink" href="#c.DRM_PVR_SYNC_OP_FLAG_HANDLE_TYPE_TIMELINE_SYNCOBJ" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicates the handle passed in drm_pvr_sync_op::handle is a timeline syncobj handle.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SYNC_OP_FLAG_SIGNAL">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SYNC_OP_FLAG_SIGNAL</span></span></span><a class="headerlink" href="#c.DRM_PVR_SYNC_OP_FLAG_SIGNAL" title="Link to this definition">¶</a><br /></dt>
<dd><p>Signal operation requested. The out-fence bound to the job will be attached to
the syncobj whose handle is passed in drm_pvr_sync_op::handle.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SYNC_OP_FLAG_WAIT">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SYNC_OP_FLAG_WAIT</span></span></span><a class="headerlink" href="#c.DRM_PVR_SYNC_OP_FLAG_WAIT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait operation requested. The job will wait for this particular syncobj or syncobj
point to be signaled before being started.
This is the default operation.</p>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_ioctl_submit_jobs_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_ioctl_submit_jobs_args</span></span></span><a class="headerlink" href="#c.drm_pvr_ioctl_submit_jobs_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_SUBMIT_JOB</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_ioctl_submit_jobs_args {
    struct drm_pvr_obj_array jobs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">jobs</span></code></dt><dd><p>[IN] Array of jobs to submit.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If the syscall returns an error it is important to check the value of
<strong>jobs.count</strong>. This indicates the index into <strong>jobs.array</strong> where the
error occurred.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_GEOM_CMD_FIRST">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_GEOM_CMD_FIRST</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_GEOM_CMD_FIRST" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicates if this the first command to be issued for a render.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_GEOM_CMD_LAST">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_GEOM_CMD_LAST</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_GEOM_CMD_LAST" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicates if this the last command to be issued for a render.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_GEOM_CMD_SINGLE_CORE">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_GEOM_CMD_SINGLE_CORE</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_GEOM_CMD_SINGLE_CORE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Forces to use single core in a multi core device.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_GEOM_CMD_FLAGS_MASK">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_GEOM_CMD_FLAGS_MASK</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_GEOM_CMD_FLAGS_MASK" title="Link to this definition">¶</a><br /></dt>
<dd><p>Logical OR of all the geometry cmd flags.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_SINGLE_CORE">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_FRAG_CMD_SINGLE_CORE</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_SINGLE_CORE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Use single core in a multi core setup.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_DEPTHBUFFER">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_FRAG_CMD_DEPTHBUFFER</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_DEPTHBUFFER" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicates whether a depth buffer is present.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_STENCILBUFFER">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_FRAG_CMD_STENCILBUFFER</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_STENCILBUFFER" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicates whether a stencil buffer is present.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_PREVENT_CDM_OVERLAP">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_FRAG_CMD_PREVENT_CDM_OVERLAP</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_PREVENT_CDM_OVERLAP" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disallow compute overlapped with this render.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_GET_VIS_RESULTS">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_FRAG_CMD_GET_VIS_RESULTS</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_GET_VIS_RESULTS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicates whether this render produces visibility results.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_SCRATCHBUFFER">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_FRAG_CMD_SCRATCHBUFFER</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_SCRATCHBUFFER" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicates whether partial renders write to a scratch buffer instead of
the final surface. It also forces the full screen copy expected to be
present on the last render after all partial renders have completed.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_DISABLE_PIXELMERGE">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_FRAG_CMD_DISABLE_PIXELMERGE</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_DISABLE_PIXELMERGE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disable pixel merging for this render.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_FLAGS_MASK">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_FRAG_CMD_FLAGS_MASK</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_FRAG_CMD_FLAGS_MASK" title="Link to this definition">¶</a><br /></dt>
<dd><p>Logical OR of all the fragment cmd flags.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_PREVENT_ALL_OVERLAP">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_PREVENT_ALL_OVERLAP</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_PREVENT_ALL_OVERLAP" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disallow other jobs overlapped with this compute.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_SINGLE_CORE">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_SINGLE_CORE</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_SINGLE_CORE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Forces to use single core in a multi core device.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_FLAGS_MASK">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_FLAGS_MASK</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_COMPUTE_CMD_FLAGS_MASK" title="Link to this definition">¶</a><br /></dt>
<dd><p>Logical OR of all the compute cmd flags.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_TRANSFER_CMD_SINGLE_CORE">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_TRANSFER_CMD_SINGLE_CORE</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_TRANSFER_CMD_SINGLE_CORE" title="Link to this definition">¶</a><br /></dt>
<dd><p>Forces job to use a single core in a multi core device.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_PVR_SUBMIT_JOB_TRANSFER_CMD_FLAGS_MASK">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_PVR_SUBMIT_JOB_TRANSFER_CMD_FLAGS_MASK</span></span></span><a class="headerlink" href="#c.DRM_PVR_SUBMIT_JOB_TRANSFER_CMD_FLAGS_MASK" title="Link to this definition">¶</a><br /></dt>
<dd><p>Logical OR of all the transfer cmd flags.</p>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_sync_op">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_sync_op</span></span></span><a class="headerlink" href="#c.drm_pvr_sync_op" title="Link to this definition">¶</a><br /></dt>
<dd><p>Object describing a sync operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_sync_op {
    __u32 handle;
    __u32 flags;
    __u64 value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle of sync object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <code class="docutils literal notranslate"><span class="pre">DRM_PVR_SYNC_OP_FLAG_</span></code> flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>Timeline value for this drm_syncobj. MBZ for a binary syncobj.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_pvr_job_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_job_type</span></span></span><a class="headerlink" href="#c.drm_pvr_job_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for <a class="reference internal" href="#c.drm_pvr_job" title="drm_pvr_job"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pvr_job</span></code></a>.job_type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_JOB_TYPE_GEOMETRY</span></code></dt><dd><p>Job type is geometry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_JOB_TYPE_FRAGMENT</span></code></dt><dd><p>Job type is fragment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_JOB_TYPE_COMPUTE</span></code></dt><dd><p>Job type is compute.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_PVR_JOB_TYPE_TRANSFER_FRAG</span></code></dt><dd><p>Job type is a fragment transfer.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_hwrt_data_ref">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_hwrt_data_ref</span></span></span><a class="headerlink" href="#c.drm_pvr_hwrt_data_ref" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reference HWRT data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_hwrt_data_ref {
    __u32 set_handle;
    __u32 data_index;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">set_handle</span></code></dt><dd><p>HWRT data set handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_index</span></code></dt><dd><p>Index of the HWRT data inside the data set.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_pvr_job">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_pvr_job</span></span></span><a class="headerlink" href="#c.drm_pvr_job" title="Link to this definition">¶</a><br /></dt>
<dd><p>Job arguments passed to the <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_SUBMIT_JOBS</span></code> ioctl</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_pvr_job {
    __u32 type;
    __u32 context_handle;
    __u32 flags;
    __u32 cmd_stream_len;
    __u64 cmd_stream;
    struct drm_pvr_obj_array sync_ops;
    struct drm_pvr_hwrt_data_ref hwrt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>[IN] Type of job being submitted</p>
<p>This must be one of the values defined by <a class="reference internal" href="#c.drm_pvr_job_type" title="drm_pvr_job_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_pvr_job_type</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context_handle</span></code></dt><dd><p>[IN] Context handle.</p>
<p>When <strong>job_type</strong> is <code class="docutils literal notranslate"><span class="pre">DRM_PVR_JOB_TYPE_RENDER</span></code>, <code class="docutils literal notranslate"><span class="pre">DRM_PVR_JOB_TYPE_COMPUTE</span></code> or
<code class="docutils literal notranslate"><span class="pre">DRM_PVR_JOB_TYPE_TRANSFER_FRAG</span></code>, this must be a valid handle returned by
<code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_PVR_CREATE_CONTEXT</span></code>. The type of context must be compatible
with the type of job being submitted.</p>
<p>When <strong>job_type</strong> is <code class="docutils literal notranslate"><span class="pre">DRM_PVR_JOB_TYPE_NULL</span></code>, this must be zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>[IN] Flags for command.</p>
<p>Those are job-dependent. See all <code class="docutils literal notranslate"><span class="pre">DRM_PVR_SUBMIT_JOB_*</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd_stream_len</span></code></dt><dd><p>[IN] Length of command stream, in bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd_stream</span></code></dt><dd><p>[IN] Pointer to command stream for command.</p>
<p>The command stream must be u64-aligned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync_ops</span></code></dt><dd><p>[IN] Fragment sync operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwrt</span></code></dt><dd><p>[IN] HWRT data used by render jobs (geometry or fragment).</p>
<p>Must be zero for non-render jobs.</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="internal-notes">
<h2>Internal notes<a class="headerlink" href="#internal-notes" title="Link to this heading">¶</a></h2>
<p>To validate the constraints imposed on IOCTL argument structs, a collection
of macros and helper functions exist in <code class="docutils literal notranslate"><span class="pre">pvr_device.h</span></code>.</p>
<p>Of the current helpers, it should only be necessary to call
<a class="reference internal" href="#c.PVR_IOCTL_UNION_PADDING_CHECK" title="PVR_IOCTL_UNION_PADDING_CHECK"><code class="xref c c-func docutils literal notranslate"><span class="pre">PVR_IOCTL_UNION_PADDING_CHECK()</span></code></a> directly. This macro should be used once in
every code path which extracts a union member from a struct passed from
userspace.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.pvr_ioctl_union_padding_check">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pvr_ioctl_union_padding_check</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">instance</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">union_offset</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">union_size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">member_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pvr_ioctl_union_padding_check" title="Link to this definition">¶</a><br /></dt>
<dd><p>Validate that the implicit padding between the end of a union member and the end of the union itself is zeroed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*instance</span></code></dt><dd><p>Pointer to the instance of the struct to validate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">union_offset</span></code></dt><dd><p>Offset into the type of <strong>instance</strong> of the target union. Must
be 64-bit aligned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">union_size</span></code></dt><dd><p>Size of the target union in the type of <strong>instance</strong>. Must be
64-bit aligned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">member_size</span></code></dt><dd><p>Size of the target member in the target union specified by
<strong>union_offset</strong> and <strong>union_size</strong>. It is assumed that the offset of the target
member is zero relative to <strong>union_offset</strong>. Must be 64-bit aligned.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>You probably want to use <a class="reference internal" href="#c.PVR_IOCTL_UNION_PADDING_CHECK" title="PVR_IOCTL_UNION_PADDING_CHECK"><code class="xref c c-func docutils literal notranslate"><span class="pre">PVR_IOCTL_UNION_PADDING_CHECK()</span></code></a> instead of calling
this function directly, since that macro abstracts away much of the setup,
and also provides some static validation. See its docs for details.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if every byte between the end of the used member of the union and
the end of that union is zeroed, or</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p></li>
</ul>
</div></blockquote>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PVR_STATIC_ASSERT_64BIT_ALIGNED">
<span class="sig-name descname"><span class="n"><span class="pre">PVR_STATIC_ASSERT_64BIT_ALIGNED</span></span></span><a class="headerlink" href="#c.PVR_STATIC_ASSERT_64BIT_ALIGNED" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">PVR_STATIC_ASSERT_64BIT_ALIGNED</span> <span class="pre">(static_expr_)</span></code></p>
<blockquote>
<div><p>Inline assertion for 64-bit alignment.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">static_expr_</span></code></dt><dd><p>Target expression to evaluate.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>static_expr_</strong> does not evaluate to a constant integer which would be a
64-bit aligned address (i.e. a multiple of 8), compilation will fail.</p>
<p><strong>Return</strong></p>
<p>The value of <strong>static_expr_</strong>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PVR_IOCTL_UNION_PADDING_CHECK">
<span class="sig-name descname"><span class="n"><span class="pre">PVR_IOCTL_UNION_PADDING_CHECK</span></span></span><a class="headerlink" href="#c.PVR_IOCTL_UNION_PADDING_CHECK" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">PVR_IOCTL_UNION_PADDING_CHECK</span> <span class="pre">(struct_instance_,</span> <span class="pre">union_,</span> <span class="pre">member_)</span></code></p>
<blockquote>
<div><p>Validate that the implicit padding between the end of a union member and the end of the union itself is zeroed.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct_instance_</span></code></dt><dd><p>An expression which evaluates to a pointer to a UAPI data
struct.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union_</span></code></dt><dd><p>The name of the union member of <strong>struct_instance_</strong> to check. If the
union member is nested within the type of <strong>struct_instance_</strong>, this may
contain the member access operator (“.”).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member_</span></code></dt><dd><p>The name of the member of <strong>union_</strong> to assess.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a wrapper around <a class="reference internal" href="#c.pvr_ioctl_union_padding_check" title="pvr_ioctl_union_padding_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">pvr_ioctl_union_padding_check()</span></code></a> which performs
alignment checks and simplifies things for the caller.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if every byte in <strong>struct_instance_</strong> between the end of <strong>member_</strong> and
the end of <strong>union_</strong> is zeroed, or</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p></li>
</ul>
</div></blockquote>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/gpu/imagination/uapi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>