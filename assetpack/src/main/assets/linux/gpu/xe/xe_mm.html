<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Memory Management &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Map Layer" href="xe_map.html" />
    <link rel="prev" title="drm/xe Intel GFX Driver" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../input/index.html">Input Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/gpu/xe/xe_mm.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="memory-management">
<h1>Memory Management<a class="headerlink" href="#memory-management" title="Link to this heading">¶</a></h1>
<section id="bo-management">
<h2>BO management<a class="headerlink" href="#bo-management" title="Link to this heading">¶</a></h2>
<p>TTM manages (placement, eviction, etc...) all BOs in XE.</p>
</section>
<section id="bo-creation">
<h2>BO creation<a class="headerlink" href="#bo-creation" title="Link to this heading">¶</a></h2>
<p>Create a chunk of memory which can be used by the GPU. Placement rules
(sysmem or vram region) passed in upon creation. TTM handles placement of BO
and can trigger eviction of other BOs to make space for the new BO.</p>
<section id="kernel-bos">
<h3>Kernel BOs<a class="headerlink" href="#kernel-bos" title="Link to this heading">¶</a></h3>
<p>A kernel BO is created as part of driver load (e.g. uC firmware images, GuC
ADS, etc...) or a BO created as part of a user operation which requires
a kernel BO (e.g. engine state, memory for page tables, etc...). These BOs
are typically mapped in the GGTT (any kernel BOs aside memory for page tables
are in the GGTT), are pinned (can’t move or be evicted at runtime), have a
vmap (XE can access the memory via xe_map layer) and have contiguous physical
memory.</p>
<p>More details of why kernel BOs are pinned and contiguous below.</p>
</section>
<section id="user-bos">
<h3>User BOs<a class="headerlink" href="#user-bos" title="Link to this heading">¶</a></h3>
<p>A user BO is created via the DRM_IOCTL_XE_GEM_CREATE IOCTL. Once it is
created the BO can be mmap’d (via DRM_IOCTL_XE_GEM_MMAP_OFFSET) for user
access and it can be bound for GPU access (via DRM_IOCTL_XE_VM_BIND). All
user BOs are evictable and user BOs are never pinned by XE. The allocation of
the backing store can be deferred from creation time until first use which is
either mmap, bind, or pagefault.</p>
<section id="private-bos">
<h4>Private BOs<a class="headerlink" href="#private-bos" title="Link to this heading">¶</a></h4>
<p>A private BO is a user BO created with a valid VM argument passed into the
create IOCTL. If a BO is private it cannot be exported via prime FD and
mappings can only be created for the BO within the VM it is tied to. Lastly,
the BO dma-resv slots / lock point to the VM’s dma-resv slots / lock (all
private BOs to a VM share common dma-resv slots / lock).</p>
</section>
<section id="external-bos">
<h4>External BOs<a class="headerlink" href="#external-bos" title="Link to this heading">¶</a></h4>
<p>An external BO is a user BO created with a NULL VM argument passed into the
create IOCTL. An external BO can be shared with different UMDs / devices via
prime FD and the BO can be mapped into multiple VMs. An external BO has its
own unique dma-resv slots / lock. An external BO will be in an array of all
VMs which has a mapping of the BO. This allows VMs to lookup and lock all
external BOs mapped in the VM as needed.</p>
</section>
<section id="bo-placement">
<h4>BO placement<a class="headerlink" href="#bo-placement" title="Link to this heading">¶</a></h4>
<p>When a user BO is created, a mask of valid placements is passed indicating
which memory regions are considered valid.</p>
<p>The memory region information is available via query uAPI (TODO: add link).</p>
</section>
</section>
</section>
<section id="bo-validation">
<h2>BO validation<a class="headerlink" href="#bo-validation" title="Link to this heading">¶</a></h2>
<p>BO validation (ttm_bo_validate) refers to ensuring a BO has a valid
placement. If a BO was swapped to temporary storage, a validation call will
trigger a move back to a valid (location where GPU can access BO) placement.
Validation of a BO may evict other BOs to make room for the BO being
validated.</p>
</section>
<section id="bo-eviction-moving">
<h2>BO eviction / moving<a class="headerlink" href="#bo-eviction-moving" title="Link to this heading">¶</a></h2>
<p>All eviction (or in other words, moving a BO from one memory location to
another) is routed through TTM with a callback into XE.</p>
<section id="runtime-eviction">
<h3>Runtime eviction<a class="headerlink" href="#runtime-eviction" title="Link to this heading">¶</a></h3>
<p>Runtime evictions refers to during normal operations where TTM decides it
needs to move a BO. Typically this is because TTM needs to make room for
another BO and the evicted BO is first BO on LRU list that is not locked.</p>
<p>An example of this is a new BO which can only be placed in VRAM but there is
not space in VRAM. There could be multiple BOs which have sysmem and VRAM
placement rules which currently reside in VRAM, TTM trigger a will move of
one (or multiple) of these BO(s) until there is room in VRAM to place the new
BO. The evicted BO(s) are valid but still need new bindings before the BO
used again (exec or compute mode rebind worker).</p>
<p>Another example would be, TTM can’t find a BO to evict which has another
valid placement. In this case TTM will evict one (or multiple) unlocked BO(s)
to a temporary unreachable (invalid) placement. The evicted BO(s) are invalid
and before next use need to be moved to a valid placement and rebound.</p>
<p>In both cases, moves of these BOs are scheduled behind the fences in the BO’s
dma-resv slots.</p>
<p>WW locking tries to ensures if 2 VMs use 51% of the memory forward progress
is made on both VMs.</p>
<p>Runtime eviction uses per a GT migration engine (TODO: link to migration
engine doc) to do a GPU memcpy from one location to another.</p>
</section>
<section id="rebinds-after-runtime-eviction">
<h3>Rebinds after runtime eviction<a class="headerlink" href="#rebinds-after-runtime-eviction" title="Link to this heading">¶</a></h3>
<p>When BOs are moved, every mapping (VMA) of the BO needs to rebound before
the BO is used again. Every VMA is added to an evicted list of its VM when
the BO is moved. This is safe because of the VM locking structure (TODO: link
to VM locking doc). On the next use of a VM (exec or compute mode rebind
worker) the evicted VMA list is checked and rebinds are triggered. In the
case of faulting VM, the rebind is done in the page fault handler.</p>
</section>
<section id="suspend-resume-eviction-of-vram">
<h3>Suspend / resume eviction of VRAM<a class="headerlink" href="#suspend-resume-eviction-of-vram" title="Link to this heading">¶</a></h3>
<p>During device suspend / resume VRAM may lose power which means the contents
of VRAM’s memory is blown away. Thus BOs present in VRAM at the time of
suspend must be moved to sysmem in order for their contents to be saved.</p>
<p>A simple TTM call (ttm_resource_manager_evict_all) can move all non-pinned
(user) BOs to sysmem. External BOs that are pinned need to be manually
evicted with a simple loop + xe_bo_evict call. It gets a little trickier
with kernel BOs.</p>
<p>Some kernel BOs are used by the GT migration engine to do moves, thus we
can’t move all of the BOs via the GT migration engine. For simplity, use a
TTM memcpy (CPU) to move any kernel (pinned) BO on either suspend or resume.</p>
<p>Some kernel BOs need to be restored to the exact same physical location. TTM
makes this rather easy but the caveat is the memory must be contiguous. Again
for simplity, we enforce that all kernel (pinned) BOs are contiguous and
restored to the same physical location.</p>
<p>Pinned external BOs in VRAM are restored on resume via the GPU.</p>
</section>
<section id="rebinds-after-suspend-resume">
<h3>Rebinds after suspend / resume<a class="headerlink" href="#rebinds-after-suspend-resume" title="Link to this heading">¶</a></h3>
<p>Most kernel BOs have GGTT mappings which must be restored during the resume
process. All user BOs are rebound after validation on their next use.</p>
</section>
</section>
<section id="future-work">
<h2>Future work<a class="headerlink" href="#future-work" title="Link to this heading">¶</a></h2>
<p>Trim the list of BOs which is saved / restored via TTM memcpy on suspend /
resume. All we really need to save / restore via TTM memcpy is the memory
required for the GuC to load and the memory for the GT migrate engine to
operate.</p>
<p>Do not require kernel BOs to be contiguous in physical memory / restored to
the same physical address on resume. In all likelihood the only memory that
needs to be restored to the same physical address is memory used for page
tables. All of that memory is allocated 1 page at time so the contiguous
requirement isn’t needed. Some work on the vmap code would need to be done if
kernel BOs are not contiguous too.</p>
<p>Make some kernel BO evictable rather than pinned. An example of this would be
engine state, in all likelihood if the dma-slots of these BOs where properly
used rather than pinning we could safely evict + rebind these BOs as needed.</p>
<p>Some kernel BOs do not need to be restored on resume (e.g. GuC ADS as that is
repopulated on resume), add flag to mark such objects as no save / restore.</p>
</section>
<section id="ggtt">
<h2>GGTT<a class="headerlink" href="#ggtt" title="Link to this heading">¶</a></h2>
<p>Xe GGTT implements the support for a Global Virtual Address space that is used
for resources that are accessible to privileged (i.e. kernel-mode) processes,
and not tied to a specific user-level process. For example, the Graphics
micro-Controller (GuC) and Display Engine (if present) utilize this Global
address space.</p>
<p>The Global GTT (GGTT) translates from the Global virtual address to a physical
address that can be accessed by HW. The GGTT is a flat, single-level table.</p>
<p>Xe implements a simplified version of the GGTT specifically managing only a
certain range of it that goes from the Write Once Protected Content Memory (WOPCM)
Layout to a predefined GUC_GGTT_TOP. This approach avoids complications related to
the GuC (Graphics Microcontroller) hardware limitations. The GuC address space
is limited on both ends of the GGTT, because the GuC shim HW redirects
accesses to those addresses to other HW areas instead of going through the
GGTT. On the bottom end, the GuC can’t access offsets below the WOPCM size,
while on the top side the limit is fixed at GUC_GGTT_TOP. To keep things
simple, instead of checking each object to see if they are accessed by GuC or
not, we just exclude those areas from the allocator. Additionally, to simplify
the driver load, we use the maximum WOPCM size in this logic instead of the
programmed one, so we don’t need to wait until the actual size to be
programmed is determined (which requires FW fetch) before initializing the
GGTT. These simplifications might waste space in the GGTT (about 20-25 MBs
depending on the platform) but we can live with this. Another benefit of this
is the GuC bootrom can’t access anything below the WOPCM max size so anything
the bootrom needs to access (e.g. a RSA key) needs to be placed in the GGTT
above the WOPCM max size. Starting the GGTT allocations above the WOPCM max
give us the correct placement for free.</p>
<section id="ggtt-internal-api">
<h3>GGTT Internal API<a class="headerlink" href="#ggtt-internal-api" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.xe_ggtt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt</span></span></span><a class="headerlink" href="#c.xe_ggtt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Main GGTT struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xe_ggtt {
    struct xe_tile *tile;
    u64 size;
#define XE_GGTT_FLAGS_64K BIT(0);
    unsigned int flags;
    struct xe_bo *scratch;
    struct mutex lock;
    u64 __iomem *gsm;
    const struct xe_ggtt_pt_ops *pt_ops;
    struct drm_mm mm;
    unsigned int access_count;
    struct workqueue_struct *wq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tile</span></code></dt><dd><p>Back pointer to tile where this GGTT belongs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Total size of this GGTT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags for this GGTT
Acceptable flags:
- <code class="docutils literal notranslate"><span class="pre">XE_GGTT_FLAGS_64K</span></code> - if PTE size is 64K. Otherwise, regular is 4K.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scratch</span></code></dt><dd><p>Internal object allocation used as a scratch page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Mutex lock to protect GGTT data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gsm</span></code></dt><dd><p>The iomem pointer to the actual location of the translation
table located in the GSM for easy PTE manipulation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_ops</span></code></dt><dd><p>Page Table operations per platform</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm</span></code></dt><dd><p>The memory manager used to manage individual GGTT allocations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access_count</span></code></dt><dd><p>counts GGTT writes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>Dedicated unordered work queue to process node removals</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>In general, each tile can contains its own Global Graphics Translation Table
(GGTT) instance.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.xe_ggtt_node">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node</span></span></span><a class="headerlink" href="#c.xe_ggtt_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>A node in GGTT.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xe_ggtt_node {
    struct xe_ggtt *ggtt;
    struct drm_mm_node base;
    struct work_struct delayed_removal_work;
    bool invalidate_on_remove;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ggtt</span></code></dt><dd><p>Back pointer to xe_ggtt where this region will be inserted at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>A drm_mm_node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_removal_work</span></code></dt><dd><p>The work struct for the delayed removal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">invalidate_on_remove</span></code></dt><dd><p>If it needs invalidation upon removal</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct needs to be initialized (only-once) with <a class="reference internal" href="#c.xe_ggtt_node_init" title="xe_ggtt_node_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_init()</span></code></a> before any node
insertion, reservation, or ‘ballooning’.
It will, then, be finalized by either <a class="reference internal" href="#c.xe_ggtt_node_remove" title="xe_ggtt_node_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_remove()</span></code></a> or xe_ggtt_node_deballoon().</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.xe_ggtt_pt_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_pt_ops</span></span></span><a class="headerlink" href="#c.xe_ggtt_pt_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>GGTT Page table operations Which can vary from platform to platform.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xe_ggtt_pt_ops {
    u64 (*pte_encode_bo)(struct xe_bo *bo, u64 bo_offset, u16 pat_index);
    void (*ggtt_set_pte)(struct xe_ggtt *ggtt, u64 addr, u64 pte);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pte_encode_bo</span></code></dt><dd><p>Encode PTE address for a given BO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ggtt_set_pte</span></code></dt><dd><p>Directly write into GGTT’s PTE</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_init_early">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_init_early</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_init_early" title="Link to this definition">¶</a><br /></dt>
<dd><p>Early GGTT initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It allows to create new mappings usable by the GuC.
Mappings are not usable by the HW engines, as it doesn’t have scratch nor
initial clear done to it yet. That will happen in the regular, non-early
GGTT initialization.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_node_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">invalidate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_node_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove a <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> from the GGTT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> to be removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">invalidate</span></code></dt><dd><p>if node needs invalidation upon removal</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Regular non-early GGTT initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> to be initialized</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_node_insert_balloon">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node_insert_balloon</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_node_insert_balloon" title="Link to this definition">¶</a><br /></dt>
<dd><p>prevent allocation of specified GGTT addresses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> to hold reserved GGTT node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>the starting GGTT address of the reserved region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>then end GGTT address of the reserved region</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use <a class="reference internal" href="#c.xe_ggtt_node_remove_balloon" title="xe_ggtt_node_remove_balloon"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_remove_balloon()</span></code></a> to release a reserved GGTT node.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_node_remove_balloon">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node_remove_balloon</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_node_remove_balloon" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a reserved GGTT region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> with reserved GGTT region</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.xe_ggtt_node_insert_balloon" title="xe_ggtt_node_insert_balloon"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_insert_balloon()</span></code></a> for details.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_node_insert_locked">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node_insert_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">mm_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_node_insert_locked" title="Link to this definition">¶</a><br /></dt>
<dd><p>Locked version to insert a <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> into the GGTT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> to be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">size</span></code></dt><dd><p>size of the node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">align</span></code></dt><dd><p>alignment constrain of the node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mm_flags</span></code></dt><dd><p>flags to control the node behavior</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It cannot be called without first having called <a class="reference internal" href="#c.xe_ggtt_init" title="xe_ggtt_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_init()</span></code></a> once.
To be used in cases where ggtt-&gt;lock is already taken.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_node_insert">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node_insert</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_node_insert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Insert a <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> into the GGTT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> to be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">size</span></code></dt><dd><p>size of the node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">align</span></code></dt><dd><p>alignment constrain of the node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It cannot be called without first having called <a class="reference internal" href="#c.xe_ggtt_init" title="xe_ggtt_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_init()</span></code></a> once.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_node_init">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_node_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize <code class="docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code> struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> where the new node will later be inserted/reserved.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will allocated the struct <code class="docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code> and return it’s pointer.
This struct will then be freed after the node removal upon <a class="reference internal" href="#c.xe_ggtt_node_remove" title="xe_ggtt_node_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_remove()</span></code></a>
or <a class="reference internal" href="#c.xe_ggtt_node_remove_balloon" title="xe_ggtt_node_remove_balloon"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_remove_balloon()</span></code></a>.
Having <code class="docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code> struct allocated doesn’t mean that the node is already allocated
in GGTT. Only the <a class="reference internal" href="#c.xe_ggtt_node_insert" title="xe_ggtt_node_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_insert()</span></code></a>, <a class="reference internal" href="#c.xe_ggtt_node_insert_locked" title="xe_ggtt_node_insert_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_insert_locked()</span></code></a>,
<a class="reference internal" href="#c.xe_ggtt_node_insert_balloon" title="xe_ggtt_node_insert_balloon"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_insert_balloon()</span></code></a> will ensure the node is inserted or reserved in GGTT.</p>
<p><strong>Return</strong></p>
<p>A pointer to <code class="docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code> struct on success. An ERR_PTR otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_node_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_node_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>Forcebly finalize <code class="docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code> struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> to be freed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If anything went wrong with either <a class="reference internal" href="#c.xe_ggtt_node_insert" title="xe_ggtt_node_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_insert()</span></code></a>, <a class="reference internal" href="#c.xe_ggtt_node_insert_locked" title="xe_ggtt_node_insert_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_insert_locked()</span></code></a>,
or <a class="reference internal" href="#c.xe_ggtt_node_insert_balloon" title="xe_ggtt_node_insert_balloon"><code class="xref c c-func docutils literal notranslate"><span class="pre">xe_ggtt_node_insert_balloon()</span></code></a>; and this <strong>node</strong> is not going to be reused, then,
this function needs to be called to free the <code class="docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code> struct</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_node_allocated">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_node_allocated</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_node_allocated" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check if node is allocated in GGTT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xe_ggtt_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> to be inspected</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if allocated, False otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_map_bo">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_map_bo</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xe_bo</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_map_bo" title="Link to this definition">¶</a><br /></dt>
<dd><p>Map the BO into GGTT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> where node will be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_bo</span> <span class="pre">*bo</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">xe_bo</span></code> to be mapped</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_insert_bo_at">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_insert_bo_at</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xe_bo</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_insert_bo_at" title="Link to this definition">¶</a><br /></dt>
<dd><p>Insert BO at a specific GGTT space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> where bo will be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_bo</span> <span class="pre">*bo</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">xe_bo</span></code> to be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>address where it will be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>end of the range where it will be inserted</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_insert_bo">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_insert_bo</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xe_bo</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_insert_bo" title="Link to this definition">¶</a><br /></dt>
<dd><p>Insert BO into GGTT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> where bo will be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_bo</span> <span class="pre">*bo</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">xe_bo</span></code> to be inserted</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_remove_bo">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_remove_bo</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xe_bo</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_remove_bo" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove a BO from the GGTT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> where node will be removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_bo</span> <span class="pre">*bo</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">xe_bo</span></code> to be removed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_largest_hole">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_largest_hole</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">alignment</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">spare</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_largest_hole" title="Link to this definition">¶</a><br /></dt>
<dd><p>Largest GGTT hole</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> that will be inspected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt><dd><p>minimum alignment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*spare</span></code></dt><dd><p>If not NULL: in: desired memory size to be spared / out: Adjusted possible spare</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of the largest continuous GGTT region</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_assign">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_assign</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><span class="n"><span class="pre">xe_ggtt_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">vfid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_assign" title="Link to this definition">¶</a><br /></dt>
<dd><p>assign a GGTT region to the VF</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xe_ggtt_node</span> <span class="pre">*node</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt_node" title="xe_ggtt_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt_node</span></code></a> to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">vfid</span></code></dt><dd><p>the VF identifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by the PF driver to assign a GGTT region to the VF.
In addition to PTE’s VFID bits 11:2 also PRESENT bit 0 is set as on some
platforms VFs can’t modify that either.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_dump">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_dump</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_dump" title="Link to this definition">¶</a><br /></dt>
<dd><p>Dump GGTT for debug</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> to be dumped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm_printer</span></code> helper handle to be used to dump the information</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xe_ggtt_print_holes">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xe_ggtt_print_holes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><span class="n"><span class="pre">xe_ggtt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ggtt</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">alignment</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xe_ggtt_print_holes" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print holes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xe_ggtt</span> <span class="pre">*ggtt</span></code></dt><dd><p>the <a class="reference internal" href="#c.xe_ggtt" title="xe_ggtt"><code class="xref c c-type docutils literal notranslate"><span class="pre">xe_ggtt</span></code></a> to be inspected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt><dd><p>min alignment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>the <a class="reference internal" href="../drm-internals.html#c.drm_printer" title="drm_printer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_printer</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Print GGTT ranges that are available and return total size available.</p>
<p><strong>Return</strong></p>
<p>Total available size.</p>
</div>
</section>
</section>
<section id="pagetable-building">
<h2>Pagetable building<a class="headerlink" href="#pagetable-building" title="Link to this heading">¶</a></h2>
<p>Below we use the term “page-table” for both page-directories, containing
pointers to lower level page-directories or page-tables, and level 0
page-tables that contain only page-table-entries pointing to memory pages.</p>
<p>When inserting an address range in an already existing page-table tree
there will typically be a set of page-tables that are shared with other
address ranges, and a set that are private to this address range.
The set of shared page-tables can be at most two per level,
and those can’t be updated immediately because the entries of those
page-tables may still be in use by the gpu for other mappings. Therefore
when inserting entries into those, we instead stage those insertions by
adding insertion data into struct xe_vm_pgtable_update structures. This
data, (subtrees for the cpu and page-table-entries for the gpu) is then
added in a separate commit step. CPU-data is committed while still under the
vm lock, the object lock and for userptr, the notifier lock in read mode.
The GPU async data is committed either by the GPU or CPU after fulfilling
relevant dependencies.
For non-shared page-tables (and, in fact, for shared ones that aren’t
existing at the time of staging), we add the data in-place without the
special update structures. This private part of the page-table tree will
remain disconnected from the vm page-table tree until data is committed to
the shared page tables of the vm tree in the commit phase.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/gpu/xe/xe_mm.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>