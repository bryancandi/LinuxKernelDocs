<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Interfacce deprecate, caratteristiche del linguaggio, attributi, e convenzioni &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.14.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/it_IT/process/deprecated.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
Italian

<ul>

<li><a href="../../../process/deprecated.html">English</a></li>

<li><a href="../../sp_SP/process/deprecated.html">Spanish</a></li>

</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In caso di dubbi sulla correttezza del contenuto di questa traduzione,
l’unico riferimento valido è la documentazione ufficiale in inglese.
Per maggiori informazioni consultate le <a class="reference internal" href="../index.html#it-disclaimer"><span class="std std-ref">avvertenze</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../process/deprecated.html#deprecated"><span class="std std-ref">Documentation/process/deprecated.rst</span></a></p>
</dd>
<dt class="field-even">Translator<span class="colon">:</span></dt>
<dd class="field-even"><p>Federico Vaga &lt;<a class="reference external" href="mailto:federico&#46;vaga&#37;&#52;&#48;vaga&#46;pv&#46;it">federico<span>&#46;</span>vaga<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</p>
</dd>
</dl>
<section id="interfacce-deprecate-caratteristiche-del-linguaggio-attributi-e-convenzioni">
<span id="it-deprecated"></span><h1>Interfacce deprecate, caratteristiche del linguaggio, attributi, e convenzioni<a class="headerlink" href="#interfacce-deprecate-caratteristiche-del-linguaggio-attributi-e-convenzioni" title="Link to this heading">¶</a></h1>
<p>In un mondo perfetto, sarebbe possibile prendere tutti gli usi di
un’interfaccia deprecata e convertirli in quella nuova, e così sarebbe
possibile rimuovere la vecchia interfaccia in un singolo ciclo di sviluppo.
Tuttavia, per via delle dimensioni del kernel, la gerarchia dei manutentori e
le tempistiche, non è sempre possibile fare questo tipo di conversione tutta
in una volta. Questo significa che nuove istanze di una vecchia interfaccia
potrebbero aggiungersi al kernel proprio quando si sta cercando di rimuoverle,
aumentando così il carico di lavoro. Al fine di istruire gli sviluppatori su
cosa è considerato deprecato (e perché), è stata create la seguente lista a cui
fare riferimento quando qualcuno propone modifiche che usano cose deprecate.</p>
<section id="deprecated">
<h2>__deprecated<a class="headerlink" href="#deprecated" title="Link to this heading">¶</a></h2>
<p>Nonostante questo attributo marchi visibilmente un interfaccia come deprecata,
<a class="reference external" href="https://git.kernel.org/linus/771c035372a036f83353eef46dbb829780330234">non produce più alcun avviso durante la compilazione</a>
perché uno degli obiettivi del kernel è quello di compilare senza avvisi;
inoltre, nessuno stava agendo per rimuovere queste interfacce. Nonostante l’uso
di <cite>__deprecated</cite> in un file d’intestazione sia opportuno per segnare una
interfaccia come ‘vecchia’, questa non è una soluzione completa. L’interfaccia
deve essere rimossa dal kernel, o aggiunta a questo documento per scoraggiarne
l’uso.</p>
</section>
<section id="bug-e-bug-on">
<h2>BUG() e BUG_ON()<a class="headerlink" href="#bug-e-bug-on" title="Link to this heading">¶</a></h2>
<p>Al loro posto usate WARN() e WARN_ON() per gestire le
condizioni “impossibili” e gestitele come se fosse possibile farlo.
Nonostante le funzioni della famiglia BUG() siano state progettate
per asserire “situazioni impossibili” e interrompere in sicurezza un
thread del kernel, queste si sono rivelate essere troppo rischiose
(per esempio, in quale ordine rilasciare i <em>lock</em>? Ci sono stati che
sono stati ripristinati?). Molto spesso l’uso di BUG()
destabilizza il sistema o lo corrompe del tutto, il che rende
impossibile un’attività di debug o anche solo leggere un rapporto
circa l’errore.  Linus ha un’opinione molto critica al riguardo:
<a class="reference external" href="https://lore.kernel.org/lkml/CA+55aFy6jNLsywVYdGp83AMrXBo_P-pkjkphPGrO=82SPKCpLQ&#64;mail.gmail.com/">email 1</a>,
<a class="reference external" href="https://lore.kernel.org/lkml/CAHk-=whDHsbK3HTOpTF=ue_o04onRwTEaK_ZoJp_fjbqq4+=Jw&#64;mail.gmail.com/">email 2</a></p>
<p>Tenete presente che la famiglia di funzioni WARN() dovrebbe essere
usato solo per situazioni che si suppone siano “impossibili”.  Se
volete avvisare gli utenti riguardo a qualcosa di possibile anche se
indesiderato, usare le funzioni della famiglia <a class="reference internal" href="../../../core-api/printk-basics.html#c.pr_warn" title="pr_warn"><code class="xref c c-func docutils literal notranslate"><span class="pre">pr_warn()</span></code></a>.  Chi
amministra il sistema potrebbe aver attivato l’opzione sysctl
<em>panic_on_warn</em> per essere sicuri che il sistema smetta di funzionare
in caso si verifichino delle condizioni “inaspettate”. (per esempio,
date un’occhiata al questo <a class="reference external" href="https://git.kernel.org/linus/d4689846881d160a4d12a514e991a740bcb5d65a">commit</a>)</p>
</section>
<section id="calcoli-codificati-negli-argomenti-di-un-allocatore">
<h2>Calcoli codificati negli argomenti di un allocatore<a class="headerlink" href="#calcoli-codificati-negli-argomenti-di-un-allocatore" title="Link to this heading">¶</a></h2>
<p>Il calcolo dinamico delle dimensioni (specialmente le moltiplicazioni) non
dovrebbero essere fatto negli argomenti di funzioni di allocazione di memoria
(o simili) per via del rischio di overflow. Questo può portare a valori più
piccoli di quelli che il chiamante si aspettava. L’uso di questo modo di
allocare può portare ad un overflow della memoria di heap e altri
malfunzionamenti. (Si fa eccezione per valori numerici per i quali il
compilatore può generare avvisi circa un potenziale overflow. Tuttavia, anche in
questi casi è preferibile riscrivere il codice come suggerito di seguito).</p>
<p>Per esempio, non usate <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">*</span> <span class="pre">size</span></code> come argomento:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo = kmalloc(count * size, GFP_KERNEL);
</pre></div>
</div>
<p>Al suo posto, si dovrebbe usare l’allocatore a due argomenti:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo = kmalloc_array(count, size, GFP_KERNEL);
</pre></div>
</div>
<p>Nello specifico, <a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> può essere sostituta da <a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc_array" title="kmalloc_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc_array()</span></code></a>, e <a class="reference internal" href="../../../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a>
da <a class="reference internal" href="../../../core-api/mm-api.html#c.kcalloc" title="kcalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kcalloc()</span></code></a>.</p>
<p>Se questo tipo di allocatore non è disponibile, allora dovrebbero essere usate
le funzioni del tipo <em>saturate-on-overflow</em>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bar = dma_alloc_coherent(dev, array_size(count, size), &amp;dma, GFP_KERNEL);
</pre></div>
</div>
<p>Un altro tipico caso da evitare è quello di calcolare la dimensione di una
struttura seguita da un vettore di altre strutture, come nel seguente caso:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>header = kzalloc(sizeof(*header) + count * sizeof(*header-&gt;item),
                 GFP_KERNEL);
</pre></div>
</div>
<p>Invece, usate la seguente funzione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>header = kzalloc(struct_size(header, item, count), GFP_KERNEL);
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Se per caso state usando <a class="reference internal" href="../../../core-api/kernel-api.html#c.struct_size" title="struct_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">struct_size()</span></code></a> su una struttura dati che
in coda contiene un array di lunghezza zero o uno, allora siete
invitati a riorganizzare il vostro codice usando il
<a class="reference external" href="#zero-length-and-one-element-arrays">flexible array member</a>.</p>
</div>
<p>Per altri calcoli, usate le funzioni <a class="reference internal" href="../../../core-api/kernel-api.html#c.size_mul" title="size_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">size_mul()</span></code></a>, <a class="reference internal" href="../../../core-api/kernel-api.html#c.size_add" title="size_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">size_add()</span></code></a>, e <a class="reference internal" href="../../../core-api/kernel-api.html#c.size_sub" title="size_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">size_sub()</span></code></a>. Per
esempio, al posto di:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo = krealloc(current_size + chunk_size * (count - 3), GFP_KERNEL);
</pre></div>
</div>
<p>dovreste scrivere:</p>
<blockquote>
<div><dl class="simple">
<dt>foo = krealloc(size_add(current_size,</dt><dd><dl class="simple">
<dt>size_mul(chunk_size,</dt><dd><p>size_sub(count, 3))), GFP_KERNEL);</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Per maggiori dettagli fate riferimento a <a class="reference internal" href="../../../core-api/kernel-api.html#c.array3_size" title="array3_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">array3_size()</span></code></a> e <a class="reference internal" href="../../../core-api/kernel-api.html#c.flex_array_size" title="flex_array_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">flex_array_size()</span></code></a>, ma
anche le funzioni della famiglia <a class="reference internal" href="../../../core-api/kernel-api.html#c.check_mul_overflow" title="check_mul_overflow"><code class="xref c c-func docutils literal notranslate"><span class="pre">check_mul_overflow()</span></code></a>, <a class="reference internal" href="../../../core-api/kernel-api.html#c.check_add_overflow" title="check_add_overflow"><code class="xref c c-func docutils literal notranslate"><span class="pre">check_add_overflow()</span></code></a>,
<a class="reference internal" href="../../../core-api/kernel-api.html#c.check_sub_overflow" title="check_sub_overflow"><code class="xref c c-func docutils literal notranslate"><span class="pre">check_sub_overflow()</span></code></a>, e <a class="reference internal" href="../../../core-api/kernel-api.html#c.check_shl_overflow" title="check_shl_overflow"><code class="xref c c-func docutils literal notranslate"><span class="pre">check_shl_overflow()</span></code></a>.</p>
</section>
<section id="simple-strtol-simple-strtoll-simple-strtoul-simple-strtoull">
<h2>simple_strtol(), simple_strtoll(), simple_strtoul(), simple_strtoull()<a class="headerlink" href="#simple-strtol-simple-strtoll-simple-strtoul-simple-strtoull" title="Link to this heading">¶</a></h2>
<p>Le funzioni <a class="reference internal" href="../../../core-api/kernel-api.html#c.simple_strtol" title="simple_strtol"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtol()</span></code></a>, <a class="reference internal" href="../../../core-api/kernel-api.html#c.simple_strtoll" title="simple_strtoll"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtoll()</span></code></a>,
<a class="reference internal" href="../../../core-api/kernel-api.html#c.simple_strtoul" title="simple_strtoul"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtoul()</span></code></a>, e <a class="reference internal" href="../../../core-api/kernel-api.html#c.simple_strtoull" title="simple_strtoull"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtoull()</span></code></a> ignorano volutamente
i possibili overflow, e questo può portare il chiamante a generare risultati
inaspettati. Le rispettive funzioni <a class="reference internal" href="../../../core-api/kernel-api.html#c.kstrtol" title="kstrtol"><code class="xref c c-func docutils literal notranslate"><span class="pre">kstrtol()</span></code></a>, <a class="reference internal" href="../../../core-api/kernel-api.html#c.kstrtoll" title="kstrtoll"><code class="xref c c-func docutils literal notranslate"><span class="pre">kstrtoll()</span></code></a>,
<a class="reference internal" href="../../../core-api/kernel-api.html#c.kstrtoul" title="kstrtoul"><code class="xref c c-func docutils literal notranslate"><span class="pre">kstrtoul()</span></code></a>, e <a class="reference internal" href="../../../core-api/kernel-api.html#c.kstrtoull" title="kstrtoull"><code class="xref c c-func docutils literal notranslate"><span class="pre">kstrtoull()</span></code></a> sono da considerarsi le corrette
sostitute; tuttavia va notato che queste richiedono che la stringa sia
terminata con il carattere NUL o quello di nuova riga.</p>
</section>
<section id="strcpy">
<h2>strcpy()<a class="headerlink" href="#strcpy" title="Link to this heading">¶</a></h2>
<p>La funzione <a class="reference internal" href="../../../core-api/kernel-api.html#c.strcpy" title="strcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strcpy()</span></code></a> non fa controlli agli estremi del buffer
di destinazione. Questo può portare ad un overflow oltre i limiti del
buffer e generare svariati tipi di malfunzionamenti. Nonostante l’opzione
<cite>CONFIG_FORTIFY_SOURCE=y</cite> e svariate opzioni del compilatore aiutano
a ridurne il rischio, non c’è alcuna buona ragione per continuare ad usare
questa funzione. La versione sicura da usare è <a class="reference internal" href="../../../core-api/kernel-api.html#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a>, tuttavia va
prestata attenzione a tutti quei casi dove viene usato il valore di
ritorno di <a class="reference internal" href="../../../core-api/kernel-api.html#c.strcpy" title="strcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strcpy()</span></code></a>.  La funzione <a class="reference internal" href="../../../core-api/kernel-api.html#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a> non ritorna un puntatore
alla destinazione, ma un contatore dei byte non NUL copiati (oppure
un errno negativo se la stringa è stata troncata).</p>
</section>
<section id="strncpy-su-stringe-terminate-con-nul">
<h2>strncpy() su stringe terminate con NUL<a class="headerlink" href="#strncpy-su-stringe-terminate-con-nul" title="Link to this heading">¶</a></h2>
<p>L’utilizzo di <a class="reference internal" href="../../../core-api/kernel-api.html#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a> non fornisce alcuna garanzia sul fatto che
il buffer di destinazione verrà terminato con il carattere NUL. Questo
potrebbe portare a diversi overflow di lettura o altri malfunzionamenti
causati, appunto, dalla mancanza del terminatore. Questa estende la
terminazione nel buffer di destinazione quando la stringa d’origine è più
corta; questo potrebbe portare ad una penalizzazione delle prestazioni per
chi usa solo stringe terminate. La versione sicura da usare è
<a class="reference internal" href="../../../core-api/kernel-api.html#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a>, tuttavia va prestata attenzione a tutti quei casi dove
viene usato il valore di ritorno di <a class="reference internal" href="../../../core-api/kernel-api.html#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a>.  La funzione <a class="reference internal" href="../../../core-api/kernel-api.html#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a>
non ritorna un puntatore alla destinazione, ma un contatore dei byte
non NUL copiati (oppure un errno negativo se la stringa è stata
troncata). Tutti i casi che necessitano di estendere la
terminazione con NUL dovrebbero usare <a class="reference internal" href="../../../core-api/kernel-api.html#c.strscpy_pad" title="strscpy_pad"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy_pad()</span></code></a>.</p>
<p>Se il chiamate no usa stringhe terminate con NUL, allore <a class="reference internal" href="../../../core-api/kernel-api.html#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a>
può continuare ad essere usata, ma i buffer di destinazione devono essere
marchiati con l’attributo <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html">__nonstring</a>
per evitare avvisi durante la compilazione.</p>
</section>
<section id="strlcpy">
<h2>strlcpy()<a class="headerlink" href="#strlcpy" title="Link to this heading">¶</a></h2>
<p>La funzione strlcpy(), per prima cosa, legge interamente il buffer di
origine, magari leggendo più di quanto verrà effettivamente copiato. Questo
è inefficiente e può portare a overflow di lettura quando la stringa non è
terminata con NUL. La versione sicura da usare è <a class="reference internal" href="../../../core-api/kernel-api.html#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a>, tuttavia
va prestata attenzione a tutti quei casi dove viene usato il valore di
ritorno di strlcpy(), dato che <a class="reference internal" href="../../../core-api/kernel-api.html#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a> ritorna un valore di errno
negativo quanto la stringa viene troncata.</p>
</section>
<section id="segnaposto-p-nella-stringa-di-formato">
<h2>Segnaposto %p nella stringa di formato<a class="headerlink" href="#segnaposto-p-nella-stringa-di-formato" title="Link to this heading">¶</a></h2>
<p>Tradizionalmente, l’uso del segnaposto “%p” nella stringa di formato
esponne un indirizzo di memoria in dmesg, proc, sysfs, eccetera.  Per
evitare che questi indirizzi vengano sfruttati da malintenzionati,
tutto gli usi di “%p” nel kernel rappresentano l’hash dell’indirizzo,
rendendolo di fatto inutilizzabile.  Nuovi usi di “%p” non dovrebbero
essere aggiunti al kernel.  Per una rappresentazione testuale di un
indirizzo usate “%pS”, l’output è migliore perché mostrerà il nome del
simbolo.  Per tutto il resto, semplicemente non usate “%p”.</p>
<p>Parafrasando la <a class="reference external" href="https://lore.kernel.org/lkml/CA+55aFwQEd_d40g4mUCSsVRZzrFPUJt74vc6PPpb675hYNXcKw&#64;mail.gmail.com/">guida</a>
di Linus:</p>
<ul class="simple">
<li><p>Se il valore hash di “%p” è inutile, chiediti se il puntatore stesso
è importante. Forse dovrebbe essere rimosso del tutto?</p></li>
<li><p>Se credi davvero che il vero valore del puntatore sia importante,
perché alcuni stati del sistema o i livelli di privilegi di un
utente sono considerati “special”? Se pensi di poterlo giustificare
(in un commento e nel messaggio del commit) abbastanza bene da
affrontare il giudizio di Linus, allora forse potrai usare “%px”,
assicurandosi anche di averne il permesso.</p></li>
</ul>
<p>Potete disabilitare temporaneamente l’hashing di “%p” nel caso in cui questa
funzionalità vi sia d’ostacolo durante una sessione di debug. Per farlo
aggiungete l’opzione di debug “<a class="reference external" href="https://git.kernel.org/linus/5ead723a20e0447bc7db33dc3070b420e5f80aa6">no_hash_pointers</a>” alla
riga di comando del kernel.</p>
</section>
<section id="vettori-a-dimensione-variabile-vla">
<h2>Vettori a dimensione variabile (VLA)<a class="headerlink" href="#vettori-a-dimensione-variabile-vla" title="Link to this heading">¶</a></h2>
<p>Usare VLA sullo stack produce codice molto peggiore rispetto a quando si usano
vettori a dimensione fissa. Questi <a class="reference external" href="https://git.kernel.org/linus/02361bc77888">problemi di prestazioni</a>,
tutt’altro che banali, sono già un motivo valido per eliminare i VLA; in
aggiunta sono anche un problema per la sicurezza. La crescita dinamica di un
vettore nello stack potrebbe eccedere la memoria rimanente in tale segmento.
Questo può portare a dei malfunzionamenti, potrebbe sovrascrivere
dati importanti alla fine dello stack (quando il kernel è compilato senza
<cite>CONFIG_THREAD_INFO_IN_TASK=y</cite>), o sovrascrivere un pezzo di memoria adiacente
allo stack (quando il kernel è compilato senza <cite>CONFIG_VMAP_STACK=y</cite>).</p>
</section>
<section id="salto-implicito-nell-istruzione-switch-case">
<h2>Salto implicito nell’istruzione switch-case<a class="headerlink" href="#salto-implicito-nell-istruzione-switch-case" title="Link to this heading">¶</a></h2>
<p>Il linguaggio C permette ai casi di un’istruzione <cite>switch</cite> di saltare al
prossimo caso quando l’istruzione “break” viene omessa alla fine del caso
corrente. Tuttavia questo rende il codice ambiguo perché non è sempre ovvio se
l’istruzione “break” viene omessa intenzionalmente o è un baco. Per esempio,
osservando il seguente pezzo di codice non è chiaro se lo stato
<cite>STATE_ONE</cite> è stato progettato apposta per eseguire anche <cite>STATE_TWO</cite>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (value) {
case STATE_ONE:
        do_something();
case STATE_TWO:
        do_other();
        break;
default:
        WARN(&quot;unknown state&quot;);
}
</pre></div>
</div>
<p>Dato che c’è stata una lunga lista di problemi <a class="reference external" href="https://cwe.mitre.org/data/definitions/484.html">dovuti alla mancanza dell’istruzione
“break”</a>, oggigiorno non
permettiamo più che vi sia un “salto implicito” (<em>fall-through</em>). Per
identificare un salto implicito intenzionale abbiamo adottato la pseudo
parola chiave ‘fallthrough’ che viene espansa nell’estensione di gcc
<cite>__attribute__((fallthrough))</cite> <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Attributes.html">Statement Attributes</a>.
(Quando la sintassi C17/C18 <cite>[[fallthrough]]</cite> sarà più comunemente
supportata dai compilatori C, analizzatori statici, e dagli IDE,
allora potremo usare quella sintassi per la pseudo parola chiave)</p>
<p>Quando la sintassi [[fallthrough]] sarà più comunemente supportata dai
compilatori, analizzatori statici, e ambienti di sviluppo IDE,
allora potremo usarla anche noi.</p>
<p>Ne consegue che tutti i blocchi switch/case devono finire in uno dei seguenti
modi:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">break;</span></code></p></li>
<li><p><cite>fallthrough;`</cite></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">continue;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">&lt;label&gt;;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">[expression];</span></code></p></li>
</ul>
</section>
<section id="array-di-lunghezza-zero-o-con-un-solo-elemento">
<h2>Array di lunghezza zero o con un solo elemento<a class="headerlink" href="#array-di-lunghezza-zero-o-con-un-solo-elemento" title="Link to this heading">¶</a></h2>
<p>All’interno del kernel ricorre spesso la necessita di avere membri
di dimensione variabile all’interno di una struttura dati. In questi
casi il codice del kernel dovrebbe usare sempre i <a class="reference external" href="https://en.wikipedia.org/wiki/Flexible_array_member">“flexible array
member”</a>. La
tecnica degli array a lunghezza nulla o di un solo elemento non
dovrebbe essere più usata.</p>
<p>Nel codice C più vecchio, la dichiarazione di un membro di dimensione
variabile in coda ad una struttura dati veniva fatto dichiarando un
array di un solo elemento posizionato alla fine della struttura dati:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct something {
        size_t count;
        struct foo items[1];
};
</pre></div>
</div>
<p>Questo ha portato ad un calcolo di sizeof() traballante (dovrebbe
rimuovere la dimensione del singolo elemento in coda per calcolare la
dimensione esatta dell’ “intestazione”). Per evitare questi problemi è
stata introdotta un’ <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">estensione a GNU C</a> che
permettesse la dichiarazione di array a lungezza zero:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct something {
        size_t count;
        struct foo items[0];
};
</pre></div>
</div>
<p>Ma questo ha portato nuovi problemi, e non ha risolto alcuni dei
problemi che affliggono entrambe le tecniche: per esempio
l’impossibilità di riconoscere se un array di quel tipo viene usato
nel mezzo di una struttura dati e _non_ alla fine (potrebbe accadere
sia direttamente, sia indirettamente quando si usano le unioni o le
strutture di strutture).</p>
<p>Lo standard C99 introduce i “flexible array members”. Questi array non
hanno una dimensione nella loro dichiarazione:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct something {
        size_t count;
        struct foo items[];
};
</pre></div>
</div>
<p>Questo è il modo con cui ci si aspetta che vengano dichiarati gli
elementi di lunghezza variabile in coda alle strutture dati.  Permette
al compilatore di produrre errori quando gli array flessibili non si
trovano alla fine della struttura dati, il che permette di prevenire
alcuni tipi di bachi dovuti a <a class="reference external" href="https://git.kernel.org/linus/76497732932f15e7323dc805e8ea8dc11bb587cf">comportamenti inaspettati</a>.
Inoltre, permette al compilatore di analizzare correttamente le
dimensioni degli array (attraverso sizeof(), <cite>CONFIG_FORTIFY_SOURCE</cite>,
e <cite>CONFIG_UBSAN_BOUNDS</cite>). Per esempio, non esiste alcun meccanismo in
grado di avvisarci che il seguente uso di sizeof() dia sempre come
zero come risultato:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct something {
        size_t count;
        struct foo items[0];
};

struct something *instance;

instance = kmalloc(struct_size(instance, items, count), GFP_KERNEL);
instance-&gt;count = count;

size = sizeof(instance-&gt;items) * instance-&gt;count;
memcpy(instance-&gt;items, source, size);
</pre></div>
</div>
<p>Il valore di <code class="docutils literal notranslate"><span class="pre">size</span></code> nell’ultima riga sarà <code class="docutils literal notranslate"><span class="pre">zero</span></code>, quando uno
invece si aspetterebbe che il suo valore sia la dimensione totale in
byte dell’allocazione dinamica che abbiamo appena fatto per l’array
<code class="docutils literal notranslate"><span class="pre">items</span></code>. Qui un paio di esempi reali del problema: <a class="reference external" href="https://git.kernel.org/linus/f2cd32a443da694ac4e28fbf4ac6f9d5cc63a539">collegamento 1</a>,
<a class="reference external" href="https://git.kernel.org/linus/ab91c2a89f86be2898cee208d492816ec238b2cf">collegamento 2</a>.
Invece, <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">i flexible array members hanno un tipo incompleto, e quindi
sizeof() non può essere applicato</a>; dunque ogni
uso scorretto di questo operatore verrà identificato immediatamente
durante la compilazione.</p>
<p>Per quanto riguarda gli array di un solo elemento, bisogna essere
consapevoli che <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">questi array occupano almeno quanto lo spazio di un
singolo oggetti dello stesso tipo</a>, e quindi
contribuiscono al calcolo della dimensione della struttura che li
contiene. In questo caso è facile commettere errori quando si vuole
calcolare la dimensione totale della memoria totale da allocare per
una struttura dati:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct something {
        size_t count;
        struct foo items[1];
};

struct something *instance;

instance = kmalloc(struct_size(instance, items, count - 1), GFP_KERNEL);
instance-&gt;count = count;

size = sizeof(instance-&gt;items) * instance-&gt;count;
memcpy(instance-&gt;items, source, size);
</pre></div>
</div>
<p>In questo esempio ci siamo dovuti ricordare di usare <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">-</span> <span class="pre">1</span></code> in
<a class="reference internal" href="../../../core-api/kernel-api.html#c.struct_size" title="struct_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">struct_size()</span></code></a>, altrimenti avremmo --inavvertitamente-- allocato
memoria per un oggetti <code class="docutils literal notranslate"><span class="pre">items</span></code> in più. Il modo più pulito e meno
propenso agli errori è quello di usare i <cite>flexible array member</cite>, in
combinazione con <a class="reference internal" href="../../../core-api/kernel-api.html#c.struct_size" title="struct_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">struct_size()</span></code></a> e <a class="reference internal" href="../../../core-api/kernel-api.html#c.flex_array_size" title="flex_array_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">flex_array_size()</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct something {
        size_t count;
        struct foo items[];
};

struct something *instance;

instance = kmalloc(struct_size(instance, items, count), GFP_KERNEL);
instance-&gt;count = count;

memcpy(instance-&gt;items, source, flex_array_size(instance, items, instance-&gt;count));
</pre></div>
</div>
<p>Ci sono due casi speciali dove è necessario usare la macro DECLARE_FLEX_ARRAY()
(da notare che la stessa macro è chiamata __DECLARE_FLEX_ARRAY() nei file di
intestazione UAPI). Uno è quando l’array flessibile è l’unico elemento di una
struttura, e l’altro quando è parte di un unione. Per motivi non tecnici, entrambi
i casi d’uso non sono permessi dalla specifica C99. Per esempio, per
convertire il seguente codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct something {
    ...
    union {
        struct type1 one[0];
        struct type2 two[0];
    };
};
</pre></div>
</div>
<p>La macro di supporto dev’essere usata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct something {
    ...
    union {
        DECLARE_FLEX_ARRAY(struct type1, one);
        DECLARE_FLEX_ARRAY(struct type2, two);
    };
};
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/it_IT/process/deprecated.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>