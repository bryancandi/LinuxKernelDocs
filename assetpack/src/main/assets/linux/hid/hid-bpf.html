<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>HID-BPF &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="UHID - User-space I/O driver support for HID subsystem" href="uhid.html" />
    <link rel="prev" title="HID I/O Transport Drivers" href="hid-transport.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.14.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../input/index.html">Input Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpu/index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/hid/hid-bpf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="hid-bpf">
<h1>HID-BPF<a class="headerlink" href="#hid-bpf" title="Link to this heading">¶</a></h1>
<p>HID is a standard protocol for input devices but some devices may require
custom tweaks, traditionally done with a kernel driver fix. Using the eBPF
capabilities instead speeds up development and adds new capabilities to the
existing HID interfaces.</p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#when-and-why-to-use-hid-bpf" id="id1">When (and why) to use HID-BPF</a></p>
<ul>
<li><p><a class="reference internal" href="#dead-zone-of-a-joystick" id="id2">Dead zone of a joystick</a></p></li>
<li><p><a class="reference internal" href="#simple-fixup-of-report-descriptor" id="id3">Simple fixup of report descriptor</a></p></li>
<li><p><a class="reference internal" href="#add-a-new-feature-that-requires-a-new-kernel-api" id="id4">Add a new feature that requires a new kernel API</a></p></li>
<li><p><a class="reference internal" href="#morph-a-device-into-something-else-and-control-that-from-userspace" id="id5">Morph a device into something else and control that from userspace</a></p></li>
<li><p><a class="reference internal" href="#firewall" id="id6">Firewall</a></p></li>
<li><p><a class="reference internal" href="#tracing" id="id7">Tracing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#high-level-view-of-hid-bpf" id="id8">High-level view of HID-BPF</a></p></li>
<li><p><a class="reference internal" href="#in-tree-hid-bpf-programs-and-udev-hid-bpf" id="id9">In-tree HID-BPF programs and <code class="docutils literal notranslate"><span class="pre">udev-hid-bpf</span></code></a></p></li>
<li><p><a class="reference internal" href="#available-types-of-programs" id="id10">Available types of programs</a></p></li>
<li><p><a class="reference internal" href="#developer-api" id="id11">Developer API:</a></p>
<ul>
<li><p><a class="reference internal" href="#available-struct-ops-for-hid-bpf" id="id12">Available <code class="docutils literal notranslate"><span class="pre">struct_ops</span></code> for HID-BPF:</a></p></li>
<li><p><a class="reference internal" href="#user-api-data-structures-available-in-programs" id="id13">User API data structures available in programs:</a></p></li>
<li><p><a class="reference internal" href="#available-api-that-can-be-used-in-all-hid-bpf-struct-ops-programs" id="id14">Available API that can be used in all HID-BPF struct_ops programs:</a></p></li>
<li><p><a class="reference internal" href="#available-api-that-can-be-used-in-syscall-hid-bpf-programs-or-in-sleepable-hid-bpf-struct-ops-programs" id="id15">Available API that can be used in syscall HID-BPF programs or in sleepable HID-BPF struct_ops programs:</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#general-overview-of-a-hid-bpf-program" id="id16">General overview of a HID-BPF program</a></p>
<ul>
<li><p><a class="reference internal" href="#accessing-the-data-attached-to-the-context" id="id17">Accessing the data attached to the context</a></p></li>
<li><p><a class="reference internal" href="#effect-of-a-hid-bpf-program" id="id18">Effect of a HID-BPF program</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#attaching-a-bpf-program-to-a-device" id="id19">Attaching a bpf program to a device</a></p></li>
<li><p><a class="reference internal" href="#an-almost-complete-example-of-a-bpf-enhanced-hid-device" id="id20">An (almost) complete example of a BPF enhanced HID device</a></p>
<ul>
<li><p><a class="reference internal" href="#filtering-events" id="id21">Filtering events</a></p></li>
<li><p><a class="reference internal" href="#controlling-the-device" id="id22">Controlling the device</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="when-and-why-to-use-hid-bpf">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">When (and why) to use HID-BPF</a><a class="headerlink" href="#when-and-why-to-use-hid-bpf" title="Link to this heading">¶</a></h2>
<p>There are several use cases when using HID-BPF is better
than standard kernel driver fix:</p>
<section id="dead-zone-of-a-joystick">
<h3><a class="toc-backref" href="#id2" role="doc-backlink">Dead zone of a joystick</a><a class="headerlink" href="#dead-zone-of-a-joystick" title="Link to this heading">¶</a></h3>
<p>Assuming you have a joystick that is getting older, it is common to see it
wobbling around its neutral point. This is usually filtered at the application
level by adding a <em>dead zone</em> for this specific axis.</p>
<p>With HID-BPF, we can apply this filtering in the kernel directly so userspace
does not get woken up when nothing else is happening on the input controller.</p>
<p>Of course, given that this dead zone is specific to an individual device, we
can not create a generic fix for all of the same joysticks. Adding a custom
kernel API for this (e.g. by adding a sysfs entry) does not guarantee this new
kernel API will be broadly adopted and maintained.</p>
<p>HID-BPF allows the userspace program to load the program itself, ensuring we
only load the custom API when we have a user.</p>
</section>
<section id="simple-fixup-of-report-descriptor">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Simple fixup of report descriptor</a><a class="headerlink" href="#simple-fixup-of-report-descriptor" title="Link to this heading">¶</a></h3>
<p>In the HID tree, half of the drivers only fix one key or one byte
in the report descriptor. These fixes all require a kernel patch and the
subsequent shepherding into a release, a long and painful process for users.</p>
<p>We can reduce this burden by providing an eBPF program instead. Once such a
program  has been verified by the user, we can embed the source code into the
kernel tree and ship the eBPF program and load it directly instead of loading
a specific kernel module for it.</p>
<p>Note: distribution of eBPF programs and their inclusion in the kernel is not
yet fully implemented</p>
</section>
<section id="add-a-new-feature-that-requires-a-new-kernel-api">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Add a new feature that requires a new kernel API</a><a class="headerlink" href="#add-a-new-feature-that-requires-a-new-kernel-api" title="Link to this heading">¶</a></h3>
<p>An example for such a feature are the Universal Stylus Interface (USI) pens.
Basically, USI pens require a new kernel API because there are new
channels of communication that our HID and input stack do not support.
Instead of using hidraw or creating new sysfs entries or ioctls, we can rely
on eBPF to have the kernel API controlled by the consumer and to not
impact the performances by waking up userspace every time there is an
event.</p>
</section>
<section id="morph-a-device-into-something-else-and-control-that-from-userspace">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Morph a device into something else and control that from userspace</a><a class="headerlink" href="#morph-a-device-into-something-else-and-control-that-from-userspace" title="Link to this heading">¶</a></h3>
<p>The kernel has a relatively static mapping of HID items to evdev bits.
It cannot decide to dynamically transform a given device into something else
as it does not have the required context and any such transformation cannot be
undone (or even discovered) by userspace.</p>
<p>However, some devices are useless with that static way of defining devices. For
example, the Microsoft Surface Dial is a pushbutton with haptic feedback that
is barely usable as of today.</p>
<p>With eBPF, userspace can morph that device into a mouse, and convert the dial
events into wheel events. Also, the userspace program can set/unset the haptic
feedback depending on the context. For example, if a menu is visible on the
screen we likely need to have a haptic click every 15 degrees. But when
scrolling in a web page the user experience is better when the device emits
events at the highest resolution.</p>
</section>
<section id="firewall">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Firewall</a><a class="headerlink" href="#firewall" title="Link to this heading">¶</a></h3>
<p>What if we want to prevent other users to access a specific feature of a
device? (think a possibly broken firmware update entry point)</p>
<p>With eBPF, we can intercept any HID command emitted to the device and
validate it or not.</p>
<p>This also allows to sync the state between the userspace and the
kernel/bpf program because we can intercept any incoming command.</p>
</section>
<section id="tracing">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Tracing</a><a class="headerlink" href="#tracing" title="Link to this heading">¶</a></h3>
<p>The last usage is tracing events and all the fun we can do we BPF to summarize
and analyze events.</p>
<p>Right now, tracing relies on hidraw. It works well except for a couple
of issues:</p>
<ol class="arabic simple">
<li><p>if the driver doesn’t export a hidraw node, we can’t trace anything
(eBPF will be a “god-mode” there, so this may raise some eyebrows)</p></li>
<li><p>hidraw doesn’t catch other processes’ requests to the device, which
means that we have cases where we need to add printks to the kernel
to understand what is happening.</p></li>
</ol>
</section>
</section>
<section id="high-level-view-of-hid-bpf">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">High-level view of HID-BPF</a><a class="headerlink" href="#high-level-view-of-hid-bpf" title="Link to this heading">¶</a></h2>
<p>The main idea behind HID-BPF is that it works at an array of bytes level.
Thus, all of the parsing of the HID report and the HID report descriptor
must be implemented in the userspace component that loads the eBPF
program.</p>
<p>For example, in the dead zone joystick from above, knowing which fields
in the data stream needs to be set to <code class="docutils literal notranslate"><span class="pre">0</span></code> needs to be computed by userspace.</p>
<p>A corollary of this is that HID-BPF doesn’t know about the other subsystems
available in the kernel. <em>You can not directly emit input event through the
input API from eBPF</em>.</p>
<p>When a BPF program needs to emit input events, it needs to talk with the HID
protocol, and rely on the HID kernel processing to translate the HID data into
input events.</p>
</section>
<section id="in-tree-hid-bpf-programs-and-udev-hid-bpf">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">In-tree HID-BPF programs and <code class="docutils literal notranslate"><span class="pre">udev-hid-bpf</span></code></a><a class="headerlink" href="#in-tree-hid-bpf-programs-and-udev-hid-bpf" title="Link to this heading">¶</a></h2>
<p>Official device fixes are shipped in the kernel tree as source in the
<code class="docutils literal notranslate"><span class="pre">drivers/hid/bpf/progs</span></code> directory. This allows to add selftests to them in
<code class="docutils literal notranslate"><span class="pre">tools/testing/selftests/hid</span></code>.</p>
<p>However, the compilation of these objects is not part of a regular kernel compilation
given that they need an external tool to be loaded. This tool is currently
<a class="reference external" href="https://libevdev.pages.freedesktop.org/udev-hid-bpf/index.html">udev-hid-bpf</a>.</p>
<p>For convenience, that external repository duplicates the files from here in
<code class="docutils literal notranslate"><span class="pre">drivers/hid/bpf/progs</span></code> into its own <code class="docutils literal notranslate"><span class="pre">src/bpf/stable</span></code> directory. This allows
distributions to not have to pull the entire kernel source tree to ship and package
those HID-BPF fixes. <code class="docutils literal notranslate"><span class="pre">udev-hid-bpf</span></code> also has capabilities of handling multiple
objects files depending on the kernel the user is running.</p>
</section>
<section id="available-types-of-programs">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Available types of programs</a><a class="headerlink" href="#available-types-of-programs" title="Link to this heading">¶</a></h2>
<p>HID-BPF is built “on top” of BPF, meaning that we use bpf struct_ops method to
declare our programs.</p>
<p>HID-BPF has the following attachment types available:</p>
<ol class="arabic simple">
<li><p>event processing/filtering with <code class="docutils literal notranslate"><span class="pre">SEC(&quot;struct_ops/hid_device_event&quot;)</span></code> in libbpf</p></li>
<li><p>actions coming from userspace with <code class="docutils literal notranslate"><span class="pre">SEC(&quot;syscall&quot;)</span></code> in libbpf</p></li>
<li><p>change of the report descriptor with <code class="docutils literal notranslate"><span class="pre">SEC(&quot;struct_ops/hid_rdesc_fixup&quot;)</span></code> or
<code class="docutils literal notranslate"><span class="pre">SEC(&quot;struct_ops.s/hid_rdesc_fixup&quot;)</span></code> in libbpf</p></li>
</ol>
<p>A <code class="docutils literal notranslate"><span class="pre">hid_device_event</span></code> is calling a BPF program when an event is received from
the device. Thus we are in IRQ context and can act on the data or notify userspace.
And given that we are in IRQ context, we can not talk back to the device.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">syscall</span></code> means that userspace called the syscall <code class="docutils literal notranslate"><span class="pre">BPF_PROG_RUN</span></code> facility.
This time, we can do any operations allowed by HID-BPF, and talking to the device is
allowed.</p>
<p>Last, <code class="docutils literal notranslate"><span class="pre">hid_rdesc_fixup</span></code> is different from the others as there can be only one
BPF program of this type. This is called on <code class="docutils literal notranslate"><span class="pre">probe</span></code> from the driver and allows to
change the report descriptor from the BPF program. Once a <code class="docutils literal notranslate"><span class="pre">hid_rdesc_fixup</span></code>
program has been loaded, it is not possible to overwrite it unless the program which
inserted it allows us by pinning the program and closing all of its fds pointing to it.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">hid_rdesc_fixup</span></code> can be declared as sleepable (<code class="docutils literal notranslate"><span class="pre">SEC(&quot;struct_ops.s/hid_rdesc_fixup&quot;)</span></code>).</p>
</section>
<section id="developer-api">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Developer API:</a><a class="headerlink" href="#developer-api" title="Link to this heading">¶</a></h2>
<section id="available-struct-ops-for-hid-bpf">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Available <code class="docutils literal notranslate"><span class="pre">struct_ops</span></code> for HID-BPF:</a><a class="headerlink" href="#available-struct-ops-for-hid-bpf" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.hid_bpf_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_ops</span></span></span><a class="headerlink" href="#c.hid_bpf_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>A BPF struct_ops of callbacks allowing to attach HID-BPF programs to a HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hid_bpf_ops {
    int hid_id;
    u32 flags;
    int (*hid_device_event)(struct hid_bpf_ctx *ctx, enum hid_report_type report_type, u64 source);
    int (*hid_rdesc_fixup)(struct hid_bpf_ctx *ctx);
    int (*hid_hw_request)(struct hid_bpf_ctx *ctx, unsigned char reportnum,enum hid_report_type rtype, enum hid_class_request reqtype, u64 source);
    int (*hid_hw_output_report)(struct hid_bpf_ctx *ctx, u64 source);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">hid_id</span></code></dt><dd><p>the HID uniq ID to attach to. This is writeable before <code class="docutils literal notranslate"><span class="pre">load()</span></code>, and
cannot be changed after</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags used while attaching the struct_ops to the device. Currently only
available value is <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">BPF_F_BEFORE</span></code>.
Writeable only before <code class="docutils literal notranslate"><span class="pre">load()</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hid_device_event</span></code></dt><dd><p>called whenever an event is coming in from the device</p>
<p>It has the following arguments:</p>
<p><code class="docutils literal notranslate"><span class="pre">ctx</span></code>: The HID-BPF context as <a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span></code></a></p>
<p>Return: <code class="docutils literal notranslate"><span class="pre">0</span></code> on success and keep processing; a positive
value to change the incoming size buffer; a negative
error code to interrupt the processing of this event</p>
<p>Context: Interrupt context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hid_rdesc_fixup</span></code></dt><dd><p>called when the probe function parses the report descriptor
of the HID device</p>
<p>It has the following arguments:</p>
<p><code class="docutils literal notranslate"><span class="pre">ctx</span></code>: The HID-BPF context as <a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span></code></a></p>
<p>Return: <code class="docutils literal notranslate"><span class="pre">0</span></code> on success and keep processing; a positive
value to change the incoming size buffer; a negative
error code to interrupt the processing of this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hid_hw_request</span></code></dt><dd><p>called whenever a hid_hw_raw_request() call is emitted
on the HID device</p>
<p>It has the following arguments:</p>
<p><code class="docutils literal notranslate"><span class="pre">ctx</span></code>: The HID-BPF context as <a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span></code></a></p>
<p><code class="docutils literal notranslate"><span class="pre">reportnum</span></code>: the report number, as in hid_hw_raw_request()</p>
<p><code class="docutils literal notranslate"><span class="pre">rtype</span></code>: the report type (<code class="docutils literal notranslate"><span class="pre">HID_INPUT_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_FEATURE_REPORT</span></code>,
<code class="docutils literal notranslate"><span class="pre">HID_OUTPUT_REPORT</span></code>)</p>
<p><code class="docutils literal notranslate"><span class="pre">reqtype</span></code>: the request</p>
<p><code class="docutils literal notranslate"><span class="pre">source</span></code>: a u64 referring to a uniq but identifiable source. If <code class="docutils literal notranslate"><span class="pre">0</span></code>, the
kernel itself emitted that call. For hidraw, <code class="docutils literal notranslate"><span class="pre">source</span></code> is set
to the associated <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span></code>.</p>
<p>Return: <code class="docutils literal notranslate"><span class="pre">0</span></code> to keep processing the request by hid-core; any other value
stops hid-core from processing that event. A positive value should be
returned with the number of bytes returned in the incoming buffer; a
negative error code interrupts the processing of this call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hid_hw_output_report</span></code></dt><dd><p>called whenever a hid_hw_output_report() call is emitted
on the HID device</p>
<p>It has the following arguments:</p>
<p><code class="docutils literal notranslate"><span class="pre">ctx</span></code>: The HID-BPF context as <a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span></code></a></p>
<p><code class="docutils literal notranslate"><span class="pre">source</span></code>: a u64 referring to a uniq but identifiable source. If <code class="docutils literal notranslate"><span class="pre">0</span></code>, the
kernel itself emitted that call. For hidraw, <code class="docutils literal notranslate"><span class="pre">source</span></code> is set
to the associated <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span></code>.</p>
<p>Return: <code class="docutils literal notranslate"><span class="pre">0</span></code> to keep processing the request by hid-core; any other value
stops hid-core from processing that event. A positive value should be
returned with the number of bytes written to the device; a negative error
code interrupts the processing of this call.</p>
</dd>
</dl>
</div>
</section>
<section id="user-api-data-structures-available-in-programs">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">User API data structures available in programs:</a><a class="headerlink" href="#user-api-data-structures-available-in-programs" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.hid_bpf_ctx">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_ctx</span></span></span><a class="headerlink" href="#c.hid_bpf_ctx" title="Link to this definition">¶</a><br /></dt>
<dd><p>User accessible data for all HID programs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hid_bpf_ctx {
    struct hid_device *hid;
    __u32 allocated_size;
    union {
        __s32 retval;
        __s32 size;
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">hid</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_device</span></code> representing the device itself</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allocated_size</span></code></dt><dd><p>Allocated size of data.</p>
<p>This is how much memory is available and can be requested
by the HID program.
Note that for <code class="docutils literal notranslate"><span class="pre">HID_BPF_RDESC_FIXUP</span></code>, that memory is set to
<code class="docutils literal notranslate"><span class="pre">4096</span></code> (4 KB)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">retval</span></code></dt><dd><p>Return value of the previous program.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Valid data in the data field.</p>
<p>Programs can get the available valid size in data by fetching this field.
Programs can also change this value by returning a positive number in the
program.
To discard the event, return a negative error code.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> must always be less or equal than <code class="docutils literal notranslate"><span class="pre">allocated_size</span></code> (it is enforced
once all BPF programs have been run).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">data</span></code> is not directly accessible from the context. We need to issue
a call to <a class="reference internal" href="#c.hid_bpf_get_data" title="hid_bpf_get_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_get_data()</span></code></a> in order to get a pointer to that field.</p>
<p><code class="docutils literal notranslate"><span class="pre">hid</span></code> and <code class="docutils literal notranslate"><span class="pre">allocated_size</span></code> are read-only, <code class="docutils literal notranslate"><span class="pre">size</span></code> and <code class="docutils literal notranslate"><span class="pre">retval</span></code> are read-write.</p>
</section>
<section id="available-api-that-can-be-used-in-all-hid-bpf-struct-ops-programs">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Available API that can be used in all HID-BPF struct_ops programs:</a><a class="headerlink" href="#available-api-that-can-be-used-in-all-hid-bpf-struct-ops-programs" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_get_data">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="n"><span class="pre">__u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_get_data</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">rdwr_buf_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_get_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the kernel memory pointer associated with the context <strong>ctx</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>The HID-BPF context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>The offset within the memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">size_t</span> <span class="pre">rdwr_buf_size</span></code></dt><dd><p>the const size of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>returns</strong> <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error, an <code class="docutils literal notranslate"><span class="pre">__u8</span></code> memory pointer on success</p>
</div>
</section>
<section id="available-api-that-can-be-used-in-syscall-hid-bpf-programs-or-in-sleepable-hid-bpf-struct-ops-programs">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Available API that can be used in syscall HID-BPF programs or in sleepable HID-BPF struct_ops programs:</a><a class="headerlink" href="#available-api-that-can-be-used-in-syscall-hid-bpf-programs-or-in-sleepable-hid-bpf-struct-ops-programs" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_allocate_context">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_allocate_context</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">hid_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_allocate_context" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate a context to the given HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hid_id</span></code></dt><dd><p>the system unique identifier of the HID device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>returns</strong> A pointer to <a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span></code></a> on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_release_context">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_release_context</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_release_context" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release the previously allocated context <strong>ctx</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the HID-BPF context to release</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_hw_request">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_hw_request</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">__u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">buf__sz</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hid_report_type</span></span><span class="w"> </span><span class="n"><span class="pre">rtype</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hid_class_request</span></span><span class="w"> </span><span class="n"><span class="pre">reqtype</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_hw_request" title="Link to this definition">¶</a><br /></dt>
<dd><p>Communicate with a HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the HID-BPF context previously allocated in <a class="reference internal" href="#c.hid_bpf_allocate_context" title="hid_bpf_allocate_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_allocate_context()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">*buf</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">PTR_TO_MEM</span></code> buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buf__sz</span></code></dt><dd><p>the size of the data to transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_report_type</span> <span class="pre">rtype</span></code></dt><dd><p>the type of the report (<code class="docutils literal notranslate"><span class="pre">HID_INPUT_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_FEATURE_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_OUTPUT_REPORT</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_class_request</span> <span class="pre">reqtype</span></code></dt><dd><p>the type of the request (<code class="docutils literal notranslate"><span class="pre">HID_REQ_GET_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_REQ_SET_REPORT</span></code>, ...)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>returns</strong> <code class="docutils literal notranslate"><span class="pre">0</span></code> on success, a negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_hw_output_report">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_hw_output_report</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">__u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">buf__sz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_hw_output_report" title="Link to this definition">¶</a><br /></dt>
<dd><p>Send an output report to a HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the HID-BPF context previously allocated in <a class="reference internal" href="#c.hid_bpf_allocate_context" title="hid_bpf_allocate_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_allocate_context()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">*buf</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">PTR_TO_MEM</span></code> buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buf__sz</span></code></dt><dd><p>the size of the data to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success, a negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_try_input_report">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_try_input_report</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hid_report_type</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">buf__sz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_try_input_report" title="Link to this definition">¶</a><br /></dt>
<dd><p>Inject a HID report in the kernel from a HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the HID-BPF context previously allocated in <a class="reference internal" href="#c.hid_bpf_allocate_context" title="hid_bpf_allocate_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_allocate_context()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_report_type</span> <span class="pre">type</span></code></dt><dd><p>the type of the report (<code class="docutils literal notranslate"><span class="pre">HID_INPUT_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_FEATURE_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_OUTPUT_REPORT</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">PTR_TO_MEM</span></code> buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">size_t</span> <span class="pre">buf__sz</span></code></dt><dd><p>the size of the data to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">0</span></code> on success, a negative error code otherwise. This function will immediately
fail if the device is not available, thus can be safely used in IRQ context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_input_report">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_input_report</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hid_report_type</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">buf__sz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_input_report" title="Link to this definition">¶</a><br /></dt>
<dd><p>Inject a HID report in the kernel from a HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the HID-BPF context previously allocated in <a class="reference internal" href="#c.hid_bpf_allocate_context" title="hid_bpf_allocate_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_allocate_context()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_report_type</span> <span class="pre">type</span></code></dt><dd><p>the type of the report (<code class="docutils literal notranslate"><span class="pre">HID_INPUT_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_FEATURE_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_OUTPUT_REPORT</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">PTR_TO_MEM</span></code> buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">size_t</span> <span class="pre">buf__sz</span></code></dt><dd><p>the size of the data to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">0</span></code> on success, a negative error code otherwise. This function will wait for the
device to be available before injecting the event, thus needs to be called in sleepable
context.</p>
</div>
</section>
</section>
<section id="general-overview-of-a-hid-bpf-program">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">General overview of a HID-BPF program</a><a class="headerlink" href="#general-overview-of-a-hid-bpf-program" title="Link to this heading">¶</a></h2>
<section id="accessing-the-data-attached-to-the-context">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Accessing the data attached to the context</a><a class="headerlink" href="#accessing-the-data-attached-to-the-context" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span></code> doesn’t export the <code class="docutils literal notranslate"><span class="pre">data</span></code> fields directly and to access
it, a bpf program needs to first call <a class="reference internal" href="#c.hid_bpf_get_data" title="hid_bpf_get_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_get_data()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">offset</span></code> can be any integer, but <code class="docutils literal notranslate"><span class="pre">size</span></code> needs to be constant, known at compile
time.</p>
<p>This allows the following:</p>
<ol class="arabic">
<li><p>for a given device, if we know that the report length will always be of a certain value,
we can request the <code class="docutils literal notranslate"><span class="pre">data</span></code> pointer to point at the full report length.</p>
<p>The kernel will ensure we are using a correct size and offset and eBPF will ensure
the code will not attempt to read or write outside of the boundaries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u8 *data = hid_bpf_get_data(ctx, 0 /* offset */, 256 /* size */);

if (!data)
    return 0; /* ensure data is correct, now the verifier knows we
               * have 256 bytes available */

bpf_printk(&quot;hello world: %02x %02x %02x&quot;, data[0], data[128], data[255]);
</pre></div>
</div>
</li>
<li><p>if the report length is variable, but we know the value of <code class="docutils literal notranslate"><span class="pre">X</span></code> is always a 16-bit
integer, we can then have a pointer to that value only:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u16 *x = hid_bpf_get_data(ctx, offset, sizeof(*x));

if (!x)
    return 0; /* something went wrong */

*x += 1; /* increment X by one */
</pre></div>
</div>
</li>
</ol>
</section>
<section id="effect-of-a-hid-bpf-program">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Effect of a HID-BPF program</a><a class="headerlink" href="#effect-of-a-hid-bpf-program" title="Link to this heading">¶</a></h3>
<p>For all HID-BPF attachment types except for <code class="xref c c-func docutils literal notranslate"><span class="pre">hid_rdesc_fixup()</span></code>, several eBPF
programs can be attached to the same device. If a HID-BPF struct_ops has a
<code class="xref c c-func docutils literal notranslate"><span class="pre">hid_rdesc_fixup()</span></code> while another is already attached to the device, the
kernel will return <cite>-EINVAL</cite> when attaching the struct_ops.</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">BPF_F_BEFORE</span></code> is added to the flags while attaching the program, the new
program is appended at the end of the list.
<code class="docutils literal notranslate"><span class="pre">BPF_F_BEFORE</span></code> will insert the new program at the beginning of the list which is
useful for e.g. tracing where we need to get the unprocessed events from the device.</p>
<p>Note that if there are multiple programs using the <code class="docutils literal notranslate"><span class="pre">BPF_F_BEFORE</span></code> flag,
only the most recently loaded one is actually the first in the list.</p>
<section id="sec-struct-ops-hid-device-event">
<h4><code class="docutils literal notranslate"><span class="pre">SEC(&quot;struct_ops/hid_device_event&quot;)</span></code><a class="headerlink" href="#sec-struct-ops-hid-device-event" title="Link to this heading">¶</a></h4>
<p>Whenever a matching event is raised, the eBPF programs are called one after the other
and are working on the same data buffer.</p>
<p>If a program changes the data associated with the context, the next one will see
the modified data but it will have <em>no</em> idea of what the original data was.</p>
<p>Once all the programs are run and return <code class="docutils literal notranslate"><span class="pre">0</span></code> or a positive value, the rest of the
HID stack will work on the modified data, with the <code class="docutils literal notranslate"><span class="pre">size</span></code> field of the last hid_bpf_ctx
being the new size of the input stream of data.</p>
<p>A BPF program returning a negative error discards the event, i.e. this event will not be
processed by the HID stack. Clients (hidraw, input, LEDs) will <strong>not</strong> see this event.</p>
</section>
<section id="sec-syscall">
<h4><code class="docutils literal notranslate"><span class="pre">SEC(&quot;syscall&quot;)</span></code><a class="headerlink" href="#sec-syscall" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">syscall</span></code> are not attached to a given device. To tell which device we are working
with, userspace needs to refer to the device by its unique system id (the last 4 numbers
in the sysfs path: <code class="docutils literal notranslate"><span class="pre">/sys/bus/hid/devices/xxxx:yyyy:zzzz:0000</span></code>).</p>
<p>To retrieve a context associated with the device, the program must call
<a class="reference internal" href="#c.hid_bpf_allocate_context" title="hid_bpf_allocate_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_allocate_context()</span></code></a> and must release it with <a class="reference internal" href="#c.hid_bpf_release_context" title="hid_bpf_release_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_release_context()</span></code></a>
before returning.
Once the context is retrieved, one can also request a pointer to kernel memory with
<a class="reference internal" href="#c.hid_bpf_get_data" title="hid_bpf_get_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_get_data()</span></code></a>. This memory is big enough to support all input/output/feature
reports of the given device.</p>
</section>
<section id="sec-struct-ops-hid-rdesc-fixup">
<h4><code class="docutils literal notranslate"><span class="pre">SEC(&quot;struct_ops/hid_rdesc_fixup&quot;)</span></code><a class="headerlink" href="#sec-struct-ops-hid-rdesc-fixup" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">hid_rdesc_fixup</span></code> program works in a similar manner to <code class="docutils literal notranslate"><span class="pre">.report_fixup</span></code>
of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_driver</span></code>.</p>
<p>When the device is probed, the kernel sets the data buffer of the context with the
content of the report descriptor. The memory associated with that buffer is
<code class="docutils literal notranslate"><span class="pre">HID_MAX_DESCRIPTOR_SIZE</span></code> (currently 4kB).</p>
<p>The eBPF program can modify the data buffer at-will and the kernel uses the
modified content and size as the report descriptor.</p>
<p>Whenever a struct_ops containing a <code class="docutils literal notranslate"><span class="pre">SEC(&quot;struct_ops/hid_rdesc_fixup&quot;)</span></code> program
is attached (if no program was attached before), the kernel immediately disconnects
the HID device and does a reprobe.</p>
<p>In the same way, when this struct_ops is detached, the kernel issues a disconnect
on the device.</p>
<p>There is no <code class="docutils literal notranslate"><span class="pre">detach</span></code> facility in HID-BPF. Detaching a program happens when
all the user space file descriptors pointing at a HID-BPF struct_ops link are closed.
Thus, if we need to replace a report descriptor fixup, some cooperation is
required from the owner of the original report descriptor fixup.
The previous owner will likely pin the struct_ops link in the bpffs, and we can then
replace it through normal bpf operations.</p>
</section>
</section>
</section>
<section id="attaching-a-bpf-program-to-a-device">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">Attaching a bpf program to a device</a><a class="headerlink" href="#attaching-a-bpf-program-to-a-device" title="Link to this heading">¶</a></h2>
<p>We now use standard struct_ops attachment through <code class="docutils literal notranslate"><span class="pre">bpf_map__attach_struct_ops()</span></code>.
But given that we need to attach a struct_ops to a dedicated HID device, the caller
must set <code class="docutils literal notranslate"><span class="pre">hid_id</span></code> in the struct_ops map before loading the program in the kernel.</p>
<p><code class="docutils literal notranslate"><span class="pre">hid_id</span></code> is the unique system ID of the HID device (the last 4 numbers in the
sysfs path: <code class="docutils literal notranslate"><span class="pre">/sys/bus/hid/devices/xxxx:yyyy:zzzz:0000</span></code>)</p>
<p>One can also set <code class="docutils literal notranslate"><span class="pre">flags</span></code>, which is of type <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_bpf_attach_flags</span></code>.</p>
<p>We can not rely on hidraw to bind a BPF program to a HID device. hidraw is an
artefact of the processing of the HID device, and is not stable. Some drivers
even disable it, so that removes the tracing capabilities on those devices
(where it is interesting to get the non-hidraw traces).</p>
<p>On the other hand, the <code class="docutils literal notranslate"><span class="pre">hid_id</span></code> is stable for the entire life of the HID device,
even if we change its report descriptor.</p>
<p>Given that hidraw is not stable when the device disconnects/reconnects, we recommend
accessing the current report descriptor of the device through the sysfs.
This is available at <code class="docutils literal notranslate"><span class="pre">/sys/bus/hid/devices/BUS:VID:PID.000N/report_descriptor</span></code> as a
binary stream.</p>
<p>Parsing the report descriptor is the responsibility of the BPF programmer or the userspace
component that loads the eBPF program.</p>
</section>
<section id="an-almost-complete-example-of-a-bpf-enhanced-hid-device">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">An (almost) complete example of a BPF enhanced HID device</a><a class="headerlink" href="#an-almost-complete-example-of-a-bpf-enhanced-hid-device" title="Link to this heading">¶</a></h2>
<p><em>Foreword: for most parts, this could be implemented as a kernel driver</em></p>
<p>Let’s imagine we have a new tablet device that has some haptic capabilities
to simulate the surface the user is scratching on. This device would also have
a specific 3 positions switch to toggle between <em>pencil on paper</em>, <em>cray on a wall</em>
and <em>brush on a painting canvas</em>. To make things even better, we can control the
physical position of the switch through a feature report.</p>
<p>And of course, the switch is relying on some userspace component to control the
haptic feature of the device itself.</p>
<section id="filtering-events">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Filtering events</a><a class="headerlink" href="#filtering-events" title="Link to this heading">¶</a></h3>
<p>The first step consists in filtering events from the device. Given that the switch
position is actually reported in the flow of the pen events, using hidraw to implement
that filtering would mean that we wake up userspace for every single event.</p>
<p>This is OK for libinput, but having an external library that is just interested in
one byte in the report is less than ideal.</p>
<p>For that, we can create a basic skeleton for our BPF program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &quot;vmlinux.h&quot;
#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;

/* HID programs need to be GPL */
char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;;

/* HID-BPF kfunc API definitions */
extern __u8 *hid_bpf_get_data(struct hid_bpf_ctx *ctx,
                            unsigned int offset,
                            const size_t __sz) __ksym;

struct {
      __uint(type, BPF_MAP_TYPE_RINGBUF);
      __uint(max_entries, 4096 * 64);
} ringbuf SEC(&quot;.maps&quot;);

__u8 current_value = 0;

SEC(&quot;struct_ops/hid_device_event&quot;)
int BPF_PROG(filter_switch, struct hid_bpf_ctx *hid_ctx)
{
      __u8 *data = hid_bpf_get_data(hid_ctx, 0 /* offset */, 192 /* size */);
      __u8 *buf;

      if (!data)
              return 0; /* EPERM check */

      if (current_value != data[152]) {
              buf = bpf_ringbuf_reserve(&amp;ringbuf, 1, 0);
              if (!buf)
                      return 0;

              *buf = data[152];

              bpf_ringbuf_commit(buf, 0);

              current_value = data[152];
      }

      return 0;
}

SEC(&quot;.struct_ops.link&quot;)
struct hid_bpf_ops haptic_tablet = {
      .hid_device_event = (void *)filter_switch,
};
</pre></div>
</div>
<p>To attach <code class="docutils literal notranslate"><span class="pre">haptic_tablet</span></code>, userspace needs to set <code class="docutils literal notranslate"><span class="pre">hid_id</span></code> first:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int attach_filter(struct hid *hid_skel, int hid_id)
{
      int err, link_fd;

      hid_skel-&gt;struct_ops.haptic_tablet-&gt;hid_id = hid_id;
      err = hid__load(skel);
      if (err)
              return err;

      link_fd = bpf_map__attach_struct_ops(hid_skel-&gt;maps.haptic_tablet);
      if (!link_fd) {
              fprintf(stderr, &quot;can not attach HID-BPF program: %m\n&quot;);
              return -1;
      }

      return link_fd; /* the fd of the created bpf_link */
}
</pre></div>
</div>
<p>Our userspace program can now listen to notifications on the ring buffer, and
is awaken only when the value changes.</p>
<p>When the userspace program doesn’t need to listen to events anymore, it can just
close the returned bpf link from <code class="xref c c-func docutils literal notranslate"><span class="pre">attach_filter()</span></code>, which will tell the kernel to
detach the program from the HID device.</p>
<p>Of course, in other use cases, the userspace program can also pin the fd to the
BPF filesystem through a call to <code class="xref c c-func docutils literal notranslate"><span class="pre">bpf_obj_pin()</span></code>, as with any bpf_link.</p>
</section>
<section id="controlling-the-device">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Controlling the device</a><a class="headerlink" href="#controlling-the-device" title="Link to this heading">¶</a></h3>
<p>To be able to change the haptic feedback from the tablet, the userspace program
needs to emit a feature report on the device itself.</p>
<p>Instead of using hidraw for that, we can create a <code class="docutils literal notranslate"><span class="pre">SEC(&quot;syscall&quot;)</span></code> program
that talks to the device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* some more HID-BPF kfunc API definitions */
extern struct hid_bpf_ctx *hid_bpf_allocate_context(unsigned int hid_id) __ksym;
extern void hid_bpf_release_context(struct hid_bpf_ctx *ctx) __ksym;
extern int hid_bpf_hw_request(struct hid_bpf_ctx *ctx,
                            __u8* data,
                            size_t len,
                            enum hid_report_type type,
                            enum hid_class_request reqtype) __ksym;


struct hid_send_haptics_args {
      /* data needs to come at offset 0 so we can do a memcpy into it */
      __u8 data[10];
      unsigned int hid;
};

SEC(&quot;syscall&quot;)
int send_haptic(struct hid_send_haptics_args *args)
{
      struct hid_bpf_ctx *ctx;
      int ret = 0;

      ctx = hid_bpf_allocate_context(args-&gt;hid);
      if (!ctx)
              return 0; /* EPERM check */

      ret = hid_bpf_hw_request(ctx,
                               args-&gt;data,
                               10,
                               HID_FEATURE_REPORT,
                               HID_REQ_SET_REPORT);

      hid_bpf_release_context(ctx);

      return ret;
}
</pre></div>
</div>
<p>And then userspace needs to call that program directly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int set_haptic(struct hid *hid_skel, int hid_id, __u8 haptic_value)
{
      int err, prog_fd;
      int ret = -1;
      struct hid_send_haptics_args args = {
              .hid = hid_id,
      };
      DECLARE_LIBBPF_OPTS(bpf_test_run_opts, tattrs,
              .ctx_in = &amp;args,
              .ctx_size_in = sizeof(args),
      );

      args.data[0] = 0x02; /* report ID of the feature on our device */
      args.data[1] = haptic_value;

      prog_fd = bpf_program__fd(hid_skel-&gt;progs.set_haptic);

      err = bpf_prog_test_run_opts(prog_fd, &amp;tattrs);
      return err;
}
</pre></div>
</div>
<p>Now our userspace program is aware of the haptic state and can control it. The
program could make this state further available to other userspace programs
(e.g. via a DBus API).</p>
<p>The interesting bit here is that we did not created a new kernel API for this.
Which means that if there is a bug in our implementation, we can change the
interface with the kernel at-will, because the userspace application is
responsible for its own usage.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/hid/hid-bpf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>