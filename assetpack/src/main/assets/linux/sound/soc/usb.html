<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>ASoC USB support &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Advanced Linux Sound Architecture - Driver Configuration guide" href="../alsa-configuration.html" />
    <link rel="prev" title="Creating codec to codec dai link for ALSA dapm" href="codec-to-codec.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../input/index.html">Input Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../gpu/index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sound/soc/usb.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="asoc-usb-support">
<h1>ASoC USB support<a class="headerlink" href="#asoc-usb-support" title="Link to this heading">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>In order to leverage the existing USB sound device support in ALSA, the
ASoC USB APIs are introduced to allow the subsystems to exchange
configuration information.</p>
<p>One potential use case would be to support USB audio offloading, which is
an implementation that allows for an alternate power-optimized path in the audio
subsystem to handle the transfer of audio data over the USB bus.  This would
let the main processor to stay in lower power modes for longer duration.  The
following is an example design of how the ASoC and ALSA pieces can be connected
together to achieve this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           USB                   |            ASoC
                                 |  _________________________
                                 | |   ASoC Platform card    |
                                 | |_________________________|
                                 |         |           |
                                 |      ___V____   ____V____
                                 |     |ASoC BE | |ASoC FE  |
                                 |     |DAI LNK | |DAI LNK  |
                                 |     |________| |_________|
                                 |         ^  ^        ^
                                 |         |  |________|
                                 |      ___V____    |
                                 |     |SoC-USB |   |
 ________       ________               |        |   |
|USB SND |&lt;---&gt;|USBSND  |&lt;------------&gt;|________|   |
|(card.c)|     |offld   |&lt;----------                |
|________|     |________|___     | |                |
    ^               ^       |    | |    ____________V_________
    |               |       |    | |   |IPC                   |
 __ V_______________V_____  |    | |   |______________________|
|USB SND (endpoint.c)     | |    | |              ^
|_________________________| |    | |              |
            ^               |    | |   ___________V___________
            |               |    | |-&gt;|audio DSP              |
 ___________V_____________  |    |    |_______________________|
|XHCI HCD                 |&lt;-    |
|_________________________|      |
</pre></div>
</div>
</section>
<section id="soc-usb-driver">
<h2>SoC USB driver<a class="headerlink" href="#soc-usb-driver" title="Link to this heading">¶</a></h2>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_usb</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code>: list head for SND SoC struct list</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">component</span></code>: reference to ASoC component</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">connection_status_cb</span></code>: callback to notify connection events</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">update_offload_route_info</span></code>: callback to fetch selected USB sound card/PCM
device</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">priv_data</span></code>: driver data</p></li>
</ul>
</div></blockquote>
<p>The snd_soc_usb structure can be referenced using the ASoC platform card
device, or a USB device (udev-&gt;dev).  This is created by the ASoC BE DAI
link, and the USB sound entity will be able to pass information to the
ASoC BE DAI link using this structure.</p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_usb_device</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">card_idx</span></code>: sound card index associated with USB sound device</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chip_idx</span></code>: USB sound chip array index</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cpcm_idx</span></code>: capture pcm device indexes associated with the USB sound device</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppcm_idx</span></code>: playback pcm device indexes associated with the USB sound device</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_playback</span></code>: number of playback streams</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_capture</span></code>: number of capture streams</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code>: list head for the USB sound device list</p></li>
</ul>
</div></blockquote>
<p>The struct snd_soc_usb_device is created by the USB sound offload driver.
This will carry basic parameters/limitations that will be used to
determine the possible offloading paths for this USB audio device.</p>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h3>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>int snd_soc_usb_find_supported_format(int card_idx,
                struct snd_pcm_hw_params *params, int direction)
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">card_idx</span></code>: the index into the USB sound chip array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">params</span></code>: Requested PCM parameters from the USB DPCM BE DAI link</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code>: capture or playback</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_find_supported_format()</strong> ensures that the requested audio profile
being requested by the external DSP is supported by the USB device.</p>
<p>Returns 0 on success, and -EOPNOTSUPP on failure.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>int snd_soc_usb_connect(struct device <span class="ge">*usbdev, struct snd_soc_usb_device *</span>sdev)
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">usbdev</span></code>: the usb device that was discovered</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sdev</span></code>: capabilities of the device</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_connect()</strong> notifies the ASoC USB DCPM BE DAI link of a USB
audio device detection.  This can be utilized in the BE DAI
driver to keep track of available USB audio devices.  This is intended
to be called by the USB offload driver residing in USB SND.</p>
<p>Returns 0 on success, negative error code on failure.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>int snd_soc_usb_disconnect(struct device <span class="ge">*usbdev, struct snd_soc_usb_device *</span>sdev)
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">usbdev</span></code>: the usb device that was removed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sdev</span></code>: capabilities to free</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_disconnect()</strong> notifies the ASoC USB DCPM BE DAI link of a USB
audio device removal.  This is intended to be called by the USB offload
driver that resides in USB SND.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>void <span class="ge">*snd_soc_usb_find_priv_data(struct device *</span>usbdev)
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">usbdev</span></code>: the usb device to reference to find private data</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_find_priv_data()</strong> fetches the private data saved to the SoC USB
device.</p>
<p>Returns pointer to priv_data on success, NULL on failure.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>int snd_soc_usb_setup_offload_jack(struct snd_soc_component *component,
                                struct snd_soc_jack *jack)
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">component</span></code>: ASoC component to add the jack</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jack</span></code>: jack component to populate</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_setup_offload_jack()</strong> is a helper to add a sound jack control to
the platform sound card.  This will allow for consistent naming to be used on
designs that support USB audio offloading.  Additionally, this will enable the
jack to notify of changes.</p>
<p>Returns 0 on success, negative otherwise.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>int snd_soc_usb_update_offload_route(struct device *dev, int card, int pcm,
                                     int direction, enum snd_soc_usb_kctl path,
                                     long *route)
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dev</span></code>: USB device to look up offload path mapping</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">card</span></code>: USB sound card index</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pcm</span></code>: USB sound PCM device index</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code>: direction to fetch offload routing information</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">path</span></code>: kcontrol selector - pcm device or card index</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">route</span></code>: mapping of sound card and pcm indexes for the offload path.  This is</dt><dd><p>an array of two integers that will carry the card and pcm device indexes
in that specific order.  This can be used as the array for the kcontrol
output.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_update_offload_route()</strong> calls a registered callback to the USB BE DAI
link to fetch the information about the mapped ASoC devices for executing USB audio
offload for the device. <code class="docutils literal notranslate"><span class="pre">route</span></code> may be a pointer to a kcontrol value output array,
which carries values when the kcontrol is read.</p>
<p>Returns 0 on success, negative otherwise.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>struct snd_soc_usb <span class="ge">*snd_soc_usb_allocate_port(struct snd_soc_component *</span>component,
                void *data);
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">component</span></code>: DPCM BE DAI link component</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: private data</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_allocate_port()</strong> allocates a SoC USB device and populates standard
parameters that is used for further operations.</p>
<p>Returns a pointer to struct soc_usb on success, negative on error.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>void snd_soc_usb_free_port(struct snd_soc_usb *usb);
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">usb</span></code>: SoC USB device to free</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_free_port()</strong> frees a SoC USB device.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>void snd_soc_usb_add_port(struct snd_soc_usb *usb);
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">usb</span></code>: SoC USB device to add</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_add_port()</strong> add an allocated SoC USB device to the SOC USB framework.
Once added, this device can be referenced by further operations.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>void snd_soc_usb_remove_port(struct snd_soc_usb *usb);
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">usb</span></code>: SoC USB device to remove</p></li>
</ul>
</div></blockquote>
<p><strong>snd_soc_usb_remove_port()</strong> removes a SoC USB device from the SoC USB framework.
After removing a device, any SOC USB operations would not be able to reference the
device removed.</p>
</section>
<section id="how-to-register-to-soc-usb">
<h3>How to Register to SoC USB<a class="headerlink" href="#how-to-register-to-soc-usb" title="Link to this heading">¶</a></h3>
<p>The ASoC DPCM USB BE DAI link is the entity responsible for allocating and
registering the SoC USB device on the component bind.  Likewise, it will
also be responsible for freeing the allocated resources.  An example can
be shown below:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>static int q6usb_component_probe(struct snd_soc_component *component)
{
        ...
        data-&gt;usb = snd_soc_usb_allocate_port(component, 1, &amp;data-&gt;priv);
        if (!data-&gt;usb)
                return -ENOMEM;

        usb-&gt;connection_status_cb = q6usb_alsa_connection_cb;

        ret = snd_soc_usb_add_port(usb);
        if (ret &lt; 0) {
                dev_err(component-&gt;dev, &quot;failed to add usb port\n&quot;);
                goto free_usb;
        }
<span class="cp">        ...</span>
}

static void q6usb_component_remove(struct snd_soc_component *component)
{
        ...
        snd_soc_usb_remove_port(data-&gt;usb);
        snd_soc_usb_free_port(data-&gt;usb);
}

static const struct snd_soc_component_driver q6usb_dai_component = {
        .probe = q6usb_component_probe,
        .remove = q6usb_component_remove,
        .name = &quot;q6usb-dai-component&quot;,
<span class="cp">        ...</span>
};
</pre></div>
</div>
<p>BE DAI links can pass along vendor specific information as part of the
call to allocate the SoC USB device.  This will allow any BE DAI link
parameters or settings to be accessed by the USB offload driver that
resides in USB SND.</p>
</section>
<section id="usb-audio-device-connection-flow">
<h3>USB Audio Device Connection Flow<a class="headerlink" href="#usb-audio-device-connection-flow" title="Link to this heading">¶</a></h3>
<p>USB devices can be hotplugged into the USB ports at any point in time.
The BE DAI link should be aware of the current state of the physical USB
port, i.e. if there are any USB devices with audio interface(s) connected.
connection_status_cb() can be used to notify the BE DAI link of any change.</p>
<p>This is called whenever there is a USB SND interface bind or remove event,
using snd_soc_usb_connect() or snd_soc_usb_disconnect():</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>static void qc_usb_audio_offload_probe(struct snd_usb_audio *chip)
{
        ...
        snd_soc_usb_connect(usb_get_usb_backend(udev), sdev);
<span class="cp">        ...</span>
}

static void qc_usb_audio_offload_disconnect(struct snd_usb_audio *chip)
{
        ...
        snd_soc_usb_disconnect(usb_get_usb_backend(chip-&gt;dev), dev-&gt;sdev);
<span class="cp">        ...</span>
}
</pre></div>
</div>
<p>In order to account for conditions where driver or device existence is
not guaranteed, USB SND exposes snd_usb_rediscover_devices() to resend the
connect events for any identified USB audio interfaces.  Consider the
the following situation:</p>
<blockquote>
<div><dl>
<dt><strong>usb_audio_probe()</strong></dt><dd><div class="line-block">
<div class="line">--&gt; USB audio streams allocated and saved to usb_chip[]</div>
<div class="line">--&gt; Propagate connect event to USB offload driver in USB SND</div>
<div class="line">--&gt; <strong>snd_soc_usb_connect()</strong> exits as USB BE DAI link is not ready</div>
</div>
</dd>
<dt>BE DAI link component probe</dt><dd><div class="line-block">
<div class="line">--&gt; DAI link is probed and SoC USB port is allocated</div>
<div class="line">--&gt; The USB audio device connect event is missed</div>
</div>
</dd>
</dl>
</div></blockquote>
<p>To ensure connection events are not missed, <strong>snd_usb_rediscover_devices()</strong>
is executed when the SoC USB device is registered.  Now, when the BE DAI
link component probe occurs, the following highlights the sequence:</p>
<blockquote>
<div><dl>
<dt>BE DAI link component probe</dt><dd><div class="line-block">
<div class="line">--&gt; DAI link is probed and SoC USB port is allocated</div>
<div class="line">--&gt; SoC USB device added, and <strong>snd_usb_rediscover_devices()</strong> runs</div>
</div>
</dd>
<dt><strong>snd_usb_rediscover_devices()</strong></dt><dd><div class="line-block">
<div class="line">--&gt; Traverses through usb_chip[] and for non-NULL entries issue</div>
<div class="line-block">
<div class="line"><strong>connection_status_cb()</strong></div>
</div>
</div>
</dd>
</dl>
</div></blockquote>
<p>In the case where the USB offload driver is unbound, while USB SND is ready,
the <strong>snd_usb_rediscover_devices()</strong> is called during module init.  This allows
for the offloading path to also be enabled with the following flow:</p>
<blockquote>
<div><dl>
<dt><strong>usb_audio_probe()</strong></dt><dd><div class="line-block">
<div class="line">--&gt; USB audio streams allocated and saved to usb_chip[]</div>
<div class="line">--&gt; Propagate connect event to USB offload driver in USB SND</div>
<div class="line">--&gt; USB offload driver <strong>NOT</strong> ready!</div>
</div>
</dd>
<dt>BE DAI link component probe</dt><dd><div class="line-block">
<div class="line">--&gt; DAI link is probed and SoC USB port is allocated</div>
<div class="line">--&gt; No USB connect event due to missing USB offload driver</div>
</div>
</dd>
<dt>USB offload driver probe</dt><dd><div class="line-block">
<div class="line">--&gt; <strong>qc_usb_audio_offload_init()</strong></div>
<div class="line">--&gt; Calls <strong>snd_usb_rediscover_devices()</strong> to notify of devices</div>
</div>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="usb-offload-related-kcontrols">
<h2>USB Offload Related Kcontrols<a class="headerlink" href="#usb-offload-related-kcontrols" title="Link to this heading">¶</a></h2>
<section id="details">
<h3>Details<a class="headerlink" href="#details" title="Link to this heading">¶</a></h3>
<p>A set of kcontrols can be utilized by applications to help select the proper sound
devices to enable USB audio offloading.  SoC USB exposes the get_offload_dev()
callback that designs can use to ensure that the proper indices are returned to the
application.</p>
</section>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h3>
<p><strong>Example:</strong></p>
<blockquote>
<div><p><strong>Sound Cards</strong>:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 [SM8250MTPWCD938]: sm8250 - SM8250-MTP-WCD9380-WSA8810-VA-D
                                      SM8250-MTP-WCD9380-WSA8810-VA-DMIC
1 [Seri           ]: USB-Audio - Plantronics Blackwire 3225 Seri
                                      Plantronics Plantronics Blackwire
                                      3225 Seri at usb-xhci-hcd.1.auto-1.1,
                                      full sp
2 [C320M          ]: USB-Audio - Plantronics C320-M
            Plantronics Plantronics C320-M at usb-xhci-hcd.1.auto-1.2, full speed
</pre></div>
</div>
</div></blockquote>
<p><strong>PCM Devices</strong>:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>card 0: SM8250MTPWCD938 [SM8250-MTP-WCD9380-WSA8810-VA-D], device 0: MultiMedia1 (*) []
Subdevices: 1/1
Subdevice #0: subdevice #0
card 0: SM8250MTPWCD938 [SM8250-MTP-WCD9380-WSA8810-VA-D], device 1: MultiMedia2 (*) []
Subdevices: 1/1
Subdevice #0: subdevice #0
card 1: Seri [Plantronics Blackwire 3225 Seri], device 0: USB Audio [USB Audio]
Subdevices: 1/1
Subdevice #0: subdevice #0
card 2: C320M [Plantronics C320-M], device 0: USB Audio [USB Audio]
Subdevices: 1/1
Subdevice #0: subdevice #0
</pre></div>
</div>
</div></blockquote>
<p><strong>USB Sound Card</strong> - card#1:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>USB Offload Playback Card Route PCM#0   -1 (range -1-&gt;32)
USB Offload Playback PCM Route PCM#0    -1 (range -1-&gt;255)
</pre></div>
</div>
</div></blockquote>
<p><strong>USB Sound Card</strong> - card#2:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>USB Offload Playback Card Route PCM#0   0 (range -1-&gt;32)
USB Offload Playback PCM Route PCM#0    1 (range -1-&gt;255)
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p>The above example shows a scenario where the system has one ASoC platform card
(card#0) and two USB sound devices connected (card#1 and card#2).  When reading
the available kcontrols for each USB audio device, the following kcontrols lists
the mapped offload card and pcm device indexes for the specific USB device:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">USB</span> <span class="pre">Offload</span> <span class="pre">Playback</span> <span class="pre">Card</span> <span class="pre">Route</span> <span class="pre">PCM#*</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">USB</span> <span class="pre">Offload</span> <span class="pre">Playback</span> <span class="pre">PCM</span> <span class="pre">Route</span> <span class="pre">PCM#*</span></code></p>
</div></blockquote>
<p>The kcontrol is indexed, because a USB audio device could potentially have
several PCM devices.  The above kcontrols are defined as:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">USB</span> <span class="pre">Offload</span> <span class="pre">Playback</span> <span class="pre">Card</span> <span class="pre">Route</span> <span class="pre">PCM#</span></code> <strong>(R)</strong>: Returns the ASoC platform sound
card index for a mapped offload path.  The output <strong>“0”</strong> (card index) signifies
that there is an available offload path for the USB SND device through card#0.
If <strong>“-1”</strong> is seen, then no offload path is available for the USB SND device.
This kcontrol exists for each USB audio device that exists in the system, and
its expected to derive the current status of offload based on the output value
for the kcontrol along with the PCM route kcontrol.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">USB</span> <span class="pre">Offload</span> <span class="pre">Playback</span> <span class="pre">PCM</span> <span class="pre">Route</span> <span class="pre">PCM#</span></code> <strong>(R)</strong>: Returns the ASoC platform sound
PCM device index for a mapped offload path.  The output <strong>“1”</strong> (PCM device index)
signifies that there is an available offload path for the USB SND device through
PCM device#0. If <strong>“-1”</strong> is seen, then no offload path is available for the USBSND device.  This kcontrol exists for each USB audio device that exists in the
system, and its expected to derive the current status of offload based on the
output value for this kcontrol, in addition to the card route kcontrol.</p></li>
</ul>
</div></blockquote>
</section>
<section id="usb-offload-playback-route-kcontrol">
<h3>USB Offload Playback Route Kcontrol<a class="headerlink" href="#usb-offload-playback-route-kcontrol" title="Link to this heading">¶</a></h3>
<p>In order to allow for vendor specific implementations on audio offloading device
selection, the SoC USB layer exposes the following:</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>int (<span class="ge">*update_offload_route_info)(struct snd_soc_component *</span>component,
                                 int card, int pcm, int direction,
                                 enum snd_soc_usb_kctl path,
                                 long *route)
</pre></div>
</div>
<p>These are specific for the <strong>USB Offload Playback Card Route PCM#</strong> and <strong>USB
Offload PCM Route PCM#</strong> kcontrols.</p>
<p>When users issue get calls to the kcontrol, the registered SoC USB callbacks will
execute the registered function calls to the DPCM BE DAI link.</p>
<p><strong>Callback Registration:</strong></p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>static int q6usb_component_probe(struct snd_soc_component *component)
<span class="gh">{</span>
<span class="gh">...</span>
usb = snd_soc_usb_allocate_port(component, 1, &amp;data-&gt;priv);
if (IS_ERR(usb))
        return -ENOMEM;

usb-&gt;connection_status_cb = q6usb_alsa_connection_cb;
usb-&gt;update_offload_route_info = q6usb_get_offload_dev;

ret = snd_soc_usb_add_port(usb);
</pre></div>
</div>
</section>
<section id="existing-usb-sound-kcontrol">
<h3>Existing USB Sound Kcontrol<a class="headerlink" href="#existing-usb-sound-kcontrol" title="Link to this heading">¶</a></h3>
<p>With the introduction of USB offload support, the above USB offload kcontrol
will be added to the pre existing list of kcontrols identified by the USB sound
framework.  These kcontrols are still the main controls that are used to
modify characteristics pertaining to the USB audio device.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Number of controls: 9
ctl     type    num     name                                    value
0       INT     2       Capture Channel Map                     0, 0 (range 0-&gt;36)
1       INT     2       Playback Channel Map                    0, 0 (range 0-&gt;36)
2       BOOL    1       Headset Capture Switch                  On
3       INT     1       Headset Capture Volume                  10 (range 0-&gt;13)
4       BOOL    1       Sidetone Playback Switch                On
5       INT     1       Sidetone Playback Volume                4096 (range 0-&gt;8192)
6       BOOL    1       Headset Playback Switch                 On
7       INT     2       Headset Playback Volume                 20, 20 (range 0-&gt;24)
8       INT     1       USB Offload Playback Card Route PCM#0   0 (range -1-&gt;32)
9       INT     1       USB Offload Playback PCM Route PCM#0    1 (range -1-&gt;255)
</pre></div>
</div>
</div></blockquote>
<p>Since USB audio device controls are handled over the USB control endpoint, use the
existing mechanisms present in the USB mixer to set parameters, such as volume.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/sound/soc/usb.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>