<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Driver Basics &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Driver Model" href="driver-model/index.html" />
    <link rel="prev" title="Driver implementer’s API guide" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Driver Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l3"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l3"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/basics.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="driver-basics">
<h1>Driver Basics<a class="headerlink" href="#driver-basics" title="Link to this heading">¶</a></h1>
<section id="driver-entry-and-exit-points">
<h2>Driver Entry and Exit points<a class="headerlink" href="#driver-entry-and-exit-points" title="Link to this heading">¶</a></h2>
<dl class="c macro">
<dt class="sig sig-object c" id="c.module_init">
<span class="sig-name descname"><span class="n"><span class="pre">module_init</span></span></span><a class="headerlink" href="#c.module_init" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">module_init</span> <span class="pre">(x)</span></code></p>
<blockquote>
<div><p>driver initialization entry point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>function to be run at kernel boot time or module insertion</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> will either be called during do_initcalls() (if
builtin) or at module insertion time (if a module).  There can only
be one per module.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.module_exit">
<span class="sig-name descname"><span class="n"><span class="pre">module_exit</span></span></span><a class="headerlink" href="#c.module_exit" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">module_exit</span> <span class="pre">(x)</span></code></p>
<blockquote>
<div><p>driver exit entry point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>function to be run when driver is removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a> will wrap the driver clean-up code
with cleanup_module() when used with rmmod when
the driver is a module.  If the driver is statically
compiled into the kernel, <a class="reference internal" href="#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a> has no effect.
There can only be one per module.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.klp_modinfo">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">klp_modinfo</span></span></span><a class="headerlink" href="#c.klp_modinfo" title="Link to this definition">¶</a><br /></dt>
<dd><p>ELF information preserved from the livepatch module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct klp_modinfo {
    Elf_Ehdr hdr;
    Elf_Shdr *sechdrs;
    char *secstrings;
    unsigned int symndx;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">hdr</span></code></dt><dd><p>ELF header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sechdrs</span></code></dt><dd><p>Section header table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secstrings</span></code></dt><dd><p>String table for the section headers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symndx</span></code></dt><dd><p>The symbol table section index</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.try_module_get">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">try_module_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.try_module_get" title="module"><span class="n"><span class="pre">module</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">module</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.try_module_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>take module refcount unless module is being removed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>the module we should check for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only try to get a module reference count if the module is not being removed.
This call will fail if the module is in the process of being removed.</p>
<p>Care must also be taken to ensure the module exists and is alive prior to
usage of this call. This can be gauranteed through two means:</p>
<ol class="arabic simple">
<li><p>Direct protection: you know an earlier caller must have increased the
module reference through __module_get(). This can typically be achieved
by having another entity other than the module itself increment the
module reference count.</p></li>
<li><p>Implied protection: there is an implied protection against module
removal. An example of this is the implied protection used by kernfs /
sysfs. The sysfs store / read file operations are guaranteed to exist
through the use of kernfs’s active reference (see kernfs_active()) and a
sysfs / kernfs file removal cannot happen unless the same file is not
active. Therefore, if a sysfs file is being read or written to the module
which created it must still exist. It is therefore safe to use
<a class="reference internal" href="#c.try_module_get" title="try_module_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code></a> on module sysfs store / read ops.</p></li>
</ol>
<p>One of the real values to <a class="reference internal" href="#c.try_module_get" title="try_module_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code></a> is the module_is_live() check
which ensures that the caller of <a class="reference internal" href="#c.try_module_get" title="try_module_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code></a> can yield to userspace
module removal requests and gracefully fail if the module is on its way out.</p>
<p>Returns true if the reference count was successfully incremented.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.module_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">module_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.module_put" title="module"><span class="n"><span class="pre">module</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">module</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.module_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a reference count to a module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>the module we should release a reference count for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you successfully bump a reference count to a module with <a class="reference internal" href="#c.try_module_get" title="try_module_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code></a>,
when you are finished you must call <a class="reference internal" href="#c.module_put" title="module_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_put()</span></code></a> to release that reference
count.</p>
</div>
</section>
<section id="driver-device-table">
<h2>Driver device table<a class="headerlink" href="#driver-device-table" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.usb_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">usb_device_id</span></span></span><a class="headerlink" href="#c.usb_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>identifies USB devices for probing and hotplugging</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_device_id {
    __u16 match_flags;
    __u16 idVendor;
    __u16 idProduct;
    __u16 bcdDevice_lo;
    __u16 bcdDevice_hi;
    __u8 bDeviceClass;
    __u8 bDeviceSubClass;
    __u8 bDeviceProtocol;
    __u8 bInterfaceClass;
    __u8 bInterfaceSubClass;
    __u8 bInterfaceProtocol;
    __u8 bInterfaceNumber;
    kernel_ulong_t driver_info  ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">match_flags</span></code></dt><dd><p>Bit mask controlling which of the other fields are used to
match against new devices. Any field except for driver_info may be
used, although some only make sense in conjunction with other fields.
This is usually set by a USB_DEVICE_*() macro, which sets all
other fields in this structure except for driver_info.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idVendor</span></code></dt><dd><p>USB vendor ID for a device; numbers are assigned
by the USB forum to its members.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idProduct</span></code></dt><dd><p>Vendor-assigned product ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcdDevice_lo</span></code></dt><dd><p>Low end of range of vendor-assigned product version numbers.
This is also used to identify individual product versions, for
a range consisting of a single device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcdDevice_hi</span></code></dt><dd><p>High end of version number range.  The range of product
versions is inclusive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceClass</span></code></dt><dd><p>Class of device; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Device classes specify behavior of all
the interfaces on a device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceSubClass</span></code></dt><dd><p>Subclass of device; associated with bDeviceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceProtocol</span></code></dt><dd><p>Protocol of device; associated with bDeviceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceClass</span></code></dt><dd><p>Class of interface; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Interface classes specify behavior only
of a given interface; other interfaces may support other classes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceSubClass</span></code></dt><dd><p>Subclass of interface; associated with bInterfaceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceProtocol</span></code></dt><dd><p>Protocol of interface; associated with bInterfaceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceNumber</span></code></dt><dd><p>Number of interface; composite devices may use
fixed interface numbers to differentiate between vendor-specific
interfaces.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_info</span></code></dt><dd><p>Holds information used by the driver.  Usually it holds
a pointer to a descriptor understood by the driver, or perhaps
device flags.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>In most cases, drivers will create a table of device IDs by using
<a class="reference internal" href="usb/usb.html#c.USB_DEVICE" title="USB_DEVICE"><code class="xref c c-func docutils literal notranslate"><span class="pre">USB_DEVICE()</span></code></a>, or similar macros designed for that purpose.
They will then export it to userspace using MODULE_DEVICE_TABLE(),
and provide it to the USB core through their usb_driver structure.</p>
<p>See the usb_match_id() function for information about how matches are
performed.  Briefly, you will normally use one of several macros to help
construct these entries.  Each entry you provide will either identify
one or more specific products, or will identify a class of products
which have agreed to behave the same.  You should put the more specific
matches towards the beginning of your table, so that driver_info can
record quirks of specific products.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.ACPI_DEVICE_CLASS">
<span class="sig-name descname"><span class="n"><span class="pre">ACPI_DEVICE_CLASS</span></span></span><a class="headerlink" href="#c.ACPI_DEVICE_CLASS" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">ACPI_DEVICE_CLASS</span> <span class="pre">(_cls,</span> <span class="pre">_msk)</span></code></p>
<blockquote>
<div><p>macro used to describe an ACPI device with the PCI-defined class-code information</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_cls</span></code></dt><dd><p>the class, subclass, prog-if triple for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_msk</span></code></dt><dd><p>the class mask for this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro is used to create a struct acpi_device_id that matches a
specific PCI class. The .id and .driver_data fields will be left
initialized with the default value.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.mdio_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mdio_device_id</span></span></span><a class="headerlink" href="#c.mdio_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>identifies PHY devices on an MDIO/MII bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mdio_device_id {
    __u32 phy_id;
    __u32 phy_id_mask;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_id</span></code></dt><dd><p>The result of
(mdio_read(<code class="xref c c-type docutils literal notranslate"><span class="pre">MII_PHYSID1</span></code>) &lt;&lt; 16 | mdio_read(<code class="xref c c-type docutils literal notranslate"><span class="pre">MII_PHYSID2</span></code>)) &amp; <strong>phy_id_mask</strong>
for this PHY type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_id_mask</span></code></dt><dd><p>Defines the significant bits of <strong>phy_id</strong>.  A value of 0
is used to terminate an array of <a class="reference internal" href="#c.mdio_device_id" title="mdio_device_id"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device_id</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.amba_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">amba_id</span></span></span><a class="headerlink" href="#c.amba_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>identifies a device on an AMBA bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amba_id {
    unsigned int            id;
    unsigned int            mask;
    void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>The significant bits if the hardware device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>Bitmask specifying which bits of the id field are significant when
matching.  A driver binds to a device when ((hardware device ID) &amp; mask)
== id.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Private data used by the driver.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.mips_cdmm_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mips_cdmm_device_id</span></span></span><a class="headerlink" href="#c.mips_cdmm_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>identifies devices in MIPS CDMM bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mips_cdmm_device_id {
    __u8 type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Device type identifier.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.mei_cl_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mei_cl_device_id</span></span></span><a class="headerlink" href="#c.mei_cl_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>MEI client device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mei_cl_device_id {
    char name[MEI_CL_NAME_SIZE];
    uuid_le uuid;
    __u8 version;
    kernel_ulong_t driver_info;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>helper name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>client uuid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>client protocol version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_info</span></code></dt><dd><p>information used by the driver.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>identifies mei client device by uuid and name</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.rio_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rio_device_id</span></span></span><a class="headerlink" href="#c.rio_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>RIO device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rio_device_id {
    __u16 did, vid;
    __u16 asm_did, asm_vid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">did</span></code></dt><dd><p>RapidIO device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vid</span></code></dt><dd><p>RapidIO vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asm_did</span></code></dt><dd><p>RapidIO assembly device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asm_vid</span></code></dt><dd><p>RapidIO assembly vendor ID</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Identifies a RapidIO device based on both the device/vendor IDs and
the assembly device/vendor IDs.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fsl_mc_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fsl_mc_device_id</span></span></span><a class="headerlink" href="#c.fsl_mc_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>MC object device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsl_mc_device_id {
    __u16 vendor;
    const char obj_type[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vendor</span></code></dt><dd><p>vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj_type</span></code></dt><dd><p>MC object type</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Type of entries in the “device Id” table for MC object devices supported by
a MC object device driver. The last entry of the table has vendor set to 0x0</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.tb_service_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tb_service_id</span></span></span><a class="headerlink" href="#c.tb_service_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>Thunderbolt service identifiers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tb_service_id {
    __u32 match_flags;
    char protocol_key[8 + 1];
    __u32 protocol_id;
    __u32 protocol_version;
    __u32 protocol_revision;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">match_flags</span></code></dt><dd><p>Flags used to match the structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_key</span></code></dt><dd><p>Protocol key the service supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_id</span></code></dt><dd><p>Protocol id the service supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_version</span></code></dt><dd><p>Version of the protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_revision</span></code></dt><dd><p>Revision of the protocol software</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Driver specific data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Thunderbolt XDomain services are exposed as devices where each device
carries the protocol information the service supports. Thunderbolt
XDomain service drivers match against that information.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.typec_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">typec_device_id</span></span></span><a class="headerlink" href="#c.typec_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>USB Type-C alternate mode identifiers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct typec_device_id {
    __u16 svid;
    __u8 mode;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">svid</span></code></dt><dd><p>Standard or Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Mode index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Driver specific data</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.tee_client_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tee_client_device_id</span></span></span><a class="headerlink" href="#c.tee_client_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>tee based device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tee_client_device_id {
    uuid_t uuid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>For TEE based client devices we use the device uuid as
the identifier.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.wmi_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wmi_device_id</span></span></span><a class="headerlink" href="#c.wmi_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>WMI device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct wmi_device_id {
    const char guid_string[UUID_STRING_LEN+1];
    const void *context;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">guid_string</span></code></dt><dd><p>36 char string of the form fa50ff2b-f2e8-45de-83fa-65417f2f49ba</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt><dd><p>pointer to driver specific data</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.mhi_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mhi_device_id</span></span></span><a class="headerlink" href="#c.mhi_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>MHI device identification</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mhi_device_id {
    const char chan[MHI_NAME_SIZE];
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chan</span></code></dt><dd><p>MHI channel name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>driver data;</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dfl_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dfl_device_id</span></span></span><a class="headerlink" href="#c.dfl_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>dfl device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dfl_device_id {
    __u16 type;
    __u16 feature_id;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>DFL FIU type of the device. See enum dfl_id_type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">feature_id</span></code></dt><dd><p>feature identifier local to its DFL FIU type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>driver specific data.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ishtp_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ishtp_device_id</span></span></span><a class="headerlink" href="#c.ishtp_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>ISHTP device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ishtp_device_id {
    guid_t guid;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">guid</span></code></dt><dd><p>GUID of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>pointer to driver specific data</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.cdx_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cdx_device_id</span></span></span><a class="headerlink" href="#c.cdx_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>CDX device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cdx_device_id {
    __u16 vendor;
    __u16 device;
    __u16 subvendor;
    __u16 subdevice;
    __u32 class;
    __u32 class_mask;
    __u32 override_only;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vendor</span></code></dt><dd><p>Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt><dd><p>Device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subvendor</span></code></dt><dd><p>Subsystem vendor ID (or CDX_ANY_ID)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subdevice</span></code></dt><dd><p>Subsystem device ID (or CDX_ANY_ID)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class</span></code></dt><dd><p>Device class
Most drivers do not need to specify class/class_mask
as vendor/device is normally sufficient.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class_mask</span></code></dt><dd><p>Limit which sub-fields of the class field are compared.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">override_only</span></code></dt><dd><p>Match only when dev-&gt;driver_override is this driver.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Type of entries in the “device Id” table for CDX devices supported by
a CDX device driver.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.coreboot_device_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">coreboot_device_id</span></span></span><a class="headerlink" href="#c.coreboot_device_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>Identifies a coreboot table entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct coreboot_device_id {
    __u32 tag;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tag</span></code></dt><dd><p>tag ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>driver specific data</p>
</dd>
</dl>
</div>
</section>
<section id="delaying-and-scheduling-routines">
<h2>Delaying and scheduling routines<a class="headerlink" href="#delaying-and-scheduling-routines" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.prev_cputime">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">prev_cputime</span></span></span><a class="headerlink" href="#c.prev_cputime" title="Link to this definition">¶</a><br /></dt>
<dd><p>snapshot of system and user cputime</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct prev_cputime {
#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE;
    u64 utime;
    u64 stime;
    raw_spinlock_t lock;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">utime</span></code></dt><dd><p>time spent in user mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stime</span></code></dt><dd><p>time spent in system mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>protects the above two fields</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Stores previous user/system time values such that we can guarantee
monotonicity.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_cpus_allowed_ptr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_cpus_allowed_ptr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cpumask</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_cpus_allowed_ptr" title="Link to this definition">¶</a><br /></dt>
<dd><p>set CPU affinity mask of a task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*new_mask</span></code></dt><dd><p>CPU affinity mask</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.task_nice">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task_nice</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.task_nice" title="Link to this definition">¶</a><br /></dt>
<dd><p>return the nice value of a given task.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>the task in question.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The nice value [ -20 ... 0 ... 19 ].</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.is_idle_task">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_idle_task</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.is_idle_task" title="Link to this definition">¶</a><br /></dt>
<dd><p>is the specified task an idle task?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>the task in question.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if <strong>p</strong> is an idle task. 0 otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wake_up_process">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wake_up_process</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wake_up_process" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wake up a specific process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>The process to be woken up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to wake up the nominated process and move it to the set of runnable
processes.</p>
<p>This function executes a full memory barrier before accessing the task state.</p>
<p><strong>Return</strong></p>
<p>1 if the process was woken up, 0 if it was already running.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.preempt_notifier_register">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">preempt_notifier_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">preempt_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">notifier</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_notifier_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>tell me when current is being preempted &amp; rescheduled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">preempt_notifier</span> <span class="pre">*notifier</span></code></dt><dd><p>notifier struct to register</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.preempt_notifier_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">preempt_notifier_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">preempt_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">notifier</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_notifier_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>no longer interested in preemption notifications</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">preempt_notifier</span> <span class="pre">*notifier</span></code></dt><dd><p>notifier struct to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <em>not</em> safe to call from within a preemption notifier.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.preempt_schedule_notrace">
<span class="pre">__visible</span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">notrace</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">preempt_schedule_notrace</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_schedule_notrace" title="Link to this definition">¶</a><br /></dt>
<dd><p>preempt_schedule called by tracing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The tracing infrastructure uses preempt_enable_notrace to prevent
recursion and tracing preempt enabling caused by the tracing
infrastructure itself. But as tracing can happen in areas coming
from userspace or just about to enter userspace, a preempt enable
can occur before user_exit() is called. This will cause the scheduler
to be called when the system is still in usermode.</p>
<p>To prevent this, the preempt_enable_notrace will use this function
instead of preempt_schedule() to exit user context if needed before
calling the scheduler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cpupri_find_fitness">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cpupri_find_fitness</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cpupri</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cpumask</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lowest_mask</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fitness_fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_find_fitness" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the best (lowest-pri) CPU in the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>The task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*lowest_mask</span></code></dt><dd><p>A mask to fill in with selected CPUs (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*fitness_fn)(struct</span> <span class="pre">task_struct</span> <span class="pre">*p,</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>A pointer to a function to do custom checks whether the CPU
fits a specific criteria so that we only return those CPUs.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function returns the recommended CPUs as calculated during the
current invocation.  By the time the call returns, the CPUs may have in
fact changed priorities any number of times.  While not ideal, it is not
an issue of correctness since the normal rebalancer logic will correct
any discrepancies created by racing against the uncertainty of the current
priority configuration.</p>
<p><strong>Return</strong></p>
<p>(int)bool - CPUs were found</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cpupri_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cpupri_set</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cpupri</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">newpri</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>update the CPU priority setting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The target CPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newpri</span></code></dt><dd><p>The priority (INVALID,NORMAL,RT1-RT99,HIGHER) to assign to this CPU</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Assumes cpu_rq(cpu)-&gt;lock is locked</p>
<p><strong>Return</strong></p>
<p>(void)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cpupri_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cpupri_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cpupri</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize the cpupri structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-ENOMEM on memory allocation failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cpupri_cleanup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cpupri_cleanup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cpupri</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_cleanup" title="Link to this definition">¶</a><br /></dt>
<dd><p>clean up the cpupri structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.update_tg_load_avg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">update_tg_load_avg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.update_tg_load_avg" title="cfs_rq"><span class="n"><span class="pre">cfs_rq</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cfs_rq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.update_tg_load_avg" title="Link to this definition">¶</a><br /></dt>
<dd><p>update the tg’s load avg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>the cfs_rq whose avg changed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function ‘ensures’: tg-&gt;load_avg := Sum tg-&gt;cfs_rq[]-&gt;avg.load.
However, because tg-&gt;load_avg is a global value there are performance
considerations.</p>
<p>In order to avoid having to look at the other cfs_rq’s, we use a
differential update where we store the last value we propagated. This in
turn allows skipping updates if the differential is ‘small’.</p>
<p>Updating tg’s load_avg is necessary before update_cfs_share().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.update_cfs_rq_load_avg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">update_cfs_rq_load_avg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">now</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.update_cfs_rq_load_avg" title="cfs_rq"><span class="n"><span class="pre">cfs_rq</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cfs_rq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.update_cfs_rq_load_avg" title="Link to this definition">¶</a><br /></dt>
<dd><p>update the cfs_rq’s load/util averages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">now</span></code></dt><dd><p>current time, as per cfs_rq_clock_pelt()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The cfs_rq avg is the direct sum of all its entities (blocked and runnable)
avg. The immediate corollary is that all (fair) tasks must be attached.</p>
<p>cfs_rq-&gt;avg is used for task_h_load() and update_cfs_share() for example.</p>
<p>Since both these conditions indicate a changed cfs_rq-&gt;avg.load we should
call <a class="reference internal" href="#c.update_tg_load_avg" title="update_tg_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_tg_load_avg()</span></code></a> when this function returns true.</p>
<p><strong>Return</strong></p>
<p>true if the load decayed or we removed load.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.attach_entity_load_avg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">attach_entity_load_avg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.attach_entity_load_avg" title="cfs_rq"><span class="n"><span class="pre">cfs_rq</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cfs_rq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sched_entity</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">se</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.attach_entity_load_avg" title="Link to this definition">¶</a><br /></dt>
<dd><p>attach this entity to its cfs_rq load avg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to attach to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_entity</span> <span class="pre">*se</span></code></dt><dd><p>sched_entity to attach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="update_cfs_rq_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_cfs_rq_load_avg()</span></code></a> before this, since we rely on
cfs_rq-&gt;avg.last_update_time being current.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.detach_entity_load_avg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">detach_entity_load_avg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.detach_entity_load_avg" title="cfs_rq"><span class="n"><span class="pre">cfs_rq</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cfs_rq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sched_entity</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">se</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.detach_entity_load_avg" title="Link to this definition">¶</a><br /></dt>
<dd><p>detach this entity from its cfs_rq load avg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to detach from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_entity</span> <span class="pre">*se</span></code></dt><dd><p>sched_entity to detach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="update_cfs_rq_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_cfs_rq_load_avg()</span></code></a> before this, since we rely on
cfs_rq-&gt;avg.last_update_time being current.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cpu_util">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cpu_util</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dst_cpu</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">boost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cpu_util" title="Link to this definition">¶</a><br /></dt>
<dd><p>Estimates the amount of CPU capacity used by CFS tasks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the CPU to get the utilization for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task for which the CPU utilization should be predicted or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dst_cpu</span></code></dt><dd><p>CPU <strong>p</strong> migrates to, -1 if <strong>p</strong> moves from <strong>cpu</strong> or <strong>p</strong> == NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">boost</span></code></dt><dd><p>1 to enable boosting, otherwise 0</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The unit of the return value must be the same as the one of CPU capacity
so that CPU utilization can be compared with CPU capacity.</p>
<p>CPU utilization is the sum of running time of runnable tasks plus the
recent utilization of currently non-runnable tasks on that CPU.
It represents the amount of CPU capacity currently used by CFS tasks in
the range [0..max CPU capacity] with max CPU capacity being the CPU
capacity at f_max.</p>
<p>The estimated CPU utilization is defined as the maximum between CPU
utilization and sum of the estimated utilization of the currently
runnable tasks on that CPU. It preserves a utilization “snapshot” of
previously-executed tasks, which helps better deduce how busy a CPU will
be when a long-sleeping task wakes up. The contribution to CPU utilization
of such a task would be significantly decayed at this point of time.</p>
<p>Boosted CPU utilization is defined as max(CPU runnable, CPU utilization).
CPU contention for CFS tasks can be detected by CPU runnable &gt; CPU
utilization. Boosting is implemented in <a class="reference internal" href="#c.cpu_util" title="cpu_util"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_util()</span></code></a> so that internal
users (e.g. EAS) can use it next to external users (e.g. schedutil),
latter via cpu_util_cfs_boost().</p>
<p>CPU utilization can be higher than the current CPU capacity
(f_curr/f_max * max CPU capacity) or even the max CPU capacity because
of rounding errors as well as task migrations or wakeups of new tasks.
CPU utilization has to be capped to fit into the [0..max CPU capacity]
range. Otherwise a group of CPUs (CPU0 util = 121% + CPU1 util = 80%)
could be seen as over-utilized even though CPU1 has 20% of spare CPU
capacity. CPU utilization is allowed to overshoot current CPU capacity
though since this is useful for predicting the CPU capacity required
after task migrations (scheduler-driven DVFS).</p>
<p><strong>Return</strong></p>
<p>(Boosted) (estimated) utilization for the specified CPU.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sched_use_asym_prio">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sched_use_asym_prio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sched_domain</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sched_use_asym_prio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check whether asym_packing priority must be used</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_domain</span> <span class="pre">*sd</span></code></dt><dd><p>The scheduling domain of the load balancing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>A CPU</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Always use CPU priority when balancing load between SMT siblings. When
balancing load between cores, it is not sufficient that <strong>cpu</strong> is idle. Only
use CPU priority if the whole core is idle.</p>
<p><strong>Return</strong></p>
<p>True if the priority of <strong>cpu</strong> must be followed. False otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sched_group_asym">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sched_group_asym</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lb_env</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">env</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_lb_stats</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgs</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sched_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">group</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sched_group_asym" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check if the destination CPU can do asym_packing balance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*sgs</span></code></dt><dd><p>Load-balancing statistics of the candidate busiest group</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*group</span></code></dt><dd><p>The candidate busiest group</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>env</strong>::dst_cpu can do asym_packing if it has higher priority than the
preferred CPU of <strong>group</strong>.</p>
<p><strong>Return</strong></p>
<p>true if <strong>env</strong>::dst_cpu can do with asym_packing load balance. False
otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.update_sg_lb_stats">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">update_sg_lb_stats</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lb_env</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">env</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sd_lb_stats</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sds</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sched_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">group</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_lb_stats</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgs</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sg_overloaded</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sg_overutilized</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sg_lb_stats" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update sched_group’s statistics for load balancing.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>Load-balancing data with statistics of the local group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*group</span></code></dt><dd><p>sched_group whose statistics are to be updated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*sgs</span></code></dt><dd><p>variable to hold the statistics for this group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*sg_overloaded</span></code></dt><dd><p>sched_group is overloaded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*sg_overutilized</span></code></dt><dd><p>sched_group is overutilized</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.update_sd_pick_busiest">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">update_sd_pick_busiest</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lb_env</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">env</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sd_lb_stats</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sds</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sched_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sg</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_lb_stats</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sd_pick_busiest" title="Link to this definition">¶</a><br /></dt>
<dd><p>return 1 on busiest group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>sched_domain statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*sg</span></code></dt><dd><p>sched_group candidate to be checked for being the busiest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*sgs</span></code></dt><dd><p>sched_group statistics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if <strong>sg</strong> is a busier group than the previously selected
busiest group.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>sg</strong> is a busier group than the previously selected
busiest group. <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idle_cpu_without">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idle_cpu_without</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idle_cpu_without" title="Link to this definition">¶</a><br /></dt>
<dd><p>would a given CPU be idle without p ?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor on which idleness is tested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task which should be ignored.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the CPU would be idle. 0 otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.update_sd_lb_stats">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">update_sd_lb_stats</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lb_env</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">env</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sd_lb_stats</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sds</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sd_lb_stats" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update sched_domain’s statistics for load balancing.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>variable to hold the statistics for this sched_domain.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.calculate_imbalance">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">calculate_imbalance</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lb_env</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">env</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sd_lb_stats</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sds</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.calculate_imbalance" title="Link to this definition">¶</a><br /></dt>
<dd><p>Calculate the amount of imbalance present within the groups of a given sched_domain during load balance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>load balance environment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>statistics of the sched_domain whose imbalance is to be calculated.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sched_balance_find_src_group">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sched_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sched_balance_find_src_group</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lb_env</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">env</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sched_balance_find_src_group" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the busiest group within the sched_domain if there is an imbalance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also calculates the amount of runnable load which should be moved
to restore balance.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>The busiest group if imbalance exists.</p></li>
</ul>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DECLARE_COMPLETION">
<span class="sig-name descname"><span class="n"><span class="pre">DECLARE_COMPLETION</span></span></span><a class="headerlink" href="#c.DECLARE_COMPLETION" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DECLARE_COMPLETION</span> <span class="pre">(work)</span></code></p>
<blockquote>
<div><p>declare and initialize a completion structure</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>identifier for the completion structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro declares and initializes a completion structure. Generally used
for static declarations. You should use the _ONSTACK variant for automatic
variables.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DECLARE_COMPLETION_ONSTACK">
<span class="sig-name descname"><span class="n"><span class="pre">DECLARE_COMPLETION_ONSTACK</span></span></span><a class="headerlink" href="#c.DECLARE_COMPLETION_ONSTACK" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DECLARE_COMPLETION_ONSTACK</span> <span class="pre">(work)</span></code></p>
<blockquote>
<div><p>declare and initialize a completion structure</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>identifier for the completion structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro declares and initializes a completion structure on the kernel
stack.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.init_completion">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">init_completion</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">completion</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.init_completion" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a dynamically allocated completion</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*x</span></code></dt><dd><p>pointer to completion structure that is to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This inline function will initialize a dynamically created completion
structure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.reinit_completion">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reinit_completion</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">completion</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.reinit_completion" title="Link to this definition">¶</a><br /></dt>
<dd><p>reinitialize a completion structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*x</span></code></dt><dd><p>pointer to completion structure that is to be reinitialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This inline function should be used to reinitialize a completion structure so it can
be reused. This is especially important after complete_all() is used.</p>
</div>
</section>
<section id="time-and-timer-routines">
<h2>Time and timer routines<a class="headerlink" href="#time-and-timer-routines" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_jiffies_64">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_jiffies_64</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_jiffies_64" title="Link to this definition">¶</a><br /></dt>
<dd><p>read the 64-bit non-atomic jiffies_64 value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When BITS_PER_LONG &lt; 64, this uses sequence number sampling using
jiffies_lock to protect the 64-bit read.</p>
<p><strong>Return</strong></p>
<p>current 64-bit jiffies value</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_after">
<span class="sig-name descname"><span class="n"><span class="pre">time_after</span></span></span><a class="headerlink" href="#c.time_after" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_after</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>returns true if the time a is after time b.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first comparable as unsigned long</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second comparable as unsigned long</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do this with “&lt;0” and “&gt;=0” to only test the sign of the result. A
good compiler would generate better code (and a really good compiler
wouldn’t care). Gcc is currently neither.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is after time b, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_before">
<span class="sig-name descname"><span class="n"><span class="pre">time_before</span></span></span><a class="headerlink" href="#c.time_before" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_before</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>returns true if the time a is before time b.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first comparable as unsigned long</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second comparable as unsigned long</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is before time b, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_after_eq">
<span class="sig-name descname"><span class="n"><span class="pre">time_after_eq</span></span></span><a class="headerlink" href="#c.time_after_eq" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_after_eq</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>returns true if the time a is after or the same as time b.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first comparable as unsigned long</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second comparable as unsigned long</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is after or the same as time b, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_before_eq">
<span class="sig-name descname"><span class="n"><span class="pre">time_before_eq</span></span></span><a class="headerlink" href="#c.time_before_eq" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_before_eq</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>returns true if the time a is before or the same as time b.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first comparable as unsigned long</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second comparable as unsigned long</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is before or the same as time b, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_in_range">
<span class="sig-name descname"><span class="n"><span class="pre">time_in_range</span></span></span><a class="headerlink" href="#c.time_in_range" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_in_range</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>Calculate whether a is in the range of [b, c].</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>beginning of the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>end of the range</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is in the range [b, c], otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_in_range_open">
<span class="sig-name descname"><span class="n"><span class="pre">time_in_range_open</span></span></span><a class="headerlink" href="#c.time_in_range_open" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_in_range_open</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>Calculate whether a is in the range of [b, c).</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>beginning of the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>end of the range</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is in the range [b, c), otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_after64">
<span class="sig-name descname"><span class="n"><span class="pre">time_after64</span></span></span><a class="headerlink" href="#c.time_after64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_after64</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>returns true if the time a is after time b.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first comparable as __u64</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second comparable as __u64</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be used when utilizing jiffies_64 (i.e. return value of
<a class="reference internal" href="#c.get_jiffies_64" title="get_jiffies_64"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_jiffies_64()</span></code></a>).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is after time b, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_before64">
<span class="sig-name descname"><span class="n"><span class="pre">time_before64</span></span></span><a class="headerlink" href="#c.time_before64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_before64</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>returns true if the time a is before time b.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first comparable as __u64</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second comparable as __u64</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be used when utilizing jiffies_64 (i.e. return value of
<a class="reference internal" href="#c.get_jiffies_64" title="get_jiffies_64"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_jiffies_64()</span></code></a>).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is before time b, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_after_eq64">
<span class="sig-name descname"><span class="n"><span class="pre">time_after_eq64</span></span></span><a class="headerlink" href="#c.time_after_eq64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_after_eq64</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>returns true if the time a is after or the same as time b.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first comparable as __u64</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second comparable as __u64</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be used when utilizing jiffies_64 (i.e. return value of
<a class="reference internal" href="#c.get_jiffies_64" title="get_jiffies_64"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_jiffies_64()</span></code></a>).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is after or the same as time b, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_before_eq64">
<span class="sig-name descname"><span class="n"><span class="pre">time_before_eq64</span></span></span><a class="headerlink" href="#c.time_before_eq64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_before_eq64</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>returns true if the time a is before or the same as time b.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first comparable as __u64</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second comparable as __u64</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be used when utilizing jiffies_64 (i.e. return value of
<a class="reference internal" href="#c.get_jiffies_64" title="get_jiffies_64"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_jiffies_64()</span></code></a>).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is before or the same as time b, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_in_range64">
<span class="sig-name descname"><span class="n"><span class="pre">time_in_range64</span></span></span><a class="headerlink" href="#c.time_in_range64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_in_range64</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>Calculate whether a is in the range of [b, c].</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>beginning of the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>end of the range</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is in the range [b, c], otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_is_before_jiffies">
<span class="sig-name descname"><span class="n"><span class="pre">time_is_before_jiffies</span></span></span><a class="headerlink" href="#c.time_is_before_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_is_before_jiffies</span> <span class="pre">(a)</span></code></p>
<blockquote>
<div><p>return true if a is before jiffies</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time (unsigned long) to compare to jiffies</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is before jiffies, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_is_before_jiffies64">
<span class="sig-name descname"><span class="n"><span class="pre">time_is_before_jiffies64</span></span></span><a class="headerlink" href="#c.time_is_before_jiffies64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_is_before_jiffies64</span> <span class="pre">(a)</span></code></p>
<blockquote>
<div><p>return true if a is before jiffies_64</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time (__u64) to compare to jiffies_64</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is before jiffies_64, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_is_after_jiffies">
<span class="sig-name descname"><span class="n"><span class="pre">time_is_after_jiffies</span></span></span><a class="headerlink" href="#c.time_is_after_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_is_after_jiffies</span> <span class="pre">(a)</span></code></p>
<blockquote>
<div><p>return true if a is after jiffies</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time (unsigned long) to compare to jiffies</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is after jiffies, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_is_after_jiffies64">
<span class="sig-name descname"><span class="n"><span class="pre">time_is_after_jiffies64</span></span></span><a class="headerlink" href="#c.time_is_after_jiffies64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_is_after_jiffies64</span> <span class="pre">(a)</span></code></p>
<blockquote>
<div><p>return true if a is after jiffies_64</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time (__u64) to compare to jiffies_64</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is after jiffies_64, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_is_before_eq_jiffies">
<span class="sig-name descname"><span class="n"><span class="pre">time_is_before_eq_jiffies</span></span></span><a class="headerlink" href="#c.time_is_before_eq_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_is_before_eq_jiffies</span> <span class="pre">(a)</span></code></p>
<blockquote>
<div><p>return true if a is before or equal to jiffies</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time (unsigned long) to compare to jiffies</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is before or the same as jiffies, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_is_before_eq_jiffies64">
<span class="sig-name descname"><span class="n"><span class="pre">time_is_before_eq_jiffies64</span></span></span><a class="headerlink" href="#c.time_is_before_eq_jiffies64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_is_before_eq_jiffies64</span> <span class="pre">(a)</span></code></p>
<blockquote>
<div><p>return true if a is before or equal to jiffies_64</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time (__u64) to compare to jiffies_64</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is before or the same jiffies_64, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_is_after_eq_jiffies">
<span class="sig-name descname"><span class="n"><span class="pre">time_is_after_eq_jiffies</span></span></span><a class="headerlink" href="#c.time_is_after_eq_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_is_after_eq_jiffies</span> <span class="pre">(a)</span></code></p>
<blockquote>
<div><p>return true if a is after or equal to jiffies</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time (unsigned long) to compare to jiffies</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is after or the same as jiffies, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.time_is_after_eq_jiffies64">
<span class="sig-name descname"><span class="n"><span class="pre">time_is_after_eq_jiffies64</span></span></span><a class="headerlink" href="#c.time_is_after_eq_jiffies64" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">time_is_after_eq_jiffies64</span> <span class="pre">(a)</span></code></p>
<blockquote>
<div><p>return true if a is after or equal to jiffies_64</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>time (__u64) to compare to jiffies_64</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> is time a is after or the same as jiffies_64, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.jiffies_to_nsecs">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jiffies_to_nsecs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.jiffies_to_nsecs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert jiffies to nanoseconds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>jiffies value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>nanoseconds value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.msecs_to_jiffies">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">msecs_to_jiffies</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.msecs_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>convert milliseconds to jiffies</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">m</span></code></dt><dd><p>time in milliseconds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>conversion is done as follows:</p>
<ul class="simple">
<li><p>negative values mean ‘infinite timeout’ (MAX_JIFFY_OFFSET)</p></li>
<li><p>‘too large’ values [that would result in larger than
MAX_JIFFY_OFFSET values] mean ‘infinite timeout’ too.</p></li>
<li><p>all other values are converted to jiffies by either multiplying
the input value by a factor or dividing it with a factor and
handling any 32-bit overflows.
for the details see _msecs_to_jiffies()</p></li>
</ul>
<p><a class="reference internal" href="#c.msecs_to_jiffies" title="msecs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">msecs_to_jiffies()</span></code></a> checks for the passed in value being a constant
via __builtin_constant_p() allowing gcc to eliminate most of the
code. <a class="reference internal" href="#c.__msecs_to_jiffies" title="__msecs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__msecs_to_jiffies()</span></code></a> is called if the value passed does not
allow constant folding and the actual conversion must be done at
runtime.
The HZ range specific helpers _msecs_to_jiffies() are called both
directly here and from <a class="reference internal" href="#c.__msecs_to_jiffies" title="__msecs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__msecs_to_jiffies()</span></code></a> in the case where
constant folding is not possible.</p>
<p><strong>Return</strong></p>
<p>jiffies value</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.secs_to_jiffies">
<span class="sig-name descname"><span class="n"><span class="pre">secs_to_jiffies</span></span></span><a class="headerlink" href="#c.secs_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">secs_to_jiffies</span> <span class="pre">(_secs)</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>convert seconds to jiffies</p></li>
</ul>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_secs</span></code></dt><dd><p>time in seconds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Conversion is done by simple multiplication with HZ</p>
<p><a class="reference internal" href="#c.secs_to_jiffies" title="secs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">secs_to_jiffies()</span></code></a> is defined as a macro rather than a static inline
function so it can be used in static initializers.</p>
<p><strong>Return</strong></p>
<p>jiffies value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.usecs_to_jiffies">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">usecs_to_jiffies</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.usecs_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>convert microseconds to jiffies</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">u</span></code></dt><dd><p>time in microseconds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>conversion is done as follows:</p>
<ul class="simple">
<li><p>‘too large’ values [that would result in larger than
MAX_JIFFY_OFFSET values] mean ‘infinite timeout’ too.</p></li>
<li><p>all other values are converted to jiffies by either multiplying
the input value by a factor or dividing it with a factor and
handling any 32-bit overflows as for msecs_to_jiffies.</p></li>
</ul>
<p><a class="reference internal" href="#c.usecs_to_jiffies" title="usecs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">usecs_to_jiffies()</span></code></a> checks for the passed in value being a constant
via __builtin_constant_p() allowing gcc to eliminate most of the
code. <a class="reference internal" href="#c.__usecs_to_jiffies" title="__usecs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__usecs_to_jiffies()</span></code></a> is called if the value passed does not
allow constant folding and the actual conversion must be done at
runtime.
The HZ range specific helpers _usecs_to_jiffies() are called both
directly here and from <a class="reference internal" href="#c.__msecs_to_jiffies" title="__msecs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__msecs_to_jiffies()</span></code></a> in the case where
constant folding is not possible.</p>
<p><strong>Return</strong></p>
<p>jiffies value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.jiffies_to_msecs">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jiffies_to_msecs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.jiffies_to_msecs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert jiffies to milliseconds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>jiffies value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Avoid unnecessary multiplications/divisions in the
two most common HZ cases.</p>
<p><strong>Return</strong></p>
<p>milliseconds value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.jiffies_to_usecs">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jiffies_to_usecs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.jiffies_to_usecs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert jiffies to microseconds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>jiffies value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>microseconds value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mktime64">
<span class="n"><span class="pre">time64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mktime64</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">year0</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mon0</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">day</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">hour</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mktime64" title="Link to this definition">¶</a><br /></dt>
<dd><p>Converts date to seconds.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">year0</span></code></dt><dd><p>year to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mon0</span></code></dt><dd><p>month to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">day</span></code></dt><dd><p>day to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hour</span></code></dt><dd><p>hour to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>minute to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sec</span></code></dt><dd><p>second to convert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts Gregorian date to seconds since 1970-01-01 00:00:00.
Assumes input in normal date format, i.e. 1980-12-31 23:59:59
=&gt; year=1980, mon=12, day=31, hour=23, min=59, sec=59.</p>
<p>[For the Julian calendar (which was used in Russia before 1917,
Britain &amp; colonies before 1752, anywhere else before 1582,
and is still in use by some communities) leave out the
-year/100+year/400 terms, and add 10.]</p>
<p>This algorithm was first published by Gauss (I think).</p>
<p>A leap second can be indicated by calling this function with sec as
60 (allowable under ISO 8601).  The leap second is treated the same
as the following second since they don’t exist in UNIX time.</p>
<p>An encoding of midnight at the end of the day as 24:00:00 - ie. midnight
tomorrow - (allowable under ISO 8601) is supported.</p>
<p><strong>Return</strong></p>
<p>seconds since the epoch time for the given input date</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_normalized_timespec64">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_normalized_timespec64</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span>, <span class="n"><span class="pre">time64_t</span></span><span class="w"> </span><span class="n"><span class="pre">sec</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">nsec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_normalized_timespec64" title="Link to this definition">¶</a><br /></dt>
<dd><p>set timespec sec and nsec parts and normalize</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>pointer to timespec variable to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time64_t</span> <span class="pre">sec</span></code></dt><dd><p>seconds to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">nsec</span></code></dt><dd><p>nanoseconds to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set seconds and nanoseconds field of a timespec variable and
normalize to the timespec storage format</p>
<p><strong>Note</strong></p>
<p>The tv_nsec part is always in the range of 0 &lt;= tv_nsec &lt; NSEC_PER_SEC.
For negative values only the tv_sec field is negative !</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ns_to_timespec64">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ns_to_timespec64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">nsec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ns_to_timespec64" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert nanoseconds to timespec64</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">nsec</span></code></dt><dd><p>the nanoseconds value to be converted</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the timespec64 representation of the nsec parameter.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__msecs_to_jiffies">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__msecs_to_jiffies</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__msecs_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>convert milliseconds to jiffies</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">m</span></code></dt><dd><p>time in milliseconds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>conversion is done as follows:</p>
<ul class="simple">
<li><p>negative values mean ‘infinite timeout’ (MAX_JIFFY_OFFSET)</p></li>
<li><p>‘too large’ values [that would result in larger than
MAX_JIFFY_OFFSET values] mean ‘infinite timeout’ too.</p></li>
<li><p>all other values are converted to jiffies by either multiplying
the input value by a factor or dividing it with a factor and
handling any 32-bit overflows.
for the details see _msecs_to_jiffies()</p></li>
</ul>
<p><a class="reference internal" href="#c.msecs_to_jiffies" title="msecs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">msecs_to_jiffies()</span></code></a> checks for the passed in value being a constant
via __builtin_constant_p() allowing gcc to eliminate most of the
code, <a class="reference internal" href="#c.__msecs_to_jiffies" title="__msecs_to_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__msecs_to_jiffies()</span></code></a> is called if the value passed does not
allow constant folding and the actual conversion must be done at
runtime.
The _msecs_to_jiffies helpers are the HZ dependent conversion
routines found in include/linux/jiffies.h</p>
<p><strong>Return</strong></p>
<p>jiffies value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__usecs_to_jiffies">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__usecs_to_jiffies</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__usecs_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>convert microseconds to jiffies</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">u</span></code></dt><dd><p>time in milliseconds</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>jiffies value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.timespec64_to_jiffies">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">timespec64_to_jiffies</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.timespec64_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert a timespec64 value to jiffies</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*value</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The TICK_NSEC - 1 rounds up the value to the next resolution.  Note
that a remainder subtract here would not do the right thing as the
resolution values don’t fall on second boundaries.  I.e. the line:
nsec -= nsec % TICK_NSEC; is NOT a correct resolution rounding.
Note that due to the small error in the multiplier here, this
rounding is incorrect for sufficiently large values of tv_nsec, but
well formed timespecs should have tv_nsec &lt; NSEC_PER_SEC, so we’re
OK.</p>
<p>Rather, we just shift the bits off the right.</p>
<p>The &gt;&gt; (NSEC_JIFFIE_SC - SEC_JIFFIE_SC) converts the scaled nsec
value to a scaled second value.</p>
<p><strong>Return</strong></p>
<p>jiffies value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.jiffies_to_timespec64">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jiffies_to_timespec64</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">jiffies</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.jiffies_to_timespec64" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert jiffies value to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">jiffies</span></code></dt><dd><p>jiffies value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*value</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span></code></p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.jiffies_to_clock_t">
<span class="n"><span class="pre">clock_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jiffies_to_clock_t</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.jiffies_to_clock_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert jiffies to clock_t</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">x</span></code></dt><dd><p>jiffies value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>jiffies converted to clock_t (CLOCKS_PER_SEC)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clock_t_to_jiffies">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clock_t_to_jiffies</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clock_t_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert clock_t to jiffies</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">x</span></code></dt><dd><p>clock_t value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>clock_t value converted to jiffies</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.jiffies_64_to_clock_t">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jiffies_64_to_clock_t</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.jiffies_64_to_clock_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert jiffies_64 to clock_t</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">x</span></code></dt><dd><p>jiffies_64 value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>jiffies_64 value converted to 64-bit “clock_t” (CLOCKS_PER_SEC)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.jiffies64_to_nsecs">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jiffies64_to_nsecs</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.jiffies64_to_nsecs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert jiffies64 to nanoseconds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">j</span></code></dt><dd><p>jiffies64 value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>nanoseconds value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.jiffies64_to_msecs">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">jiffies64_to_msecs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.jiffies64_to_msecs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert jiffies64 to milliseconds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u64</span> <span class="pre">j</span></code></dt><dd><p>jiffies64 value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>milliseconds value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.nsecs_to_jiffies64">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nsecs_to_jiffies64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.nsecs_to_jiffies64" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert nsecs in u64 to jiffies64</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">n</span></code></dt><dd><p>nsecs in u64</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike {m,u}secs_to_jiffies, type of input is not unsigned int but u64.
And this doesn’t return MAX_JIFFY_OFFSET since this function is designed
for scheduler, not for use in device drivers to calculate timeout value.</p>
<p><strong>note</strong></p>
<blockquote>
<div><p>NSEC_PER_SEC = 10^9 = (5^9 * 2^9) = (1953125 * 512)
ULLONG_MAX ns = 18446744073.709551615 secs = about 584 years</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>nsecs converted to jiffies64 value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.nsecs_to_jiffies">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nsecs_to_jiffies</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.nsecs_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert nsecs in u64 to jiffies</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">n</span></code></dt><dd><p>nsecs in u64</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike {m,u}secs_to_jiffies, type of input is not unsigned int but u64.
And this doesn’t return MAX_JIFFY_OFFSET since this function is designed
for scheduler, not for use in device drivers to calculate timeout value.</p>
<p><strong>note</strong></p>
<blockquote>
<div><p>NSEC_PER_SEC = 10^9 = (5^9 * 2^9) = (1953125 * 512)
ULLONG_MAX ns = 18446744073.709551615 secs = about 584 years</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>nsecs converted to jiffies value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_timespec64">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_timespec64</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">__kernel_timespec</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_timespec64" title="Link to this definition">¶</a><br /></dt>
<dd><p>get user’s time value into kernel space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>destination <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">__kernel_timespec</span> <span class="pre">__user</span> <span class="pre">*uts</span></code></dt><dd><p>user’s time value as <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_timespec</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handles compat or 32-bit modes.</p>
<p><strong>Return</strong></p>
<p>0 on success or negative errno on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_timespec64">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_timespec64</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">__kernel_timespec</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_timespec64" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert timespec64 value to __kernel_timespec format and copy the latter to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>input <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_timespec</span> <span class="pre">__user</span> <span class="pre">*uts</span></code></dt><dd><p>user’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_timespec</span></code></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or negative errno on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_old_timespec32">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_old_timespec32</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_old_timespec32" title="Link to this definition">¶</a><br /></dt>
<dd><p>get user’s old-format time value into kernel space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>destination <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*uts</span></code></dt><dd><p>user’s old-format time value (<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">old_timespec32</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handles X86_X32_ABI compatibility conversion.</p>
<p><strong>Return</strong></p>
<p>0 on success or negative errno on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_old_timespec32">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_old_timespec32</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_old_timespec32" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert timespec64 value to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">old_timespec32</span></code> and copy the latter to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>input <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*uts</span></code></dt><dd><p>user’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">old_timespec32</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handles X86_X32_ABI compatibility conversion.</p>
<p><strong>Return</strong></p>
<p>0 on success or negative errno on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_itimerspec64">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_itimerspec64</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">itimerspec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">it</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">__kernel_itimerspec</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_itimerspec64" title="Link to this definition">¶</a><br /></dt>
<dd><p>get user’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_itimerspec</span></code> into kernel space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">itimerspec64</span> <span class="pre">*it</span></code></dt><dd><p>destination <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">itimerspec64</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">__kernel_itimerspec</span> <span class="pre">__user</span> <span class="pre">*uit</span></code></dt><dd><p>user’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_itimerspec</span></code></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or negative errno on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_itimerspec64">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_itimerspec64</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">itimerspec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">it</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">__kernel_itimerspec</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_itimerspec64" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">itimerspec64</span></code> to __kernel_itimerspec format and copy the latter to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">itimerspec64</span> <span class="pre">*it</span></code></dt><dd><p>input <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">itimerspec64</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_itimerspec</span> <span class="pre">__user</span> <span class="pre">*uit</span></code></dt><dd><p>user’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_itimerspec</span></code></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or negative errno on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_old_itimerspec32">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_old_itimerspec32</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">itimerspec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">its</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">old_itimerspec32</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_old_itimerspec32" title="Link to this definition">¶</a><br /></dt>
<dd><p>get user’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">old_itimerspec32</span></code> into kernel space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">itimerspec64</span> <span class="pre">*its</span></code></dt><dd><p>destination <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">itimerspec64</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">old_itimerspec32</span> <span class="pre">__user</span> <span class="pre">*uits</span></code></dt><dd><p>user’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">old_itimerspec32</span></code></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or negative errno on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_old_itimerspec32">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_old_itimerspec32</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">itimerspec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">its</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">old_itimerspec32</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_old_itimerspec32" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">itimerspec64</span></code> to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">old_itimerspec32</span></code> and copy the latter to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">itimerspec64</span> <span class="pre">*its</span></code></dt><dd><p>input <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">itimerspec64</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">old_itimerspec32</span> <span class="pre">__user</span> <span class="pre">*uits</span></code></dt><dd><p>user’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">old_itimerspec32</span></code></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or negative errno on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__round_jiffies_relative">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__round_jiffies_relative</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_relative" title="Link to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.__round_jiffies_relative" title="__round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies_relative()</span></code></a> rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.round_jiffies">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">round_jiffies</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.round_jiffies" title="round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies()</span></code></a> rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.round_jiffies_relative">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">round_jiffies_relative</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_relative" title="Link to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.round_jiffies_relative" title="round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies_relative()</span></code></a> rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__round_jiffies_up_relative">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__round_jiffies_up_relative</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_up_relative" title="Link to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.__round_jiffies_relative" title="__round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies_relative()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.round_jiffies_up">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">round_jiffies_up</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_up" title="Link to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.round_jiffies" title="round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.round_jiffies_up_relative">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">round_jiffies_up_relative</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_up_relative" title="Link to this definition">¶</a><br /></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.round_jiffies_relative" title="round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies_relative()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.timer_init_key">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">timer_init_key</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lock_class_key</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_init_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*func)(struct</span> <span class="pre">timer_list</span> <span class="pre">*)</span></code></dt><dd><p>timer callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>timer flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*key</span></code></dt><dd><p>lockdep class key of the fake lock used for tracking timer
sync lock dependencies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.timer_init_key" title="timer_init_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_init_key()</span></code></a> must be done to a timer prior to calling <em>any</em> of the
other timer functions.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mod_timer_pending">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mod_timer_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">expires</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_timer_pending" title="Link to this definition">¶</a><br /></dt>
<dd><p>Modify a pending timer’s timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The pending timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>New absolute timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mod_timer_pending" title="mod_timer_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer_pending()</span></code></a> is the same for pending timers as <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a>, but
will not activate inactive timers.</p>
<p>If <strong>timer-&gt;function</strong> == NULL then the start operation is silently
discarded.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was inactive and not modified or was in</dt><dd><p>shutdown state and the operation was discarded</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was active and requeued to expire at <strong>expires</strong></p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mod_timer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mod_timer</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">expires</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_timer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Modify a timer’s timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>New absolute timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>mod_timer(timer, expires) is equivalent to:</p>
<blockquote>
<div><p>timer_delete(timer); timer-&gt;expires = expires; add_timer(timer);</p>
</div></blockquote>
<p><a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a> is more efficient than the above open coded sequence. In
case that the timer is inactive, the <a class="reference internal" href="#c.timer_delete" title="timer_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete()</span></code></a> part is a NOP. The
timer is in any case activated with the new expiry time <strong>expires</strong>.</p>
<p>Note that if there are multiple unserialized concurrent users of the
same timer, then <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a> is the only safe way to modify the timeout,
since <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> cannot modify an already running timer.</p>
<p>If <strong>timer-&gt;function</strong> == NULL then the start operation is silently
discarded. In this case the return value is 0 and meaningless.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was inactive and started or was in shutdown</dt><dd><p>state and the operation was discarded</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was active and requeued to expire at <strong>expires</strong> or</dt><dd><p>the timer was active and not modified because <strong>expires</strong> did
not change the effective expiry time</p>
</dd>
</dl>
</li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.timer_reduce">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">timer_reduce</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">expires</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_reduce" title="Link to this definition">¶</a><br /></dt>
<dd><p>Modify a timer’s timeout if it would reduce the timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>New absolute timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.timer_reduce" title="timer_reduce"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_reduce()</span></code></a> is very similar to <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a>, except that it will only
modify an enqueued timer if that would reduce the expiration time. If
<strong>timer</strong> is not enqueued it starts the timer.</p>
<p>If <strong>timer-&gt;function</strong> == NULL then the start operation is silently
discarded.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was inactive and started or was in shutdown</dt><dd><p>state and the operation was discarded</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was active and requeued to expire at <strong>expires</strong> or</dt><dd><p>the timer was active and not modified because <strong>expires</strong>
did not change the effective expiry time such that the
timer would expire earlier than already scheduled</p>
</dd>
</dl>
</li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.add_timer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">add_timer</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Start a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be started</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start <strong>timer</strong> to expire at <strong>timer-&gt;expires</strong> in the future. <strong>timer-&gt;expires</strong>
is the absolute expiry time measured in ‘jiffies’. When the timer expires
timer-&gt;function(timer) will be invoked from soft interrupt context.</p>
<p>The <strong>timer-&gt;expires</strong> and <strong>timer-&gt;function</strong> fields must be set prior
to calling this function.</p>
<p>If <strong>timer-&gt;function</strong> == NULL then the start operation is silently
discarded.</p>
<p>If <strong>timer-&gt;expires</strong> is already in the past <strong>timer</strong> will be queued to
expire at the next timer tick.</p>
<p>This can only operate on an inactive timer. Attempts to invoke this on
an active timer are rejected with a warning.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.add_timer_local">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">add_timer_local</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer_local" title="Link to this definition">¶</a><br /></dt>
<dd><p>Start a timer on the local CPU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be started</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> except that the timer flag TIMER_PINNED is set.</p>
<p>See <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> for further details.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.add_timer_global">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">add_timer_global</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer_global" title="Link to this definition">¶</a><br /></dt>
<dd><p>Start a timer without TIMER_PINNED flag set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be started</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> except that the timer flag TIMER_PINNED is unset.</p>
<p>See <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> for further details.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.add_timer_on">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">add_timer_on</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer_on" title="Link to this definition">¶</a><br /></dt>
<dd><p>Start a timer on a particular CPU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be started</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The CPU to start it on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> except that it starts the timer on the given CPU and
the TIMER_PINNED flag is set. When timer shouldn’t be a pinned timer in
the next round, <a class="reference internal" href="#c.add_timer_global" title="add_timer_global"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer_global()</span></code></a> should be used instead as it unsets
the TIMER_PINNED flag.</p>
<p>See <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> for further details.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.timer_delete">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">timer_delete</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_delete" title="Link to this definition">¶</a><br /></dt>
<dd><p>Deactivate a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be deactivated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function only deactivates a pending timer, but contrary to
<a class="reference internal" href="#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a> it does not take into account whether the timer’s
callback function is concurrently executed on a different CPU or not.
It neither prevents rearming of the timer.  If <strong>timer</strong> can be rearmed
concurrently then the return value of this function is meaningless.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was pending and deactivated</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.timer_shutdown">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">timer_shutdown</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_shutdown" title="Link to this definition">¶</a><br /></dt>
<dd><p>Deactivate a timer and prevent rearming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be deactivated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function does not wait for an eventually running timer callback on a
different CPU but it prevents rearming of the timer. Any attempt to arm
<strong>timer</strong> after this function returns will be silently ignored.</p>
<p>This function is useful for teardown code and should only be used when
<a class="reference internal" href="#c.timer_shutdown_sync" title="timer_shutdown_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_shutdown_sync()</span></code></a> cannot be invoked due to locking or context constraints.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was pending</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.timer_delete_sync_try">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">timer_delete_sync_try</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_delete_sync_try" title="Link to this definition">¶</a><br /></dt>
<dd><p>Try to deactivate a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>Timer to deactivate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tries to deactivate a timer. On success the timer is not
queued and the timer callback function is not running on any CPU.</p>
<p>This function does not guarantee that the timer cannot be rearmed right
after dropping the base lock. That needs to be prevented by the calling
code if necessary.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>  - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>  - The timer was pending and deactivated</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code> - The timer callback function is running on a different CPU</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.timer_delete_sync">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">timer_delete_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_delete_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>Deactivate a timer and wait for the handler to finish.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be deactivated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Synchronization rules: Callers must prevent restarting of the timer,
otherwise this function is meaningless. It must not be called from
interrupt contexts unless the timer is an irqsafe one. The caller must
not hold locks which would prevent completion of the timer’s callback
function. The timer’s handler must not call <a class="reference internal" href="#c.add_timer_on" title="add_timer_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer_on()</span></code></a>. Upon exit
the timer is not queued and the handler is not running on any CPU.</p>
<p>For !irqsafe timers, the caller must not hold locks that are held in
interrupt context. Even if the lock has nothing to do with the timer in
question.  Here’s why:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU0                             CPU1
----                             ----
                                 &lt;SOFTIRQ&gt;
                                   call_timer_fn();
                                   base-&gt;running_timer = mytimer;
spin_lock_irq(somelock);
                                 &lt;IRQ&gt;
                                    spin_lock(somelock);
timer_delete_sync(mytimer);
while (base-&gt;running_timer == mytimer);
</pre></div>
</div>
<p>Now <a class="reference internal" href="#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a> will never return and never release somelock.
The interrupt on the other CPU is waiting to grab somelock but it has
interrupted the softirq that CPU0 is waiting to finish.</p>
<p>This function cannot guarantee that the timer is not rearmed again by
some concurrent or preempting code, right after it dropped the base
lock. If there is the possibility of a concurrent rearm then the return
value of the function is meaningless.</p>
<p>If such a guarantee is needed, e.g. for teardown situations then use
<a class="reference internal" href="#c.timer_shutdown_sync" title="timer_shutdown_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_shutdown_sync()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was pending and deactivated</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.timer_shutdown_sync">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">timer_shutdown_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_shutdown_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>Shutdown a timer and prevent rearming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be shutdown</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>When the function returns it is guaranteed that:</dt><dd><ul class="simple">
<li><p><strong>timer</strong> is not queued</p></li>
<li><p>The callback function of <strong>timer</strong> is not running</p></li>
<li><p><strong>timer</strong> cannot be enqueued again. Any attempt to rearm
<strong>timer</strong> is silently ignored.</p></li>
</ul>
</dd>
</dl>
<p>See <a class="reference internal" href="#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a> for synchronization rules.</p>
<p>This function is useful for final teardown of an infrastructure where
the timer is subject to a circular dependency problem.</p>
<p>A common pattern for this is a timer and a workqueue where the timer can
schedule work and work can arm the timer. On shutdown the workqueue must
be destroyed and the timer must be prevented from rearming. Unless the
code has conditionals like ‘if (mything-&gt;in_shutdown)’ to prevent that
there is no way to get this correct with <a class="reference internal" href="#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a>.</p>
<p><a class="reference internal" href="#c.timer_shutdown_sync" title="timer_shutdown_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_shutdown_sync()</span></code></a> is solving the problem. The correct ordering of
calls in this case is:</p>
<blockquote>
<div><p>timer_shutdown_sync(<code class="xref c c-type docutils literal notranslate"><span class="pre">mything-&gt;timer</span></code>);
workqueue_destroy(<code class="xref c c-type docutils literal notranslate"><span class="pre">mything-&gt;workqueue</span></code>);</p>
</div></blockquote>
<p>After this ‘mything’ can be safely freed.</p>
<p>This obviously implies that the timer is not required to be functional
for the rest of the shutdown operation.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was pending</p></li>
</ul>
</div>
</section>
<section id="high-resolution-timers">
<h2>High-resolution timers<a class="headerlink" href="#high-resolution-timers" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.ktime_set">
<span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ktime_set</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">secs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nsecs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set a ktime_t variable from a seconds/nanoseconds value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">s64</span> <span class="pre">secs</span></code></dt><dd><p>seconds to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nsecs</span></code></dt><dd><p>nanoseconds to set</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The ktime_t representation of the value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ktime_compare">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ktime_compare</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmp2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_compare" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compares two ktime_t variables for less, greater or equal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>...</dt><dd><p>cmp1  &lt; cmp2: return &lt;0
cmp1 == cmp2: return 0
cmp1  &gt; cmp2: return &gt;0</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ktime_after">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ktime_after</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmp2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_after" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compare if a ktime_t value is bigger than another one.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if cmp1 happened after cmp2.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ktime_before">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ktime_before</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmp2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_before" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compare if a ktime_t value is smaller than another one.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if cmp1 happened before cmp2.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ktime_to_timespec64_cond">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ktime_to_timespec64_cond</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">kt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_to_timespec64_cond" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert a ktime_t variable to timespec64 format only if the variable contains data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">kt</span></code></dt><dd><p>the ktime_t variable to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>the timespec variable to store the result in</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if there was a successful conversion, <code class="docutils literal notranslate"><span class="pre">false</span></code> if kt was 0.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.hrtimer_sleeper">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_sleeper</span></span></span><a class="headerlink" href="#c.hrtimer_sleeper" title="Link to this definition">¶</a><br /></dt>
<dd><p>simple sleeper structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer_sleeper {
    struct hrtimer timer;
    struct task_struct *task;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">timer</span></code></dt><dd><p>embedded timer structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task</span></code></dt><dd><p>task to wake up</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>task is set to NULL, when the timer expires.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_start">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">tim</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_start" title="Link to this definition">¶</a><br /></dt>
<dd><p>(re)start an hrtimer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">tim</span></code></dt><dd><p>expiry time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode: absolute (HRTIMER_MODE_ABS) or
relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);
softirq based mode is considered for debug purpose only!</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_get_remaining">
<span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_get_remaining</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_get_remaining" title="Link to this definition">¶</a><br /></dt>
<dd><p>get remaining time for the timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to read</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_is_queued">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_is_queued</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_is_queued" title="Link to this definition">¶</a><br /></dt>
<dd><p>check, whether the timer is on one of the queues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>Timer to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the timer is queued, false otherwise</p>
<p><strong>Description</strong></p>
<p>The function can be used lockless, but it gives only a current snapshot.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_update_function">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_update_function</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_restart</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_update_function" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update the timer’s callback function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>Timer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_restart</span> <span class="pre">(*function)(struct</span> <span class="pre">hrtimer</span> <span class="pre">*)</span></code></dt><dd><p>New callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only safe to call if the timer is not enqueued. Can be called in the callback function if the
timer is not enqueued at the same time (see the comments above HRTIMER_STATE_ENQUEUED).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_forward_now">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_forward_now</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">interval</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_forward_now" title="Link to this definition">¶</a><br /></dt>
<dd><p>forward the timer expiry so it expires after now</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to forward</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">interval</span></code></dt><dd><p>the interval to forward</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is a variant of <a class="reference internal" href="#c.hrtimer_forward" title="hrtimer_forward"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_forward()</span></code></a>. The timer will expire after the current
time of the hrtimer clock base. See <a class="reference internal" href="#c.hrtimer_forward" title="hrtimer_forward"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_forward()</span></code></a> for details.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_forward">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_forward</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">now</span></span>, <span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">interval</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_forward" title="Link to this definition">¶</a><br /></dt>
<dd><p>forward the timer expiry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to forward</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">now</span></code></dt><dd><p>forward past this time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">interval</span></code></dt><dd><p>the interval to forward</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forward the timer expiry so it will expire in the future.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This only updates the timer expiry value and does not requeue the timer.</p>
</div>
<p>There is also a variant of the function <a class="reference internal" href="#c.hrtimer_forward_now" title="hrtimer_forward_now"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_forward_now()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Can be safely called from the callback function of <strong>timer</strong>. If called
from other contexts <strong>timer</strong> must neither be enqueued nor running the
callback and the caller needs to take care of serialization.</p>
<p><strong>Return</strong></p>
<p>The number of overruns are returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_start_range_ns">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_start_range_ns</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="n"><span class="pre">tim</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">delta_ns</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_start_range_ns" title="Link to this definition">¶</a><br /></dt>
<dd><p>(re)start an hrtimer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">tim</span></code></dt><dd><p>expiry time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">delta_ns</span></code></dt><dd><p>“slack” range for the timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode: absolute (HRTIMER_MODE_ABS) or
relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);
softirq based mode is considered for debug purpose only!</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_try_to_cancel">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_try_to_cancel</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_try_to_cancel" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to deactivate a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to stop</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 when the timer was not active</p></li>
<li><p>1 when the timer was active</p></li>
<li><p>-1 when the timer is currently executing the callback function and
cannot be stopped</p></li>
</ul>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_cancel">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_cancel</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_cancel" title="Link to this definition">¶</a><br /></dt>
<dd><p>cancel a timer and wait for the handler to finish.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be cancelled</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 when the timer was not active
1 when the timer was active</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__hrtimer_get_remaining">
<span class="n"><span class="pre">ktime_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__hrtimer_get_remaining</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">adjust</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__hrtimer_get_remaining" title="Link to this definition">¶</a><br /></dt>
<dd><p>get remaining time for the timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">adjust</span></code></dt><dd><p>adjust relative timers when CONFIG_TIME_LOW_RES=y</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_setup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_setup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_restart</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="n"><span class="pre">clockid_t</span></span><span class="w"> </span><span class="n"><span class="pre">clock_id</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_setup" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a timer to the given clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_restart</span> <span class="pre">(*function)(struct</span> <span class="pre">hrtimer</span> <span class="pre">*)</span></code></dt><dd><p>the callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt><dd><p>the clock to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>The modes which are relevant for initialization:
HRTIMER_MODE_ABS, HRTIMER_MODE_REL, HRTIMER_MODE_ABS_SOFT,
HRTIMER_MODE_REL_SOFT</p>
<p>The PINNED variants of the above can be handed in,
but the PINNED bit is ignored as pinning happens
when the hrtimer is started</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_setup_on_stack">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_setup_on_stack</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timer</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_restart</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="n"><span class="pre">clockid_t</span></span><span class="w"> </span><span class="n"><span class="pre">clock_id</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_setup_on_stack" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a timer on stack memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_restart</span> <span class="pre">(*function)(struct</span> <span class="pre">hrtimer</span> <span class="pre">*)</span></code></dt><dd><p>the callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt><dd><p>The clock to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>The timer mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.hrtimer_setup" title="hrtimer_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_setup()</span></code></a>, except that this one must be used if struct hrtimer is in stack
memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_sleeper_start_expires">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_sleeper_start_expires</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hrtimer_sleeper" title="hrtimer_sleeper"><span class="n"><span class="pre">hrtimer_sleeper</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sl</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_sleeper_start_expires" title="Link to this definition">¶</a><br /></dt>
<dd><p>Start a hrtimer sleeper timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*sl</span></code></dt><dd><p>sleeper to be started</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode abs/rel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper around hrtimer_start_expires() for hrtimer_sleeper based timers
to allow PREEMPT_RT to tweak the delivery mode (soft/hardirq context)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hrtimer_setup_sleeper_on_stack">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hrtimer_setup_sleeper_on_stack</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hrtimer_sleeper" title="hrtimer_sleeper"><span class="n"><span class="pre">hrtimer_sleeper</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sl</span></span>, <span class="n"><span class="pre">clockid_t</span></span><span class="w"> </span><span class="n"><span class="pre">clock_id</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hrtimer_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_setup_sleeper_on_stack" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a sleeper in stack memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*sl</span></code></dt><dd><p>sleeper to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt><dd><p>the clock to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode abs/rel</p>
</dd>
</dl>
</div>
</section>
<section id="wait-queues-and-wake-events">
<h2>Wait queues and Wake events<a class="headerlink" href="#wait-queues-and-wake-events" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.waitqueue_active">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">waitqueue_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.waitqueue_active" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>locklessly test for waiters on the queue</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue to test for waiters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns true if the wait list is not empty</p>
<p>Use either while holding wait_queue_head::lock or when used for wakeups
with an extra smp_mb() like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU0 - waker                    CPU1 - waiter

                                for (;;) {
@cond = true;                     prepare_to_wait(&amp;wq_head, &amp;wait, state);
smp_mb();                         // smp_mb() from set_current_state()
if (waitqueue_active(wq_head))         if (@cond)
  wake_up(wq_head);                      break;
                                  schedule();
                                }
                                finish_wait(&amp;wq_head, &amp;wait);
</pre></div>
</div>
<p>Because without the explicit smp_mb() it’s possible for the
<a class="reference internal" href="#c.waitqueue_active" title="waitqueue_active"><code class="xref c c-func docutils literal notranslate"><span class="pre">waitqueue_active()</span></code></a> load to get hoisted over the <strong>cond</strong> store such that we’ll
observe an empty wait list while the waiter might not observe <strong>cond</strong>.</p>
<p>Also note that this ‘optimization’ trades a spin_lock() for an smp_mb(),
which (when the lock is uncontended) are of roughly equal cost.</p>
<p><strong>NOTE</strong></p>
<p>this function is lockless and requires care, incorrect usage _will_
lead to sporadic and non-obvious failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_has_single_sleeper">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_has_single_sleeper</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_has_single_sleeper" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if there is only one sleeper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>wait queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true of wq_head has only one sleeper on the list.</p>
<p>Please refer to the comment for waitqueue_active.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_has_sleeper">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_has_sleeper</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_has_sleeper" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if there are any waiting processes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>wait queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if wq_head has waiting processes</p>
<p>Please refer to the comment for waitqueue_active.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wake_up_pollfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wake_up_pollfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wake_up_pollfree" title="Link to this definition">¶</a><br /></dt>
<dd><p>signal that a polled waitqueue is going away</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the wait queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In the very rare cases where a -&gt;poll() implementation uses a waitqueue whose
lifetime is tied to a task rather than to the ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’ being polled,
this function must be called before the waitqueue is freed so that
non-blocking polls (e.g. epoll) are notified that the queue is going away.</p>
<p>The caller must also RCU-delay the freeing of the wait_queue_head, e.g. via
an explicit <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> or <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, or via SLAB_TYPESAFE_BY_RCU.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event</span></span></span><a class="headerlink" href="#c.wait_event" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_freezable">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_freezable</span></span></span><a class="headerlink" href="#c.wait_event_freezable" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_freezable</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep (or freeze) until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE -- so as not to contribute
to system load) until the <strong>condition</strong> evaluates to true. The
<strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_timeout">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_timeout</span></span></span><a class="headerlink" href="#c.wait_event_timeout" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_cmd">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_cmd</span></span></span><a class="headerlink" href="#c.wait_event_cmd" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_cmd</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">cmd1,</span> <span class="pre">cmd2)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd1</span></code></dt><dd><p>the command will be executed before sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd2</span></code></dt><dd><p>the command will be executed after sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible</span></span></span><a class="headerlink" href="#c.wait_event_interruptible" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_timeout">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_timeout</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_timeout" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed, or -<code class="docutils literal notranslate"><span class="pre">ERESTARTSYS</span></code> if it was
interrupted by a signal.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_hrtimeout">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_hrtimeout</span></span></span><a class="headerlink" href="#c.wait_event_hrtimeout" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_hrtimeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, as a ktime_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function returns 0 if <strong>condition</strong> became true, or -ETIME if the timeout
elapsed.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_hrtimeout">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_hrtimeout</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_hrtimeout" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_hrtimeout</span> <span class="pre">(wq,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, as a ktime_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function returns 0 if <strong>condition</strong> became true, -ERESTARTSYS if it was
interrupted by a signal, or -ETIME if the timeout elapsed.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_idle">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_idle</span></span></span><a class="headerlink" href="#c.wait_event_idle" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_idle</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>wait for a condition without contributing to system load</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_idle_exclusive">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_idle_exclusive</span></span></span><a class="headerlink" href="#c.wait_event_idle_exclusive" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_idle_exclusive</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>wait for a condition with contributing to system load</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus if other processes wait on the same list, when this
process is woken further processes are not considered.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_idle_timeout">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_idle_timeout</span></span></span><a class="headerlink" href="#c.wait_event_idle_timeout" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_idle_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep without load until a condition becomes true or a timeout elapses</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_idle_exclusive_timeout">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_idle_exclusive_timeout</span></span></span><a class="headerlink" href="#c.wait_event_idle_exclusive_timeout" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_idle_exclusive_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep without load until a condition becomes true or a timeout elapses</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus if other processes wait on the same list, when this
process is woken further processes are not considered.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_locked">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_locked</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_locked" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_locked</span> <span class="pre">(wq,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock()/spin_unlock()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_locked_irq">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_locked_irq</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_locked_irq" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_locked_irq</span> <span class="pre">(wq,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_exclusive_locked">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_exclusive_locked</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_exclusive_locked" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_exclusive_locked</span> <span class="pre">(wq,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep exclusively until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock()/spin_unlock()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_exclusive_locked_irq">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_exclusive_locked_irq</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_exclusive_locked_irq" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_exclusive_locked_irq</span> <span class="pre">(wq,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_killable">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_killable</span></span></span><a class="headerlink" href="#c.wait_event_killable" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_killable</span> <span class="pre">(wq_head,</span> <span class="pre">condition)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_KILLABLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_state">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_state</span></span></span><a class="headerlink" href="#c.wait_event_state" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_state</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">state)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>state to sleep in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (<strong>state</strong>) until the <strong>condition</strong> evaluates to true
or a signal is received (when allowed by <strong>state</strong>).  The <strong>condition</strong> is checked
each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a signal
(when allowed by <strong>state</strong>) and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_killable_timeout">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_killable_timeout</span></span></span><a class="headerlink" href="#c.wait_event_killable_timeout" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_killable_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_KILLABLE) until the
<strong>condition</strong> evaluates to true or a kill signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>Only kill signals interrupt this process.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed, or -<code class="docutils literal notranslate"><span class="pre">ERESTARTSYS</span></code> if it was
interrupted by a kill signal.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_lock_irq_cmd">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_lock_irq_cmd</span></span></span><a class="headerlink" href="#c.wait_event_lock_irq_cmd" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_lock_irq_cmd</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock,</span> <span class="pre">cmd)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before cmd
and schedule() and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>a command which is invoked outside the critical section before
sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_lock_irq">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_lock_irq</span></span></span><a class="headerlink" href="#c.wait_event_lock_irq" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_lock_irq</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_lock_irq_cmd">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_lock_irq_cmd</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq_cmd" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_lock_irq_cmd</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock,</span> <span class="pre">cmd)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before cmd and
schedule() and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>a command which is invoked outside the critical section before
sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.</p>
<p>The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_lock_irq">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_lock_irq</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_lock_irq</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<p>The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.wait_event_interruptible_lock_irq_timeout">
<span class="sig-name descname"><span class="n"><span class="pre">wait_event_interruptible_lock_irq_timeout</span></span></span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq_timeout" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">wait_event_interruptible_lock_irq_timeout</span> <span class="pre">(wq_head,</span> <span class="pre">condition,</span> <span class="pre">lock,</span> <span class="pre">timeout)</span></code></p>
<blockquote>
<div><p>sleep until a condition gets true or a timeout elapses. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<p>The function returns 0 if the <strong>timeout</strong> elapsed, -ERESTARTSYS if it
was interrupted by a signal, and the remaining jiffies otherwise
if the condition evaluated to true before the timeout elapsed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__wake_up">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__wake_up</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_head</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_exclusive</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up" title="Link to this definition">¶</a><br /></dt>
<dd><p>wake up threads blocked on a waitqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_exclusive</span></code></dt><dd><p>how many wake-one or wake-many threads to wake up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>is directly passed to the wakeup function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this function wakes up a task, it executes a full memory barrier
before accessing the task state.  Returns the number of exclusive
tasks that were awaken.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__wake_up_sync_key">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__wake_up_sync_key</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_head</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up_sync_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>wake up threads blocked on a waitqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>opaque value to be passed to wakeup targets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sync wakeup differs that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are ‘synchronized’
with each other. This can prevent needless bouncing between CPUs.</p>
<p>On UP it can prevent extra preemption.</p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__wake_up_locked_sync_key">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__wake_up_locked_sync_key</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_head</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up_locked_sync_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>wake up a thread blocked on a locked waitqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>opaque value to be passed to wakeup targets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sync wakeup differs in that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are ‘synchronized’
with each other. This can prevent needless bouncing between CPUs.</p>
<p>On UP it can prevent extra preemption.</p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.finish_wait">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">finish_wait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_head</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_queue_entry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq_entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.finish_wait" title="Link to this definition">¶</a><br /></dt>
<dd><p>clean up after waiting in a queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>waitqueue waited on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_entry</span> <span class="pre">*wq_entry</span></code></dt><dd><p>wait descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets current thread back to running state and removes
the wait descriptor from the given waitqueue if still
queued.</p>
</div>
</section>
<section id="internal-functions">
<h2>Internal Functions<a class="headerlink" href="#internal-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.wait_task_stopped">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wait_task_stopped</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wait_opts</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wo</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ptrace</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_task_stopped" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait for <code class="docutils literal notranslate"><span class="pre">TASK_STOPPED</span></code> or <code class="docutils literal notranslate"><span class="pre">TASK_TRACED</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_opts</span> <span class="pre">*wo</span></code></dt><dd><p>wait options</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ptrace</span></code></dt><dd><p>is the wait for ptrace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle sys_wait4() work for <code class="docutils literal notranslate"><span class="pre">p</span></code> in state <code class="docutils literal notranslate"><span class="pre">TASK_STOPPED</span></code> or <code class="docutils literal notranslate"><span class="pre">TASK_TRACED</span></code>.</p>
<p><strong>Context</strong></p>
<p>read_lock(<code class="xref c c-type docutils literal notranslate"><span class="pre">tasklist_lock</span></code>), which is released if return value is
non-zero.  Also, grabs and releases <strong>p-&gt;sighand-&gt;siglock</strong>.</p>
<p><strong>Return</strong></p>
<p>0 if wait condition didn’t exist and search for other wait conditions
should continue.  Non-zero return, -errno on failure and <strong>p</strong>’s pid on
success, implies that tasklist_lock is released and wait condition
search should terminate.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.task_set_jobctl_pending">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task_set_jobctl_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.task_set_jobctl_pending" title="Link to this definition">¶</a><br /></dt>
<dd><p>set jobctl pending bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>pending bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>mask</strong> from <strong>task-&gt;jobctl</strong>.  <strong>mask</strong> must be subset of
<code class="docutils literal notranslate"><span class="pre">JOBCTL_PENDING_MASK</span></code> | <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_CONSUME</span></code> | <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_SIGMASK</span></code> |
<code class="docutils literal notranslate"><span class="pre">JOBCTL_TRAPPING</span></code>.  If stop signo is being set, the existing signo is
cleared.  If <strong>task</strong> is already being killed or exiting, this function
becomes noop.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>mask</strong> is set, <code class="docutils literal notranslate"><span class="pre">false</span></code> if made noop because <strong>task</strong> was dying.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.task_clear_jobctl_trapping">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task_clear_jobctl_trapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.task_clear_jobctl_trapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>clear jobctl trapping bit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If JOBCTL_TRAPPING is set, a ptracer is waiting for us to enter TRACED.
Clear it and wake up the ptracer.  Note that we don’t need any further
locking.  <strong>task-&gt;siglock</strong> guarantees that <strong>task-&gt;parent</strong> points to the
ptracer.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.task_clear_jobctl_pending">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task_clear_jobctl_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.task_clear_jobctl_pending" title="Link to this definition">¶</a><br /></dt>
<dd><p>clear jobctl pending bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>pending bits to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>mask</strong> from <strong>task-&gt;jobctl</strong>.  <strong>mask</strong> must be subset of
<code class="docutils literal notranslate"><span class="pre">JOBCTL_PENDING_MASK</span></code>.  If <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> is being cleared, other
STOP bits are cleared together.</p>
<p>If clearing of <strong>mask</strong> leaves no stop or trap pending, this function calls
<a class="reference internal" href="#c.task_clear_jobctl_trapping" title="task_clear_jobctl_trapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">task_clear_jobctl_trapping()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.task_participate_group_stop">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">task_participate_group_stop</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.task_participate_group_stop" title="Link to this definition">¶</a><br /></dt>
<dd><p>participate in a group stop</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>task participating in a group stop</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>task</strong> has <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> set and is participating in a group stop.
Group stop states are cleared and the group stop count is consumed if
<code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_CONSUME</span></code> was set.  If the consumption completes the group
stop, the appropriate <cite>SIGNAL_*</cite> flags are set.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if group stop completion should be notified to the parent, <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ptrace_trap_notify">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ptrace_trap_notify</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ptrace_trap_notify" title="Link to this definition">¶</a><br /></dt>
<dd><p>schedule trap to notify ptracer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*t</span></code></dt><dd><p>tracee wanting to notify tracer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function schedules sticky ptrace trap which is cleared on the next
TRAP_STOP to notify ptracer of an event.  <strong>t</strong> must have been seized by
ptracer.</p>
<p>If <strong>t</strong> is running, STOP trap will be taken.  If trapped for STOP and
ptracer is listening for events, tracee is woken up so that it can
re-trap for the new event.  If trapped otherwise, STOP trap will be
eventually taken without returning to userland after the existing traps
are finished by PTRACE_CONT.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.force_sig_seccomp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">force_sig_seccomp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">syscall</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">reason</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">force_coredump</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.force_sig_seccomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>signals the task to allow in-process syscall emulation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">syscall</span></code></dt><dd><p>syscall number to send to userland</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reason</span></code></dt><dd><p>filter-supplied reason code to send to userland (via si_errno)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_coredump</span></code></dt><dd><p>true to trigger a coredump</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces a SIGSYS with a code of SYS_SECCOMP and related sigsys info.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.do_notify_parent_cldstop">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">do_notify_parent_cldstop</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tsk</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">for_ptracer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">why</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.do_notify_parent_cldstop" title="Link to this definition">¶</a><br /></dt>
<dd><p>notify parent of stopped/continued state change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>task reporting the state change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">for_ptracer</span></code></dt><dd><p>the notification is for ptracer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">why</span></code></dt><dd><p>CLD_{CONTINUED|STOPPED|TRAPPED} to report</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notify <strong>tsk</strong>’s parent that the stopped/continued state has changed.  If
<strong>for_ptracer</strong> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, <strong>tsk</strong>’s group leader notifies to its real parent.
If <code class="docutils literal notranslate"><span class="pre">true</span></code>, <strong>tsk</strong> reports to <strong>tsk-&gt;parent</strong> which should be the ptracer.</p>
<p><strong>Context</strong></p>
<p>Must be called with tasklist_lock at least read locked.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.do_signal_stop">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">do_signal_stop</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">signr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.do_signal_stop" title="Link to this definition">¶</a><br /></dt>
<dd><p>handle group stop for SIGSTOP and other stop signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">signr</span></code></dt><dd><p>signr causing group stop if initiating</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> is not set yet, initiate group stop with <strong>signr</strong>
and participate in it.  If already set, participate in the existing
group stop.  If participated in a group stop (and thus slept), <code class="docutils literal notranslate"><span class="pre">true</span></code> is
returned with siglock released.</p>
<p>If ptraced, this function doesn’t handle stop itself.  Instead,
<code class="docutils literal notranslate"><span class="pre">JOBCTL_TRAP_STOP</span></code> is scheduled and <code class="docutils literal notranslate"><span class="pre">false</span></code> is returned with siglock
untouched.  The caller must ensure that INTERRUPT trap handling takes
places afterwards.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held, which is released
on <code class="docutils literal notranslate"><span class="pre">true</span></code> return.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if group stop is already cancelled or ptrace trap is scheduled.
<code class="docutils literal notranslate"><span class="pre">true</span></code> if participated in group stop.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.do_jobctl_trap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">do_jobctl_trap</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.do_jobctl_trap" title="Link to this definition">¶</a><br /></dt>
<dd><p>take care of ptrace jobctl traps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When PT_SEIZED, it’s used for both group stop and explicit
SEIZE/INTERRUPT traps.  Both generate PTRACE_EVENT_STOP trap with
accompanying siginfo.  If stopped, lower eight bits of exit_code contain
the stop signal; otherwise, <code class="docutils literal notranslate"><span class="pre">SIGTRAP</span></code>.</p>
<p>When !PT_SEIZED, it’s used only for group stop trap with stop signal
number as exit_code and no siginfo.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held, which may be
released and re-acquired before returning with intervening sleep.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.do_freezer_trap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">do_freezer_trap</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.do_freezer_trap" title="Link to this definition">¶</a><br /></dt>
<dd><p>handle the freezer jobctl trap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Puts the task into frozen state, if only the task is not about to quit.
In this case it drops JOBCTL_TRAP_FREEZE.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held,
which is always released before returning.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.signal_delivered">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">signal_delivered</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ksignal</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ksig</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">stepping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.signal_delivered" title="Link to this definition">¶</a><br /></dt>
<dd><p>called after signal delivery to update blocked signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ksignal</span> <span class="pre">*ksig</span></code></dt><dd><p>kernel signal struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stepping</span></code></dt><dd><p>nonzero if debugger single-step or block-step in use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called when a signal has successfully been
delivered. It updates the blocked signals accordingly (<strong>ksig-&gt;ka.sa.sa_mask</strong>
is always blocked), and the signal itself is blocked unless <code class="docutils literal notranslate"><span class="pre">SA_NODEFER</span></code>
is set in <strong>ksig-&gt;ka.sa.sa_flags</strong>.  Tracing is notified.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_restart_syscall">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_restart_syscall</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_restart_syscall" title="Link to this definition">¶</a><br /></dt>
<dd><p>restart a system call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_current_blocked">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_current_blocked</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">sigset_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">newset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_current_blocked" title="Link to this definition">¶</a><br /></dt>
<dd><p>change current-&gt;blocked mask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">*newset</span></code></dt><dd><p>new mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is wrong to change -&gt;blocked directly, this helper should be used
to ensure the process can’t miss a shared signal we are going to block.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_rt_sigprocmask">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_rt_sigprocmask</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">how</span></span>, <span class="n"><span class="pre">sigset_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nset</span></span>, <span class="n"><span class="pre">sigset_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">oset</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">sigsetsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigprocmask" title="Link to this definition">¶</a><br /></dt>
<dd><p>change the list of currently blocked signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">how</span></code></dt><dd><p>whether to add, remove, or set signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">nset</span></code></dt><dd><p>stores pending signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oset</span></code></dt><dd><p>previous value of signal mask if non-null</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_rt_sigpending">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_rt_sigpending</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">sigset_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uset</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">sigsetsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigpending" title="Link to this definition">¶</a><br /></dt>
<dd><p>examine a pending signal that has been raised while blocked</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uset</span></code></dt><dd><p>stores pending signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type or larger</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.copy_siginfo_to_external32">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">copy_siginfo_to_external32</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">compat_siginfo</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kernel_siginfo</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_siginfo_to_external32" title="Link to this definition">¶</a><br /></dt>
<dd><p>copy a kernel siginfo into a compat user siginfo</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">compat_siginfo</span> <span class="pre">*to</span></code></dt><dd><p>compat siginfo destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kernel_siginfo</span> <span class="pre">*from</span></code></dt><dd><p>kernel siginfo source</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function does not work properly for the SIGCHLD on x32, but
fortunately it doesn’t have to.  The only valid callers for this function are
copy_siginfo_to_user32, which is overriden for x32 and the coredump code.
The latter does not care because SIGCHLD will never cause a coredump.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.do_sigtimedwait">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">do_sigtimedwait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">sigset_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">which</span></span>, <span class="n"><span class="pre">kernel_siginfo_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.do_sigtimedwait" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for queued signals specified in <strong>which</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">sigset_t</span> <span class="pre">*which</span></code></dt><dd><p>queued signals to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_siginfo_t</span> <span class="pre">*info</span></code></dt><dd><p>if non-null, the signal’s siginfo is returned here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>upper bound on process time suspension</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_rt_sigtimedwait">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_rt_sigtimedwait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">sigset_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uthese</span></span>, <span class="n"><span class="pre">siginfo_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uinfo</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">__kernel_timespec</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uts</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">sigsetsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigtimedwait" title="Link to this definition">¶</a><br /></dt>
<dd><p>synchronously wait for queued signals specified in <strong>uthese</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uthese</span></code></dt><dd><p>queued signals to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt><dd><p>if non-null, the signal’s siginfo is returned here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">__kernel_timespec</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uts</span></code></dt><dd><p>upper bound on process time suspension</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_kill">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_kill</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pid_t</span></span><span class="w"> </span><span class="n"><span class="pre">pid</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sig</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_kill" title="Link to this definition">¶</a><br /></dt>
<dd><p>send a signal to a process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_pidfd_send_signal">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_pidfd_send_signal</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">pidfd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sig</span></span>, <span class="n"><span class="pre">siginfo_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_pidfd_send_signal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Signal a process through a pidfd</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pidfd</span></code></dt><dd><p>file descriptor of the process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>signal info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>future flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send the signal to the thread group or to the individual thread depending
on PIDFD_THREAD.
In the future extension to <strong>flags</strong> may be used to override the default scope
of <strong>pidfd</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative errno on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_tgkill">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_tgkill</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pid_t</span></span><span class="w"> </span><span class="n"><span class="pre">tgid</span></span>, <span class="n"><span class="pre">pid_t</span></span><span class="w"> </span><span class="n"><span class="pre">pid</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sig</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_tgkill" title="Link to this definition">¶</a><br /></dt>
<dd><p>send signal to one specific thread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">tgid</span></code></dt><dd><p>the thread group ID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
<p>This syscall also checks the <strong>tgid</strong> and returns -ESRCH even if the PID
exists but it’s not belonging to the target process anymore. This
method solves the problem of threads exiting and PIDs getting reused.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_tkill">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_tkill</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pid_t</span></span><span class="w"> </span><span class="n"><span class="pre">pid</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sig</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_tkill" title="Link to this definition">¶</a><br /></dt>
<dd><p>send signal to one specific task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
<p>Send a signal to only one task, even if it’s a CLONE_THREAD task.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_rt_sigqueueinfo">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_rt_sigqueueinfo</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pid_t</span></span><span class="w"> </span><span class="n"><span class="pre">pid</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sig</span></span>, <span class="n"><span class="pre">siginfo_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uinfo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigqueueinfo" title="Link to this definition">¶</a><br /></dt>
<dd><p>send signal information to a signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt><dd><p>signal info to be sent</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_sigpending">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_sigpending</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">old_sigset_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_sigpending" title="Link to this definition">¶</a><br /></dt>
<dd><p>examine pending signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uset</span></code></dt><dd><p>where mask of pending signal is returned</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_sigprocmask">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_sigprocmask</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">how</span></span>, <span class="n"><span class="pre">old_sigset_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nset</span></span>, <span class="n"><span class="pre">old_sigset_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">oset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_sigprocmask" title="Link to this definition">¶</a><br /></dt>
<dd><p>examine and change blocked signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">how</span></code></dt><dd><p>whether to add, remove, or set signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">nset</span></code></dt><dd><p>signals to add or remove (if non-null)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oset</span></code></dt><dd><p>previous value of signal mask if non-null</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some platforms have their own version with special arguments;
others support only sys_rt_sigprocmask.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_rt_sigaction">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_rt_sigaction</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sig</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sigaction</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">act</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sigaction</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">oact</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">sigsetsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigaction" title="Link to this definition">¶</a><br /></dt>
<dd><p>alter an action taken by a process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigaction</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">act</span></code></dt><dd><p>new sigaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sigaction</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oact</span></code></dt><dd><p>used to save the previous sigaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_rt_sigsuspend">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_rt_sigsuspend</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">sigset_t</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">unewset</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">sigsetsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigsuspend" title="Link to this definition">¶</a><br /></dt>
<dd><p>replace the signal mask for a value with the <strong>unewset</strong> value until a signal is received</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">unewset</span></code></dt><dd><p>new signal mask value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kthread_create">
<span class="sig-name descname"><span class="n"><span class="pre">kthread_create</span></span></span><a class="headerlink" href="#c.kthread_create" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kthread_create</span> <span class="pre">(threadfn,</span> <span class="pre">data,</span> <span class="pre">namefmt,</span> <span class="pre">arg...)</span></code></p>
<blockquote>
<div><p>create a kthread on the current node</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">threadfn</span></code></dt><dd><p>the function to run in the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>data pointer for <strong>threadfn()</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namefmt</span></code></dt><dd><p>printf-style format string for the thread name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">arg...</span></code></dt><dd><p>arguments for <strong>namefmt</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro will create a kthread on the current node, leaving it in
the stopped state.  This is just a helper for <a class="reference internal" href="#c.kthread_create_on_node" title="kthread_create_on_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create_on_node()</span></code></a>;
see the documentation there for more details.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kthread_run">
<span class="sig-name descname"><span class="n"><span class="pre">kthread_run</span></span></span><a class="headerlink" href="#c.kthread_run" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kthread_run</span> <span class="pre">(threadfn,</span> <span class="pre">data,</span> <span class="pre">namefmt,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>create and wake a thread.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">threadfn</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namefmt</span></code></dt><dd><p>printf-style name for the thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenient wrapper for <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a> followed by
<a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>.  Returns the kthread or ERR_PTR(-ENOMEM).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_run_on_cpu">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kthread_run_on_cpu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">threadfn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">namefmt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_run_on_cpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>create and wake a cpu bound thread.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*threadfn)(void</span> <span class="pre">*data)</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The cpu on which the thread should be bound,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*namefmt</span></code></dt><dd><p>printf-style name for the thread. Format is restricted
to “name.*``u``”. Code fills in cpu number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenient wrapper for <a class="reference internal" href="#c.kthread_create_on_cpu" title="kthread_create_on_cpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create_on_cpu()</span></code></a>
followed by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>.  Returns the kthread or
ERR_PTR(-ENOMEM).</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kthread_run_worker">
<span class="sig-name descname"><span class="n"><span class="pre">kthread_run_worker</span></span></span><a class="headerlink" href="#c.kthread_run_worker" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kthread_run_worker</span> <span class="pre">(flags,</span> <span class="pre">namefmt,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>create and wake a kthread worker.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags modifying the default behavior of the worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namefmt</span></code></dt><dd><p>printf-style name for the thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenient wrapper for kthread_create_worker() followed by
<a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>.  Returns the kthread_worker or ERR_PTR(-ENOMEM).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_run_worker_on_cpu">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kthread_run_worker_on_cpu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">namefmt</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_run_worker_on_cpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>create and wake a cpu bound kthread worker.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags modifying the default behavior of the worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the thread. Format is restricted
to “name.*``u``”. Code fills in cpu number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenient wrapper for <a class="reference internal" href="#c.kthread_create_worker_on_cpu" title="kthread_create_worker_on_cpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create_worker_on_cpu()</span></code></a>
followed by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>.  Returns the kthread_worker or
ERR_PTR(-ENOMEM).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_should_stop">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_should_stop</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_should_stop" title="Link to this definition">¶</a><br /></dt>
<dd><p>should this kthread return now?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When someone calls <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> on your kthread, it will be woken
and this will return true.  You should then return, and your return
value will be passed through to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_should_park">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_should_park</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_should_park" title="Link to this definition">¶</a><br /></dt>
<dd><p>should this kthread park now?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When someone calls <a class="reference internal" href="#c.kthread_park" title="kthread_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_park()</span></code></a> on your kthread, it will be woken
and this will return true.  You should then do the necessary
cleanup and call kthread_parkme()</p>
<p>Similar to <a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a>, but this keeps the thread alive
and in a park position. <a class="reference internal" href="#c.kthread_unpark" title="kthread_unpark"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_unpark()</span></code></a> “restarts” the thread and
calls the thread function again.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_freezable_should_stop">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_freezable_should_stop</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">was_frozen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_freezable_should_stop" title="Link to this definition">¶</a><br /></dt>
<dd><p>should this freezable kthread return now?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*was_frozen</span></code></dt><dd><p>optional out parameter, indicates whether <code class="docutils literal notranslate"><span class="pre">current</span></code> was frozen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a> for freezable kthreads, which will enter
refrigerator if necessary.  This function is safe from <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> /
freezer deadlock and freezable kthreads should use this function instead
of calling try_to_freeze() directly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_func">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kthread_func</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_func" title="Link to this definition">¶</a><br /></dt>
<dd><p>return the function specified on kthread creation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>kthread task in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the task is not a kthread.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_data">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kthread_data</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>return data value specified on kthread creation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>kthread task in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the data value specified when kthread <strong>task</strong> was created.
The caller is responsible for ensuring the validity of <strong>task</strong> when
calling this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__noreturn</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_exit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_exit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Cause the current kthread return <strong>result</strong> to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">result</span></code></dt><dd><p>The integer value to return to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>While kthread_exit can be called directly, it exists so that
functions which do some additional work in non-modular code such as
module_put_and_kthread_exit can be implemented.</p>
<p>Does not return.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_complete_and_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__noreturn</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_complete_and_exit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">completion</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">comp</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">code</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_complete_and_exit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Exit the current kthread.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*comp</span></code></dt><dd><p>Completion to complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">code</span></code></dt><dd><p>The integer value to return to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If present, complete <strong>comp</strong> and then return code to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
<p>A kernel thread whose module may be removed after the completion of
<strong>comp</strong> can use this function to exit safely.</p>
<p>Does not return.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_create_on_node">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kthread_create_on_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">threadfn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">namefmt</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_on_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a kthread.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*threadfn)(void</span> <span class="pre">*data)</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>task and thread structures for the thread are allocated on this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function creates and names a kernel
thread.  The thread will be stopped: use <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a> to start
it.  See also <a class="reference internal" href="#c.kthread_run" title="kthread_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_run()</span></code></a>.  The new thread has SCHED_NORMAL policy and
is affine to all CPUs.</p>
<p>If thread is going to be bound on a particular cpu, give its node
in <strong>node</strong>, to get NUMA affinity for kthread stack, or else give NUMA_NO_NODE.
When woken, the thread will run <strong>threadfn()</strong> with <strong>data</strong> as its
argument. <strong>threadfn()</strong> can either return directly if it is a
standalone thread for which no one will call <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>, or
return when ‘<a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a>’ is true (which means
<a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> has been called).  The return value should be zero
or a negative error number; it will be passed to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
<p>Returns a task_struct or ERR_PTR(-ENOMEM) or ERR_PTR(-EINTR).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_bind">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_bind</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_bind" title="Link to this definition">¶</a><br /></dt>
<dd><p>bind a just-created kthread to a cpu.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>cpu (might not be online, must be possible) for <strong>k</strong> to run on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is equivalent to set_cpus_allowed(),
except that <strong>cpu</strong> doesn’t need to be online, and the thread must be
stopped (i.e., just returned from <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_create_on_cpu">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kthread_create_on_cpu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">threadfn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">namefmt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_on_cpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a cpu bound kthread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*threadfn)(void</span> <span class="pre">*data)</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The cpu on which the thread should be bound,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*namefmt</span></code></dt><dd><p>printf-style name for the thread. Format is restricted
to “name.*``u``”. Code fills in cpu number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function creates and names a kernel thread</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_unpark">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_unpark</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_unpark" title="Link to this definition">¶</a><br /></dt>
<dd><p>unpark a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_park" title="kthread_should_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_park()</span></code></a> for <strong>k</strong> to return false, wakes it, and
waits for it to return. If the thread is marked percpu then its
bound to the cpu again.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_park">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_park</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_park" title="Link to this definition">¶</a><br /></dt>
<dd><p>park a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_park" title="kthread_should_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_park()</span></code></a> for <strong>k</strong> to return true, wakes it, and
waits for it to return. This can also be called after <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>
instead of calling <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>: the thread will park without
calling threadfn().</p>
<p>Returns 0 if the thread is parked, -ENOSYS if the thread exited.
If called by the kthread itself just the park bit is set.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_stop">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_stop</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_stop" title="Link to this definition">¶</a><br /></dt>
<dd><p>stop a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a> for <strong>k</strong> to return true, wakes it, and
waits for it to exit. This can also be called after <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>
instead of calling <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>: the thread will exit without
calling threadfn().</p>
<p>If threadfn() may call <a class="reference internal" href="#c.kthread_exit" title="kthread_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_exit()</span></code></a> itself, the caller must ensure
task_struct can’t go away.</p>
<p>Returns the result of threadfn(), or <code class="docutils literal notranslate"><span class="pre">-EINTR</span></code> if <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>
was never called.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_stop_put">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_stop_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_stop_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>stop a thread and put its task struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a> and put its task_struct.
Only use when holding an extra task struct reference obtained by
calling get_task_struct().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_worker_fn">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_worker_fn</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker_ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_worker_fn" title="Link to this definition">¶</a><br /></dt>
<dd><p>kthread function to process kthread_worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*worker_ptr</span></code></dt><dd><p>pointer to initialized kthread_worker</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the main cycle of kthread worker. It processes
work_list until it is stopped with <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>. It sleeps when the queue
is empty.</p>
<p>The works are not allowed to keep any locks, disable preemption or interrupts
when they finish. There is defined a safe point for freezing when one work
finishes and before a new one is started.</p>
<p>Also the works must not be handled by more than one worker at the same time,
see also <a class="reference internal" href="#c.kthread_queue_work" title="kthread_queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_queue_work()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_create_worker_on_node">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kthread_create_worker_on_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">namefmt</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_worker_on_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a kthread worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags modifying the default behavior of the worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>task structure for the thread is allocated on this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the kthread worker (task).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the allocated worker on success, ERR_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR_PTR(-EINTR)
when the caller was killed by a fatal signal.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_create_worker_on_cpu">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kthread_create_worker_on_cpu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">namefmt</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_worker_on_cpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a kthread worker and bind it to a given CPU and the associated NUMA node.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags modifying the default behavior of the worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the thread. Format is restricted
to “name.*``u``”. Code fills in cpu number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use a valid CPU number if you want to bind the kthread worker
to the given CPU and the associated NUMA node.</p>
<p>A good practice is to add the cpu number also into the worker name.
For example, use kthread_create_worker_on_cpu(cpu, “helper/<code class="docutils literal notranslate"><span class="pre">d</span></code>”, cpu).</p>
<p>CPU hotplug:
The kthread worker API is simple and generic. It just provides a way
to create, use, and destroy workers.</p>
<p>It is up to the API user how to handle CPU hotplug. They have to decide
how to handle pending work items, prevent queuing new ones, and
restore the functionality when the CPU goes off and on. There are a
few catches:</p>
<blockquote>
<div><ul class="simple">
<li><p>CPU affinity gets lost when it is scheduled on an offline CPU.</p></li>
<li><p>The worker might not exist when the CPU was off when the user
created the workers.</p></li>
</ul>
</div></blockquote>
<p>Good practice is to implement two CPU hotplug callbacks and to
destroy/create the worker when the CPU goes down/up.</p>
<p><strong>Return</strong></p>
<p>The pointer to the allocated worker on success, ERR_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR_PTR(-EINTR)
when the caller was killed by a fatal signal.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_queue_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_queue_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_queue_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue a kthread_work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>target kthread_worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>kthread_work to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue <strong>work</strong> to work processor <strong>task</strong> for async execution.  <strong>task</strong>
must have been created with kthread_create_worker().  Returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
if <strong>work</strong> was successfully queued, <code class="docutils literal notranslate"><span class="pre">false</span></code> if it was already pending.</p>
<p>Reinitialize the work if it needs to be used by another worker.
For example, when the worker was stopped and started again.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_delayed_work_timer_fn">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_delayed_work_timer_fn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_delayed_work_timer_fn" title="Link to this definition">¶</a><br /></dt>
<dd><p>callback that queues the associated kthread delayed work when the timer expires.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*t</span></code></dt><dd><p>pointer to the expired timer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format of the function is defined by struct timer_list.
It should have been called from irqsafe timer with irq already off.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_queue_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_queue_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_queue_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue the associated kthread work after a delay.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>target kthread_worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>kthread_delayed_work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queuing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the work has not been pending it starts a timer that will queue
the work after the given <strong>delay</strong>. If <strong>delay</strong> is zero, it queues the
work immediately.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if the <strong>work</strong> has already been pending. It means that
either the timer was running or the work was queued. It returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_flush_work">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_flush_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_flush_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>flush a kthread_work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>work to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>work</strong> is queued or executing, wait for it to finish execution.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_mod_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_mod_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_mod_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>modify delay of or queue a kthread delayed work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>kthread worker to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>kthread delayed work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queuing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>dwork</strong> is idle, equivalent to <a class="reference internal" href="#c.kthread_queue_delayed_work" title="kthread_queue_delayed_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_queue_delayed_work()</span></code></a>. Otherwise,
modify <strong>dwork</strong>’s timer so that it expires after <strong>delay</strong>. If <strong>delay</strong> is zero,
<strong>work</strong> is guaranteed to be queued immediately.</p>
<p>A special case is when the work is being canceled in parallel.
It might be caused either by the real <a class="reference internal" href="#c.kthread_cancel_delayed_work_sync" title="kthread_cancel_delayed_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_delayed_work_sync()</span></code></a>
or yet another <a class="reference internal" href="#c.kthread_mod_delayed_work" title="kthread_mod_delayed_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_mod_delayed_work()</span></code></a> call. We let the other command
win and return <code class="docutils literal notranslate"><span class="pre">true</span></code> here. The return value can be used for reference
counting and the number of queued works stays the same. Anyway, the caller
is supposed to synchronize these operations a reasonable way.</p>
<p>This function is safe to call from any context including IRQ handler.
See __kthread_cancel_work() and <a class="reference internal" href="#c.kthread_delayed_work_timer_fn" title="kthread_delayed_work_timer_fn"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_delayed_work_timer_fn()</span></code></a>
for details.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>dwork</strong> was idle and queued, <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_cancel_work_sync">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_cancel_work_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_cancel_work_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>cancel a kthread work and wait for it to finish</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>the kthread work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cancel <strong>work</strong> and wait for its execution to finish.  This function
can be used even if the work re-queues itself. On return from this
function, <strong>work</strong> is guaranteed to be not pending or executing on any CPU.</p>
<p>kthread_cancel_work_sync(<code class="xref c c-type docutils literal notranslate"><span class="pre">delayed_work-&gt;work</span></code>) must not be used for
delayed_work’s. Use <a class="reference internal" href="#c.kthread_cancel_delayed_work_sync" title="kthread_cancel_delayed_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_delayed_work_sync()</span></code></a> instead.</p>
<p>The caller must ensure that the worker on which <strong>work</strong> was last
queued can’t be destroyed before this function returns.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>work</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_cancel_delayed_work_sync">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_cancel_delayed_work_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_cancel_delayed_work_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>cancel a kthread delayed work and wait for it to finish.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>the kthread delayed work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <a class="reference internal" href="#c.kthread_cancel_work_sync" title="kthread_cancel_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_work_sync()</span></code></a> for delayed works.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dwork</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_flush_worker">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_flush_worker</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_flush_worker" title="Link to this definition">¶</a><br /></dt>
<dd><p>flush all current works on a kthread_worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until all currently executing or pending works on <strong>worker</strong> are
finished.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_destroy_worker">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_destroy_worker</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kthread_worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_destroy_worker" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroy a kthread worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush and destroy <strong>worker</strong>.  The simple flush is enough because the kthread
worker API is used only in trivial scenarios.  There are no multi-step state
machines needed.</p>
<p>Note that this function is not responsible for handling delayed work, so
caller should be responsible for queuing or canceling all delayed work items
before invoke this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_use_mm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_use_mm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_use_mm" title="Link to this definition">¶</a><br /></dt>
<dd><p>make the calling kthread operate on an address space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>address space to operate on</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_unuse_mm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_unuse_mm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_unuse_mm" title="Link to this definition">¶</a><br /></dt>
<dd><p>reverse the effect of <a class="reference internal" href="#c.kthread_use_mm" title="kthread_use_mm"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_use_mm()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>address space to operate on</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kthread_associate_blkcg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kthread_associate_blkcg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cgroup_subsys_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">css</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_associate_blkcg" title="Link to this definition">¶</a><br /></dt>
<dd><p>associate blkcg to current kthread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*css</span></code></dt><dd><p>the cgroup info</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current thread must be a kthread. The thread is running jobs on behalf of
other threads. In some cases, we expect the jobs attach cgroup info of
original threads instead of that of current thread. This function stores
original thread’s cgroup info in current kthread context for later
retrieval.</p>
</div>
</section>
<section id="reference-counting">
<h2>Reference counting<a class="headerlink" href="#reference-counting" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_set</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>set a refcount’s value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>value to which the refcount will be set</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_set_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_set_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_set_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>set a refcount’s value with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>value to which the refcount will be set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be used when memory occupied by the object might be
reused to store another object -- consider SLAB_TYPESAFE_BY_RCU.</p>
<p>Provides release memory ordering which will order previous memory operations
against this store. This ensures all updates to this object are visible
once the refcount is set and stale values from the object previously
occupying this memory are overwritten with new ones.</p>
<p>This function should be called only after new object is fully initialized.
After this call the object should be considered visible to other tasks even
if it was not yet added into an object collection normally used to discover
it. This is because other tasks might have discovered the object previously
occupying the same memory and after memory reuse they can succeed in taking
refcount to the new object and start using it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_read">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a refcount’s value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the refcount’s value</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_add_not_zero">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_add_not_zero</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a value to a refcount unless it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>the value to add to the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_inc" title="refcount_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_inc()</span></code></a>, or one of its variants, should instead be used to
increment a reference count.</p>
<p><strong>Return</strong></p>
<p>false if the passed refcount is 0, true otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_add_not_zero_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_add_not_zero_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add_not_zero_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a value to a refcount with acquire ordering unless it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>the value to add to the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>This function should be used when memory occupied by the object might be
reused to store another object -- consider SLAB_TYPESAFE_BY_RCU.</p>
<p>Provides acquire memory ordering on success, it is assumed the caller has
guaranteed the object memory to be stable (RCU, etc.). It does provide a
control dependency and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_inc_not_zero_acquire" title="refcount_inc_not_zero_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_inc_not_zero_acquire()</span></code></a> should instead be used to increment a
reference count.</p>
<p><strong>Return</strong></p>
<p>false if the passed refcount is 0, true otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a value to a refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>the value to add to the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.atomic_add" title="atomic_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add()</span></code></a>, but will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_inc" title="refcount_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_inc()</span></code></a>, or one of its variants, should instead be used to
increment a reference count.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_inc_not_zero">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_inc_not_zero</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>increment a refcount unless it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount to increment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.atomic_inc_not_zero" title="atomic_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_not_zero()</span></code></a>, but will saturate at REFCOUNT_SATURATED
and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p><strong>Return</strong></p>
<p>true if the increment was successful, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_inc_not_zero_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_inc_not_zero_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc_not_zero_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>increment a refcount with acquire ordering unless it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount to increment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.refcount_inc_not_zero" title="refcount_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_inc_not_zero()</span></code></a>, but provides acquire memory ordering on
success.</p>
<p>This function should be used when memory occupied by the object might be
reused to store another object -- consider SLAB_TYPESAFE_BY_RCU.</p>
<p>Provides acquire memory ordering on success, it is assumed the caller has
guaranteed the object memory to be stable (RCU, etc.). It does provide a
control dependency and thereby orders future stores. See the comment on top.</p>
<p><strong>Return</strong></p>
<p>true if the increment was successful, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_inc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>increment a refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount to increment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.atomic_inc" title="atomic_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc()</span></code></a>, but will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller already has a
reference on the object.</p>
<p>Will WARN if the refcount is 0, as this represents a possible use-after-free
condition.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_sub_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_sub_and_test</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_sub_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>subtract from a refcount and test if it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>amount to subtract from the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.atomic_dec_and_test" title="atomic_dec_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_and_test()</span></code></a>, but it will WARN, return false and
ultimately leak on underflow and will fail to decrement when saturated
at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides an acquire ordering on success such that free()
must come after.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_dec" title="refcount_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_dec()</span></code></a>, or one of its variants, should instead be used to
decrement a reference count.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_dec_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_dec_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrement a refcount and test if it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.atomic_dec_and_test" title="atomic_dec_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_and_test()</span></code></a>, it will WARN on underflow and fail to
decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides an acquire ordering on success such that free()
must come after.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_dec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrement a refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.atomic_dec" title="atomic_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec()</span></code></a>, it will WARN on underflow and fail to decrement
when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_dec_if_one">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_dec_if_one</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_if_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrement a refcount if it is 1</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No atomic_t counterpart, it attempts a 1 -&gt; 0 transition and returns the
success thereof.</p>
<p>Like all decrement operations, it provides release memory order and provides
a control dependency.</p>
<p>It can be used like a try-delete operator; this explicit case is provided
and not cmpxchg in generic, because that would allow implementing unsafe
operations.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_dec_not_one">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_dec_not_one</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_not_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrement a refcount if it is not 1</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No atomic_t counterpart, it decrements unless the value is 1, in which case
it will return false.</p>
<p>Was often done like: atomic_add_unless(<code class="xref c c-type docutils literal notranslate"><span class="pre">var</span></code>, -1, 1)</p>
<p><strong>Return</strong></p>
<p>true if the decrement operation was successful, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_dec_and_mutex_lock">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_dec_and_mutex_lock</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mutex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lock</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_mutex_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>return holding mutex if able to decrement refcount to 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be locked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="../kernel-hacking/locking.html#c.atomic_dec_and_mutex_lock" title="atomic_dec_and_mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_and_mutex_lock()</span></code></a>, it will WARN on underflow and fail
to decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that free() must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold mutex if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_dec_and_lock">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_dec_and_lock</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">spinlock_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lock</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>return holding spinlock if able to decrement refcount to 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>the spinlock to be locked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec_and_lock(), it will WARN on underflow and fail to
decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that free() must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold spinlock if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.refcount_dec_and_lock_irqsave">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">refcount_dec_and_lock_irqsave</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">refcount_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">spinlock_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lock</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_lock_irqsave" title="Link to this definition">¶</a><br /></dt>
<dd><p>return holding spinlock with disabled interrupts if able to decrement refcount to 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>the spinlock to be locked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*flags</span></code></dt><dd><p>saved IRQ-flags if the is acquired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.refcount_dec_and_lock" title="refcount_dec_and_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_dec_and_lock()</span></code></a> above except that the spinlock is acquired
with disabled interrupts.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold spinlock if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
</div>
</section>
<section id="atomics">
<h2>Atomics<a class="headerlink" href="#atomics" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_read">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_read" title="raw_atomic_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_read()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_read_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_read_acquire</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_read_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_read_acquire" title="raw_atomic_read_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_read_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_set</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_set" title="raw_atomic_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_set()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_set_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_set_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_set_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_set_release" title="raw_atomic_set_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_set_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add" title="raw_atomic_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_return">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_return</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_return" title="raw_atomic_add_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_return_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_return_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_return_acquire" title="raw_atomic_add_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_return_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_return_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_return_release" title="raw_atomic_add_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_return_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_return_relaxed" title="raw_atomic_add_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_add" title="raw_atomic_fetch_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_add()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_add_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_add_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_add_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_add_acquire" title="raw_atomic_fetch_add_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_add_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_add_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_add_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_add_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_add_release" title="raw_atomic_fetch_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_add_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_add_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_add_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_add_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_add_relaxed" title="raw_atomic_fetch_add_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_add_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_sub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_sub" title="raw_atomic_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_sub()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_sub_return">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_sub_return</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_sub_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_sub_return" title="raw_atomic_sub_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_sub_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_sub_return_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_sub_return_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_sub_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_sub_return_acquire" title="raw_atomic_sub_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_sub_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_sub_return_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_sub_return_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_sub_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_sub_return_release" title="raw_atomic_sub_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_sub_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_sub_return_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_sub_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_sub_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_sub_return_relaxed" title="raw_atomic_sub_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_sub_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_sub">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_sub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_sub" title="raw_atomic_fetch_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_sub()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_sub_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_sub_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_sub_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_sub_acquire" title="raw_atomic_fetch_sub_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_sub_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_sub_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_sub_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_sub_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_sub_release" title="raw_atomic_fetch_sub_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_sub_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_sub_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_sub_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_sub_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_sub_relaxed" title="raw_atomic_fetch_sub_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_sub_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_inc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_inc" title="raw_atomic_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_inc()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_inc_return">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_inc_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_inc_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_inc_return" title="raw_atomic_inc_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_inc_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_inc_return_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_inc_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_inc_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_inc_return_acquire" title="raw_atomic_inc_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_inc_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_inc_return_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_inc_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_inc_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_inc_return_release" title="raw_atomic_inc_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_inc_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_inc_return_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_inc_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_inc_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_inc_return_relaxed" title="raw_atomic_inc_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_inc_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_inc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_inc" title="raw_atomic_fetch_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_inc()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_inc_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_inc_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_inc_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_inc_acquire" title="raw_atomic_fetch_inc_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_inc_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_inc_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_inc_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_inc_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_inc_release" title="raw_atomic_fetch_inc_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_inc_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_inc_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_inc_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_inc_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_inc_relaxed" title="raw_atomic_fetch_inc_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_inc_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_dec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_dec" title="raw_atomic_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_dec()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_dec_return">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_dec_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_dec_return" title="raw_atomic_dec_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_dec_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_dec_return_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_dec_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_dec_return_acquire" title="raw_atomic_dec_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_dec_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_dec_return_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_dec_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_dec_return_release" title="raw_atomic_dec_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_dec_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_dec_return_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_dec_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_dec_return_relaxed" title="raw_atomic_dec_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_dec_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_dec">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_dec" title="raw_atomic_fetch_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_dec()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_dec_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_dec_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_dec_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_dec_acquire" title="raw_atomic_fetch_dec_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_dec_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_dec_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_dec_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_dec_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_dec_release" title="raw_atomic_fetch_dec_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_dec_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_dec_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_dec_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_dec_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_dec_relaxed" title="raw_atomic_fetch_dec_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_dec_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_and">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_and</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_and" title="raw_atomic_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_and()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_and">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_and</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_and" title="raw_atomic_fetch_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_and()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_and_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_and_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_and_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_and_acquire" title="raw_atomic_fetch_and_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_and_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_and_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_and_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_and_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_and_release" title="raw_atomic_fetch_and_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_and_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_and_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_and_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_and_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_and_relaxed" title="raw_atomic_fetch_and_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_and_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_andnot">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_andnot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_andnot" title="raw_atomic_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_andnot()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_andnot">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_andnot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_andnot" title="raw_atomic_fetch_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_andnot()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_andnot_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_andnot_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_andnot_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_andnot_acquire" title="raw_atomic_fetch_andnot_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_andnot_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_andnot_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_andnot_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_andnot_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_andnot_release" title="raw_atomic_fetch_andnot_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_andnot_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_andnot_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_andnot_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_andnot_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_andnot_relaxed" title="raw_atomic_fetch_andnot_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_andnot_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_or">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_or</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_or" title="raw_atomic_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_or()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_or">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_or</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_or" title="raw_atomic_fetch_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_or()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_or_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_or_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_or_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_or_acquire" title="raw_atomic_fetch_or_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_or_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_or_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_or_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_or_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_or_release" title="raw_atomic_fetch_or_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_or_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_or_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_or_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_or_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_or_relaxed" title="raw_atomic_fetch_or_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_or_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_xor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_xor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_xor" title="raw_atomic_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_xor()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_xor">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_xor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_xor" title="raw_atomic_fetch_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_xor()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_xor_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_xor_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_xor_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_xor_acquire" title="raw_atomic_fetch_xor_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_xor_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_xor_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_xor_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_xor_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_xor_release" title="raw_atomic_fetch_xor_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_xor_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_xor_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_xor_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_xor_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_xor_relaxed" title="raw_atomic_fetch_xor_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_xor_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_xchg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_xchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_xchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_xchg" title="raw_atomic_xchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_xchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_xchg_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_xchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_xchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_xchg_acquire" title="raw_atomic_xchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_xchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_xchg_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_xchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_xchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_xchg_release" title="raw_atomic_xchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_xchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_xchg_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_xchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_xchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_xchg_relaxed" title="raw_atomic_xchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_xchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_cmpxchg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old</span></code></dt><dd><p>int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_cmpxchg" title="raw_atomic_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_cmpxchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_cmpxchg_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old</span></code></dt><dd><p>int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_cmpxchg_acquire" title="raw_atomic_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_cmpxchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_cmpxchg_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old</span></code></dt><dd><p>int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_cmpxchg_release" title="raw_atomic_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_cmpxchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_cmpxchg_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old</span></code></dt><dd><p>int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_cmpxchg_relaxed" title="raw_atomic_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_cmpxchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_try_cmpxchg">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_try_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_try_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*old</span></code></dt><dd><p>pointer to int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_try_cmpxchg" title="raw_atomic_try_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_try_cmpxchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_try_cmpxchg_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_try_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_try_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*old</span></code></dt><dd><p>pointer to int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_try_cmpxchg_acquire" title="raw_atomic_try_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_try_cmpxchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_try_cmpxchg_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_try_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_try_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*old</span></code></dt><dd><p>pointer to int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_try_cmpxchg_release" title="raw_atomic_try_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_try_cmpxchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_try_cmpxchg_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_try_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_try_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*old</span></code></dt><dd><p>pointer to int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_try_cmpxchg_relaxed" title="raw_atomic_try_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_try_cmpxchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_sub_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_sub_and_test</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_sub_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_sub_and_test" title="raw_atomic_sub_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_sub_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_dec_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_dec_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_dec_and_test" title="raw_atomic_dec_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_dec_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_inc_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_inc_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_inc_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_inc_and_test" title="raw_atomic_inc_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_inc_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_negative</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_negative" title="raw_atomic_add_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_negative()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_negative_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_negative_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_negative_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_negative_acquire" title="raw_atomic_add_negative_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_negative_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_negative_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_negative_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_negative_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_negative_release" title="raw_atomic_add_negative_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_negative_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_negative_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_negative_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_negative_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_negative_relaxed" title="raw_atomic_add_negative_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_negative_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_fetch_add_unless">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_fetch_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_fetch_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">a</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">u</span></code></dt><dd><p>int value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_fetch_add_unless" title="raw_atomic_fetch_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_fetch_add_unless()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_add_unless">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">a</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">u</span></code></dt><dd><p>int value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_add_unless" title="raw_atomic_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_add_unless()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_inc_not_zero">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_inc_not_zero</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_inc_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_inc_not_zero" title="raw_atomic_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_inc_not_zero()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_inc_unless_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_inc_unless_negative</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_inc_unless_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_inc_unless_negative" title="raw_atomic_inc_unless_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_inc_unless_negative()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_dec_unless_positive">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_dec_unless_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_unless_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement unless positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &lt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_dec_unless_positive" title="raw_atomic_dec_unless_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_dec_unless_positive()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_dec_if_positive">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_dec_if_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_if_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement if positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt; 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_dec_if_positive" title="raw_atomic_dec_if_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_dec_if_positive()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The old value of (<strong>v</strong> - 1), regardless of whether <strong>v</strong> was updated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_read">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_read" title="raw_atomic64_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_read()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_read_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_read_acquire</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_read_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_read_acquire" title="raw_atomic64_read_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_read_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_set</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_set" title="raw_atomic64_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_set()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_set_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_set_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_set_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_set_release" title="raw_atomic64_set_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_set_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add" title="raw_atomic64_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_return">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_return" title="raw_atomic64_add_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_return_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_return_acquire" title="raw_atomic64_add_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_return_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_return_release" title="raw_atomic64_add_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_return_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_return_relaxed" title="raw_atomic64_add_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_add">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_add</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_add" title="raw_atomic64_fetch_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_add()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_add_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_add_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_add_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_add_acquire" title="raw_atomic64_fetch_add_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_add_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_add_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_add_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_add_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_add_release" title="raw_atomic64_fetch_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_add_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_add_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_add_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_add_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_add_relaxed" title="raw_atomic64_fetch_add_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_add_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_sub</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_sub" title="raw_atomic64_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_sub()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_sub_return">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_sub_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_sub_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_sub_return" title="raw_atomic64_sub_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_sub_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_sub_return_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_sub_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_sub_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_sub_return_acquire" title="raw_atomic64_sub_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_sub_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_sub_return_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_sub_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_sub_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_sub_return_release" title="raw_atomic64_sub_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_sub_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_sub_return_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_sub_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_sub_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_sub_return_relaxed" title="raw_atomic64_sub_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_sub_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_sub">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_sub</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_sub" title="raw_atomic64_fetch_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_sub()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_sub_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_sub_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_sub_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_sub_acquire" title="raw_atomic64_fetch_sub_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_sub_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_sub_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_sub_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_sub_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_sub_release" title="raw_atomic64_fetch_sub_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_sub_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_sub_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_sub_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_sub_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_sub_relaxed" title="raw_atomic64_fetch_sub_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_sub_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_inc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_inc" title="raw_atomic64_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_inc()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_inc_return">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_inc_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_inc_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_inc_return" title="raw_atomic64_inc_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_inc_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_inc_return_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_inc_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_inc_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_inc_return_acquire" title="raw_atomic64_inc_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_inc_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_inc_return_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_inc_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_inc_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_inc_return_release" title="raw_atomic64_inc_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_inc_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_inc_return_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_inc_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_inc_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_inc_return_relaxed" title="raw_atomic64_inc_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_inc_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_inc">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_inc" title="raw_atomic64_fetch_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_inc()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_inc_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_inc_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_inc_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_inc_acquire" title="raw_atomic64_fetch_inc_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_inc_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_inc_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_inc_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_inc_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_inc_release" title="raw_atomic64_fetch_inc_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_inc_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_inc_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_inc_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_inc_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_inc_relaxed" title="raw_atomic64_fetch_inc_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_inc_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_dec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_dec" title="raw_atomic64_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_dec()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_dec_return">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_dec_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_dec_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_dec_return" title="raw_atomic64_dec_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_dec_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_dec_return_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_dec_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_dec_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_dec_return_acquire" title="raw_atomic64_dec_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_dec_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_dec_return_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_dec_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_dec_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_dec_return_release" title="raw_atomic64_dec_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_dec_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_dec_return_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_dec_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_dec_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_dec_return_relaxed" title="raw_atomic64_dec_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_dec_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_dec">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_dec" title="raw_atomic64_fetch_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_dec()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_dec_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_dec_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_dec_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_dec_acquire" title="raw_atomic64_fetch_dec_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_dec_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_dec_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_dec_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_dec_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_dec_release" title="raw_atomic64_fetch_dec_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_dec_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_dec_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_dec_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_dec_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_dec_relaxed" title="raw_atomic64_fetch_dec_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_dec_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_and">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_and</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_and" title="raw_atomic64_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_and()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_and">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_and</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_and" title="raw_atomic64_fetch_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_and()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_and_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_and_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_and_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_and_acquire" title="raw_atomic64_fetch_and_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_and_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_and_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_and_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_and_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_and_release" title="raw_atomic64_fetch_and_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_and_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_and_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_and_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_and_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_and_relaxed" title="raw_atomic64_fetch_and_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_and_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_andnot">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_andnot</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_andnot" title="raw_atomic64_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_andnot()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_andnot">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_andnot</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_andnot" title="raw_atomic64_fetch_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_andnot()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_andnot_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_andnot_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_andnot_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_andnot_acquire" title="raw_atomic64_fetch_andnot_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_andnot_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_andnot_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_andnot_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_andnot_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_andnot_release" title="raw_atomic64_fetch_andnot_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_andnot_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_andnot_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_andnot_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_andnot_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_andnot_relaxed" title="raw_atomic64_fetch_andnot_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_andnot_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_or">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_or</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_or" title="raw_atomic64_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_or()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_or">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_or</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_or" title="raw_atomic64_fetch_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_or()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_or_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_or_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_or_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_or_acquire" title="raw_atomic64_fetch_or_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_or_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_or_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_or_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_or_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_or_release" title="raw_atomic64_fetch_or_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_or_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_or_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_or_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_or_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_or_relaxed" title="raw_atomic64_fetch_or_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_or_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_xor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_xor</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_xor" title="raw_atomic64_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_xor()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_xor">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_xor</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_xor" title="raw_atomic64_fetch_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_xor()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_xor_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_xor_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_xor_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_xor_acquire" title="raw_atomic64_fetch_xor_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_xor_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_xor_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_xor_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_xor_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_xor_release" title="raw_atomic64_fetch_xor_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_xor_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_xor_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_xor_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_xor_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_xor_relaxed" title="raw_atomic64_fetch_xor_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_xor_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_xchg">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_xchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_xchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_xchg" title="raw_atomic64_xchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_xchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_xchg_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_xchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_xchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_xchg_acquire" title="raw_atomic64_xchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_xchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_xchg_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_xchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_xchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_xchg_release" title="raw_atomic64_xchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_xchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_xchg_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_xchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_xchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_xchg_relaxed" title="raw_atomic64_xchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_xchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_cmpxchg">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">old</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_cmpxchg" title="raw_atomic64_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_cmpxchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_cmpxchg_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">old</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_cmpxchg_acquire" title="raw_atomic64_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_cmpxchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_cmpxchg_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">old</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_cmpxchg_release" title="raw_atomic64_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_cmpxchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_cmpxchg_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">old</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_cmpxchg_relaxed" title="raw_atomic64_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_cmpxchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_try_cmpxchg">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_try_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_try_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">*old</span></code></dt><dd><p>pointer to s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_try_cmpxchg" title="raw_atomic64_try_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_try_cmpxchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_try_cmpxchg_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_try_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_try_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">*old</span></code></dt><dd><p>pointer to s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_try_cmpxchg_acquire" title="raw_atomic64_try_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_try_cmpxchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_try_cmpxchg_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_try_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_try_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">*old</span></code></dt><dd><p>pointer to s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_try_cmpxchg_release" title="raw_atomic64_try_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_try_cmpxchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_try_cmpxchg_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_try_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_try_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">*old</span></code></dt><dd><p>pointer to s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_try_cmpxchg_relaxed" title="raw_atomic64_try_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_try_cmpxchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_sub_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_sub_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_sub_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_sub_and_test" title="raw_atomic64_sub_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_sub_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_dec_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_dec_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_dec_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_dec_and_test" title="raw_atomic64_dec_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_dec_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_inc_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_inc_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_inc_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_inc_and_test" title="raw_atomic64_inc_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_inc_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_negative</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_negative" title="raw_atomic64_add_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_negative()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_negative_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_negative_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_negative_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_negative_acquire" title="raw_atomic64_add_negative_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_negative_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_negative_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_negative_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_negative_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_negative_release" title="raw_atomic64_add_negative_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_negative_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_negative_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_negative_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_negative_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_negative_relaxed" title="raw_atomic64_add_negative_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_negative_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_fetch_add_unless">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_fetch_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_fetch_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">a</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">u</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_fetch_add_unless" title="raw_atomic64_fetch_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_fetch_add_unless()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_add_unless">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">a</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">u</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_add_unless" title="raw_atomic64_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_add_unless()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_inc_not_zero">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_inc_not_zero</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_inc_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_inc_not_zero" title="raw_atomic64_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_inc_not_zero()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_inc_unless_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_inc_unless_negative</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_inc_unless_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_inc_unless_negative" title="raw_atomic64_inc_unless_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_inc_unless_negative()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_dec_unless_positive">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_dec_unless_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_dec_unless_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement unless positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &lt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_dec_unless_positive" title="raw_atomic64_dec_unless_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_dec_unless_positive()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic64_dec_if_positive">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic64_dec_if_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic64_dec_if_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement if positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt; 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic64_dec_if_positive" title="raw_atomic64_dec_if_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic64_dec_if_positive()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The old value of (<strong>v</strong> - 1), regardless of whether <strong>v</strong> was updated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_read">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_read" title="raw_atomic_long_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_read()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_read_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_read_acquire</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_read_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_read_acquire" title="raw_atomic_long_read_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_read_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_set</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_set" title="raw_atomic_long_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_set()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_set_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_set_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_set_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_set_release" title="raw_atomic_long_set_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_set_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add" title="raw_atomic_long_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_return">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_return</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_return" title="raw_atomic_long_add_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_return_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_return_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_return_acquire" title="raw_atomic_long_add_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_return_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_return_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_return_release" title="raw_atomic_long_add_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_return_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_return_relaxed" title="raw_atomic_long_add_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_add">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_add" title="raw_atomic_long_fetch_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_add()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_add_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_add_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_add_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_add_acquire" title="raw_atomic_long_fetch_add_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_add_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_add_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_add_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_add_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_add_release" title="raw_atomic_long_fetch_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_add_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_add_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_add_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_add_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_add_relaxed" title="raw_atomic_long_fetch_add_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_add_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_sub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_sub" title="raw_atomic_long_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_sub()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_sub_return">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_sub_return</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_sub_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_sub_return" title="raw_atomic_long_sub_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_sub_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_sub_return_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_sub_return_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_sub_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_sub_return_acquire" title="raw_atomic_long_sub_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_sub_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_sub_return_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_sub_return_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_sub_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_sub_return_release" title="raw_atomic_long_sub_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_sub_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_sub_return_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_sub_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_sub_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_sub_return_relaxed" title="raw_atomic_long_sub_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_sub_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_sub">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_sub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_sub" title="raw_atomic_long_fetch_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_sub()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_sub_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_sub_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_sub_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_sub_acquire" title="raw_atomic_long_fetch_sub_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_sub_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_sub_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_sub_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_sub_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_sub_release" title="raw_atomic_long_fetch_sub_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_sub_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_sub_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_sub_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_sub_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_sub_relaxed" title="raw_atomic_long_fetch_sub_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_sub_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_inc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_inc" title="raw_atomic_long_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_inc()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_inc_return">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_inc_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_inc_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_inc_return" title="raw_atomic_long_inc_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_inc_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_inc_return_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_inc_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_inc_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_inc_return_acquire" title="raw_atomic_long_inc_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_inc_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_inc_return_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_inc_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_inc_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_inc_return_release" title="raw_atomic_long_inc_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_inc_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_inc_return_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_inc_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_inc_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_inc_return_relaxed" title="raw_atomic_long_inc_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_inc_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_inc">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_inc" title="raw_atomic_long_fetch_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_inc()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_inc_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_inc_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_inc_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_inc_acquire" title="raw_atomic_long_fetch_inc_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_inc_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_inc_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_inc_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_inc_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_inc_release" title="raw_atomic_long_fetch_inc_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_inc_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_inc_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_inc_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_inc_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_inc_relaxed" title="raw_atomic_long_fetch_inc_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_inc_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_dec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_dec" title="raw_atomic_long_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_dec()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_dec_return">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_dec_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_dec_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_dec_return" title="raw_atomic_long_dec_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_dec_return()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_dec_return_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_dec_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_dec_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_dec_return_acquire" title="raw_atomic_long_dec_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_dec_return_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_dec_return_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_dec_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_dec_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_dec_return_release" title="raw_atomic_long_dec_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_dec_return_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_dec_return_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_dec_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_dec_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_dec_return_relaxed" title="raw_atomic_long_dec_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_dec_return_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_dec">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_dec" title="raw_atomic_long_fetch_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_dec()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_dec_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_dec_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_dec_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_dec_acquire" title="raw_atomic_long_fetch_dec_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_dec_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_dec_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_dec_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_dec_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_dec_release" title="raw_atomic_long_fetch_dec_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_dec_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_dec_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_dec_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_dec_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_dec_relaxed" title="raw_atomic_long_fetch_dec_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_dec_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_and">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_and</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_and" title="raw_atomic_long_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_and()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_and">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_and</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_and" title="raw_atomic_long_fetch_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_and()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_and_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_and_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_and_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_and_acquire" title="raw_atomic_long_fetch_and_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_and_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_and_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_and_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_and_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_and_release" title="raw_atomic_long_fetch_and_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_and_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_and_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_and_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_and_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_and_relaxed" title="raw_atomic_long_fetch_and_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_and_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_andnot">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_andnot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_andnot" title="raw_atomic_long_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_andnot()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_andnot">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_andnot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_andnot" title="raw_atomic_long_fetch_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_andnot()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_andnot_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_andnot_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_andnot_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_andnot_acquire" title="raw_atomic_long_fetch_andnot_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_andnot_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_andnot_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_andnot_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_andnot_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_andnot_release" title="raw_atomic_long_fetch_andnot_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_andnot_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_andnot_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_andnot_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_andnot_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_andnot_relaxed" title="raw_atomic_long_fetch_andnot_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_andnot_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_or">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_or</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_or" title="raw_atomic_long_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_or()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_or">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_or</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_or" title="raw_atomic_long_fetch_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_or()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_or_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_or_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_or_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_or_acquire" title="raw_atomic_long_fetch_or_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_or_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_or_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_or_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_or_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_or_release" title="raw_atomic_long_fetch_or_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_or_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_or_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_or_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_or_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_or_relaxed" title="raw_atomic_long_fetch_or_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_or_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_xor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_xor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_xor" title="raw_atomic_long_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_xor()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_xor">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_xor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_xor" title="raw_atomic_long_fetch_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_xor()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_xor_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_xor_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_xor_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_xor_acquire" title="raw_atomic_long_fetch_xor_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_xor_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_xor_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_xor_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_xor_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_xor_release" title="raw_atomic_long_fetch_xor_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_xor_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_xor_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_xor_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_xor_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_xor_relaxed" title="raw_atomic_long_fetch_xor_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_xor_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_xchg">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_xchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_xchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_xchg" title="raw_atomic_long_xchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_xchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_xchg_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_xchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_xchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_xchg_acquire" title="raw_atomic_long_xchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_xchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_xchg_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_xchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_xchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_xchg_release" title="raw_atomic_long_xchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_xchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_xchg_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_xchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_xchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_xchg_relaxed" title="raw_atomic_long_xchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_xchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_cmpxchg">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">old</span></code></dt><dd><p>long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_cmpxchg" title="raw_atomic_long_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_cmpxchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_cmpxchg_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">old</span></code></dt><dd><p>long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_cmpxchg_acquire" title="raw_atomic_long_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_cmpxchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_cmpxchg_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">old</span></code></dt><dd><p>long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_cmpxchg_release" title="raw_atomic_long_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_cmpxchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_cmpxchg_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">old</span></code></dt><dd><p>long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_cmpxchg_relaxed" title="raw_atomic_long_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_cmpxchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_try_cmpxchg">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_try_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_try_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>pointer to long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_try_cmpxchg" title="raw_atomic_long_try_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_try_cmpxchg()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_try_cmpxchg_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_try_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_try_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>pointer to long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_try_cmpxchg_acquire" title="raw_atomic_long_try_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_try_cmpxchg_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_try_cmpxchg_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_try_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_try_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>pointer to long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_try_cmpxchg_release" title="raw_atomic_long_try_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_try_cmpxchg_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_try_cmpxchg_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_try_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_try_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>pointer to long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_try_cmpxchg_relaxed" title="raw_atomic_long_try_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_try_cmpxchg_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_sub_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_sub_and_test</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_sub_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_sub_and_test" title="raw_atomic_long_sub_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_sub_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_dec_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_dec_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_dec_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_dec_and_test" title="raw_atomic_long_dec_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_dec_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_inc_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_inc_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_inc_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_inc_and_test" title="raw_atomic_long_inc_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_inc_and_test()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_negative</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_negative" title="raw_atomic_long_add_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_negative()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_negative_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_negative_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_negative_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_negative_acquire" title="raw_atomic_long_add_negative_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_negative_acquire()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_negative_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_negative_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_negative_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_negative_release" title="raw_atomic_long_add_negative_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_negative_release()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_negative_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_negative_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_negative_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_negative_relaxed" title="raw_atomic_long_add_negative_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_negative_relaxed()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_fetch_add_unless">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_fetch_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_fetch_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">a</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">u</span></code></dt><dd><p>long value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_fetch_add_unless" title="raw_atomic_long_fetch_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_fetch_add_unless()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_add_unless">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">a</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">u</span></code></dt><dd><p>long value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_add_unless" title="raw_atomic_long_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_add_unless()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_inc_not_zero">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_inc_not_zero</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_inc_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_inc_not_zero" title="raw_atomic_long_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_inc_not_zero()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_inc_unless_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_inc_unless_negative</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_inc_unless_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_inc_unless_negative" title="raw_atomic_long_inc_unless_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_inc_unless_negative()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_dec_unless_positive">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_dec_unless_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_dec_unless_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement unless positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &lt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_dec_unless_positive" title="raw_atomic_long_dec_unless_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_dec_unless_positive()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.atomic_long_dec_if_positive">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">atomic_long_dec_if_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_long_dec_if_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement if positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt; 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Unsafe to use in noinstr code; use <a class="reference internal" href="#c.raw_atomic_long_dec_if_positive" title="raw_atomic_long_dec_if_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">raw_atomic_long_dec_if_positive()</span></code></a> there.</p>
<p><strong>Return</strong></p>
<p>The old value of (<strong>v</strong> - 1), regardless of whether <strong>v</strong> was updated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_read">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_read" title="atomic_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_read()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_read_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_read_acquire</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_read_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_read_acquire" title="atomic_read_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_read_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_set</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_set" title="atomic_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_set()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_set_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_set_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_set_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_set_release" title="atomic_set_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_set_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add" title="atomic_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_return">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_return</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_return" title="atomic_add_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_return_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_return_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_return_acquire" title="atomic_add_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_return_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_return_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_return_release" title="atomic_add_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_return_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_return_relaxed" title="atomic_add_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_add" title="atomic_fetch_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_add()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_add_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_add_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_add_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_add_acquire" title="atomic_fetch_add_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_add_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_add_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_add_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_add_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_add_release" title="atomic_fetch_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_add_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_add_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_add_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_add_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_add_relaxed" title="atomic_fetch_add_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_add_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_sub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_sub" title="atomic_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_sub()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_sub_return">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_sub_return</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_sub_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_sub_return" title="atomic_sub_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_sub_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_sub_return_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_sub_return_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_sub_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_sub_return_acquire" title="atomic_sub_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_sub_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_sub_return_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_sub_return_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_sub_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_sub_return_release" title="atomic_sub_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_sub_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_sub_return_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_sub_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_sub_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_sub_return_relaxed" title="atomic_sub_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_sub_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_sub">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_sub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_sub" title="atomic_fetch_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_sub()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_sub_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_sub_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_sub_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_sub_acquire" title="atomic_fetch_sub_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_sub_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_sub_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_sub_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_sub_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_sub_release" title="atomic_fetch_sub_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_sub_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_sub_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_sub_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_sub_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_sub_relaxed" title="atomic_fetch_sub_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_sub_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_inc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_inc" title="atomic_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_inc_return">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_inc_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_inc_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_inc_return" title="atomic_inc_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_inc_return_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_inc_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_inc_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_inc_return_acquire" title="atomic_inc_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_inc_return_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_inc_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_inc_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_inc_return_release" title="atomic_inc_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_inc_return_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_inc_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_inc_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_inc_return_relaxed" title="atomic_inc_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_inc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_inc" title="atomic_fetch_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_inc()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_inc_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_inc_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_inc_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_inc_acquire" title="atomic_fetch_inc_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_inc_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_inc_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_inc_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_inc_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_inc_release" title="atomic_fetch_inc_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_inc_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_inc_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_inc_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_inc_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_inc_relaxed" title="atomic_fetch_inc_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_inc_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_dec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_dec" title="atomic_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_dec_return">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_dec_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_dec_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_dec_return" title="atomic_dec_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_dec_return_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_dec_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_dec_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_dec_return_acquire" title="atomic_dec_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_dec_return_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_dec_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_dec_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_dec_return_release" title="atomic_dec_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_dec_return_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_dec_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_dec_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_dec_return_relaxed" title="atomic_dec_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_dec">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_dec" title="atomic_fetch_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_dec()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_dec_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_dec_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_dec_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_dec_acquire" title="atomic_fetch_dec_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_dec_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_dec_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_dec_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_dec_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_dec_release" title="atomic_fetch_dec_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_dec_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_dec_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_dec_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_dec_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_dec_relaxed" title="atomic_fetch_dec_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_dec_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_and">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_and</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_and" title="atomic_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_and()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_and">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_and</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_and" title="atomic_fetch_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_and()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_and_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_and_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_and_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_and_acquire" title="atomic_fetch_and_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_and_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_and_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_and_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_and_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_and_release" title="atomic_fetch_and_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_and_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_and_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_and_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_and_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_and_relaxed" title="atomic_fetch_and_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_and_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_andnot">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_andnot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_andnot" title="atomic_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_andnot()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_andnot">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_andnot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_andnot" title="atomic_fetch_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_andnot()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_andnot_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_andnot_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_andnot_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_andnot_acquire" title="atomic_fetch_andnot_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_andnot_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_andnot_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_andnot_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_andnot_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_andnot_release" title="atomic_fetch_andnot_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_andnot_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_andnot_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_andnot_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_andnot_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_andnot_relaxed" title="atomic_fetch_andnot_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_andnot_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_or">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_or</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_or" title="atomic_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_or()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_or">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_or</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_or" title="atomic_fetch_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_or()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_or_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_or_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_or_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_or_acquire" title="atomic_fetch_or_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_or_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_or_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_or_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_or_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_or_release" title="atomic_fetch_or_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_or_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_or_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_or_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_or_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_or_relaxed" title="atomic_fetch_or_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_or_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_xor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_xor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_xor" title="atomic_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_xor()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_xor">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_xor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_xor" title="atomic_fetch_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_xor()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_xor_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_xor_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_xor_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_xor_acquire" title="atomic_fetch_xor_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_xor_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_xor_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_xor_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_xor_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_xor_release" title="atomic_fetch_xor_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_xor_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_xor_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_xor_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_xor_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_xor_relaxed" title="atomic_fetch_xor_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_xor_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_xchg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_xchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_xchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_xchg" title="atomic_xchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_xchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_xchg_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_xchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_xchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_xchg_acquire" title="atomic_xchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_xchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_xchg_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_xchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_xchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_xchg_release" title="atomic_xchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_xchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_xchg_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_xchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_xchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_xchg_relaxed" title="atomic_xchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_xchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_cmpxchg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old</span></code></dt><dd><p>int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_cmpxchg" title="atomic_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_cmpxchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_cmpxchg_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old</span></code></dt><dd><p>int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_cmpxchg_acquire" title="atomic_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_cmpxchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_cmpxchg_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old</span></code></dt><dd><p>int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_cmpxchg_release" title="atomic_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_cmpxchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_cmpxchg_relaxed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old</span></code></dt><dd><p>int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_cmpxchg_relaxed" title="atomic_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_cmpxchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_try_cmpxchg">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_try_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_try_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*old</span></code></dt><dd><p>pointer to int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_try_cmpxchg" title="atomic_try_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_try_cmpxchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_try_cmpxchg_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_try_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_try_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*old</span></code></dt><dd><p>pointer to int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_try_cmpxchg_acquire" title="atomic_try_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_try_cmpxchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_try_cmpxchg_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_try_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_try_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*old</span></code></dt><dd><p>pointer to int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_try_cmpxchg_release" title="atomic_try_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_try_cmpxchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_try_cmpxchg_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_try_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_try_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*old</span></code></dt><dd><p>pointer to int value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new</span></code></dt><dd><p>int value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_try_cmpxchg_relaxed" title="atomic_try_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_try_cmpxchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_sub_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_sub_and_test</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_sub_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_sub_and_test" title="atomic_sub_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_sub_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_dec_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_dec_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_dec_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_dec_and_test" title="atomic_dec_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_inc_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_inc_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_inc_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_inc_and_test" title="atomic_inc_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_negative</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_negative" title="atomic_add_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_negative()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_negative_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_negative_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_negative_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_negative_acquire" title="atomic_add_negative_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_negative_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_negative_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_negative_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_negative_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_negative_release" title="atomic_add_negative_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_negative_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_negative_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_negative_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_negative_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_negative_relaxed" title="atomic_add_negative_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_negative_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_fetch_add_unless">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_fetch_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_fetch_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">a</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">u</span></code></dt><dd><p>int value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_fetch_add_unless" title="atomic_fetch_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_fetch_add_unless()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_add_unless">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">a</span></code></dt><dd><p>int value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">u</span></code></dt><dd><p>int value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_add_unless" title="atomic_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add_unless()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_inc_not_zero">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_inc_not_zero</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_inc_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_inc_not_zero" title="atomic_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_not_zero()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_inc_unless_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_inc_unless_negative</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_inc_unless_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_inc_unless_negative" title="atomic_inc_unless_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_unless_negative()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_dec_unless_positive">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_dec_unless_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_dec_unless_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement unless positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &lt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_dec_unless_positive" title="atomic_dec_unless_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_unless_positive()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_dec_if_positive">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_dec_if_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_dec_if_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement if positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt; 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_dec_if_positive" title="atomic_dec_if_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_if_positive()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The old value of (<strong>v</strong> - 1), regardless of whether <strong>v</strong> was updated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_read">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_read" title="atomic64_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_read()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_read_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_read_acquire</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_read_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_read_acquire" title="atomic64_read_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_read_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_set</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_set" title="atomic64_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_set()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_set_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_set_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_set_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_set_release" title="atomic64_set_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_set_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add" title="atomic64_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_return">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_return" title="atomic64_add_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_return_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_return_acquire" title="atomic64_add_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_return_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_return_release" title="atomic64_add_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_return_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_return_relaxed" title="atomic64_add_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_add">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_add</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_add" title="atomic64_fetch_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_add()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_add_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_add_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_add_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_add_acquire" title="atomic64_fetch_add_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_add_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_add_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_add_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_add_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_add_release" title="atomic64_fetch_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_add_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_add_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_add_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_add_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_add_relaxed" title="atomic64_fetch_add_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_add_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_sub</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_sub" title="atomic64_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_sub()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_sub_return">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_sub_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_sub_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_sub_return" title="atomic64_sub_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_sub_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_sub_return_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_sub_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_sub_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_sub_return_acquire" title="atomic64_sub_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_sub_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_sub_return_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_sub_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_sub_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_sub_return_release" title="atomic64_sub_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_sub_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_sub_return_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_sub_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_sub_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_sub_return_relaxed" title="atomic64_sub_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_sub_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_sub">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_sub</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_sub" title="atomic64_fetch_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_sub()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_sub_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_sub_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_sub_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_sub_acquire" title="atomic64_fetch_sub_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_sub_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_sub_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_sub_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_sub_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_sub_release" title="atomic64_fetch_sub_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_sub_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_sub_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_sub_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_sub_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_sub_relaxed" title="atomic64_fetch_sub_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_sub_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_inc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_inc" title="atomic64_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_inc()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_inc_return">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_inc_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_inc_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_inc_return" title="atomic64_inc_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_inc_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_inc_return_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_inc_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_inc_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_inc_return_acquire" title="atomic64_inc_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_inc_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_inc_return_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_inc_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_inc_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_inc_return_release" title="atomic64_inc_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_inc_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_inc_return_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_inc_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_inc_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_inc_return_relaxed" title="atomic64_inc_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_inc_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_inc">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_inc" title="atomic64_fetch_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_inc()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_inc_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_inc_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_inc_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_inc_acquire" title="atomic64_fetch_inc_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_inc_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_inc_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_inc_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_inc_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_inc_release" title="atomic64_fetch_inc_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_inc_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_inc_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_inc_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_inc_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_inc_relaxed" title="atomic64_fetch_inc_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_inc_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_dec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_dec" title="atomic64_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_dec()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_dec_return">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_dec_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_dec_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_dec_return" title="atomic64_dec_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_dec_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_dec_return_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_dec_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_dec_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_dec_return_acquire" title="atomic64_dec_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_dec_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_dec_return_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_dec_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_dec_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_dec_return_release" title="atomic64_dec_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_dec_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_dec_return_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_dec_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_dec_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_dec_return_relaxed" title="atomic64_dec_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_dec_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_dec">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_dec" title="atomic64_fetch_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_dec()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_dec_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_dec_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_dec_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_dec_acquire" title="atomic64_fetch_dec_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_dec_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_dec_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_dec_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_dec_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_dec_release" title="atomic64_fetch_dec_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_dec_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_dec_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_dec_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_dec_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_dec_relaxed" title="atomic64_fetch_dec_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_dec_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_and">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_and</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_and" title="atomic64_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_and()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_and">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_and</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_and" title="atomic64_fetch_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_and()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_and_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_and_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_and_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_and_acquire" title="atomic64_fetch_and_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_and_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_and_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_and_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_and_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_and_release" title="atomic64_fetch_and_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_and_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_and_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_and_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_and_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_and_relaxed" title="atomic64_fetch_and_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_and_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_andnot">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_andnot</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_andnot" title="atomic64_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_andnot()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_andnot">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_andnot</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_andnot" title="atomic64_fetch_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_andnot()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_andnot_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_andnot_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_andnot_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_andnot_acquire" title="atomic64_fetch_andnot_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_andnot_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_andnot_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_andnot_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_andnot_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_andnot_release" title="atomic64_fetch_andnot_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_andnot_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_andnot_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_andnot_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_andnot_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_andnot_relaxed" title="atomic64_fetch_andnot_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_andnot_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_or">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_or</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_or" title="atomic64_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_or()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_or">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_or</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_or" title="atomic64_fetch_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_or()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_or_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_or_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_or_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_or_acquire" title="atomic64_fetch_or_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_or_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_or_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_or_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_or_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_or_release" title="atomic64_fetch_or_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_or_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_or_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_or_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_or_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_or_relaxed" title="atomic64_fetch_or_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_or_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_xor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_xor</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_xor" title="atomic64_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_xor()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_xor">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_xor</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_xor" title="atomic64_fetch_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_xor()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_xor_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_xor_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_xor_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_xor_acquire" title="atomic64_fetch_xor_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_xor_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_xor_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_xor_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_xor_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_xor_release" title="atomic64_fetch_xor_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_xor_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_xor_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_xor_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_xor_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_xor_relaxed" title="atomic64_fetch_xor_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_xor_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_xchg">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_xchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_xchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_xchg" title="atomic64_xchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_xchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_xchg_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_xchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_xchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_xchg_acquire" title="atomic64_xchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_xchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_xchg_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_xchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_xchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_xchg_release" title="atomic64_xchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_xchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_xchg_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_xchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_xchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_xchg_relaxed" title="atomic64_xchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_xchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_cmpxchg">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">old</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_cmpxchg" title="atomic64_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_cmpxchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_cmpxchg_acquire">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">old</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_cmpxchg_acquire" title="atomic64_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_cmpxchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_cmpxchg_release">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">old</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_cmpxchg_release" title="atomic64_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_cmpxchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_cmpxchg_relaxed">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">old</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_cmpxchg_relaxed" title="atomic64_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_cmpxchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_try_cmpxchg">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_try_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_try_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">*old</span></code></dt><dd><p>pointer to s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_try_cmpxchg" title="atomic64_try_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_try_cmpxchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_try_cmpxchg_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_try_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_try_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">*old</span></code></dt><dd><p>pointer to s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_try_cmpxchg_acquire" title="atomic64_try_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_try_cmpxchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_try_cmpxchg_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_try_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_try_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">*old</span></code></dt><dd><p>pointer to s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_try_cmpxchg_release" title="atomic64_try_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_try_cmpxchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_try_cmpxchg_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_try_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_try_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">*old</span></code></dt><dd><p>pointer to s64 value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">new</span></code></dt><dd><p>s64 value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_try_cmpxchg_relaxed" title="atomic64_try_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_try_cmpxchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_sub_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_sub_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_sub_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_sub_and_test" title="atomic64_sub_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_sub_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_dec_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_dec_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_dec_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_dec_and_test" title="atomic64_dec_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_dec_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_inc_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_inc_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_inc_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_inc_and_test" title="atomic64_inc_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_inc_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_negative</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_negative" title="atomic64_add_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_negative()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_negative_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_negative_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_negative_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_negative_acquire" title="atomic64_add_negative_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_negative_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_negative_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_negative_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_negative_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_negative_release" title="atomic64_add_negative_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_negative_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_negative_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_negative_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_negative_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">i</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_negative_relaxed" title="atomic64_add_negative_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_negative_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_fetch_add_unless">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_fetch_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_fetch_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">a</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">u</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_fetch_add_unless" title="atomic64_fetch_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_fetch_add_unless()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_add_unless">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">a</span></code></dt><dd><p>s64 value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">u</span></code></dt><dd><p>s64 value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_add_unless" title="atomic64_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_add_unless()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_inc_not_zero">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_inc_not_zero</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_inc_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_inc_not_zero" title="atomic64_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_inc_not_zero()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_inc_unless_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_inc_unless_negative</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_inc_unless_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_inc_unless_negative" title="atomic64_inc_unless_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_inc_unless_negative()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_dec_unless_positive">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_dec_unless_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_dec_unless_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement unless positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &lt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_dec_unless_positive" title="atomic64_dec_unless_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_dec_unless_positive()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic64_dec_if_positive">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic64_dec_if_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic64_dec_if_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement if positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic64_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic64_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt; 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic64_dec_if_positive" title="atomic64_dec_if_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic64_dec_if_positive()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The old value of (<strong>v</strong> - 1), regardless of whether <strong>v</strong> was updated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_read">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_read" title="atomic_long_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_read()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_read_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_read_acquire</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_read_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic load with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically loads the value of <strong>v</strong> with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_read_acquire" title="atomic_long_read_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_read_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The value loaded from <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_set</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_set" title="atomic_long_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_set()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_set_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_set_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_set_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic set with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets <strong>v</strong> to <strong>i</strong> with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_set_release" title="atomic_long_set_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_set_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add" title="atomic_long_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_return">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_return</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_return" title="atomic_long_add_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_return_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_return_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_return_acquire" title="atomic_long_add_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_return_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_return_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_return_release" title="atomic_long_add_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_return_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_return_relaxed" title="atomic_long_add_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_add">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_add" title="atomic_long_fetch_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_add()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_add_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_add_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_add_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_add_acquire" title="atomic_long_fetch_add_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_add_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_add_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_add_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_add_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_add_release" title="atomic_long_fetch_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_add_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_add_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_add_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_add_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_add_relaxed" title="atomic_long_fetch_add_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_add_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_sub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_sub" title="atomic_long_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_sub()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_sub_return">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_sub_return</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_sub_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_sub_return" title="atomic_long_sub_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_sub_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_sub_return_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_sub_return_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_sub_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_sub_return_acquire" title="atomic_long_sub_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_sub_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_sub_return_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_sub_return_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_sub_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_sub_return_release" title="atomic_long_sub_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_sub_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_sub_return_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_sub_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_sub_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_sub_return_relaxed" title="atomic_long_sub_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_sub_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_sub">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_sub</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_sub" title="atomic_long_fetch_sub"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_sub()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_sub_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_sub_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_sub_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_sub_acquire" title="atomic_long_fetch_sub_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_sub_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_sub_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_sub_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_sub_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_sub_release" title="atomic_long_fetch_sub_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_sub_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_sub_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_sub_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_sub_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_sub_relaxed" title="atomic_long_fetch_sub_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_sub_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_inc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_inc" title="atomic_long_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_inc()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_inc_return">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_inc_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_inc_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_inc_return" title="atomic_long_inc_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_inc_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_inc_return_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_inc_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_inc_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_inc_return_acquire" title="atomic_long_inc_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_inc_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_inc_return_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_inc_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_inc_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_inc_return_release" title="atomic_long_inc_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_inc_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_inc_return_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_inc_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_inc_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_inc_return_relaxed" title="atomic_long_inc_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_inc_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_inc">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_inc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_inc" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_inc" title="atomic_long_fetch_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_inc()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_inc_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_inc_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_inc_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_inc_acquire" title="atomic_long_fetch_inc_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_inc_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_inc_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_inc_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_inc_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_inc_release" title="atomic_long_fetch_inc_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_inc_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_inc_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_inc_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_inc_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_inc_relaxed" title="atomic_long_fetch_inc_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_inc_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_dec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_dec" title="atomic_long_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_dec()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_dec_return">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_dec_return</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_dec_return" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_dec_return" title="atomic_long_dec_return"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_dec_return()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_dec_return_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_dec_return_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_dec_return_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_dec_return_acquire" title="atomic_long_dec_return_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_dec_return_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_dec_return_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_dec_return_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_dec_return_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_dec_return_release" title="atomic_long_dec_return_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_dec_return_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_dec_return_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_dec_return_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_dec_return_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_dec_return_relaxed" title="atomic_long_dec_return_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_dec_return_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The updated value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_dec">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_dec</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_dec" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_dec" title="atomic_long_fetch_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_dec()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_dec_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_dec_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_dec_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_dec_acquire" title="atomic_long_fetch_dec_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_dec_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_dec_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_dec_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_dec_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_dec_release" title="atomic_long_fetch_dec_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_dec_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_dec_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_dec_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_dec_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_dec_relaxed" title="atomic_long_fetch_dec_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_dec_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_and">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_and</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_and" title="atomic_long_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_and()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_and">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_and</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_and" title="atomic_long_fetch_and"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_and()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_and_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_and_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_and_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_and_acquire" title="atomic_long_fetch_and_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_and_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_and_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_and_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_and_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_and_release" title="atomic_long_fetch_and_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_and_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_and_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_and_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_and_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_and_relaxed" title="atomic_long_fetch_and_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_and_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_andnot">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_andnot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_andnot" title="atomic_long_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_andnot()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_andnot">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_andnot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_andnot" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_andnot" title="atomic_long_fetch_andnot"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_andnot()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_andnot_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_andnot_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_andnot_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_andnot_acquire" title="atomic_long_fetch_andnot_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_andnot_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_andnot_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_andnot_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_andnot_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_andnot_release" title="atomic_long_fetch_andnot_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_andnot_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_andnot_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_andnot_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_andnot_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise AND NOT with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> &amp; <strong>~i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_andnot_relaxed" title="atomic_long_fetch_andnot_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_andnot_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_or">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_or</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_or" title="atomic_long_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_or()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_or">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_or</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_or" title="atomic_long_fetch_or"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_or()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_or_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_or_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_or_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_or_acquire" title="atomic_long_fetch_or_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_or_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_or_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_or_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_or_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_or_release" title="atomic_long_fetch_or_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_or_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_or_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_or_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_or_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise OR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> | <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_or_relaxed" title="atomic_long_fetch_or_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_or_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_xor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_xor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_xor" title="atomic_long_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_xor()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>Nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_xor">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_xor</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_xor" title="atomic_long_fetch_xor"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_xor()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_xor_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_xor_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_xor_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_xor_acquire" title="atomic_long_fetch_xor_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_xor_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_xor_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_xor_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_xor_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_xor_release" title="atomic_long_fetch_xor_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_xor_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_xor_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_xor_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_xor_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic bitwise XOR with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> ^ <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_xor_relaxed" title="atomic_long_fetch_xor_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_xor_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_xchg">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_xchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_xchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_xchg" title="atomic_long_xchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_xchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_xchg_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_xchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_xchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_xchg_acquire" title="atomic_long_xchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_xchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_xchg_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_xchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_xchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_xchg_release" title="atomic_long_xchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_xchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_xchg_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_xchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_xchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_xchg_relaxed" title="atomic_long_xchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_xchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_cmpxchg">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">old</span></code></dt><dd><p>long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_cmpxchg" title="atomic_long_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_cmpxchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_cmpxchg_acquire">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">old</span></code></dt><dd><p>long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_cmpxchg_acquire" title="atomic_long_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_cmpxchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_cmpxchg_release">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">old</span></code></dt><dd><p>long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_cmpxchg_release" title="atomic_long_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_cmpxchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_cmpxchg_relaxed">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">old</span></code></dt><dd><p>long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_cmpxchg_relaxed" title="atomic_long_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_cmpxchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_try_cmpxchg">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_try_cmpxchg</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_try_cmpxchg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>pointer to long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with full ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_try_cmpxchg" title="atomic_long_try_cmpxchg"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_try_cmpxchg()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_try_cmpxchg_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_try_cmpxchg_acquire</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_try_cmpxchg_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>pointer to long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with acquire ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_try_cmpxchg_acquire" title="atomic_long_try_cmpxchg_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_try_cmpxchg_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_try_cmpxchg_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_try_cmpxchg_release</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_try_cmpxchg_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>pointer to long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with release ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_try_cmpxchg_release" title="atomic_long_try_cmpxchg_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_try_cmpxchg_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_try_cmpxchg_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_try_cmpxchg_relaxed</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_try_cmpxchg_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic compare and exchange with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>pointer to long value to compare with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">new</span></code></dt><dd><p>long value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> == <strong>old</strong>), atomically updates <strong>v</strong> to <strong>new</strong> with relaxed ordering.
Otherwise, <strong>v</strong> is not modified, <strong>old</strong> is updated to the current value of <strong>v</strong>,
and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_try_cmpxchg_relaxed" title="atomic_long_try_cmpxchg_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_try_cmpxchg_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the exchange occured, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_sub_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_sub_and_test</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_sub_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic subtract and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_sub_and_test" title="atomic_long_sub_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_sub_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_dec_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_dec_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_dec_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_dec_and_test" title="atomic_long_dec_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_dec_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_inc_and_test">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_inc_and_test</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_inc_and_test" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment and test if zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_inc_and_test" title="atomic_long_inc_and_test"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_inc_and_test()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is zero, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_negative</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with full ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_negative" title="atomic_long_add_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_negative()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_negative_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_negative_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_negative_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with acquire ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with acquire ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_negative_acquire" title="atomic_long_add_negative_acquire"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_negative_acquire()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_negative_release">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_negative_release</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_negative_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with release ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with release ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_negative_release" title="atomic_long_add_negative_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_negative_release()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_negative_relaxed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_negative_relaxed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_negative_relaxed" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add and test if negative with relaxed ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">i</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>i</strong>) with relaxed ordering.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_negative_relaxed" title="atomic_long_add_negative_relaxed"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_negative_relaxed()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if the resulting value of <strong>v</strong> is negative, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_fetch_add_unless">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_fetch_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_fetch_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">a</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">u</span></code></dt><dd><p>long value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_fetch_add_unless" title="atomic_long_fetch_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_fetch_add_unless()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The original value of <strong>v</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_add_unless">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_add_unless</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">u</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_add_unless" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic add unless value with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">a</span></code></dt><dd><p>long value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">u</span></code></dt><dd><p>long value to compare with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != <strong>u</strong>), atomically updates <strong>v</strong> to (<strong>v</strong> + <strong>a</strong>) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_add_unless" title="atomic_long_add_unless"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_add_unless()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_inc_not_zero">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_inc_not_zero</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_inc_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless zero with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> != 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_inc_not_zero" title="atomic_long_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_inc_not_zero()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_inc_unless_negative">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_inc_unless_negative</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_inc_unless_negative" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic increment unless negative with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> + 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_inc_unless_negative" title="atomic_long_inc_unless_negative"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_inc_unless_negative()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_dec_unless_positive">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_dec_unless_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_dec_unless_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement unless positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &lt;= 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_dec_unless_positive" title="atomic_long_dec_unless_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_dec_unless_positive()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p><strong>true</strong> if <strong>v</strong> was updated, <strong>false</strong> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.raw_atomic_long_dec_if_positive">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">raw_atomic_long_dec_if_positive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">atomic_long_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.raw_atomic_long_dec_if_positive" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomic decrement if positive with full ordering</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_long_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer to atomic_long_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If (<strong>v</strong> &gt; 0), atomically updates <strong>v</strong> to (<strong>v</strong> - 1) with full ordering.
Otherwise, <strong>v</strong> is not modified and relaxed ordering is provided.</p>
<p>Safe to use in noinstr code; prefer <a class="reference internal" href="#c.atomic_long_dec_if_positive" title="atomic_long_dec_if_positive"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_long_dec_if_positive()</span></code></a> elsewhere.</p>
<p><strong>Return</strong></p>
<p>The old value of (<strong>v</strong> - 1), regardless of whether <strong>v</strong> was updated.</p>
</div>
</section>
<section id="kernel-objects-manipulation">
<h2>Kernel objects manipulation<a class="headerlink" href="#kernel-objects-manipulation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_get_path">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kobject_get_path</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_get_path" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate memory and fill in the path for <strong>kobj</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject in question, with which to build the path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>the allocation type used to allocate the path</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The newly allocated memory, caller must free with <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_set_name">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_set_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_set_name" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the name of a kobject.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>struct kobject to set the name of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format string used to build the name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This sets the name of the kobject.  If you have already added the
kobject to the system, you must call <a class="reference internal" href="#c.kobject_rename" title="kobject_rename"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_rename()</span></code></a> in order to
change the name of the kobject.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobj_type</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ktype</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a kobject structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>pointer to the kobject to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kobj_type</span> <span class="pre">*ktype</span></code></dt><dd><p>pointer to the ktype for this kobject.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will properly initialize a kobject such that it can then
be passed to the <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a> call.</p>
<p>After this function is called, the kobject MUST be cleaned up by a call
to <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a>, not by a call to kfree directly to ensure that all of
the memory is cleaned up properly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>The main kobject add function.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>the kobject to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent of the kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format to name the kobject with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The kobject name is set and added to the kobject hierarchy in this
function.</p>
<p>If <strong>parent</strong> is set, then the parent of the <strong>kobj</strong> will be set to it.
If <strong>parent</strong> is NULL, then the parent of the <strong>kobj</strong> will be set to the
kobject associated with the kset assigned to this kobject.  If no kset
is assigned to the kobject, then the kobject will be located in the
root of the sysfs tree.</p>
<p>Note, no “add” uevent will be created with this call, the caller should set
up all of the necessary sysfs files for the object and then call
<a class="reference internal" href="#c.kobject_uevent" title="kobject_uevent"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_uevent()</span></code></a> with the UEVENT_ADD parameter to ensure that
userspace is properly notified of this kobject’s creation.</p>
<p><strong>Return</strong></p>
<dl>
<dt>If this function returns an error, kobject_put() must be</dt><dd><p>called to properly clean up the memory associated with the
object.  Under no instance should the kobject that is passed
to this function be directly freed with a call to <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>,
that can leak memory.</p>
<p>If this function returns success, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> must also be called
in order to properly clean up the memory associated with the object.</p>
<p>In short, once this function is called, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> MUST be called
when the use of the object is finished in order to properly free
everything.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_init_and_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_init_and_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobj_type</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ktype</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_init_and_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a kobject structure and add it to the kobject hierarchy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>pointer to the kobject to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kobj_type</span> <span class="pre">*ktype</span></code></dt><dd><p>pointer to the ktype for this kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent of this kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>the name of the kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function combines the call to <a class="reference internal" href="#c.kobject_init" title="kobject_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_init()</span></code></a> and <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>.</p>
<p>If this function returns an error, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> must be called to
properly clean up the memory associated with the object.  This is the
same type of error handling after a call to <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a> and kobject
lifetime rules are the same here.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_rename">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_rename</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_rename" title="Link to this definition">¶</a><br /></dt>
<dd><p>Change the name of an object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object in question.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*new_name</span></code></dt><dd><p>object’s new name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the responsibility of the caller to provide mutual
exclusion between two different calls of kobject_rename
on the same kobject and to ensure that new_name is valid and
won’t conflict with other kobjects.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_move">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_move</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_move" title="Link to this definition">¶</a><br /></dt>
<dd><p>Move object to another parent.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object in question.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*new_parent</span></code></dt><dd><p>object’s new parent (can be NULL)</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_del" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unlink kobject from hierarchy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the function that should be called to delete an object
successfully added via <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kobject_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Increment refcount for object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>Decrement refcount for object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement the refcount, and if 0, call kobject_cleanup().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_create_and_add">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kobject_create_and_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_create_and_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a struct kobject dynamically and register it with sysfs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name for the kobject</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>the parent kobject of this kobject, if any.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a kobject structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
<a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> and the structure will be dynamically freed when
it is no longer being used.</p>
<p>If the kobject was not able to be created, NULL will be returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kset_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kset_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kset</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize and add a kset.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*k</span></code></dt><dd><p>kset.</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>On error, the kset.kobj.name allocated by() kobj_set_name()
is freed, it can not be used any more.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kset_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kset_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kset</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove a kset.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*k</span></code></dt><dd><p>kset.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kset_find_obj">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kset_find_obj</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kset_find_obj" title="kset"><span class="n"><span class="pre">kset</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kset</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_find_obj" title="Link to this definition">¶</a><br /></dt>
<dd><p>Search for object in kset.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*kset</span></code></dt><dd><p>kset we’re looking in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>object’s name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock kset via <strong>kset-&gt;subsys</strong>, and iterate over <strong>kset-&gt;list</strong>,
looking for a matching kobject. If matching object is found
take a reference and return the object.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kset_create_and_add">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kset</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kset_create_and_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kset_uevent_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uevent_ops</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent_kobj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_create_and_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a struct kset dynamically and add it to sysfs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name for the kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kset_uevent_ops</span> <span class="pre">*uevent_ops</span></code></dt><dd><p>a struct kset_uevent_ops for the kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent_kobj</span></code></dt><dd><p>the parent kobject of this kset, if any.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a kset structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
<a class="reference internal" href="#c.kset_unregister" title="kset_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">kset_unregister()</span></code></a> and the structure will be dynamically freed when it
is no longer being used.</p>
<p>If the kset was not able to be created, NULL will be returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_uevent_env">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_uevent_env</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">kobject_action</span></span><span class="w"> </span><span class="n"><span class="pre">action</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">envp_ext</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_uevent_env" title="Link to this definition">¶</a><br /></dt>
<dd><p>send an uevent with environmental data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>struct kobject that the action is happening to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">kobject_action</span> <span class="pre">action</span></code></dt><dd><p>action that is happening</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*envp_ext[]</span></code></dt><dd><p>pointer to environmental data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if <a class="reference internal" href="#c.kobject_uevent_env" title="kobject_uevent_env"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_uevent_env()</span></code></a> is completed with success or the
corresponding error when it fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kobject_uevent">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kobject_uevent</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">kobject_action</span></span><span class="w"> </span><span class="n"><span class="pre">action</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_uevent" title="Link to this definition">¶</a><br /></dt>
<dd><p>notify userspace by sending an uevent</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>struct kobject that the action is happening to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">kobject_action</span> <span class="pre">action</span></code></dt><dd><p>action that is happening</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if <a class="reference internal" href="#c.kobject_uevent" title="kobject_uevent"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_uevent()</span></code></a> is completed with success or the
corresponding error when it fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.add_uevent_var">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">add_uevent_var</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobj_uevent_env</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">env</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.add_uevent_var" title="Link to this definition">¶</a><br /></dt>
<dd><p>add key value string to the environment buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobj_uevent_env</span> <span class="pre">*env</span></code></dt><dd><p>environment buffer structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*format</span></code></dt><dd><p>printf format for the key=value pair</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if environment variable was added successfully or -ENOMEM
if no space was available.</p>
</div>
</section>
<section id="kernel-utility-functions">
<h2>Kernel utility functions<a class="headerlink" href="#kernel-utility-functions" title="Link to this heading">¶</a></h2>
<dl class="c macro">
<dt class="sig sig-object c" id="c.might_sleep">
<span class="sig-name descname"><span class="n"><span class="pre">might_sleep</span></span></span><a class="headerlink" href="#c.might_sleep" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">might_sleep</span> <span class="pre">()</span></code></p>
<blockquote>
<div><blockquote>
<div><p>annotation for functions that can sleep</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>this macro will print a stack trace if it is executed in an atomic
context (spinlock, irq-handler, ...). Additional sections where blocking is
not allowed can be annotated with <a class="reference internal" href="#c.non_block_start" title="non_block_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_start()</span></code></a> and <a class="reference internal" href="#c.non_block_end" title="non_block_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_end()</span></code></a>
pairs.</p>
<p>This is a useful debugging help to be able to catch problems early and not
be bitten later when the calling function happens to sleep when it is not
supposed to.</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.cant_sleep">
<span class="sig-name descname"><span class="n"><span class="pre">cant_sleep</span></span></span><a class="headerlink" href="#c.cant_sleep" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">cant_sleep</span> <span class="pre">()</span></code></p>
<blockquote>
<div><blockquote>
<div><p>annotation for functions that cannot sleep</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>this macro will print a stack trace if it is executed with preemption enabled</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.cant_migrate">
<span class="sig-name descname"><span class="n"><span class="pre">cant_migrate</span></span></span><a class="headerlink" href="#c.cant_migrate" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">cant_migrate</span> <span class="pre">()</span></code></p>
<blockquote>
<div><blockquote>
<div><p>annotation for functions that cannot migrate</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>Will print a stack trace if executed in code which is migratable</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.non_block_start">
<span class="sig-name descname"><span class="n"><span class="pre">non_block_start</span></span></span><a class="headerlink" href="#c.non_block_start" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">non_block_start</span> <span class="pre">()</span></code></p>
<blockquote>
<div><blockquote>
<div><p>annotate the start of section where sleeping is prohibited</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>This is on behalf of the oom reaper, specifically when it is calling the mmu
notifiers. The problem is that if the notifier were to block on, for example,
<a class="reference internal" href="../kernel-hacking/locking.html#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a> and if the process which holds that mutex were to perform a
sleeping memory allocation, the oom reaper is now blocked on completion of
that memory allocation. Other blocking calls like <a class="reference internal" href="#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a> pose similar
issues.</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.non_block_end">
<span class="sig-name descname"><span class="n"><span class="pre">non_block_end</span></span></span><a class="headerlink" href="#c.non_block_end" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">non_block_end</span> <span class="pre">()</span></code></p>
<blockquote>
<div><blockquote>
<div><p>annotate the end of section where sleeping is prohibited</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>Closes a section opened by <a class="reference internal" href="#c.non_block_start" title="non_block_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_start()</span></code></a>.</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.trace_printk">
<span class="sig-name descname"><span class="n"><span class="pre">trace_printk</span></span></span><a class="headerlink" href="#c.trace_printk" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">trace_printk</span> <span class="pre">(fmt,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>printf formatting in the ftrace buffer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>the printf format for printing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>__trace_printk is an internal function for trace_printk() and</dt><dd><p>the <strong>ip</strong> is passed in via the <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> macro.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.</p>
<p>This is intended as a debugging tool for the developer only.
Please refrain from leaving trace_printks scattered around in
your code. (Extra memory is used for special buffers that are
allocated when <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> is used.)</p>
<p>A little optimization trick is done here. If there’s only one
argument, there’s no need to scan the string for printf formats.
The <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> will suffice. But how can we take advantage of
using <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> when <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> has only one argument?
By stringifying the args and checking the size we can tell
whether or not there are args. __stringify((__VA_ARGS__)) will
turn into “()0” with a size of 3 when there are no args, anything
else will be bigger. All we need to do is define a string to this,
and then take its size and compare to 3. If it’s bigger, use
do_trace_printk() otherwise, optimize it to <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a>. Then just
let gcc optimize the rest.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.trace_puts">
<span class="sig-name descname"><span class="n"><span class="pre">trace_puts</span></span></span><a class="headerlink" href="#c.trace_puts" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">trace_puts</span> <span class="pre">(str)</span></code></p>
<blockquote>
<div><p>write a string into the ftrace buffer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">str</span></code></dt><dd><p>the string to record</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>__trace_bputs is an internal function for trace_puts and</dt><dd><p>the <strong>ip</strong> is passed in via the trace_puts macro.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> but is made for those really fast
paths that a developer wants the least amount of “Heisenbug” effects,
where the processing of the print format is still too much.</p>
<p>This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.</p>
<p>This is intended as a debugging tool for the developer only.
Please refrain from leaving trace_puts scattered around in
your code. (Extra memory is used for special buffers that are
allocated when <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> is used.)</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if nothing was written, positive # if string was.</dt><dd><p>(1 when __trace_bputs is used, strlen(str) when __trace_puts is used)</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_list_lock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_list_lock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_list_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lock the console list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For console list or console-&gt;flags updates</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_list_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_list_unlock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_list_unlock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unlock the console list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Counterpart to <a class="reference internal" href="#c.console_list_lock" title="console_list_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_list_lock()</span></code></a></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_srcu_read_lock">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_srcu_read_lock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_srcu_read_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register a new reader for the SRCU-protected console list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use <a class="reference internal" href="tty/console.html#c.for_each_console_srcu" title="for_each_console_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_console_srcu()</span></code></a> to iterate the console list</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>A cookie to pass to <a class="reference internal" href="#c.console_srcu_read_unlock" title="console_srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_srcu_read_unlock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_srcu_read_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_srcu_read_unlock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cookie</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_srcu_read_unlock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unregister an old reader from the SRCU-protected console list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cookie</span></code></dt><dd><p>cookie returned from <a class="reference internal" href="#c.console_srcu_read_lock" title="console_srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_srcu_read_lock()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Counterpart to <a class="reference internal" href="#c.console_srcu_read_lock" title="console_srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_srcu_read_lock()</span></code></a></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.match_devname_and_update_preferred_console">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">match_devname_and_update_preferred_console</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">devname</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">short</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.match_devname_and_update_preferred_console" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update a preferred console when matching devname is found.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*devname</span></code></dt><dd><p>DEVNAME:0.0 style device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the corresponding console driver, e.g. “ttyS”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">short</span> <span class="pre">idx</span></code></dt><dd><p>Console index, e.g. port number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function checks whether a device with the given <strong>devname</strong> is
preferred via the console=DEVNAME:0.0 command line option.
It fills the missing console driver name and console index
so that a later register_console() call could find (match)
and enable this device.</p>
<p>It might be used when a driver subsystem initializes particular
devices with already known DEVNAME:0.0 style names. And it
could predict which console driver name and index this device
would later get associated with.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_lock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_lock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>block the console subsystem from printing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires a lock which guarantees that no consoles will
be in or enter their write() callback.</p>
<p>Can sleep, returns nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_trylock">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_trylock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_trylock" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to block the console subsystem from printing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to acquire a lock which guarantees that no consoles will
be in or enter their write() callback.</p>
<p>returns 1 on success, and 0 on failure to acquire the lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_unlock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_unlock" title="Link to this definition">¶</a><br /></dt>
<dd><p>unblock the legacy console subsystem from printing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the console_lock which the caller holds to block printing of
the legacy console subsystem.</p>
<p>While the console_lock was held, console output may have been buffered
by <a class="reference internal" href="../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a>. If this is the case, <a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_unlock()</span></code></a> emits the output on
legacy consoles prior to releasing the lock.</p>
<p><a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_unlock()</span></code></a>; may be called from any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_conditional_schedule">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_conditional_schedule</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_conditional_schedule" title="Link to this definition">¶</a><br /></dt>
<dd><p>yield the CPU if required</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the console code is currently allowed to sleep, and
if this CPU should yield the CPU to another task, do
so here.</p>
<p>Must be called within <a class="reference internal" href="#c.console_lock" title="console_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_lock()</span></code></a>;.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.console_force_preferred_locked">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">console_force_preferred_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="tty/console.html#c.console" title="console"><span class="n"><span class="pre">console</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">con</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.console_force_preferred_locked" title="Link to this definition">¶</a><br /></dt>
<dd><p>force a registered console preferred</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">console</span> <span class="pre">*con</span></code></dt><dd><p>The registered console to force preferred.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called under <a class="reference internal" href="#c.console_list_lock" title="console_list_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_list_lock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.printk_timed_ratelimit">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">printk_timed_ratelimit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">caller_jiffies</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">interval_msecs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.printk_timed_ratelimit" title="Link to this definition">¶</a><br /></dt>
<dd><p>caller-controlled printk ratelimiting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*caller_jiffies</span></code></dt><dd><p>pointer to caller’s state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">interval_msecs</span></code></dt><dd><p>minimum interval between prints</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.printk_timed_ratelimit" title="printk_timed_ratelimit"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk_timed_ratelimit()</span></code></a> returns true if more than <strong>interval_msecs</strong>
milliseconds have elapsed since the last time <a class="reference internal" href="#c.printk_timed_ratelimit" title="printk_timed_ratelimit"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk_timed_ratelimit()</span></code></a>
returned true.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmsg_dump_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmsg_dump_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmsg_dumper</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dumper</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a kernel log dumper.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>pointer to the kmsg_dumper structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a kernel log dumper to the system. The dump callback in the
structure will be called when the kernel oopses or panics and must be
set. Returns zero on success and <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> or <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmsg_dump_unregister">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmsg_dump_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmsg_dumper</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dumper</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a kmsg dumper.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>pointer to the kmsg_dumper structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a dump device from the system. Returns zero on success and
<code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmsg_dump_get_line">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmsg_dump_get_line</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmsg_dump_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">syslog</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">line</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_get_line" title="Link to this definition">¶</a><br /></dt>
<dd><p>retrieve one kmsg log line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dump_iter</span> <span class="pre">*iter</span></code></dt><dd><p>kmsg dump iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">syslog</span></code></dt><dd><p>include the “&lt;4&gt;” prefixes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*line</span></code></dt><dd><p>buffer to copy the line to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>maximum size of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*len</span></code></dt><dd><p>length of line placed into buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start at the beginning of the kmsg buffer, with the oldest kmsg
record, and copy one record into the provided buffer.</p>
<p>Consecutive calls will return the next available record moving
towards the end of the buffer with the youngest messages.</p>
<p>A return value of FALSE indicates that there are no more records to
read.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmsg_dump_get_buffer">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmsg_dump_get_buffer</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmsg_dump_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">syslog</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">len_out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_get_buffer" title="Link to this definition">¶</a><br /></dt>
<dd><p>copy kmsg log lines</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dump_iter</span> <span class="pre">*iter</span></code></dt><dd><p>kmsg dump iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">syslog</span></code></dt><dd><p>include the “&lt;4&gt;” prefixes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to copy the line to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>maximum size of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*len_out</span></code></dt><dd><p>length of line placed into buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start at the end of the kmsg buffer and fill the provided buffer
with as many of the <em>youngest</em> kmsg records that fit into it.
If the buffer is large enough, all available kmsg records will be
copied with a single call.</p>
<p>Consecutive calls will fill the buffer with the next block of
available older records, not including the earlier retrieved ones.</p>
<p>A return value of FALSE indicates that there are no more records to
read.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmsg_dump_rewind">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmsg_dump_rewind</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmsg_dump_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_rewind" title="Link to this definition">¶</a><br /></dt>
<dd><p>reset the iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dump_iter</span> <span class="pre">*iter</span></code></dt><dd><p>kmsg dump iterator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the dumper’s iterator so that <a class="reference internal" href="#c.kmsg_dump_get_line" title="kmsg_dump_get_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmsg_dump_get_line()</span></code></a> and
<a class="reference internal" href="#c.kmsg_dump_get_buffer" title="kmsg_dump_get_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmsg_dump_get_buffer()</span></code></a> can be called again and used multiple
times within the same dumper.dump() callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__printk_cpu_sync_wait">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__printk_cpu_sync_wait</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__printk_cpu_sync_wait" title="Link to this definition">¶</a><br /></dt>
<dd><p>Busy wait until the printk cpu-reentrant spinning lock is not owned by any CPU.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__printk_cpu_sync_try_get">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__printk_cpu_sync_try_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__printk_cpu_sync_try_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Try to acquire the printk cpu-reentrant spinning lock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If no processor has the lock, the calling processor takes the lock and
becomes the owner. If the calling processor is already the owner of the
lock, this function succeeds immediately.</p>
<p><strong>Context</strong></p>
<p>Any context. Expects interrupts to be disabled.</p>
<p><strong>Return</strong></p>
<p>1 on success, otherwise 0.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__printk_cpu_sync_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__printk_cpu_sync_put</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__printk_cpu_sync_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release the printk cpu-reentrant spinning lock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The calling processor must be the owner of the lock.</p>
<p><strong>Context</strong></p>
<p>Any context. Expects interrupts to be disabled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.panic">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">panic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.panic" title="Link to this definition">¶</a><br /></dt>
<dd><p>halt the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The text string to print</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Display a message, then perform cleanups. This function never returns.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.add_taint">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">add_taint</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">flag</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.add_taint" title="lockdep_ok"><span class="n"><span class="pre">lockdep_ok</span></span></a><span class="w"> </span><span class="n"><span class="pre">lockdep_ok</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.add_taint" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a taint flag if not already set.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flag</span></code></dt><dd><p>one of the TAINT_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">lockdep_ok</span> <span class="pre">lockdep_ok</span></code></dt><dd><p>whether lock debugging is still OK.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If something bad has gone wrong, you’ll want <strong>lockdebug_ok</strong> = false, but for
some notewortht-but-not-corrupting cases, it can be set to true.</p>
</div>
</section>
<section id="device-resource-management">
<h2>Device Resource Management<a class="headerlink" href="#device-resource-management" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.__devres_alloc_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__devres_alloc_node</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">dr_release_t</span></span><span class="w"> </span><span class="n"><span class="pre">release</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__devres_alloc_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate device resource data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Release function devres will be associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>NUMA node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the resource</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate devres of <strong>size</strong> bytes.  The allocated area is zeroed, then
associated with <strong>release</strong>.  The returned pointer can be passed to
other devres_*() functions.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated devres on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_for_each_res">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devres_for_each_res</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">dr_release_t</span></span><span class="w"> </span><span class="n"><span class="pre">release</span></span>, <span class="n"><span class="pre">dr_match_t</span></span><span class="w"> </span><span class="n"><span class="pre">match</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match_data</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_for_each_res" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to iterate resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to be called for each matched resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data for <strong>fn</strong>, the 3rd parameter of <strong>fn</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <strong>fn</strong> for each devres of <strong>dev</strong> which is associated with <strong>release</strong>
and for which <strong>match</strong> returns 1.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>void</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devres_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free device resource data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*res</span></code></dt><dd><p>Pointer to devres data to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free devres created with devres_alloc().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devres_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register device resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to add resource to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*res</span></code></dt><dd><p>Resource to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register devres <strong>res</strong> to <strong>dev</strong>.  <strong>res</strong> should have been allocated
using devres_alloc().  On driver detach, the associated release
function will be invoked and devres will be freed automatically.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_find">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devres_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">dr_release_t</span></span><span class="w"> </span><span class="n"><span class="pre">release</span></span>, <span class="n"><span class="pre">dr_match_t</span></span><span class="w"> </span><span class="n"><span class="pre">match</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find device resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to lookup resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> which is associated with <strong>release</strong>
and for which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered
to match all.</p>
<p><strong>Return</strong></p>
<p>Pointer to found devres, NULL if not found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devres_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_res</span></span>, <span class="n"><span class="pre">dr_match_t</span></span><span class="w"> </span><span class="n"><span class="pre">match</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find devres, if non-existent, add one atomically</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to lookup or add devres for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*new_res</span></code></dt><dd><p>Pointer to new initialized devres to add if not found</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> which has the same release function
as <strong>new_res</strong> and for which <strong>match</strong> return 1.  If found, <strong>new_res</strong> is
freed; otherwise, <strong>new_res</strong> is added atomically.</p>
<p><strong>Return</strong></p>
<p>Pointer to found or added devres.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devres_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">dr_release_t</span></span><span class="w"> </span><span class="n"><span class="pre">release</span></span>, <span class="n"><span class="pre">dr_match_t</span></span><span class="w"> </span><span class="n"><span class="pre">match</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find a device resource and remove it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically and
returned.</p>
<p><strong>Return</strong></p>
<p>Pointer to removed devres on success, NULL if not found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_destroy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devres_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">dr_release_t</span></span><span class="w"> </span><span class="n"><span class="pre">release</span></span>, <span class="n"><span class="pre">dr_match_t</span></span><span class="w"> </span><span class="n"><span class="pre">match</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find a device resource and destroy it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically and freed.</p>
<p>Note that the release function for the resource will not be called,
only the devres-allocated data will be freed.  The caller becomes
responsible for freeing any other data.</p>
<p><strong>Return</strong></p>
<p>0 if devres is found and freed, -ENOENT if not found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devres_release</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">dr_release_t</span></span><span class="w"> </span><span class="n"><span class="pre">release</span></span>, <span class="n"><span class="pre">dr_match_t</span></span><span class="w"> </span><span class="n"><span class="pre">match</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find a device resource and destroy it, calling release</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically, the
release function called and the resource freed.</p>
<p><strong>Return</strong></p>
<p>0 if devres is found and freed, -ENOENT if not found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_open_group">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devres_open_group</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_open_group" title="Link to this definition">¶</a><br /></dt>
<dd><p>Open a new devres group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to open devres group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>Separator ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open a new devres group for <strong>dev</strong> with <strong>id</strong>.  For <strong>id</strong>, using a
pointer to an object which won’t be used for another group is
recommended.  If <strong>id</strong> is NULL, address-wise unique ID is created.</p>
<p><strong>Return</strong></p>
<p>ID of the new group, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_close_group">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devres_close_group</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_close_group" title="Link to this definition">¶</a><br /></dt>
<dd><p>Close a devres group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to close devres group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Close the group identified by <strong>id</strong>.  If <strong>id</strong> is NULL, the latest open
group is selected.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_remove_group">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devres_remove_group</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_remove_group" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove a devres group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to remove group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove the group identified by <strong>id</strong>.  If <strong>id</strong> is NULL, the latest
open group is selected.  Note that removing a group doesn’t affect
any other resources.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devres_release_group">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devres_release_group</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_release_group" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release resources in a devres group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to release group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release all resources in the group identified by <strong>id</strong>.  If <strong>id</strong> is
NULL, the latest open group is selected.  The selected group and
groups properly nested inside the selected group are removed.</p>
<p><strong>Return</strong></p>
<p>The number of released non-group resources.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__devm_add_action">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__devm_add_action</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__devm_add_action" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a custom action to list of managed resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function that should be called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the resource (for debugging purposes)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds a custom action to the list of managed resources so that
it gets executed as part of standard resource unwinding.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_remove_action_nowarn">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_remove_action_nowarn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_remove_action_nowarn" title="Link to this definition">¶</a><br /></dt>
<dd><p>removes previously added custom action</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function implementing the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes instance of <strong>action</strong> previously added by devm_add_action().
Both action and data should match one of the existing entries.</p>
<p>In contrast to devm_remove_action(), this function does not WARN() if no
entry could have been found.</p>
<p>This should only be used if the action is contained in an object with
independent lifetime management, e.g. the Devres rust abstraction.</p>
<p>Causing the warning from regular driver code most likely indicates an abuse
of the devres API.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOENT if no entry could have been found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_release_action">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_release_action</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">action</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_release_action" title="Link to this definition">¶</a><br /></dt>
<dd><p>release previously added custom action</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function implementing the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases and removes instance of <strong>action</strong> previously added by
devm_add_action().  Both action and data should match one of the
existing entries.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_kmalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_kmalloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kmalloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource-managed kmalloc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed kmalloc.  Memory allocated with this function is
automatically freed on driver detach.  Like all other devres
resources, guaranteed alignment is unsigned long long.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_krealloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_krealloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_krealloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource-managed krealloc()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to re-allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>Pointer to the memory chunk to re-allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_size</span></code></dt><dd><p>New allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed krealloc(). Resizes the memory chunk allocated with <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>.
Behaves similarly to regular krealloc(): if <strong>ptr</strong> is NULL or ZERO_SIZE_PTR,
it’s the equivalent of <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>. If new_size is zero, it frees the
previously allocated memory and returns ZERO_SIZE_PTR. This function doesn’t
change the order in which the release callback for the re-alloc’ed devres
will be called (except when falling back to <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> or when freeing
resources when new_size is zero). The contents of the memory are preserved
up to the lesser of new and old sizes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_kstrdup">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_kstrdup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kstrdup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate resource managed space and copy an existing string into that.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_kstrdup_const">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_kstrdup_const</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kstrdup_const" title="Link to this definition">¶</a><br /></dt>
<dd><p>resource managed conditional string duplication</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for which to duplicate the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Strings allocated by devm_kstrdup_const will be automatically freed when
the associated device is detached.</p>
<p><strong>Return</strong></p>
<p>Source string if it is in .rodata section otherwise it falls back to
devm_kstrdup.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_kvasprintf">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_kvasprintf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">ap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kvasprintf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate resource managed space and format a string into that.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The printf()-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">ap</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_kasprintf">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_kasprintf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kasprintf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate resource managed space and format a string into that.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The printf()-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_kfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_kfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kfree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource-managed kfree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>Memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_kmemdup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_kmemdup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kmemdup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource-managed kmemdup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>Memory region to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Memory region length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Duplicate region of a memory using resource managed kmalloc</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_get_free_pages">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_get_free_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_free_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource-managed __get_free_pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Allocation size is (1 &lt;&lt; order) pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed get_free_pages.  Memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Address of allocated memory on success, 0 on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_free_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_free_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_free_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource-managed free_pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>Memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="#c.devm_get_free_pages" title="devm_get_free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_get_free_pages()</span></code></a>. Unlike free_pages,
there is no need to supply the <strong>order</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__devm_alloc_percpu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__percpu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__devm_alloc_percpu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__devm_alloc_percpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource-managed alloc_percpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate per-cpu memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of per-cpu memory to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>Alignment of per-cpu memory to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed alloc_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_free_percpu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_free_percpu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__percpu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdata</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_free_percpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource-managed free_percpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*pdata</span></code></dt><dd><p>Per-cpu memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="infrastructure.html#c.devm_alloc_percpu" title="devm_alloc_percpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_alloc_percpu()</span></code></a>.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/basics.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>