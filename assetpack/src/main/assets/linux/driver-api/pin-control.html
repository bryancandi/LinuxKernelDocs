<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PINCTRL (PIN CONTROL) subsystem &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PLDM Firmware Flash Update Library" href="pldmfw/index.html" />
    <link rel="prev" title="Samsung USB 2.0 PHY adaptation layer" href="phy/samsung-usb2.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="extcon.html">Extcon Device Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/pin-control.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="pinctrl-pin-control-subsystem">
<h1>PINCTRL (PIN CONTROL) subsystem<a class="headerlink" href="#pinctrl-pin-control-subsystem" title="Link to this heading">¶</a></h1>
<p>This document outlines the pin control subsystem in Linux</p>
<p>This subsystem deals with:</p>
<ul class="simple">
<li><p>Enumerating and naming controllable pins</p></li>
<li><p>Multiplexing of pins, pads, fingers (etc) see below for details</p></li>
<li><p>Configuration of pins, pads, fingers (etc), such as software-controlled
biasing and driving mode specific pins, such as pull-up, pull-down, open drain,
load capacitance etc.</p></li>
</ul>
<section id="top-level-interface">
<h2>Top-level interface<a class="headerlink" href="#top-level-interface" title="Link to this heading">¶</a></h2>
<p>Definitions:</p>
<ul class="simple">
<li><p>A PIN CONTROLLER is a piece of hardware, usually a set of registers, that
can control PINs. It may be able to multiplex, bias, set load capacitance,
set drive strength, etc. for individual pins or groups of pins.</p></li>
<li><p>PINS are equal to pads, fingers, balls or whatever packaging input or
output line you want to control and these are denoted by unsigned integers
in the range 0..maxpin. This numberspace is local to each PIN CONTROLLER, so
there may be several such number spaces in a system. This pin space may
be sparse - i.e. there may be gaps in the space with numbers where no
pin exists.</p></li>
</ul>
<p>When a PIN CONTROLLER is instantiated, it will register a descriptor to the
pin control framework, and this descriptor contains an array of pin descriptors
describing the pins handled by this specific pin controller.</p>
<p>Here is an example of a PGA (Pin Grid Array) chip seen from underneath:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     A   B   C   D   E   F   G   H

8    o   o   o   o   o   o   o   o

7    o   o   o   o   o   o   o   o

6    o   o   o   o   o   o   o   o

5    o   o   o   o   o   o   o   o

4    o   o   o   o   o   o   o   o

3    o   o   o   o   o   o   o   o

2    o   o   o   o   o   o   o   o

1    o   o   o   o   o   o   o   o
</pre></div>
</div>
<p>To register a pin controller and name all the pins on this package we can do
this in our driver:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/pinctrl.h&gt;</span>

<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_pin_desc</span><span class="w"> </span><span class="n">foo_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PINCTRL_PIN</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A8&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">PINCTRL_PIN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B8&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">PINCTRL_PIN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;C8&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="n">PINCTRL_PIN</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F1&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">PINCTRL_PIN</span><span class="p">(</span><span class="mi">62</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;G1&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">PINCTRL_PIN</span><span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;H1&quot;</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_desc</span><span class="w"> </span><span class="n">foo_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_pins</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">npins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">foo_pins</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">foo_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>

<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctl</span><span class="p">;</span>

<span class="w">        </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_register_and_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo_desc</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PARENT</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pctl</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">pinctrl_enable</span><span class="p">(</span><span class="n">pctl</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To enable the pinctrl subsystem and the subgroups for PINMUX and PINCONF and
selected drivers, you need to select them from your machine’s Kconfig entry,
since these are so tightly integrated with the machines they are used on.
See <code class="docutils literal notranslate"><span class="pre">arch/arm/mach-ux500/Kconfig</span></code> for an example.</p>
<p>Pins usually have fancier names than this. You can find these in the datasheet
for your chip. Notice that the core pinctrl.h file provides a fancy macro
called <code class="docutils literal notranslate"><span class="pre">PINCTRL_PIN()</span></code> to create the struct entries. As you can see the pins are
enumerated from 0 in the upper left corner to 63 in the lower right corner.
This enumeration was arbitrarily chosen, in practice you need to think
through your numbering system so that it matches the layout of registers
and such things in your driver, or the code may become complicated. You must
also consider matching of offsets to the GPIO ranges that may be handled by
the pin controller.</p>
<p>For a padding with 467 pads, as opposed to actual pins, the enumeration will
be like this, walking around the edge of the chip, which seems to be industry
standard too (all these pads had names, too):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  0 ..... 104
466        105
  .        .
  .        .
358        224
 357 .... 225
</pre></div>
</div>
</section>
<section id="pin-groups">
<h2>Pin groups<a class="headerlink" href="#pin-groups" title="Link to this heading">¶</a></h2>
<p>Many controllers need to deal with groups of pins, so the pin controller
subsystem has a mechanism for enumerating groups of pins and retrieving the
actual enumerated pins that are part of a certain group.</p>
<p>For example, say that we have a group of pins dealing with an SPI interface
on { 0, 8, 16, 24 }, and a group of pins dealing with an I2C interface on pins
on { 24, 25 }.</p>
<p>These two groups are presented to the pin control subsystem by implementing
some generic <code class="docutils literal notranslate"><span class="pre">pinctrl_ops</span></code> like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/pinctrl.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spi0_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="w"> </span><span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i2c0_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">24</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pingroup</span><span class="w"> </span><span class="n">foo_groups</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PINCTRL_PINGROUP</span><span class="p">(</span><span class="s">&quot;spi0_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi0_pins</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">spi0_pins</span><span class="p">)),</span>
<span class="w">        </span><span class="n">PINCTRL_PINGROUP</span><span class="p">(</span><span class="s">&quot;i2c0_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i2c0_pins</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">i2c0_pins</span><span class="p">)),</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_get_groups_count</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">foo_groups</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">foo_get_group_name</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">selector</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">foo_groups</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_get_group_pins</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">selector</span><span class="p">,</span>
<span class="w">                              </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">pins</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">npins</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">pins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_groups</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">pins</span><span class="p">;</span>
<span class="w">        </span><span class="o">*</span><span class="n">npins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_groups</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">npins</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_ops</span><span class="w"> </span><span class="n">foo_pctrl_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_groups_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_groups_count</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_group_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_group_name</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_group_pins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_group_pins</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_desc</span><span class="w"> </span><span class="n">foo_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="p">.</span><span class="n">pctlops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo_pctrl_ops</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The pin control subsystem will call the <code class="docutils literal notranslate"><span class="pre">.get_groups_count()</span></code> function to
determine the total number of legal selectors, then it will call the other functions
to retrieve the name and pins of the group. Maintaining the data structure of
the groups is up to the driver, this is just a simple example - in practice you
may need more entries in your group structure, for example specific register
ranges associated with each group and so on.</p>
</section>
<section id="pin-configuration">
<h2>Pin configuration<a class="headerlink" href="#pin-configuration" title="Link to this heading">¶</a></h2>
<p>Pins can sometimes be software-configured in various ways, mostly related
to their electronic properties when used as inputs or outputs. For example you
may be able to make an output pin high impedance (Hi-Z), or “tristate” meaning it is
effectively disconnected. You may be able to connect an input pin to VDD or GND
using a certain resistor value - pull up and pull down - so that the pin has a
stable value when nothing is driving the rail it is connected to, or when it’s
unconnected.</p>
<p>Pin configuration can be programmed by adding configuration entries into the
mapping table; see section <a class="reference internal" href="#board-machine-configuration">Board/machine configuration</a> below.</p>
<p>The format and meaning of the configuration parameter, PLATFORM_X_PULL_UP
above, is entirely defined by the pin controller driver.</p>
<p>The pin configuration driver implements callbacks for changing pin
configuration in the pin controller ops like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/pinconf.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/pinctrl.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;platform_x_pindefs.h&quot;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_pin_config_get</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">config</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_conftype</span><span class="w"> </span><span class="n">conf</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* ... Find setting for pin @ offset ... */</span>

<span class="w">        </span><span class="o">*</span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="w"> </span><span class="n">conf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_pin_config_set</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">config</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_conftype</span><span class="w"> </span><span class="o">*</span><span class="n">conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">my_conftype</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">config</span><span class="p">;</span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">conf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="no">PLATFORM_X_PULL_UP</span><span class="p">:</span>
<span class="w">                </span><span class="p">...</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_pin_config_group_get</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">selector</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">config</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_pin_config_group_set</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">selector</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">config</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinconf_ops</span><span class="w"> </span><span class="n">foo_pconf_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">pin_config_get</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_pin_config_get</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pin_config_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_pin_config_set</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pin_config_group_get</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_pin_config_group_get</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pin_config_group_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_pin_config_group_set</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Pin config operations are handled by some pin controller */</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_desc</span><span class="w"> </span><span class="n">foo_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="p">.</span><span class="n">confops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo_pconf_ops</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="interaction-with-the-gpio-subsystem">
<h2>Interaction with the GPIO subsystem<a class="headerlink" href="#interaction-with-the-gpio-subsystem" title="Link to this heading">¶</a></h2>
<p>The GPIO drivers may want to perform operations of various types on the same
physical pins that are also registered as pin controller pins.</p>
<p>First and foremost, the two subsystems can be used as completely orthogonal,
see the section named <a class="reference internal" href="#pin-control-requests-from-drivers">Pin control requests from drivers</a> and
<a class="reference internal" href="#drivers-needing-both-pin-control-and-gpios">Drivers needing both pin control and GPIOs</a> below for details. But in some
situations a cross-subsystem mapping between pins and GPIOs is needed.</p>
<p>Since the pin controller subsystem has its pinspace local to the pin controller
we need a mapping so that the pin control subsystem can figure out which pin
controller handles control of a certain GPIO pin. Since a single pin controller
may be muxing several GPIO ranges (typically SoCs that have one set of pins,
but internally several GPIO silicon blocks, each modelled as a <a class="reference internal" href="gpio/index.html#c.gpio_chip" title="gpio_chip"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">gpio_chip</span></code></a>) any number of GPIO ranges can be added to a pin controller instance
like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/gpio/driver.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/pinctrl.h&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">gpio_chip</span><span class="w"> </span><span class="n">chip_a</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">gpio_chip</span><span class="w"> </span><span class="n">chip_b</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_gpio_range</span><span class="w"> </span><span class="n">gpio_range_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;chip a&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pin_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">npins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chip_a</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_gpio_range</span><span class="w"> </span><span class="n">gpio_range_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;chip b&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">48</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pin_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">npins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chip_b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">foo_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctl</span><span class="p">;</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="n">pinctrl_add_gpio_range</span><span class="p">(</span><span class="n">pctl</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpio_range_a</span><span class="p">);</span>
<span class="w">        </span><span class="n">pinctrl_add_gpio_range</span><span class="p">(</span><span class="n">pctl</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpio_range_b</span><span class="p">);</span>
<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So this complex system has one pin controller handling two different
GPIO chips. “chip a” has 16 pins and “chip b” has 8 pins. The “chip a” and
“chip b” have different <code class="docutils literal notranslate"><span class="pre">pin_base</span></code>, which means a start pin number of the
GPIO range.</p>
<p>The GPIO range of “chip a” starts from the GPIO base of 32 and actual
pin range also starts from 32. However “chip b” has different starting
offset for the GPIO range and pin range. The GPIO range of “chip b” starts
from GPIO number 48, while the pin range of “chip b” starts from 64.</p>
<p>We can convert a gpio number to actual pin number using this <code class="docutils literal notranslate"><span class="pre">pin_base</span></code>.
They are mapped in the global GPIO pin space at:</p>
<dl class="simple">
<dt>chip a:</dt><dd><ul class="simple">
<li><p>GPIO range : [32 .. 47]</p></li>
<li><p>pin range  : [32 .. 47]</p></li>
</ul>
</dd>
<dt>chip b:</dt><dd><ul class="simple">
<li><p>GPIO range : [48 .. 55]</p></li>
<li><p>pin range  : [64 .. 71]</p></li>
</ul>
</dd>
</dl>
<p>The above examples assume the mapping between the GPIOs and pins is
linear. If the mapping is sparse or haphazard, an array of arbitrary pin
numbers can be encoded in the range like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">range_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_gpio_range</span><span class="w"> </span><span class="n">gpio_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;chip&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range_pins</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">npins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">range_pins</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chip</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this case the <code class="docutils literal notranslate"><span class="pre">pin_base</span></code> property will be ignored. If the name of a pin
group is known, the pins and npins elements of the above structure can be
initialised using the function <code class="docutils literal notranslate"><span class="pre">pinctrl_get_group_pins()</span></code>, e.g. for pin
group “foo”:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pinctrl_get_group_pins</span><span class="p">(</span><span class="n">pctl</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpio_range</span><span class="p">.</span><span class="n">pins</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpio_range</span><span class="p">.</span><span class="n">npins</span><span class="p">);</span>
</pre></div>
</div>
<p>When GPIO-specific functions in the pin control subsystem are called, these
ranges will be used to look up the appropriate pin controller by inspecting
and matching the pin to the pin ranges across all controllers. When a
pin controller handling the matching range is found, GPIO-specific functions
will be called on that specific pin controller.</p>
<p>For all functionalities dealing with pin biasing, pin muxing etc, the pin
controller subsystem will look up the corresponding pin number from the passed
in gpio number, and use the range’s internals to retrieve a pin number. After
that, the subsystem passes it on to the pin control driver, so the driver
will get a pin number into its handled number range. Further it is also passed
the range ID value, so that the pin controller knows which range it should
deal with.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">pinctrl_add_gpio_range()</span></code> from pinctrl driver is DEPRECATED. Please see
section 2.1 of <code class="docutils literal notranslate"><span class="pre">Documentation/devicetree/bindings/gpio/gpio.txt</span></code> on how to bind
pinctrl and gpio drivers.</p>
</section>
<section id="pinmux-interfaces">
<h2>PINMUX interfaces<a class="headerlink" href="#pinmux-interfaces" title="Link to this heading">¶</a></h2>
<p>These calls use the pinmux_* naming prefix.  No other calls should use that
prefix.</p>
</section>
<section id="what-is-pinmuxing">
<h2>What is pinmuxing?<a class="headerlink" href="#what-is-pinmuxing" title="Link to this heading">¶</a></h2>
<p>PINMUX, also known as padmux, ballmux, alternate functions or mission modes
is a way for chip vendors producing some kind of electrical packages to use
a certain physical pin (ball, pad, finger, etc) for multiple mutually exclusive
functions, depending on the application. By “application” in this context
we usually mean a way of soldering or wiring the package into an electronic
system, even though the framework makes it possible to also change the function
at runtime.</p>
<p>Here is an example of a PGA (Pin Grid Array) chip seen from underneath:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     A   B   C   D   E   F   G   H
   +---+
8  | o | o   o   o   o   o   o   o
   |   |
7  | o | o   o   o   o   o   o   o
   |   |
6  | o | o   o   o   o   o   o   o
   +---+---+
5  | o | o | o   o   o   o   o   o
   +---+---+               +---+
4    o   o   o   o   o   o | o | o
                           |   |
3    o   o   o   o   o   o | o | o
                           |   |
2    o   o   o   o   o   o | o | o
   +-------+-------+-------+---+---+
1  | o   o | o   o | o   o | o | o |
   +-------+-------+-------+---+---+
</pre></div>
</div>
<p>This is not tetris. The game to think of is chess. Not all PGA/BGA packages
are chessboard-like, big ones have “holes” in some arrangement according to
different design patterns, but we’re using this as a simple example. Of the
pins you see some will be taken by things like a few VCC and GND to feed power
to the chip, and quite a few will be taken by large ports like an external
memory interface. The remaining pins will often be subject to pin multiplexing.</p>
<p>The example 8x8 PGA package above will have pin numbers 0 through 63 assigned
to its physical pins. It will name the pins { A1, A2, A3 ... H6, H7, H8 } using
pinctrl_register_pins() and a suitable data set as shown earlier.</p>
<p>In this 8x8 BGA package the pins { A8, A7, A6, A5 } can be used as an SPI port
(these are four pins: CLK, RXD, TXD, FRM). In that case, pin B5 can be used as
some general-purpose GPIO pin. However, in another setting, pins { A5, B5 } can
be used as an I2C port (these are just two pins: SCL, SDA). Needless to say,
we cannot use the SPI port and I2C port at the same time. However in the inside
of the package the silicon performing the SPI logic can alternatively be routed
out on pins { G4, G3, G2, G1 }.</p>
<p>On the bottom row at { A1, B1, C1, D1, E1, F1, G1, H1 } we have something
special - it’s an external MMC bus that can be 2, 4 or 8 bits wide, and it will
consume 2, 4 or 8 pins respectively, so either { A1, B1 } are taken or
{ A1, B1, C1, D1 } or all of them. If we use all 8 bits, we cannot use the SPI
port on pins { G4, G3, G2, G1 } of course.</p>
<p>This way the silicon blocks present inside the chip can be multiplexed “muxed”
out on different pin ranges. Often contemporary SoC (systems on chip) will
contain several I2C, SPI, SDIO/MMC, etc silicon blocks that can be routed to
different pins by pinmux settings.</p>
<p>Since general-purpose I/O pins (GPIO) are typically always in shortage, it is
common to be able to use almost any pin as a GPIO pin if it is not currently
in use by some other I/O port.</p>
</section>
<section id="pinmux-conventions">
<h2>Pinmux conventions<a class="headerlink" href="#pinmux-conventions" title="Link to this heading">¶</a></h2>
<p>The purpose of the pinmux functionality in the pin controller subsystem is to
abstract and provide pinmux settings to the devices you choose to instantiate
in your machine configuration. It is inspired by the clk, GPIO and regulator
subsystems, so devices will request their mux setting, but it’s also possible
to request a single pin for e.g. GPIO.</p>
<p>The conventions are:</p>
<ul>
<li><p>FUNCTIONS can be switched in and out by a driver residing with the pin
control subsystem in the <code class="docutils literal notranslate"><span class="pre">drivers/pinctrl</span></code> directory of the kernel. The
pin control driver knows the possible functions. In the example above you can
identify three pinmux functions, one for spi, one for i2c and one for mmc.</p></li>
<li><p>FUNCTIONS are assumed to be enumerable from zero in a one-dimensional array.
In this case the array could be something like: { spi0, i2c0, mmc0 }
for the three available functions.</p></li>
<li><p>FUNCTIONS have PIN GROUPS as defined on the generic level - so a certain
function is <em>always</em> associated with a certain set of pin groups, could
be just a single one, but could also be many. In the example above the
function i2c is associated with the pins { A5, B5 }, enumerated as
{ 24, 25 } in the controller pin space.</p>
<p>The Function spi is associated with pin groups { A8, A7, A6, A5 }
and { G4, G3, G2, G1 }, which are enumerated as { 0, 8, 16, 24 } and
{ 38, 46, 54, 62 } respectively.</p>
<p>Group names must be unique per pin controller, no two groups on the same
controller may have the same name.</p>
</li>
<li><p>The combination of a FUNCTION and a PIN GROUP determine a certain function
for a certain set of pins. The knowledge of the functions and pin groups
and their machine-specific particulars are kept inside the pinmux driver,
from the outside only the enumerators are known, and the driver core can
request:</p>
<ul class="simple">
<li><p>The name of a function with a certain selector (&gt;= 0)</p></li>
<li><p>A list of groups associated with a certain function</p></li>
<li><p>That a certain group in that list to be activated for a certain function</p></li>
</ul>
<p>As already described above, pin groups are in turn self-descriptive, so
the core will retrieve the actual pin range in a certain group from the
driver.</p>
</li>
<li><p>FUNCTIONS and GROUPS on a certain PIN CONTROLLER are MAPPED to a certain
device by the board file, device tree or similar machine setup configuration
mechanism, similar to how regulators are connected to devices, usually by
name. Defining a pin controller, function and group thus uniquely identify
the set of pins to be used by a certain device. (If only one possible group
of pins is available for the function, no group name need to be supplied -
the core will simply select the first and only group available.)</p>
<p>In the example case we can define that this particular machine shall
use device spi0 with pinmux function fspi0 group gspi0 and i2c0 on function
fi2c0 group gi2c0, on the primary pin controller, we get mappings
like these:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span><span class="s">&quot;map-spi0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi0</span><span class="p">,</span><span class="w"> </span><span class="n">pinctrl0</span><span class="p">,</span><span class="w"> </span><span class="n">fspi0</span><span class="p">,</span><span class="w"> </span><span class="n">gspi0</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="s">&quot;map-i2c0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i2c0</span><span class="p">,</span><span class="w"> </span><span class="n">pinctrl0</span><span class="p">,</span><span class="w"> </span><span class="n">fi2c0</span><span class="p">,</span><span class="w"> </span><span class="n">gi2c0</span><span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Every map must be assigned a state name, pin controller, device and
function. The group is not compulsory - if it is omitted the first group
presented by the driver as applicable for the function will be selected,
which is useful for simple cases.</p>
<p>It is possible to map several groups to the same combination of device,
pin controller and function. This is for cases where a certain function on
a certain pin controller may use different sets of pins in different
configurations.</p>
</li>
<li><p>PINS for a certain FUNCTION using a certain PIN GROUP on a certain
PIN CONTROLLER are provided on a first-come first-serve basis, so if some
other device mux setting or GPIO pin request has already taken your physical
pin, you will be denied the use of it. To get (activate) a new setting, the
old one has to be put (deactivated) first.</p></li>
</ul>
<p>Sometimes the documentation and hardware registers will be oriented around
pads (or “fingers”) rather than pins - these are the soldering surfaces on the
silicon inside the package, and may or may not match the actual number of
pins/balls underneath the capsule. Pick some enumeration that makes sense to
you. Define enumerators only for the pins you can control if that makes sense.</p>
<p>Assumptions:</p>
<p>We assume that the number of possible function maps to pin groups is limited by
the hardware. I.e. we assume that there is no system where any function can be
mapped to any pin, like in a phone exchange. So the available pin groups for
a certain function will be limited to a few choices (say up to eight or so),
not hundreds or any amount of choices. This is the characteristic we have found
by inspecting available pinmux hardware, and a necessary assumption since we
expect pinmux drivers to present <em>all</em> possible function vs pin group mappings
to the subsystem.</p>
</section>
<section id="pinmux-drivers">
<h2>Pinmux drivers<a class="headerlink" href="#pinmux-drivers" title="Link to this heading">¶</a></h2>
<p>The pinmux core takes care of preventing conflicts on pins and calling
the pin controller driver to execute different settings.</p>
<p>It is the responsibility of the pinmux driver to impose further restrictions
(say for example infer electronic limitations due to load, etc.) to determine
whether or not the requested function can actually be allowed, and in case it
is possible to perform the requested mux setting, poke the hardware so that
this happens.</p>
<p>Pinmux drivers are required to supply a few callback functions, some are
optional. Usually the <code class="docutils literal notranslate"><span class="pre">.set_mux()</span></code> function is implemented, writing values into
some certain registers to activate a certain mux setting for a certain pin.</p>
<p>A simple driver for the above example will work by setting bits 0, 1, 2, 3, 4, or 5
into some register named MUX to select a certain function with a certain
group of pins would work something like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/pinctrl.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/pinmux.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spi0_0_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="w"> </span><span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spi0_1_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">38</span><span class="p">,</span><span class="w"> </span><span class="mi">46</span><span class="p">,</span><span class="w"> </span><span class="mi">54</span><span class="p">,</span><span class="w"> </span><span class="mi">62</span><span class="w"> </span><span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i2c0_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">24</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mmc0_1_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">56</span><span class="p">,</span><span class="w"> </span><span class="mi">57</span><span class="w"> </span><span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mmc0_2_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">58</span><span class="p">,</span><span class="w"> </span><span class="mi">59</span><span class="w"> </span><span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mmc0_3_pins</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">60</span><span class="p">,</span><span class="w"> </span><span class="mi">61</span><span class="p">,</span><span class="w"> </span><span class="mi">62</span><span class="p">,</span><span class="w"> </span><span class="mi">63</span><span class="w"> </span><span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pingroup</span><span class="w"> </span><span class="n">foo_groups</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PINCTRL_PINGROUP</span><span class="p">(</span><span class="s">&quot;spi0_0_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi0_0_pins</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">spi0_0_pins</span><span class="p">)),</span>
<span class="w">        </span><span class="n">PINCTRL_PINGROUP</span><span class="p">(</span><span class="s">&quot;spi0_1_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi0_1_pins</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">spi0_1_pins</span><span class="p">)),</span>
<span class="w">        </span><span class="n">PINCTRL_PINGROUP</span><span class="p">(</span><span class="s">&quot;i2c0_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i2c0_pins</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">i2c0_pins</span><span class="p">)),</span>
<span class="w">        </span><span class="n">PINCTRL_PINGROUP</span><span class="p">(</span><span class="s">&quot;mmc0_1_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mmc0_1_pins</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mmc0_1_pins</span><span class="p">)),</span>
<span class="w">        </span><span class="n">PINCTRL_PINGROUP</span><span class="p">(</span><span class="s">&quot;mmc0_2_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mmc0_2_pins</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mmc0_2_pins</span><span class="p">)),</span>
<span class="w">        </span><span class="n">PINCTRL_PINGROUP</span><span class="p">(</span><span class="s">&quot;mmc0_3_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mmc0_3_pins</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mmc0_3_pins</span><span class="p">)),</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_get_groups_count</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">foo_groups</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">foo_get_group_name</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">selector</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">foo_groups</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_get_group_pins</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">selector</span><span class="p">,</span>
<span class="w">                              </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">pins</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">npins</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">pins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_groups</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">pins</span><span class="p">;</span>
<span class="w">        </span><span class="o">*</span><span class="n">npins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_groups</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">npins</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_ops</span><span class="w"> </span><span class="n">foo_pctrl_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_groups_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_groups_count</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_group_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_group_name</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_group_pins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_group_pins</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">spi0_groups</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;spi0_0_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spi0_1_grp&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">i2c0_groups</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;i2c0_grp&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">mmc0_groups</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;mmc0_1_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mmc0_2_grp&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mmc0_3_grp&quot;</span><span class="w"> </span><span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinfunction</span><span class="w"> </span><span class="n">foo_functions</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PINCTRL_PINFUNCTION</span><span class="p">(</span><span class="s">&quot;spi0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">spi0_groups</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">spi0_groups</span><span class="p">)),</span>
<span class="w">        </span><span class="n">PINCTRL_PINFUNCTION</span><span class="p">(</span><span class="s">&quot;i2c0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i2c0_groups</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">i2c0_groups</span><span class="p">)),</span>
<span class="w">        </span><span class="n">PINCTRL_PINFUNCTION</span><span class="p">(</span><span class="s">&quot;mmc0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mmc0_groups</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mmc0_groups</span><span class="p">)),</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_get_functions_count</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">foo_functions</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">foo_get_fname</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">selector</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">foo_functions</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_get_groups</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">selector</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">**</span><span class="n">groups</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ngroups</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_functions</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">groups</span><span class="p">;</span>
<span class="w">        </span><span class="o">*</span><span class="n">ngroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_functions</span><span class="p">[</span><span class="n">selector</span><span class="p">].</span><span class="n">ngroups</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo_set_mux</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_dev</span><span class="w"> </span><span class="o">*</span><span class="n">pctldev</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">selector</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">u8</span><span class="w"> </span><span class="n">regbit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BIT</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>

<span class="w">        </span><span class="n">writeb</span><span class="p">((</span><span class="n">readb</span><span class="p">(</span><span class="n">MUX</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">regbit</span><span class="p">),</span><span class="w"> </span><span class="n">MUX</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinmux_ops</span><span class="w"> </span><span class="n">foo_pmxops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_functions_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_functions_count</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_function_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_fname</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">get_function_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_get_groups</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">set_mux</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_set_mux</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">strict</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Pinmux operations are handled by some pin controller */</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_desc</span><span class="w"> </span><span class="n">foo_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="p">.</span><span class="n">pctlops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo_pctrl_ops</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pmxops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo_pmxops</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the example activating muxing 0 and 2 at the same time setting bits
0 and 2, uses pin 24 in common so they would collide. All the same for
the muxes 1 and 5, which have pin 62 in common.</p>
<p>The beauty of the pinmux subsystem is that since it keeps track of all
pins and who is using them, it will already have denied an impossible
request like that, so the driver does not need to worry about such
things - when it gets a selector passed in, the pinmux subsystem makes
sure no other device or GPIO assignment is already using the selected
pins. Thus bits 0 and 2, or 1 and 5 in the control register will never
be set at the same time.</p>
<p>All the above functions are mandatory to implement for a pinmux driver.</p>
</section>
<section id="pin-control-interaction-with-the-gpio-subsystem">
<h2>Pin control interaction with the GPIO subsystem<a class="headerlink" href="#pin-control-interaction-with-the-gpio-subsystem" title="Link to this heading">¶</a></h2>
<p>Note that the following implies that the use case is to use a certain pin
from the Linux kernel using the API in <code class="docutils literal notranslate"><span class="pre">&lt;linux/gpio/consumer.h&gt;</span></code> with <a class="reference internal" href="gpio/index.html#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a>
and similar functions. There are cases where you may be using something
that your datasheet calls “GPIO mode”, but actually is just an electrical
configuration for a certain device. See the section below named
<a class="reference internal" href="#gpio-mode-pitfalls">GPIO mode pitfalls</a> for more details on this scenario.</p>
<p>The public pinmux API contains two functions named <code class="docutils literal notranslate"><span class="pre">pinctrl_gpio_request()</span></code>
and <code class="docutils literal notranslate"><span class="pre">pinctrl_gpio_free()</span></code>. These two functions shall <em>ONLY</em> be called from
gpiolib-based drivers as part of their <code class="docutils literal notranslate"><span class="pre">.request()</span></code> and <code class="docutils literal notranslate"><span class="pre">.free()</span></code> semantics.
Likewise the <code class="docutils literal notranslate"><span class="pre">pinctrl_gpio_direction_input()</span></code> / <code class="docutils literal notranslate"><span class="pre">pinctrl_gpio_direction_output()</span></code>
shall only be called from within respective <code class="docutils literal notranslate"><span class="pre">.direction_input()</span></code> /
<code class="docutils literal notranslate"><span class="pre">.direction_output()</span></code> gpiolib implementation.</p>
<p>NOTE that platforms and individual drivers shall <em>NOT</em> request GPIO pins to be
controlled e.g. muxed in. Instead, implement a proper gpiolib driver and have
that driver request proper muxing and other control for its pins.</p>
<p>The function list could become long, especially if you can convert every
individual pin into a GPIO pin independent of any other pins, and then try
the approach to define every pin as a function.</p>
<p>In this case, the function array would become 64 entries for each GPIO
setting and then the device functions.</p>
<p>For this reason there are two functions a pin control driver can implement
to enable only GPIO on an individual pin: <code class="docutils literal notranslate"><span class="pre">.gpio_request_enable()</span></code> and
<code class="docutils literal notranslate"><span class="pre">.gpio_disable_free()</span></code>.</p>
<p>This function will pass in the affected GPIO range identified by the pin
controller core, so you know which GPIO pins are being affected by the request
operation.</p>
<p>If your driver needs to have an indication from the framework of whether the
GPIO pin shall be used for input or output you can implement the
<code class="docutils literal notranslate"><span class="pre">.gpio_set_direction()</span></code> function. As described this shall be called from the
gpiolib driver and the affected GPIO range, pin offset and desired direction
will be passed along to this function.</p>
<p>Alternatively to using these special functions, it is fully allowed to use
named functions for each GPIO pin, the <code class="docutils literal notranslate"><span class="pre">pinctrl_gpio_request()</span></code> will attempt to
obtain the function “gpioN” where “N” is the global GPIO pin number if no
special GPIO-handler is registered.</p>
</section>
<section id="gpio-mode-pitfalls">
<h2>GPIO mode pitfalls<a class="headerlink" href="#gpio-mode-pitfalls" title="Link to this heading">¶</a></h2>
<p>Due to the naming conventions used by hardware engineers, where “GPIO”
is taken to mean different things than what the kernel does, the developer
may be confused by a datasheet talking about a pin being possible to set
into “GPIO mode”. It appears that what hardware engineers mean with
“GPIO mode” is not necessarily the use case that is implied in the kernel
interface <code class="docutils literal notranslate"><span class="pre">&lt;linux/gpio/consumer.h&gt;</span></code>: a pin that you grab from kernel code and then
either listen for input or drive high/low to assert/deassert some
external line.</p>
<p>Rather hardware engineers think that “GPIO mode” means that you can
software-control a few electrical properties of the pin that you would
not be able to control if the pin was in some other mode, such as muxed in
for a device.</p>
<p>The GPIO portions of a pin and its relation to a certain pin controller
configuration and muxing logic can be constructed in several ways. Here
are two examples.</p>
<p>Example <strong>(A)</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                  pin config
                  logic regs
                  |               +- SPI
Physical pins --- pad --- pinmux -+- I2C
                          |       +- mmc
                          |       +- GPIO
                          pin
                          multiplex
                          logic regs
</pre></div>
</div>
<p>Here some electrical properties of the pin can be configured no matter
whether the pin is used for GPIO or not. If you multiplex a GPIO onto a
pin, you can also drive it high/low from “GPIO” registers.
Alternatively, the pin can be controlled by a certain peripheral, while
still applying desired pin config properties. GPIO functionality is thus
orthogonal to any other device using the pin.</p>
<p>In this arrangement the registers for the GPIO portions of the pin controller,
or the registers for the GPIO hardware module are likely to reside in a
separate memory range only intended for GPIO driving, and the register
range dealing with pin config and pin multiplexing get placed into a
different memory range and a separate section of the data sheet.</p>
<p>A flag “strict” in struct pinmux_ops is available to check and deny
simultaneous access to the same pin from GPIO and pin multiplexing
consumers on hardware of this type. The pinctrl driver should set this flag
accordingly.</p>
<p>Example <strong>(B)</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                  pin config
                  logic regs
                  |               +- SPI
Physical pins --- pad --- pinmux -+- I2C
                  |       |       +- mmc
                  |       |
                  GPIO    pin
                          multiplex
                          logic regs
</pre></div>
</div>
<p>In this arrangement, the GPIO functionality can always be enabled, such that
e.g. a GPIO input can be used to “spy” on the SPI/I2C/MMC signal while it is
pulsed out. It is likely possible to disrupt the traffic on the pin by doing
wrong things on the GPIO block, as it is never really disconnected. It is
possible that the GPIO, pin config and pin multiplex registers are placed into
the same memory range and the same section of the data sheet, although that
need not be the case.</p>
<p>In some pin controllers, although the physical pins are designed in the same
way as (B), the GPIO function still can’t be enabled at the same time as the
peripheral functions. So again the “strict” flag should be set, denying
simultaneous activation by GPIO and other muxed in devices.</p>
<p>From a kernel point of view, however, these are different aspects of the
hardware and shall be put into different subsystems:</p>
<ul class="simple">
<li><p>Registers (or fields within registers) that control electrical
properties of the pin such as biasing and drive strength should be
exposed through the pinctrl subsystem, as “pin configuration” settings.</p></li>
<li><p>Registers (or fields within registers) that control muxing of signals
from various other HW blocks (e.g. I2C, MMC, or GPIO) onto pins should
be exposed through the pinctrl subsystem, as mux functions.</p></li>
<li><p>Registers (or fields within registers) that control GPIO functionality
such as setting a GPIO’s output value, reading a GPIO’s input value, or
setting GPIO pin direction should be exposed through the GPIO subsystem,
and if they also support interrupt capabilities, through the irqchip
abstraction.</p></li>
</ul>
<p>Depending on the exact HW register design, some functions exposed by the
GPIO subsystem may call into the pinctrl subsystem in order to
coordinate register settings across HW modules. In particular, this may
be needed for HW with separate GPIO and pin controller HW modules, where
e.g. GPIO direction is determined by a register in the pin controller HW
module rather than the GPIO HW module.</p>
<p>Electrical properties of the pin such as biasing and drive strength
may be placed at some pin-specific register in all cases or as part
of the GPIO register in case (B) especially. This doesn’t mean that such
properties necessarily pertain to what the Linux kernel calls “GPIO”.</p>
<p>Example: a pin is usually muxed in to be used as a UART TX line. But during
system sleep, we need to put this pin into “GPIO mode” and ground it.</p>
<p>If you make a 1-to-1 map to the GPIO subsystem for this pin, you may start
to think that you need to come up with something really complex, that the
pin shall be used for UART TX and GPIO at the same time, that you will grab
a pin control handle and set it to a certain state to enable UART TX to be
muxed in, then twist it over to GPIO mode and use <a class="reference internal" href="gpio/index.html#c.gpiod_direction_output" title="gpiod_direction_output"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_direction_output()</span></code></a>
to drive it low during sleep, then mux it over to UART TX again when you
wake up and maybe even <a class="reference internal" href="gpio/index.html#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a> / <a class="reference internal" href="gpio/index.html#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put()</span></code></a> as part of this cycle. This
all gets very complicated.</p>
<p>The solution is to not think that what the datasheet calls “GPIO mode”
has to be handled by the <code class="docutils literal notranslate"><span class="pre">&lt;linux/gpio/consumer.h&gt;</span></code> interface. Instead view this as
a certain pin config setting. Look in e.g. <code class="docutils literal notranslate"><span class="pre">&lt;linux/pinctrl/pinconf-generic.h&gt;</span></code>
and you find this in the documentation:</p>
<blockquote>
<div><dl class="simple">
<dt>PIN_CONFIG_OUTPUT:</dt><dd><p>this will configure the pin in output, use argument
1 to indicate high level, argument 0 to indicate low level.</p>
</dd>
</dl>
</div></blockquote>
<p>So it is perfectly possible to push a pin into “GPIO mode” and drive the
line low as part of the usual pin control map. So for example your UART
driver may look like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/consumer.h&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl</span><span class="w">          </span><span class="o">*</span><span class="n">pinctrl</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_state</span><span class="w">    </span><span class="o">*</span><span class="n">pins_default</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_state</span><span class="w">    </span><span class="o">*</span><span class="n">pins_sleep</span><span class="p">;</span>

<span class="n">pins_default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_lookup_state</span><span class="p">(</span><span class="n">uap</span><span class="o">-&gt;</span><span class="n">pinctrl</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">);</span>
<span class="n">pins_sleep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_lookup_state</span><span class="p">(</span><span class="n">uap</span><span class="o">-&gt;</span><span class="n">pinctrl</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_SLEEP</span><span class="p">);</span>

<span class="cm">/* Normal mode */</span>
<span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_select_state</span><span class="p">(</span><span class="n">pinctrl</span><span class="p">,</span><span class="w"> </span><span class="n">pins_default</span><span class="p">);</span>

<span class="cm">/* Sleep mode */</span>
<span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_select_state</span><span class="p">(</span><span class="n">pinctrl</span><span class="p">,</span><span class="w"> </span><span class="n">pins_sleep</span><span class="p">);</span>
</pre></div>
</div>
<p>And your machine configuration may look like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">uart_default_mode</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PIN_CONF_PACKED</span><span class="p">(</span><span class="n">PIN_CONFIG_DRIVE_PUSH_PULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">uart_sleep_mode</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PIN_CONF_PACKED</span><span class="p">(</span><span class="n">PIN_CONFIG_OUTPUT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_map</span><span class="w"> </span><span class="n">pinmap</span><span class="p">[]</span><span class="w"> </span><span class="n">__initdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PIN_MAP_MUX_GROUP</span><span class="p">(</span><span class="s">&quot;uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">                          </span><span class="s">&quot;u0_group&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;u0&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">PIN_MAP_CONFIGS_PIN</span><span class="p">(</span><span class="s">&quot;uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">                            </span><span class="s">&quot;UART_TX_PIN&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">uart_default_mode</span><span class="p">),</span>
<span class="w">        </span><span class="n">PIN_MAP_MUX_GROUP</span><span class="p">(</span><span class="s">&quot;uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_SLEEP</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">                          </span><span class="s">&quot;u0_group&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;gpio-mode&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">PIN_MAP_CONFIGS_PIN</span><span class="p">(</span><span class="s">&quot;uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_SLEEP</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">                            </span><span class="s">&quot;UART_TX_PIN&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">uart_sleep_mode</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">foo_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">pinctrl_register_mappings</span><span class="p">(</span><span class="n">pinmap</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pinmap</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here the pins we want to control are in the “u0_group” and there is some
function called “u0” that can be enabled on this group of pins, and then
everything is UART business as usual. But there is also some function
named “gpio-mode” that can be mapped onto the same pins to move them into
GPIO mode.</p>
<p>This will give the desired effect without any bogus interaction with the
GPIO subsystem. It is just an electrical configuration used by that device
when going to sleep, it might imply that the pin is set into something the
datasheet calls “GPIO mode”, but that is not the point: it is still used
by that UART device to control the pins that pertain to that very UART
driver, putting them into modes needed by the UART. GPIO in the Linux
kernel sense are just some 1-bit line, and is a different use case.</p>
<p>How the registers are poked to attain the push or pull, and output low
configuration and the muxing of the “u0” or “gpio-mode” group onto these
pins is a question for the driver.</p>
<p>Some datasheets will be more helpful and refer to the “GPIO mode” as
“low power mode” rather than anything to do with GPIO. This often means
the same thing electrically speaking, but in this latter case the
software engineers will usually quickly identify that this is some
specific muxing or configuration rather than anything related to the GPIO
API.</p>
</section>
<section id="board-machine-configuration">
<h2>Board/machine configuration<a class="headerlink" href="#board-machine-configuration" title="Link to this heading">¶</a></h2>
<p>Boards and machines define how a certain complete running system is put
together, including how GPIOs and devices are muxed, how regulators are
constrained and how the clock tree looks. Of course pinmux settings are also
part of this.</p>
<p>A pin controller configuration for a machine looks pretty much like a simple
regulator configuration, so for the example array above we want to enable i2c
and spi on the second function mapping:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/machine.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_map</span><span class="w"> </span><span class="n">mapping</span><span class="p">[]</span><span class="w"> </span><span class="n">__initconst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-spi.0&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">mux</span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spi0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-i2c.0&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">mux</span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;i2c0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-mmc.0&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">mux</span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The dev_name here matches to the unique device name that can be used to look
up the device struct (just like with clockdev or regulators). The function name
must match a function provided by the pinmux driver handling this pin range.</p>
<p>As you can see we may have several pin controllers on the system and thus
we need to specify which one of them contains the functions we wish to map.</p>
<p>You register this pinmux mapping to the pinmux subsystem by simply:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_register_mappings</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
</pre></div>
</div>
<p>Since the above construct is pretty common there is a helper macro to make
it even more compact which assumes you want to use pinctrl-foo and position
0 for mapping, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_map</span><span class="w"> </span><span class="n">mapping</span><span class="p">[]</span><span class="w"> </span><span class="n">__initdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PIN_MAP_MUX_GROUP</span><span class="p">(</span><span class="s">&quot;foo-i2c.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">                          </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;i2c0&quot;</span><span class="p">),</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The mapping table may also contain pin configuration entries. It’s common for
each pin/group to have a number of configuration entries that affect it, so
the table entries for configuration reference an array of config parameters
and values. An example using the convenience macros is shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">i2c_grp_configs</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">FOO_PIN_DRIVEN</span><span class="p">,</span>
<span class="w">        </span><span class="n">FOO_PIN_PULLUP</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">i2c_pin_configs</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">FOO_OPEN_COLLECTOR</span><span class="p">,</span>
<span class="w">        </span><span class="n">FOO_SLEW_RATE_SLOW</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_map</span><span class="w"> </span><span class="n">mapping</span><span class="p">[]</span><span class="w"> </span><span class="n">__initdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PIN_MAP_MUX_GROUP</span><span class="p">(</span><span class="s">&quot;foo-i2c.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">                          </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;i2c0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;i2c0&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">PIN_MAP_CONFIGS_GROUP</span><span class="p">(</span><span class="s">&quot;foo-i2c.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">                              </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;i2c0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i2c_grp_configs</span><span class="p">),</span>
<span class="w">        </span><span class="n">PIN_MAP_CONFIGS_PIN</span><span class="p">(</span><span class="s">&quot;foo-i2c.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">                            </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;i2c0scl&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i2c_pin_configs</span><span class="p">),</span>
<span class="w">        </span><span class="n">PIN_MAP_CONFIGS_PIN</span><span class="p">(</span><span class="s">&quot;foo-i2c.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">                            </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;i2c0sda&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i2c_pin_configs</span><span class="p">),</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Finally, some devices expect the mapping table to contain certain specific
named states. When running on hardware that doesn’t need any pin controller
configuration, the mapping table must still contain those named states, in
order to explicitly indicate that the states were provided and intended to
be empty. Table entry macro <code class="docutils literal notranslate"><span class="pre">PIN_MAP_DUMMY_STATE()</span></code> serves the purpose of defining
a named state without causing any pin controller to be programmed:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_map</span><span class="w"> </span><span class="n">mapping</span><span class="p">[]</span><span class="w"> </span><span class="n">__initdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PIN_MAP_DUMMY_STATE</span><span class="p">(</span><span class="s">&quot;foo-i2c.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">),</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="complex-mappings">
<h2>Complex mappings<a class="headerlink" href="#complex-mappings" title="Link to this heading">¶</a></h2>
<p>As it is possible to map a function to different groups of pins an optional
.group can be specified like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-spi.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spi0-pos-A&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spi0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spi0_0_grp&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-spi.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spi0-pos-B&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spi0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spi0_1_grp&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This example mapping is used to switch between two positions for spi0 at
runtime, as described further below under the heading <a class="reference internal" href="#runtime-pinmuxing">Runtime pinmuxing</a>.</p>
<p>Further it is possible for one named state to affect the muxing of several
groups of pins, say for example in the mmc0 example above, where you can
additively expand the mmc0 bus from 2 to 4 to 8 pins. If we want to use all
three groups for a total of 2 + 2 + 4 = 8 pins (for an 8-bit MMC bus as is the
case), we define a mapping like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-mmc.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;2bit&quot;</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0_1_grp&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-mmc.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;4bit&quot;</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0_1_grp&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-mmc.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;4bit&quot;</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0_2_grp&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-mmc.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;8bit&quot;</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0_1_grp&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-mmc.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;8bit&quot;</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0_2_grp&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo-mmc.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;8bit&quot;</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mmc0_3_grp&quot;</span><span class="p">,</span>
<span class="p">},</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The result of grabbing this mapping from the device with something like
this (see next paragraph):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_pinctrl_get</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_lookup_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;8bit&quot;</span><span class="p">);</span>
<span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_select_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>or more simply:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_pinctrl_get_select</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;8bit&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Will be that you activate all the three bottom records in the mapping at
once. Since they share the same name, pin controller device, function and
device, and since we allow multiple groups to match to a single device, they
all get selected, and they all get enabled and disable simultaneously by the
pinmux core.</p>
</section>
<section id="pin-control-requests-from-drivers">
<h2>Pin control requests from drivers<a class="headerlink" href="#pin-control-requests-from-drivers" title="Link to this heading">¶</a></h2>
<p>When a device driver is about to probe the device core will automatically
attempt to issue <code class="docutils literal notranslate"><span class="pre">pinctrl_get_select_default()</span></code> on these devices.
This way driver writers do not need to add any of the boilerplate code
of the type found below. However when doing fine-grained state selection
and not using the “default” state, you may have to do some device driver
handling of the pinctrl handles and states.</p>
<p>So if you just want to put the pins for a certain device into the default
state and be done with it, there is nothing you need to do besides
providing the proper mapping table. The device core will take care of
the rest.</p>
<p>Generally it is discouraged to let individual drivers get and enable pin
control. So if possible, handle the pin control in platform code or some other
place where you have access to all the affected <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> * pointers. In
some cases where a driver needs to e.g. switch between different mux mappings
at runtime this is not possible.</p>
<p>A typical case is if a driver needs to switch bias of pins from normal
operation and going to sleep, moving from the <code class="docutils literal notranslate"><span class="pre">PINCTRL_STATE_DEFAULT</span></code> to
<code class="docutils literal notranslate"><span class="pre">PINCTRL_STATE_SLEEP</span></code> at runtime, re-biasing or even re-muxing pins to save
current in sleep mode.</p>
<p>A driver may request a certain control state to be activated, usually just the
default state like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/consumer.h&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">foo_state</span><span class="w"> </span><span class="p">{</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_state</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">};</span>

<span class="n">foo_probe</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* Allocate a state holder named &quot;foo&quot; etc */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">foo_state</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>

<span class="w">        </span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_pinctrl_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* FIXME: clean up &quot;foo&quot; here */</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_lookup_state</span><span class="p">(</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* FIXME: clean up &quot;foo&quot; here */</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_select_state</span><span class="p">(</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="cm">/* FIXME: clean up &quot;foo&quot; here */</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This get/lookup/select/put sequence can just as well be handled by bus drivers
if you don’t want each and every driver to handle it and you know the
arrangement on your bus.</p>
<p>The semantics of the pinctrl APIs are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">pinctrl_get()</span></code> is called in process context to obtain a handle to all pinctrl
information for a given client device. It will allocate a struct from the
kernel memory to hold the pinmux state. All mapping table parsing or similar
slow operations take place within this API.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">devm_pinctrl_get()</span></code> is a variant of pinctrl_get() that causes <code class="docutils literal notranslate"><span class="pre">pinctrl_put()</span></code>
to be called automatically on the retrieved pointer when the associated
device is removed. It is recommended to use this function over plain
<code class="docutils literal notranslate"><span class="pre">pinctrl_get()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinctrl_lookup_state()</span></code> is called in process context to obtain a handle to a
specific state for a client device. This operation may be slow, too.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinctrl_select_state()</span></code> programs pin controller hardware according to the
definition of the state as given by the mapping table. In theory, this is a
fast-path operation, since it only involved blasting some register settings
into hardware. However, note that some pin controllers may have their
registers on a slow/IRQ-based bus, so client devices should not assume they
can call <code class="docutils literal notranslate"><span class="pre">pinctrl_select_state()</span></code> from non-blocking contexts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinctrl_put()</span></code> frees all information associated with a pinctrl handle.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">devm_pinctrl_put()</span></code> is a variant of <code class="docutils literal notranslate"><span class="pre">pinctrl_put()</span></code> that may be used to
explicitly destroy a pinctrl object returned by <code class="docutils literal notranslate"><span class="pre">devm_pinctrl_get()</span></code>.
However, use of this function will be rare, due to the automatic cleanup
that will occur even without calling it.</p>
<p><code class="docutils literal notranslate"><span class="pre">pinctrl_get()</span></code> must be paired with a plain <code class="docutils literal notranslate"><span class="pre">pinctrl_put()</span></code>.
<code class="docutils literal notranslate"><span class="pre">pinctrl_get()</span></code> may not be paired with <code class="docutils literal notranslate"><span class="pre">devm_pinctrl_put()</span></code>.
<code class="docutils literal notranslate"><span class="pre">devm_pinctrl_get()</span></code> can optionally be paired with <code class="docutils literal notranslate"><span class="pre">devm_pinctrl_put()</span></code>.
<code class="docutils literal notranslate"><span class="pre">devm_pinctrl_get()</span></code> may not be paired with plain <code class="docutils literal notranslate"><span class="pre">pinctrl_put()</span></code>.</p>
</li>
</ul>
<p>Usually the pin control core handled the get/put pair and call out to the
device drivers bookkeeping operations, like checking available functions and
the associated pins, whereas <code class="docutils literal notranslate"><span class="pre">pinctrl_select_state()</span></code> pass on to the pin controller
driver which takes care of activating and/or deactivating the mux setting by
quickly poking some registers.</p>
<p>The pins are allocated for your device when you issue the <code class="docutils literal notranslate"><span class="pre">devm_pinctrl_get()</span></code>
call, after this you should be able to see this in the debugfs listing of all
pins.</p>
<p>NOTE: the pinctrl system will return <code class="docutils literal notranslate"><span class="pre">-EPROBE_DEFER</span></code> if it cannot find the
requested pinctrl handles, for example if the pinctrl driver has not yet
registered. Thus make sure that the error path in your driver gracefully
cleans up and is ready to retry the probing later in the startup process.</p>
</section>
<section id="drivers-needing-both-pin-control-and-gpios">
<h2>Drivers needing both pin control and GPIOs<a class="headerlink" href="#drivers-needing-both-pin-control-and-gpios" title="Link to this heading">¶</a></h2>
<p>Again, it is discouraged to let drivers lookup and select pin control states
themselves, but again sometimes this is unavoidable.</p>
<p>So say that your driver is fetching its resources like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/consumer.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/gpio/consumer.h&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl</span><span class="w"> </span><span class="o">*</span><span class="n">pinctrl</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">gpio_desc</span><span class="w"> </span><span class="o">*</span><span class="n">gpio</span><span class="p">;</span>

<span class="n">pinctrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_pinctrl_get_select_default</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
<span class="n">gpio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_gpiod_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we first request a certain pin state and then request GPIO “foo” to be
used. If you’re using the subsystems orthogonally like this, you should
nominally always get your pinctrl handle and select the desired pinctrl
state BEFORE requesting the GPIO. This is a semantic convention to avoid
situations that can be electrically unpleasant, you will certainly want to
mux in and bias pins in a certain way before the GPIO subsystems starts to
deal with them.</p>
<p>The above can be hidden: using the device core, the pinctrl core may be
setting up the config and muxing for the pins right before the device is
probing, nevertheless orthogonal to the GPIO subsystem.</p>
<p>But there are also situations where it makes sense for the GPIO subsystem
to communicate directly with the pinctrl subsystem, using the latter as a
back-end. This is when the GPIO driver may call out to the functions
described in the section <a class="reference internal" href="#pin-control-interaction-with-the-gpio-subsystem">Pin control interaction with the GPIO subsystem</a>
above. This only involves per-pin multiplexing, and will be completely
hidden behind the gpiod_*() function namespace. In this case, the driver
need not interact with the pin control subsystem at all.</p>
<p>If a pin control driver and a GPIO driver is dealing with the same pins
and the use cases involve multiplexing, you MUST implement the pin controller
as a back-end for the GPIO driver like this, unless your hardware design
is such that the GPIO controller can override the pin controller’s
multiplexing state through hardware without the need to interact with the
pin control system.</p>
</section>
<section id="system-pin-control-hogging">
<h2>System pin control hogging<a class="headerlink" href="#system-pin-control-hogging" title="Link to this heading">¶</a></h2>
<p>Pin control map entries can be hogged by the core when the pin controller
is registered. This means that the core will attempt to call <code class="docutils literal notranslate"><span class="pre">pinctrl_get()</span></code>,
<code class="docutils literal notranslate"><span class="pre">pinctrl_lookup_state()</span></code> and <code class="docutils literal notranslate"><span class="pre">pinctrl_select_state()</span></code> on it immediately after
the pin control device has been registered.</p>
<p>This occurs for mapping table entries where the client device name is equal
to the pin controller device name, and the state name is <code class="docutils literal notranslate"><span class="pre">PINCTRL_STATE_DEFAULT</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PINCTRL_STATE_DEFAULT</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PIN_MAP_TYPE_MUX_GROUP</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">ctrl_dev_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;power_func&quot;</span><span class="p">,</span>
<span class="p">},</span>
</pre></div>
</div>
<p>Since it may be common to request the core to hog a few always-applicable
mux settings on the primary pin controller, there is a convenience macro for
this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PIN_MAP_MUX_GROUP_HOG_DEFAULT</span><span class="p">(</span><span class="s">&quot;pinctrl-foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="cm">/* group */</span><span class="p">,</span>
<span class="w">                              </span><span class="s">&quot;power_func&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This gives the exact same result as the above construction.</p>
</section>
<section id="runtime-pinmuxing">
<h2>Runtime pinmuxing<a class="headerlink" href="#runtime-pinmuxing" title="Link to this heading">¶</a></h2>
<p>It is possible to mux a certain function in and out at runtime, say to move
an SPI port from one set of pins to another set of pins. Say for example for
spi0 in the example above, we expose two different groups of pins for the same
function, but with different named in the mapping as described under
“Advanced mapping” above. So that for an SPI device, we have two states named
“pos-A” and “pos-B”.</p>
<p>This snippet first initializes a state object for both groups (in foo_probe()),
then muxes the function in the pins defined by group A, and finally muxes it in
on the pins defined by group B:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/pinctrl/consumer.h&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pinctrl_state</span><span class="w"> </span><span class="o">*</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">s2</span><span class="p">;</span>

<span class="n">foo_probe</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* Setup */</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_pinctrl_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="w">                </span><span class="p">...</span>

<span class="w">        </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_lookup_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pos-A&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span>
<span class="w">                </span><span class="p">...</span>

<span class="w">        </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_lookup_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pos-B&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
<span class="w">                </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">foo_switch</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* Enable on position A */</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_select_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="p">...</span>

<span class="w">        </span><span class="p">...</span>

<span class="w">        </span><span class="cm">/* Enable on position B */</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pinctrl_select_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="p">...</span>

<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above has to be done from process context. The reservation of the pins
will be done when the state is activated, so in effect one specific pin
can be used by different functions at different times on a running system.</p>
</section>
<section id="debugfs-files">
<h2>Debugfs files<a class="headerlink" href="#debugfs-files" title="Link to this heading">¶</a></h2>
<p>These files are created in <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/pinctrl</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pinctrl-devices</span></code>: prints each pin controller device along with columns to
indicate support for pinmux and pinconf</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinctrl-handles</span></code>: prints each configured pin controller handle and the
corresponding pinmux maps</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinctrl-maps</span></code>: prints all pinctrl maps</p></li>
</ul>
<p>A sub-directory is created inside of <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/pinctrl</span></code> for each pin
controller device containing these files:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">pins</span></code>: prints a line for each pin registered on the pin controller. The
pinctrl driver may add additional information such as register contents.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gpio-ranges</span></code>: prints ranges that map gpio lines to pins on the controller</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pingroups</span></code>: prints all pin groups registered on the pin controller</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinconf-pins</span></code>: prints pin config settings for each pin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinconf-groups</span></code>: prints pin config settings per pin group</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinmux-functions</span></code>: prints each pin function along with the pin groups that
map to the pin function</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinmux-pins</span></code>: iterates through all pins and prints mux owner, gpio owner
and if the pin is a hog</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinmux-select</span></code>: write to this file to activate a pin function for a group:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;&lt;group-name function-name&gt;&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>pinmux-select
</pre></div>
</div>
</li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/pin-control.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>