<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SCSI Interfaces Guide &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Support for Serial devices" href="serial/index.html" />
    <link rel="prev" title="Writing s390 channel device drivers" href="s390-drivers.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="coco/index.html">Confidential Computing</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="extcon.html">Extcon Device Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/scsi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="scsi-interfaces-guide">
<h1>SCSI Interfaces Guide<a class="headerlink" href="#scsi-interfaces-guide" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>James Bottomley</p>
</dd>
<dt class="field-even">Author<span class="colon">:</span></dt>
<dd class="field-even"><p>Rob Landley</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<section id="protocol-vs-bus">
<h3>Protocol vs bus<a class="headerlink" href="#protocol-vs-bus" title="Link to this heading">¶</a></h3>
<p>Once upon a time, the Small Computer Systems Interface defined both a
parallel I/O bus and a data protocol to connect a wide variety of
peripherals (disk drives, tape drives, modems, printers, scanners,
optical drives, test equipment, and medical devices) to a host computer.</p>
<p>Although the old parallel (fast/wide/ultra) SCSI bus has largely fallen
out of use, the SCSI command set is more widely used than ever to
communicate with devices over a number of different busses.</p>
<p>The <a class="reference external" href="https://www.t10.org/scsi-3.htm">SCSI protocol</a> is a big-endian
peer-to-peer packet based protocol. SCSI commands are 6, 10, 12, or 16
bytes long, often followed by an associated data payload.</p>
<p>SCSI commands can be transported over just about any kind of bus, and
are the default protocol for storage devices attached to USB, SATA, SAS,
Fibre Channel, FireWire, and ATAPI devices. SCSI packets are also
commonly exchanged over Infiniband,
TCP/IP (<a class="reference external" href="https://en.wikipedia.org/wiki/ISCSI">iSCSI</a>), even <a class="reference external" href="http://cyberelk.net/tim/parport/parscsi.html">Parallel
ports</a>.</p>
</section>
<section id="design-of-the-linux-scsi-subsystem">
<h3>Design of the Linux SCSI subsystem<a class="headerlink" href="#design-of-the-linux-scsi-subsystem" title="Link to this heading">¶</a></h3>
<p>The SCSI subsystem uses a three layer design, with upper, mid, and low
layers. Every operation involving the SCSI subsystem (such as reading a
sector from a disk) uses one driver at each of the 3 levels: one upper
layer driver, one lower layer driver, and the SCSI midlayer.</p>
<p>The SCSI upper layer provides the interface between userspace and the
kernel, in the form of block and char device nodes for I/O and ioctl().
The SCSI lower layer contains drivers for specific hardware devices.</p>
<p>In between is the SCSI mid-layer, analogous to a network routing layer
such as the IPv4 stack. The SCSI mid-layer routes a packet based data
protocol between the upper layer’s /dev nodes and the corresponding
devices in the lower layer. It manages command queues, provides error
handling and power management functions, and responds to ioctl()
requests.</p>
</section>
</section>
<section id="scsi-upper-layer">
<h2>SCSI upper layer<a class="headerlink" href="#scsi-upper-layer" title="Link to this heading">¶</a></h2>
<p>The upper layer supports the user-kernel interface by providing device
nodes.</p>
<section id="sd-scsi-disk">
<h3>sd (SCSI Disk)<a class="headerlink" href="#sd-scsi-disk" title="Link to this heading">¶</a></h3>
<p>sd (sd_mod.o)</p>
</section>
<section id="sr-scsi-cd-rom">
<h3>sr (SCSI CD-ROM)<a class="headerlink" href="#sr-scsi-cd-rom" title="Link to this heading">¶</a></h3>
<p>sr (sr_mod.o)</p>
</section>
<section id="st-scsi-tape">
<h3>st (SCSI Tape)<a class="headerlink" href="#st-scsi-tape" title="Link to this heading">¶</a></h3>
<p>st (st.o)</p>
</section>
<section id="sg-scsi-generic">
<h3>sg (SCSI Generic)<a class="headerlink" href="#sg-scsi-generic" title="Link to this heading">¶</a></h3>
<p>sg (sg.o)</p>
</section>
<section id="ch-scsi-media-changer">
<h3>ch (SCSI Media Changer)<a class="headerlink" href="#ch-scsi-media-changer" title="Link to this heading">¶</a></h3>
<p>ch (ch.c)</p>
</section>
</section>
<section id="scsi-mid-layer">
<h2>SCSI mid layer<a class="headerlink" href="#scsi-mid-layer" title="Link to this heading">¶</a></h2>
<section id="scsi-midlayer-implementation">
<h3>SCSI midlayer implementation<a class="headerlink" href="#scsi-midlayer-implementation" title="Link to this heading">¶</a></h3>
<section id="include-scsi-scsi-device-h">
<h4>include/scsi/scsi_device.h<a class="headerlink" href="#include-scsi-scsi-device-h" title="Link to this heading">¶</a></h4>
<dl class="c struct">
<dt class="sig sig-object c" id="c.scsi_vpd">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_vpd</span></span></span><a class="headerlink" href="#c.scsi_vpd" title="Link to this definition">¶</a><br /></dt>
<dd><p>SCSI Vital Product Data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct scsi_vpd {
    struct rcu_head rcu;
    int len;
    unsigned char   data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt><dd><p>For <a class="reference internal" href="../core-api/kernel-api.html#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>Length in bytes of <strong>data</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>VPD data as defined in various T10 SCSI standard documents.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.shost_for_each_device">
<span class="sig-name descname"><span class="n"><span class="pre">shost_for_each_device</span></span></span><a class="headerlink" href="#c.shost_for_each_device" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">shost_for_each_device</span> <span class="pre">(sdev,</span> <span class="pre">shost)</span></code></p>
<blockquote>
<div><p>iterate over all devices of a host</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to use as a cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shost</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host</span></code> to iterate over</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterator that returns each device attached to <strong>shost</strong>.  This loop
takes a reference on each device and releases it at the end.  If
you break out of the loop, you must call scsi_device_put(sdev).</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.__shost_for_each_device">
<span class="sig-name descname"><span class="n"><span class="pre">__shost_for_each_device</span></span></span><a class="headerlink" href="#c.__shost_for_each_device" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">__shost_for_each_device</span> <span class="pre">(sdev,</span> <span class="pre">shost)</span></code></p>
<blockquote>
<div><p>iterate over all devices of a host (UNLOCKED)</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to use as a cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shost</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host</span></code> to iterate over</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterator that returns each device attached to <strong>shost</strong>.  It does _not_
take a reference on the scsi_device, so the whole loop must be
protected by shost-&gt;host_lock.</p>
<p><strong>Note</strong></p>
<p>The only reason to use this is because you need to access the
device list in interrupt context.  Otherwise you really want to use
shost_for_each_device instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_supports_vpd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_supports_vpd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_supports_vpd" title="Link to this definition">¶</a><br /></dt>
<dd><p>test if a device supports VPD pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the ‘try_vpd_pages’ flag is set it takes precedence.
Otherwise we will assume VPD pages are supported if the
SCSI level is at least SPC-3 and ‘skip_vpd_pages’ is not set.</p>
</div>
</section>
<section id="drivers-scsi-scsi-c">
<h4>drivers/scsi/scsi.c<a class="headerlink" href="#drivers-scsi-scsi-c" title="Link to this heading">¶</a></h4>
<p>Main file for the SCSI midlayer.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_change_queue_depth">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_change_queue_depth</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">depth</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_change_queue_depth" title="Link to this definition">¶</a><br /></dt>
<dd><p>change a device’s queue depth</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI Device in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>number of commands allowed to be queued to the driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the device queue depth and returns the new value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_track_queue_full">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_track_queue_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">depth</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_track_queue_full" title="Link to this definition">¶</a><br /></dt>
<dd><p>track QUEUE_FULL events to adjust queue depth</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI Device in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>Current number of outstanding SCSI commands on this device,
not counting the one returned as QUEUE_FULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>This function will track successive QUEUE_FULL events on a</dt><dd><p>specific SCSI device to determine if and when there is a
need to adjust the queue depth on the device.</p>
</dd>
</dl>
<p>Lock Status: None held on entry</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 - No change needed, &gt;0 - Adjust queue depth to this new depth,</dt><dd><dl class="simple">
<dt>-1 - Drop back to untagged operation using host-&gt;cmd_per_lun</dt><dd><p>as the untagged command depth</p>
</dd>
</dl>
</dd>
</dl>
<p><strong>Notes</strong></p>
<dl class="simple">
<dt>Low level drivers may call this at any time and we will do</dt><dd><p>“The Right Thing.”  We are interrupt context safe.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_get_vpd_page">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_get_vpd_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">buf_len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_vpd_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get Vital Product Data from a SCSI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>The device to ask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">page</span></code></dt><dd><p>Which Vital Product Data to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>where to store the VPD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>number of bytes in the VPD buffer area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>SCSI devices may optionally supply Vital Product Data.  Each ‘page’
of VPD is defined in the appropriate SCSI document (eg SPC, SBC).
If the device supports this VPD page, this routine fills <strong>buf</strong>
with the data from that page and return 0. If the VPD page is not
supported or its content cannot be retrieved, -EINVAL is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_report_opcode">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_report_opcode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">opcode</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">short</span></span><span class="w"> </span><span class="n"><span class="pre">sa</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_report_opcode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find out if a given command is supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>scratch buffer (must be at least 20 bytes long)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">opcode</span></code></dt><dd><p>opcode for the command to look up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">sa</span></code></dt><dd><p>service action for the command to look up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses the REPORT SUPPORTED OPERATION CODES to check support for the
command identified with <strong>opcode</strong> and <strong>sa</strong>. If the command does not
have a service action, <strong>sa</strong> must be 0. Returns -EINVAL if RSOC fails,
0 if the command is not supported and 1 if the device claims to
support the command.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_get">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an additional reference to a scsi_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>device to get a reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets a reference to the scsi_device and increments the use count
of the underlying LLDD module.  You must hold host_lock of the
parent Scsi_Host or already have a reference when calling this.</p>
<p>This will fail if a device is deleted or cancelled, or when the LLD module
is in the process of being unloaded.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a reference to a scsi_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>device to release a reference on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a reference to the scsi_device and decrements the use
count of the underlying LLDD module.  The device is freed once the last
user vanishes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.starget_for_each_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">starget_for_each_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_target</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">starget</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.starget_for_each_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to walk all devices of a target</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>target whose devices we want to iterate over.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Opaque passed to each function call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*fn)(struct</span> <span class="pre">scsi_device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to call on each device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This traverses over each device of <strong>starget</strong>.  The devices have
a reference that must be released by scsi_host_put when breaking
out of the loop.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__starget_for_each_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__starget_for_each_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_target</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">starget</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__starget_for_each_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to walk all devices of a target (UNLOCKED)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>target whose devices we want to iterate over.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>parameter for callback <strong>fn()</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*fn)(struct</span> <span class="pre">scsi_device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback function that is invoked for each device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This traverses over each device of <strong>starget</strong>.  It does _not_
take a reference on the scsi_device, so the whole loop must be
protected by shost-&gt;host_lock.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers would want to use this is because
they need to access the device list in irq context.  Otherwise you
really want to use starget_for_each_device instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__scsi_device_lookup_by_target">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__scsi_device_lookup_by_target</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_target</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">starget</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__scsi_device_lookup_by_target" title="Link to this definition">¶</a><br /></dt>
<dd><p>find a device given the target (UNLOCKED)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>SCSI target pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>lun</strong> for a given
<strong>starget</strong>.  The returned scsi_device does not have an additional
reference.  You must hold the host’s host_lock over this call and
any access to the returned scsi_device. A scsi_device in state
SDEV_DEL is skipped.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers should use this is because
they need to access the device list in irq context.  Otherwise you
really want to use scsi_device_lookup_by_target instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_lookup_by_target">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_lookup_by_target</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_target</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">starget</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_lookup_by_target" title="Link to this definition">¶</a><br /></dt>
<dd><p>find a device given the target</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>SCSI target pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>lun</strong> for a given
<strong>starget</strong>.  The returned scsi_device has an additional reference that
needs to be released with scsi_device_put once you’re done with it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__scsi_device_lookup">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__scsi_device_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__scsi_device_lookup" title="Link to this definition">¶</a><br /></dt>
<dd><p>find a device given the host (UNLOCKED)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>SCSI host pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>SCSI channel (zero if only one channel)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>SCSI target number (physical unit number)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>channel</strong>, <strong>id</strong>, <strong>lun</strong>
for a given host. The returned scsi_device does not have an additional
reference.  You must hold the host’s host_lock over this call and any access
to the returned scsi_device.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers would want to use this is because
they need to access the device list in irq context.  Otherwise you
really want to use scsi_device_lookup instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_lookup">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_lookup" title="Link to this definition">¶</a><br /></dt>
<dd><p>find a device given the host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>SCSI host pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>SCSI channel (zero if only one channel)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>SCSI target number (physical unit number)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>channel</strong>, <strong>id</strong>, <strong>lun</strong>
for a given host.  The returned scsi_device has an additional reference that
needs to be released with scsi_device_put once you’re done with it.</p>
</div>
</section>
<section id="drivers-scsi-scsicam-c">
<h4>drivers/scsi/scsicam.c<a class="headerlink" href="#drivers-scsi-scsicam-c" title="Link to this heading">¶</a></h4>
<p><a class="reference external" href="http://www.t10.org/ftp/t10/drafts/cam/cam-r12b.pdf">SCSI Common Access
Method</a> support
functions, for use with HDIO_GETGEO, etc.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_bios_ptable">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_bios_ptable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_bios_ptable" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read PC partition table out of first sector of device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*dev</span></code></dt><dd><p>from this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Reads the first sector from the device and returns <code class="docutils literal notranslate"><span class="pre">0x42</span></code> bytes</dt><dd><p>starting at offset <code class="docutils literal notranslate"><span class="pre">0x1be</span></code>.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>partition table in kmalloc(GFP_KERNEL) memory, or NULL on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_partsize">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_partsize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">capacity</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">geom</span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_partsize" title="Link to this definition">¶</a><br /></dt>
<dd><p>Parse cylinders/heads/sectors from PC partition table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block device to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">capacity</span></code></dt><dd><p>size of the disk in sectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">geom[3]</span></code></dt><dd><p>output in form of [hds, cylinders, sectors]</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the BIOS mapping/geometry used to create the partition
table, storing the results in <strong>geom</strong>.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> on failure, <code class="docutils literal notranslate"><span class="pre">true</span></code> on success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsicam_bios_param">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsicam_bios_param</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">capacity</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ip</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsicam_bios_param" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determine geometry of a disk in cylinders/heads/sectors.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>which device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">capacity</span></code></dt><dd><p>size of the disk in sectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*ip</span></code></dt><dd><p>return value: ip[0]=heads, ip[1]=sectors, ip[2]=cylinders</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>determine the BIOS mapping/geometry used for a drive in a</dt><dd><p>SCSI-CAM system, storing the results in ip as required
by the HDIO_GETGEO ioctl().</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-1 on failure, 0 on success.</p>
</div>
</section>
<section id="drivers-scsi-scsi-error-c">
<h4>drivers/scsi/scsi_error.c<a class="headerlink" href="#drivers-scsi-scsi-error-c" title="Link to this heading">¶</a></h4>
<p>Common SCSI error/timeout handling routines.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_schedule_eh">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_schedule_eh</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_schedule_eh" title="Link to this definition">¶</a><br /></dt>
<dd><p>schedule EH for SCSI host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>SCSI host to invoke error handling on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule SCSI EH without scmd.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_block_when_processing_errors">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_block_when_processing_errors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_block_when_processing_errors" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prevent cmds from being queued.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>Device on which we are performing recovery.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>We block until the host is out of error recovery, and then check to
see whether the host or the device is offline.</p>
</div></blockquote>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 when dev was taken offline by error recovery. 1 OK to proceed.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_check_sense">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_disposition</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_check_sense</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_check_sense" title="Link to this definition">¶</a><br /></dt>
<dd><p>Examine scsi cmd sense</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>Cmd to have sense checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>SUCCESS or FAILED or NEEDS_RETRY or ADD_TO_MLQUEUE</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>When a deferred error is detected the current command has
not been executed and needs retrying.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_eh_prep_cmnd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_eh_prep_cmnd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scmd</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_eh_save</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ses</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmnd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmnd_size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">sense_bytes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_prep_cmnd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Save a scsi command info as part of error recovery</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>SCSI command structure to hijack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_eh_save</span> <span class="pre">*ses</span></code></dt><dd><p>structure to save restore information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*cmnd</span></code></dt><dd><p>CDB to send. Can be NULL if no new cmnd is needed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmnd_size</span></code></dt><dd><p>size in bytes of <strong>cmnd</strong> (must be &lt;= MAX_COMMAND_SIZE)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">sense_bytes</span></code></dt><dd><p>size of sense data to copy. or 0 (if != 0 <strong>cmnd</strong> is ignored)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to save a scsi command information before re-execution
as part of the error recovery process.  If <strong>sense_bytes</strong> is 0 the command
sent must be one that does not transfer any data.  If <strong>sense_bytes</strong> != 0
<strong>cmnd</strong> is ignored and this functions sets up a REQUEST_SENSE command
and cmnd buffers to read <strong>sense_bytes</strong> into <strong>scmd-&gt;sense_buffer</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_eh_restore_cmnd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_eh_restore_cmnd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scmd</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_eh_save</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ses</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_restore_cmnd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Restore a scsi command info as part of error recovery</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd*</span> <span class="pre">scmd</span></code></dt><dd><p>SCSI command structure to restore</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_eh_save</span> <span class="pre">*ses</span></code></dt><dd><p>saved information from a coresponding call to scsi_eh_prep_cmnd</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo any damage done by above <a class="reference internal" href="#c.scsi_eh_prep_cmnd" title="scsi_eh_prep_cmnd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_prep_cmnd()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_eh_finish_cmd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_eh_finish_cmd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scmd</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">done_q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_finish_cmd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Handle a cmd that eh is finished with.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>Original SCSI cmd that eh has finished.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*done_q</span></code></dt><dd><p>Queue for processed commands.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>We don’t want to use the normal command completion while we are are
still handling errors - it may cause other commands to be queued,
and that would disturb what we are doing.  Thus we really want to
keep a list of pending commands for final completion, and once we
are ready to leave error handling we handle completion for real.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_eh_get_sense">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_eh_get_sense</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work_q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">done_q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_get_sense" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get device sense data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*work_q</span></code></dt><dd><p>Queue of commands to process.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*done_q</span></code></dt><dd><p>Queue of processed commands.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>See if we need to request sense information.  if so, then get it
now, so we have a better idea of what to do.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This has the unfortunate side effect that if a shost adapter does
not automatically request sense information, we end up shutting
it down before we request it.</p>
<p>All drivers should request sense information internally these days,
so for now all I have to say is tough noogies if you end up in here.</p>
<dl class="simple">
<dt>XXX: Long term this code should go away, but that needs an audit of</dt><dd><p>all LLDDs first.</p>
</dd>
</dl>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_eh_ready_devs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_eh_ready_devs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work_q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">done_q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_ready_devs" title="Link to this definition">¶</a><br /></dt>
<dd><p>check device ready state and recover if not.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host to be recovered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*work_q</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> for pending commands.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*done_q</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> for processed commands.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_eh_flush_done_q">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_eh_flush_done_q</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">done_q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_flush_done_q" title="Link to this definition">¶</a><br /></dt>
<dd><p>finish processed commands or retry them.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*done_q</span></code></dt><dd><p>list_head of processed commands.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_report_bus_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_report_bus_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_report_bus_reset" title="Link to this definition">¶</a><br /></dt>
<dd><p>report bus reset observed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Host in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>channel on which reset was observed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Utility function used by low-level drivers to report that
they have observed a bus reset on the bus being handled.</p>
<p>Lock status: Host lock must be held.</p>
<p><strong>Return</strong></p>
<p>Nothing</p>
<p><strong>Notes</strong></p>
<dl>
<dt>This only needs to be called if the reset is one which</dt><dd><p>originates from an unknown location.  Resets originated
by the mid-level itself don’t need to call this, but there
should be no harm.</p>
<p>The main purpose of this is to make sure that a CHECK_CONDITION
is properly treated.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_report_device_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_report_device_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">target</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_report_device_reset" title="Link to this definition">¶</a><br /></dt>
<dd><p>report device reset observed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Host in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>channel on which reset was observed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">target</span></code></dt><dd><p>target on which reset was observed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Utility function used by low-level drivers to report that
they have observed a device reset on the device being handled.</p>
<p>Lock status: Host lock must be held</p>
<p><strong>Return</strong></p>
<p>Nothing</p>
<p><strong>Notes</strong></p>
<dl>
<dt>This only needs to be called if the reset is one which</dt><dd><p>originates from an unknown location.  Resets originated
by the mid-level itself don’t need to call this, but there
should be no harm.</p>
<p>The main purpose of this is to make sure that a CHECK_CONDITION
is properly treated.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_get_sense_info_fld">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_get_sense_info_fld</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sense_buffer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sb_len</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info_out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_sense_info_fld" title="Link to this definition">¶</a><br /></dt>
<dd><p>get information field from sense data (either fixed or descriptor format)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*sense_buffer</span></code></dt><dd><p>byte array of sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*info_out</span></code></dt><dd><p>pointer to 64 integer where 8 or 4 byte information
field will be placed if found.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>true if information field found, false if not found.</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-devinfo-c">
<h4>drivers/scsi/scsi_devinfo.c<a class="headerlink" href="#drivers-scsi-scsi-devinfo-c" title="Link to this heading">¶</a></h4>
<p>Manage scsi_dev_info_list, which tracks blacklisted and whitelisted
devices.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_dev_info_list_add_keyed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_dev_info_list_add_keyed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">compatible</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vendor</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">model</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">strflags</span></span>, <span class="n"><span class="pre">blist_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_devinfo_key</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_list_add_keyed" title="Link to this definition">¶</a><br /></dt>
<dd><p>add one dev_info list entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">compatible</span></code></dt><dd><p>if true, null terminate short strings.  Otherwise space pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*vendor</span></code></dt><dd><p>vendor string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*model</span></code></dt><dd><p>model (product) string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*strflags</span></code></dt><dd><p>integer string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>if strflags NULL, use this flag value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_devinfo_key</span> <span class="pre">key</span></code></dt><dd><p>specify list to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Create and add one dev_info entry for <strong>vendor</strong>, <strong>model</strong>,
<strong>strflags</strong> or <strong>flag</strong> in list specified by <strong>key</strong>. If <strong>compatible</strong>,
add to the tail of the list, do not space pad, and set
devinfo-&gt;compatible. The scsi_static_device_list entries are
added with <strong>compatible</strong> 1 and <strong>clfags</strong> NULL.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>0 OK, -error on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_get_device_flags_keyed">
<span class="n"><span class="pre">blist_flags_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_get_device_flags_keyed</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vendor</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">model</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_devinfo_key</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_device_flags_keyed" title="Link to this definition">¶</a><br /></dt>
<dd><p>get device specific flags from the dynamic device list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">scsi_device</span></code> to get flags for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*vendor</span></code></dt><dd><p>vendor name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*model</span></code></dt><dd><p>model name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_devinfo_key</span> <span class="pre">key</span></code></dt><dd><p>list to look up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search the scsi_dev_info_list specified by <strong>key</strong> for an entry
matching <strong>vendor</strong> and <strong>model</strong>, if found, return the matching
flags value, else return the host or global default settings.
Called during scan time.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_dev_info_add_list">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_dev_info_add_list</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_devinfo_key</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_add_list" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a new devinfo list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_devinfo_key</span> <span class="pre">key</span></code></dt><dd><p>key of the list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the list to add (for /proc/scsi/device_info)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the requested list, returns zero on success, -EEXIST if the
key is already registered to a list, or other error on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_dev_info_remove_list">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_dev_info_remove_list</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_devinfo_key</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_remove_list" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroy an added devinfo list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_devinfo_key</span> <span class="pre">key</span></code></dt><dd><p>key of the list to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates over the entire list first, freeing all the values, then
frees the list itself.  Returns 0 on success or -EINVAL if the key
can’t be found.</p>
</div>
</section>
<section id="drivers-scsi-scsi-ioctl-c">
<h4>drivers/scsi/scsi_ioctl.c<a class="headerlink" href="#drivers-scsi-scsi-ioctl-c" title="Link to this heading">¶</a></h4>
<p>Handle ioctl() calls for SCSI devices.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_set_medium_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_set_medium_removal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_set_medium_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>send command to allow or prevent medium removal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>target scsi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">state</span></code></dt><dd><p>removal state to set (prevent or allow)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> if <strong>sdev</strong> is not removable or not lockable or successful.</p></li>
<li><p>non-<code class="docutils literal notranslate"><span class="pre">0</span></code> is a SCSI result code if &gt; 0 or kernel error code if &lt; 0.</p></li>
<li><p>Sets <strong>sdev-&gt;locked</strong> to the new state on success.</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_cmd_allowed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_cmd_allowed</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmd</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">open_for_write</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_cmd_allowed" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check if the given command is allowed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*cmd</span></code></dt><dd><p>SCSI command to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">open_for_write</span></code></dt><dd><p>is the file / block device opened for writing?</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only a subset of commands are allowed for unprivileged users. Commands used
to format the media, update the firmware, etc. are not permitted.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the cmd is allowed, otherwise <strong>false</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_ioctl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_ioctl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">open_for_write</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_ioctl" title="Link to this definition">¶</a><br /></dt>
<dd><p>Dispatch ioctl to scsi device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device receiving ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">open_for_write</span></code></dt><dd><p>is the file / block device opened for writing?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>which ioctl is it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>data associated with ioctl</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.scsi_ioctl" title="scsi_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_ioctl()</span></code></a> function differs from most ioctls in that it
does not take a major/minor number as the dev field.  Rather, it takes
a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code>.</p>
<p><strong>Return</strong></p>
<p>varies depending on the <strong>cmd</strong></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_ioctl_block_when_processing_errors">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_ioctl_block_when_processing_errors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">ndelay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_ioctl_block_when_processing_errors" title="Link to this definition">¶</a><br /></dt>
<dd><p>prevent commands from being queued</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>target scsi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>which ioctl is it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ndelay</span></code></dt><dd><p>no delay (non-blocking)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We can process a reset even when a device isn’t fully operable.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, &lt;0 error code.</p>
</div>
</section>
<section id="drivers-scsi-scsi-lib-c">
<h4>drivers/scsi/scsi_lib.c<a class="headerlink" href="#drivers-scsi-scsi-lib-c" title="Link to this heading">¶</a></h4>
<p>SCSI queuing library.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_failures_reset_retries">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_failures_reset_retries</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_failures</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">failures</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_failures_reset_retries" title="Link to this definition">¶</a><br /></dt>
<dd><p>reset all failures to zero</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_failures</span> <span class="pre">*failures</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_failures</span></code> with specific failure modes set</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_execute_cmd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_execute_cmd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmd</span></span>, <span class="n"><span class="pre">blk_opf_t</span></span><span class="w"> </span><span class="n"><span class="pre">opf</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bufflen</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ml_retries</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_exec_args</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_execute_cmd" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert request and wait for the result</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*cmd</span></code></dt><dd><p>scsi command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">opf</span></code></dt><dd><p>block layer request cmd_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bufflen</span></code></dt><dd><p>len of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>request timeout in HZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ml_retries</span></code></dt><dd><p>number of times SCSI midlayer will retry request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">scsi_exec_args</span> <span class="pre">*args</span></code></dt><dd><p>Optional args. See struct definition for field descriptions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the scsi_cmnd result field if a command was executed, or a negative
Linux error code if we didn’t get that far.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_alloc_sgtables">
<span class="n"><span class="pre">blk_status_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_alloc_sgtables</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_alloc_sgtables" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate and initialize data and integrity scatterlists</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>SCSI command data structure to initialize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes <strong>cmd-&gt;sdb</strong> and also <strong>cmd-&gt;prot_sdb</strong> if data integrity is enabled
for <strong>cmd</strong>.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>BLK_STS_OK       - on success</p></li>
<li><p>BLK_STS_RESOURCE - if the failure is retryable</p></li>
<li><p>BLK_STS_IOERR    - if the failure is fatal</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_alloc_request">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_alloc_request</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">blk_opf_t</span></span><span class="w"> </span><span class="n"><span class="pre">opf</span></span>, <span class="n"><span class="pre">blk_mq_req_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_alloc_request" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a block request and partially initialize its <code class="xref c c-type docutils literal notranslate"><span class="pre">scsi_cmnd</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the device’s request queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">opf</span></code></dt><dd><p>the request operation code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_mq_req_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>block layer allocation flags</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span></code> pointer on success or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_from_queue">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_from_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_from_queue" title="Link to this definition">¶</a><br /></dt>
<dd><p>return sdev associated with a request_queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>The request queue to return the sdev from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the sdev associated with a request queue or NULL if the
request_queue does not reference a SCSI device.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_block_requests">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_block_requests</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_block_requests" title="Link to this definition">¶</a><br /></dt>
<dd><p>Utility function used by low-level drivers to prevent further commands from being queued to the device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There is no timer nor any other means by which the requests get unblocked
other than the low-level driver calling <a class="reference internal" href="#c.scsi_unblock_requests" title="scsi_unblock_requests"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_unblock_requests()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_unblock_requests">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_unblock_requests</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_unblock_requests" title="Link to this definition">¶</a><br /></dt>
<dd><p>Utility function used by low-level drivers to allow further commands to be queued to the device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There is no timer nor any other means by which the requests get unblocked
other than the low-level driver calling <a class="reference internal" href="#c.scsi_unblock_requests" title="scsi_unblock_requests"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_unblock_requests()</span></code></a>. This is done
as an API function so that changes to the internals of the scsi mid-layer
won’t require wholesale changes to drivers that use this feature.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_mode_select">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_mode_select</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">pf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">retries</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_mode_data</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_sense_hdr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sshdr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_mode_select" title="Link to this definition">¶</a><br /></dt>
<dd><p>issue a mode select</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI device to be queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pf</span></code></dt><dd><p>Page format bit (1 == standard, 0 == vendor specific)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sp</span></code></dt><dd><p>Save page bit (0 == don’t save, 1 == save)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>request buffer (may not be smaller than eight bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of request buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_mode_data</span> <span class="pre">*data</span></code></dt><dd><p>returns a structure abstracting the mode header data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>place to put sense data (or NULL if no sense to be collected).
must be SCSI_SENSE_BUFFERSIZE big.</p>
<p>Returns zero if successful; negative error number or scsi
status on error</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_mode_sense">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_mode_sense</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dbd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">modepage</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">subpage</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">retries</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_mode_data</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_sense_hdr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sshdr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_mode_sense" title="Link to this definition">¶</a><br /></dt>
<dd><p>issue a mode sense, falling back from 10 to six bytes if necessary.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI device to be queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dbd</span></code></dt><dd><p>set to prevent mode sense from returning block descriptors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">modepage</span></code></dt><dd><p>mode page being requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">subpage</span></code></dt><dd><p>sub-page of the mode page being requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>request buffer (may not be smaller than eight bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of request buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_mode_data</span> <span class="pre">*data</span></code></dt><dd><p>returns a structure abstracting the mode header data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>place to put sense data (or NULL if no sense to be collected).
must be SCSI_SENSE_BUFFERSIZE big.</p>
<p>Returns zero if successful, or a negative error number on failure</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_test_unit_ready">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_test_unit_ready</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">retries</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_sense_hdr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sshdr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_test_unit_ready" title="Link to this definition">¶</a><br /></dt>
<dd><p>test if unit is ready</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to change the state of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>outpout pointer for decoded sense information.</p>
<p>Returns zero if unsuccessful or an error if TUR failed.  For
removable media, UNIT_ATTENTION sets -&gt;changed flag.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_set_state">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_set_state</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device_state</span></span><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_set_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>Take the given device through the device state model.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to change the state of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_state</span> <span class="pre">state</span></code></dt><dd><p>state to change to.</p>
<p>Returns zero if successful or an error if the requested
transition is illegal.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sdev_evt_send">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sdev_evt_send</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_event</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">evt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_send" title="Link to this definition">¶</a><br /></dt>
<dd><p>send asserted event to uevent thread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi_device event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_event</span> <span class="pre">*evt</span></code></dt><dd><p>event to send</p>
<p>Assert scsi device event asynchronously.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sdev_evt_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_event</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sdev_evt_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device_event</span></span><span class="w"> </span><span class="n"><span class="pre">evt_type</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfpflags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a new scsi event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_event</span> <span class="pre">evt_type</span></code></dt><dd><p>type of event to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfpflags</span></code></dt><dd><p>GFP flags for allocation</p>
<p>Allocates and returns a new scsi_event.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sdev_evt_send_simple">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sdev_evt_send_simple</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device_event</span></span><span class="w"> </span><span class="n"><span class="pre">evt_type</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfpflags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_send_simple" title="Link to this definition">¶</a><br /></dt>
<dd><p>send asserted event to uevent thread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi_device event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_event</span> <span class="pre">evt_type</span></code></dt><dd><p>type of event to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfpflags</span></code></dt><dd><p>GFP flags for allocation</p>
<p>Assert scsi device event asynchronously, given an event type.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_quiesce">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_quiesce</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_quiesce" title="Link to this definition">¶</a><br /></dt>
<dd><p>Block all commands except power management.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to quiesce.</p>
<p>This works by trying to transition to the SDEV_QUIESCE state
(which must be a legal transition).  When the device is in this
state, only power management requests will be accepted, all others will
be deferred.</p>
<p>Must be called with user context, may sleep.</p>
<p>Returns zero if unsuccessful or an error if not.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_resume">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_resume</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_resume" title="Link to this definition">¶</a><br /></dt>
<dd><p>Restart user issued commands to a quiesced device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to resume.</p>
<p>Moves the device from quiesced back to running and restarts the
queues.</p>
<p>Must be called with user context, may sleep.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_internal_device_block_nowait">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_internal_device_block_nowait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_internal_device_block_nowait" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to transition to the SDEV_BLOCK state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>device to block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pause SCSI command processing on the specified device. Does not sleep.</p>
<p>Returns zero if successful or a negative error code upon failure.</p>
<p><strong>Notes</strong></p>
<p>This routine transitions the device to the SDEV_BLOCK state (which must be
a legal transition). When the device is in this state, command processing
is paused until the device leaves the SDEV_BLOCK state. See also
<a class="reference internal" href="#c.scsi_internal_device_unblock_nowait" title="scsi_internal_device_unblock_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_internal_device_unblock_nowait()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_internal_device_unblock_nowait">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_internal_device_unblock_nowait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device_state</span></span><span class="w"> </span><span class="n"><span class="pre">new_state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_internal_device_unblock_nowait" title="Link to this definition">¶</a><br /></dt>
<dd><p>resume a device after a block request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>device to resume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_state</span> <span class="pre">new_state</span></code></dt><dd><p>state to set the device to after unblocking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart the device queue for a previously suspended SCSI device. Does not
sleep.</p>
<p>Returns zero if successful or a negative error code upon failure.</p>
<p><strong>Notes</strong></p>
<p>This routine transitions the device to the SDEV_RUNNING state or to one of
the offline states (which must be a legal transition) allowing the midlayer
to goose the queue for this device.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_block_targets">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_block_targets</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_block_targets" title="Link to this definition">¶</a><br /></dt>
<dd><p>transition all SCSI child devices to SDEV_BLOCK state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>the Scsi_Host to which this device belongs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>a parent device of one or more scsi_target devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all children of <strong>dev</strong>, which should be scsi_target devices,
and switch all subordinate scsi devices to SDEV_BLOCK state. Wait for
ongoing scsi_queue_rq() calls to finish. May sleep.</p>
<p><strong>Note</strong></p>
<p><strong>dev</strong> must not itself be a scsi_target device.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_host_block">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_host_block</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_block" title="Link to this definition">¶</a><br /></dt>
<dd><p>Try to transition all logical units to the SDEV_BLOCK state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>device to block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pause SCSI command processing for all logical units associated with the SCSI
host and wait until pending scsi_queue_rq() calls have finished.</p>
<p>Returns zero if successful or a negative error code upon failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_kmap_atomic_sg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_kmap_atomic_sg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scatterlist</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgl</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sg_count</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">offset</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_kmap_atomic_sg" title="Link to this definition">¶</a><br /></dt>
<dd><p>find and atomically map an sg-elemnt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sgl</span></code></dt><dd><p>scatter-gather list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sg_count</span></code></dt><dd><p>number of segments in sg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>offset in bytes into sg, on return offset into the mapped area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*len</span></code></dt><dd><p>bytes to map, on return number of bytes mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns virtual address of the start of the mapped page</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_kunmap_atomic_sg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_kunmap_atomic_sg</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">virt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_kunmap_atomic_sg" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomically unmap a virtual address, previously mapped with scsi_kmap_atomic_sg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*virt</span></code></dt><dd><p>virtual address to be unmapped</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_vpd_lun_id">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_vpd_lun_id</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">id_len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_vpd_lun_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>return a unique device identification</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>buffer for the identification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">id_len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies a unique device identification into <strong>id</strong> based
on the information in the VPD page 0x83 of the device.
The string will be formatted as a SCSI name string.</p>
<p>Returns the length of the identification or error on failure.
If the identifier is longer than the supplied buffer the actual
identifier length is returned and the buffer is not zero-padded.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_vpd_tpg_id">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_vpd_tpg_id</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rel_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_vpd_tpg_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>return a target port group identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*rel_id</span></code></dt><dd><p>pointer to return relative target port in if not <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the Target Port Group identifier from the information
from VPD page 0x83 of the device.
Optionally sets <strong>rel_id</strong> to the relative target port on success.</p>
<p><strong>Return</strong></p>
<p>the identifier or error on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_build_sense">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_build_sense</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scmd</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">desc</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">asc</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">ascq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_build_sense" title="Link to this definition">¶</a><br /></dt>
<dd><p>build sense data for a command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>scsi command for which the sense should be formatted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc</span></code></dt><dd><p>Sense format (non-zero == descriptor format,
0 == fixed format)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">key</span></code></dt><dd><p>Sense key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">asc</span></code></dt><dd><p>Additional sense code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">ascq</span></code></dt><dd><p>Additional sense code qualifier</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-lib-dma-c">
<h4>drivers/scsi/scsi_lib_dma.c<a class="headerlink" href="#drivers-scsi-scsi-lib-dma-c" title="Link to this heading">¶</a></h4>
<p>SCSI library functions depending on DMA (map and unmap scatter-gather
lists).</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_dma_map">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_dma_map</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dma_map" title="Link to this definition">¶</a><br /></dt>
<dd><p>perform DMA mapping against command’s sg lists</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>scsi command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of sg lists actually used, zero if the sg lists
is NULL, or -ENOMEM if the mapping failed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_dma_unmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_dma_unmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dma_unmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>unmap command’s sg lists mapped by scsi_dma_map</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>scsi command</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-proc-c">
<h4>drivers/scsi/scsi_proc.c<a class="headerlink" href="#drivers-scsi-scsi-proc-c" title="Link to this heading">¶</a></h4>
<p>The functions in this file provide an interface between the PROC file
system and the SCSI device drivers It is mainly used for debugging,
statistics and to pass information directly to the lowlevel driver. I.E.
plumbing to manage /proc/scsi/*</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.scsi_proc_entry">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_proc_entry</span></span></span><a class="headerlink" href="#c.scsi_proc_entry" title="Link to this definition">¶</a><br /></dt>
<dd><p>(host template, SCSI proc dir) association</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct scsi_proc_entry {
    struct list_head        entry;
    const struct scsi_host_template *sht;
    struct proc_dir_entry   *proc_dir;
    unsigned int            present;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>entry in scsi_proc_list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sht</span></code></dt><dd><p>SCSI host template associated with the procfs directory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proc_dir</span></code></dt><dd><p>procfs directory associated with the SCSI host template.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">present</span></code></dt><dd><p>Number of SCSI hosts instantiated for <strong>sht</strong>.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_template_proc_dir">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">proc_dir_entry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_template_proc_dir</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_host_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sht</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_template_proc_dir" title="Link to this definition">¶</a><br /></dt>
<dd><p>returns the procfs dir for a SCSI host template</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*sht</span></code></dt><dd><p>SCSI host template pointer.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_proc_hostdir_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_proc_hostdir_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_host_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sht</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_hostdir_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create directory in /proc for a scsi host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*sht</span></code></dt><dd><p>owner of this directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets sht-&gt;proc_dir to the new directory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_proc_hostdir_rm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_proc_hostdir_rm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_host_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sht</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_hostdir_rm" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove directory in /proc for a scsi host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*sht</span></code></dt><dd><p>owner of directory</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_proc_host_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_proc_host_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_host_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add entry for this host to appropriate /proc dir</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host to add</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_proc_host_rm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_proc_host_rm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_host_rm" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove this host’s entry from /proc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>which host</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.proc_print_scsidevice">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">proc_print_scsidevice</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_print_scsidevice" title="Link to this definition">¶</a><br /></dt>
<dd><p>return data about this host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>A scsi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span></code> to output to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>prints Host, Channel, Id, Lun, Vendor, Model, Rev, Type,
and revision.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_add_single_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_add_single_device</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">host</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_single_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Respond to user request to probe for/add device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">host</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">lun</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by writing “scsi add-single-device” to /proc/scsi/scsi.</p>
<p>does <a class="reference internal" href="#c.scsi_host_lookup" title="scsi_host_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_lookup()</span></code></a> and either user_scan() if that transport
type supports it, or else scsi_scan_host_selected()</p>
<p><strong>Note</strong></p>
<p>this seems to be aimed exclusively at SCSI parallel busses.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_remove_single_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_remove_single_device</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">host</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_single_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Respond to user request to remove a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">host</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">lun</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by writing “scsi remove-single-device” to
/proc/scsi/scsi.  Does a <a class="reference internal" href="#c.scsi_device_lookup" title="scsi_device_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_device_lookup()</span></code></a> and <a class="reference internal" href="#c.scsi_remove_device" title="scsi_remove_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_device()</span></code></a></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.proc_scsi_write">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">proc_scsi_write</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.proc_scsi_write" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ppos</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_scsi_write" title="Link to this definition">¶</a><br /></dt>
<dd><p>handle writes to /proc/scsi/scsi</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of buf, at most PAGE_SIZE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>not used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this provides a legacy mechanism to add or remove devices by
Host, Channel, ID, and Lun.  To use,
“echo ‘scsi add-single-device 0 1 2 3’ &gt; /proc/scsi/scsi” or
“echo ‘scsi remove-single-device 0 1 2 3’ &gt; /proc/scsi/scsi” with
“0 1 2 3” replaced by the Host, Channel, Id, and Lun.</p>
<p><strong>Note</strong></p>
<p>this seems to be aimed at parallel SCSI. Most modern busses (USB,
SATA, Firewire, Fibre Channel, etc) dynamically assign these values to
provide a unique identifier and nothing more.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.proc_scsi_open">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">proc_scsi_open</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.proc_scsi_open" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.proc_scsi_open" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_scsi_open" title="Link to this definition">¶</a><br /></dt>
<dd><p>glue function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>passed to single_open()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Associates proc_scsi_show with this file</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_init_procfs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_init_procfs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_init_procfs" title="Link to this definition">¶</a><br /></dt>
<dd><p>create scsi and scsi/scsi in procfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_exit_procfs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_exit_procfs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_exit_procfs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove scsi/scsi and scsi from procfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-netlink-c">
<h4>drivers/scsi/scsi_netlink.c<a class="headerlink" href="#drivers-scsi-scsi-netlink-c" title="Link to this heading">¶</a></h4>
<p>Infrastructure to provide async events from transports to userspace via
netlink, using a single NETLINK_SCSITRANSPORT protocol for all
transports. See <a class="reference external" href="https://lore.kernel.org/linux-scsi/1155070439.6275.5.camel&#64;localhost.localdomain/">the original patch submission</a>
for more details.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_nl_rcv_msg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_nl_rcv_msg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff"><span class="n"><span class="pre">sk_buff</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">skb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_nl_rcv_msg" title="Link to this definition">¶</a><br /></dt>
<dd><p>Receive message handler.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>socket receive buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Extracts message from a receive buffer.</dt><dd><p>Validates message header and calls appropriate transport message handler</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_netlink_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_netlink_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_netlink_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Called by SCSI subsystem to initialize the SCSI transport netlink interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_netlink_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_netlink_exit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_netlink_exit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Called by SCSI subsystem to disable the SCSI transport netlink interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-scan-c">
<h4>drivers/scsi/scsi_scan.c<a class="headerlink" href="#drivers-scsi-scsi-scan-c" title="Link to this heading">¶</a></h4>
<p>Scan a host to determine which (if any) devices are attached. The
general scanning/probing algorithm is as follows, exceptions are made to
it depending on device specific flags, compilation options, and global
variable (boot or module load time) settings. A specific LUN is scanned
via an INQUIRY command; if the LUN has a device attached, a scsi_device
is allocated and setup for it. For every id of every channel on the
given host, start by scanning LUN 0. Skip hosts that don’t respond at
all to a scan of LUN 0. Otherwise, if LUN 0 has a device attached,
allocate and setup a scsi_device for it. If target is SCSI-3 or up,
issue a REPORT LUN, and scan all of the LUNs returned by the REPORT LUN;
else, sequentially scan LUNs up until some maximum is reached, or a LUN
is seen that cannot have a device attached to it.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_sanitize_inquiry_string">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_sanitize_inquiry_string</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_sanitize_inquiry_string" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove non-graphical chars from an INQUIRY result string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>INQUIRY result string to sanitize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The SCSI spec says that INQUIRY vendor, product, and revision
strings must consist entirely of graphic ASCII characters,
padded on the right with spaces.  Since not all devices obey
this rule, we will replace non-graphic or non-ASCII characters
with spaces.  Exception: a NUL character is interpreted as a
string terminator, so all the following characters are set to
spaces.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_add_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_add_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">host</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="n"><span class="pre">uint</span></span><span class="w"> </span><span class="n"><span class="pre">target</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates a new SCSI (LU) instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*host</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">Scsi_Host</span></code> instance where the device is located</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>target channel number (rarely other than <code class="docutils literal notranslate"><span class="pre">0</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">target</span></code></dt><dd><p>target id number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>LUN of target device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Probe for a specific LUN and add it if found.</p>
<p><strong>Notes</strong></p>
<p>This call is usually performed internally during a SCSI
bus scan when an HBA is added (i.e. <a class="reference internal" href="#c.scsi_scan_host" title="scsi_scan_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_scan_host()</span></code></a>). So it
should only be called if the HBA becomes aware of a new SCSI
device (LU) after <a class="reference internal" href="#c.scsi_scan_host" title="scsi_scan_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_scan_host()</span></code></a> has completed. If successful
this call can lead to sdev_init() and sdev_configure() callbacks
into the LLD.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success or negative error code on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_scan_target">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_scan_target</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_scan_mode</span></span><span class="w"> </span><span class="n"><span class="pre">rescan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_scan_target" title="Link to this definition">¶</a><br /></dt>
<dd><p>scan a target id, possibly including all LUNs on the target.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>host to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>channel to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>target id to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>Specific LUN to scan or SCAN_WILD_CARD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_scan_mode</span> <span class="pre">rescan</span></code></dt><dd><p>passed to LUN scanning routines; SCSI_SCAN_INITIAL for
no rescan, SCSI_SCAN_RESCAN to rescan existing LUNs,
and SCSI_SCAN_MANUAL to force scanning even if
‘scan=manual’ is set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Scan the target id on <strong>parent</strong>, <strong>channel</strong>, and <strong>id</strong>. Scan at least LUN 0,
and possibly all LUNs on the target id.</p>
<p>First try a REPORT LUN scan, if that does not scan the target, do a
sequential scan of LUNs on the target id.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_scan_host">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_scan_host</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_scan_host" title="Link to this definition">¶</a><br /></dt>
<dd><p>scan the given adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>adapter to scan</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<p>Should be called after scsi_add_host()</p>
</div>
</section>
<section id="drivers-scsi-scsi-sysctl-c">
<h4>drivers/scsi/scsi_sysctl.c<a class="headerlink" href="#drivers-scsi-scsi-sysctl-c" title="Link to this heading">¶</a></h4>
<p>Set up the sysctl entry: “/dev/scsi/logging_level”
(DEV_SCSI_LOGGING_LEVEL) which sets/returns scsi_logging_level.</p>
</section>
<section id="drivers-scsi-scsi-sysfs-c">
<h4>drivers/scsi/scsi_sysfs.c<a class="headerlink" href="#drivers-scsi-scsi-sysfs-c" title="Link to this heading">¶</a></h4>
<p>SCSI sysfs interface routines.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_remove_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_remove_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a device from the scsi bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi_device to unregister</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_remove_target">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_remove_target</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_target" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to remove a target and all its devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>generic starget or parent of generic stargets to be removed</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This is slightly racy.  It is possible that if the user
requests the addition of another device then the target won’t be
removed.</p>
</div>
</section>
<section id="drivers-scsi-hosts-c">
<h4>drivers/scsi/hosts.c<a class="headerlink" href="#drivers-scsi-hosts-c" title="Link to this heading">¶</a></h4>
<p>mid to lowlevel SCSI driver interface</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_remove_host">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_remove_host</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_host" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a scsi host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>a pointer to a scsi host to remove</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_add_host_with_dma">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_add_host_with_dma</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_host_with_dma" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a scsi host with dma device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host pointer to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> of type scsi class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dma_dev</span></code></dt><dd><p>dma device for the host</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>You rarely need to worry about this unless you’re in a
virtualised host environments, so use the simpler scsi_add_host()
function instead.</p>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success / != 0 for error</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_host_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_host_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_host_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sht</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">privsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a scsi host adapter instance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*sht</span></code></dt><dd><p>pointer to scsi host template</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">privsize</span></code></dt><dd><p>extra bytes to allocate for driver</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<blockquote>
<div><p>Allocate a new Scsi_Host and perform basic initialization.
The host is not published to the scsi midlayer until scsi_add_host
is called.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>Pointer to a new Scsi_Host</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_host_lookup">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_host_lookup</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">hostnum</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_lookup" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a reference to a Scsi_Host by host no</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hostnum</span></code></dt><dd><p>host number to locate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl>
<dt>Return value:</dt><dd><p>A pointer to located Scsi_Host or NULL.</p>
<p>The caller must do a <a class="reference internal" href="#c.scsi_host_put" title="scsi_host_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_put()</span></code></a> to drop the reference
that <a class="reference internal" href="#c.scsi_host_get" title="scsi_host_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_get()</span></code></a> took. The <a class="reference internal" href="infrastructure.html#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> below dropped
the reference from <a class="reference internal" href="infrastructure.html#c.class_find_device" title="class_find_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">class_find_device()</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_host_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_host_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>inc a Scsi_Host ref count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host to inc.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_host_busy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_host_busy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_busy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the host busy counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host to inc.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_host_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_host_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>dec a Scsi_Host ref count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host to dec.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_queue_work">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_queue_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_queue_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Queue work to the Scsi_Host workqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>Work to queue for execution.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>1 - work queued for execution
0 - work is already queued
-EINVAL - work queue doesn’t exist</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_flush_work">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_flush_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_flush_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flush a Scsi_Host’s workqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_host_complete_all_commands">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_host_complete_all_commands</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_host_status</span></span><span class="w"> </span><span class="n"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_complete_all_commands" title="Link to this definition">¶</a><br /></dt>
<dd><p>Terminate all running commands</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Scsi Host on which commands should be terminated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_host_status</span> <span class="pre">status</span></code></dt><dd><p>Status to be set for the terminated commands</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There is no protection against modification of the number
of outstanding commands. It is the responsibility of the
caller to ensure that concurrent I/O submission and/or
completion is stopped when calling this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_host_busy_iter">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_host_busy_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">priv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_busy_iter" title="Link to this definition">¶</a><br /></dt>
<dd><p>Iterate over all busy commands</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*fn)(struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to call on each busy command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>Data pointer passed to <strong>fn</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If locking against concurrent command completions is required
ithas to be provided by the caller</p>
</div>
</section>
<section id="drivers-scsi-scsi-common-c">
<h4>drivers/scsi/scsi_common.c<a class="headerlink" href="#drivers-scsi-scsi-common-c" title="Link to this heading">¶</a></h4>
<p>general support functions</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_device_type">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_device_type</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 17-char string indicating device type.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt><dd><p>type number to look up</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsilun_to_int">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsilun_to_int</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_lun</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scsilun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsilun_to_int" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert a scsi_lun to an int</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_lun</span> <span class="pre">*scsilun</span></code></dt><dd><p>struct scsi_lun to be converted.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Convert <strong>scsilun</strong> from a struct scsi_lun to a four-byte host byte-ordered
integer, and return the result. The caller must check for
truncation before using this function.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>For a description of the LUN format, post SCSI-3 see the SCSI
Architecture Model, for SCSI-3 see the SCSI Controller Commands.</p>
<p>Given a struct scsi_lun of: d2 04 0b 03 00 00 00 00, this function
returns the integer: 0x0b03d204</p>
<p>This encoding will return a standard integer LUN for LUNs smaller
than 256, which typically use a single level LUN structure with
addressing method 0.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.int_to_scsilun">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">int_to_scsilun</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">lun</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_lun</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scsilun</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.int_to_scsilun" title="Link to this definition">¶</a><br /></dt>
<dd><p>reverts an int into a scsi_lun</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>integer to be reverted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_lun</span> <span class="pre">*scsilun</span></code></dt><dd><p>struct scsi_lun to be set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Reverts the functionality of the scsilun_to_int, which packed
an 8-byte lun value into an int. This routine unpacks the int
back into the lun value.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>Given an integer : 0x0b03d204, this function returns a
struct scsi_lun of: d2 04 0b 03 00 00 00 00</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_normalize_sense">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_normalize_sense</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sense_buffer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sb_len</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_sense_hdr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sshdr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_normalize_sense" title="Link to this definition">¶</a><br /></dt>
<dd><p>normalize main elements from either fixed or descriptor sense data format into a common format.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*sense_buffer</span></code></dt><dd><p>byte array containing sense data returned by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>pointer to instance of structure that common
elements are written to.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>The “main elements” from sense data are: response_code, sense_key,
asc, ascq and additional_length (only for descriptor format).</p>
<p>Typically this function can be called after a device has
responded to a SCSI command with the CHECK_CONDITION status.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>true if valid sense data information found, else false;</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_sense_desc_find">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">scsi_sense_desc_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sense_buffer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sb_len</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">desc_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_sense_desc_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>search for a given descriptor type in descriptor sense data format.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">sense_buffer</span></code></dt><dd><p>byte array of descriptor format sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc_type</span></code></dt><dd><p>value of descriptor type to find
(e.g. 0 -&gt; information)</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>only valid when sense data is in descriptor format</p>
</div></blockquote>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>pointer to start of (first) descriptor if found else NULL</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_build_sense_buffer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_build_sense_buffer</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">desc</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">asc</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">ascq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_build_sense_buffer" title="Link to this definition">¶</a><br /></dt>
<dd><p>build sense data in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc</span></code></dt><dd><p>Sense format (non-zero == descriptor format,
0 == fixed format)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">key</span></code></dt><dd><p>Sense key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">asc</span></code></dt><dd><p>Additional sense code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">ascq</span></code></dt><dd><p>Additional sense code qualifier</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_set_sense_information">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_set_sense_information</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">buf_len</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_set_sense_information" title="Link to this definition">¶</a><br /></dt>
<dd><p>set the information field in a formatted sense data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>buffer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">info</span></code></dt><dd><p>64-bit information value to be set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success or -EINVAL for invalid sense buffer length</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_set_sense_field_pointer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_set_sense_field_pointer</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">buf_len</span></span>, <span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">fp</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">bp</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">cd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_set_sense_field_pointer" title="Link to this definition">¶</a><br /></dt>
<dd><p>set the field pointer sense key specific information in a formatted sense data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>buffer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">fp</span></code></dt><dd><p>field pointer to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">bp</span></code></dt><dd><p>bit pointer to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">cd</span></code></dt><dd><p>command/data bit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success or -EINVAL for invalid sense buffer length</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="transport-classes">
<h3>Transport classes<a class="headerlink" href="#transport-classes" title="Link to this heading">¶</a></h3>
<p>Transport classes are service libraries for drivers in the SCSI lower
layer, which expose transport attributes in sysfs.</p>
<section id="fibre-channel-transport">
<h4>Fibre Channel transport<a class="headerlink" href="#fibre-channel-transport" title="Link to this heading">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_fc.c defines transport attributes
for Fibre Channel.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_get_event_number">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_get_event_number</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_get_event_number" title="Link to this definition">¶</a><br /></dt>
<dd><p>Obtain the next sequential FC event number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>We could have inlined this, but it would have required fc_event_seq to
be exposed. For now, live with the subroutine call.
Atomic used to avoid lock/unlock...</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_host_post_fc_event">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_host_post_fc_event</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">event_number</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">fc_host_event_code</span></span><span class="w"> </span><span class="n"><span class="pre">event_code</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">data_len</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data_buf</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">vendor_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_fc_event" title="Link to this definition">¶</a><br /></dt>
<dd><p>routine to do the work of posting an event on an fc_host.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fc_host_event_code</span> <span class="pre">event_code</span></code></dt><dd><p>fc_host event being posted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">data_len</span></code></dt><dd><p>amount, in bytes, of event data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*data_buf</span></code></dt><dd><p>pointer to event data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">vendor_id</span></code></dt><dd><p>value for Vendor id</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_host_post_event">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_host_post_event</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">event_number</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">fc_host_event_code</span></span><span class="w"> </span><span class="n"><span class="pre">event_code</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">event_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_event" title="Link to this definition">¶</a><br /></dt>
<dd><p>called to post an even on an fc_host.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fc_host_event_code</span> <span class="pre">event_code</span></code></dt><dd><p>fc_host event being posted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_data</span></code></dt><dd><p>32bits of data for the event being posted</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_host_post_vendor_event">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_host_post_vendor_event</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">event_number</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">data_len</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data_buf</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">vendor_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_vendor_event" title="Link to this definition">¶</a><br /></dt>
<dd><p>called to post a vendor unique event on an fc_host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">data_len</span></code></dt><dd><p>amount, in bytes, of vendor unique data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">data_buf</span></code></dt><dd><p>pointer to vendor unique data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">vendor_id</span></code></dt><dd><p>Vendor id</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_find_rport_by_wwpn">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fc_find_rport_by_wwpn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">wwpn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_find_rport_by_wwpn" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the fc_rport pointer for a given wwpn</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the fc_rport is associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">wwpn</span></code></dt><dd><p>wwpn of the fc_rport device</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_host_fpin_rcv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_host_fpin_rcv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">fpin_len</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fpin_buf</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">event_acknowledge</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_fpin_rcv" title="Link to this definition">¶</a><br /></dt>
<dd><p>routine to process a received FPIN.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the FPIN was received on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">fpin_len</span></code></dt><dd><p>length of FPIN payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*fpin_buf</span></code></dt><dd><p>pointer to FPIN payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">event_acknowledge</span></code></dt><dd><p>1, if LLDD handles this event.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_eh_timed_out">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_timeout_action</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_eh_timed_out</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_eh_timed_out" title="Link to this definition">¶</a><br /></dt>
<dd><p>FC Transport I/O timeout intercept handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>The SCSI command which timed out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine protects against error handlers getting invoked while a
rport is in a blocked state, typically due to a temporarily loss of
connectivity. If the error handlers are allowed to proceed, requests
to abort i/o, reset the target, etc will likely fail as there is no way
to communicate with the device to perform the requested function. These
failures may result in the midlayer taking the device offline, requiring
manual intervention to restore operation.</p>
<p>This routine, called whenever an i/o times out, validates the state of
the underlying rport. If the rport is blocked, it returns
EH_RESET_TIMER, which will continue to reschedule the timeout.
Eventually, either the device will return, or devloss_tmo will fire,
and when the timeout then fires, it will be handled normally.
If the rport is not blocked, normal error handling continues.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_remove_host">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_remove_host</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remove_host" title="Link to this definition">¶</a><br /></dt>
<dd><p>called to terminate any fc_transport-related elements for a scsi host.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Which <code class="xref c c-type docutils literal notranslate"><span class="pre">Scsi_Host</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is expected to be called immediately preceding the
a driver’s call to <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>.</p>
<dl class="simple">
<dt>WARNING: A driver utilizing the fc_transport, which fails to call</dt><dd><p>this routine prior to <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>, will leave dangling
objects in /sys/class/fc_remote_ports. Access to any of these
objects can result in a system crash !!!</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_remote_port_add">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fc_remote_port_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_rport_identifiers</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>notify fc transport of the existence of a remote FC port.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host the remote port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>Channel on shost port connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport_identifiers</span> <span class="pre">*ids</span></code></dt><dd><p>The world wide names, fc address, and FC4 port
roles for the remote port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport of the existence
of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)
of the port, it’s FC address (port_id), and the FC4 roles that are
active for the port.</p>
<p>For ports that are FCP targets (aka scsi targets), the FC transport
maintains consistent target id bindings on behalf of the LLDD.
A consistent target id binding is an assignment of a target id to
a remote port identifier, which persists while the scsi host is
attached. The remote port can disappear, then later reappear, and
it’s target id assignment remains the same. This allows for shifts
in FC addressing (if binding by wwpn or wwnn) with no apparent
changes to the scsi subsystem which is based on scsi host number and
target id values.  Bindings are only valid during the attachment of
the scsi host. If the host detaches, then later re-attaches, target
id bindings may change.</p>
<p>This routine is responsible for returning a remote port structure.
The routine will search the list of remote ports it maintains
internally on behalf of consistent target id mappings. If found, the
remote port structure will be reused. Otherwise, a new remote port
structure will be allocated.</p>
<p>Whenever a remote port is allocated, a new fc_remote_port class
device is created.</p>
<p>Should not be called from interrupt context.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_remote_port_delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_remote_port_delete</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_delete" title="Link to this definition">¶</a><br /></dt>
<dd><p>notifies the fc transport that a remote port is no longer in existence.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*rport</span></code></dt><dd><p>The remote port that no longer exists</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport that a remote
port is no longer part of the topology. Note: Although a port
may no longer be part of the topology, it may persist in the remote
ports displayed by the fc_host. We do this under 2 conditions:</p>
<ol class="arabic simple">
<li><p>If the port was a scsi target, we delay its deletion by “blocking” it.
This allows the port to temporarily disappear, then reappear without
disrupting the SCSI device tree attached to it. During the “blocked”
period the port will still exist.</p></li>
<li><p>If the port was a scsi target and disappears for longer than we
expect, we’ll delete the port and the tear down the SCSI device tree
attached to it. However, we want to semi-persist the target id assigned
to that port if it eventually does exist. The port structure will
remain (although with minimal information) so that the target id
bindings also remain.</p></li>
</ol>
<p>If the remote port is not an FCP Target, it will be fully torn down
and deallocated, including the fc_remote_port class device.</p>
<p>If the remote port is an FCP Target, the port will be placed in a
temporary blocked state. From the LLDD’s perspective, the rport no
longer exists. From the SCSI midlayer’s perspective, the SCSI target
exists, but all sdevs on it are blocked from further I/O. The following
is then expected.</p>
<blockquote>
<div><p>If the remote port does not return (signaled by a LLDD call to
<a class="reference internal" href="#c.fc_remote_port_add" title="fc_remote_port_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">fc_remote_port_add()</span></code></a>) within the dev_loss_tmo timeout, then the
scsi target is removed - killing all outstanding i/o and removing the
scsi devices attached to it. The port structure will be marked Not
Present and be partially cleared, leaving only enough information to
recognize the remote port relative to the scsi target id binding if
it later appears.  The port will remain as long as there is a valid
binding (e.g. until the user changes the binding type or unloads the
scsi host with the binding).</p>
<p>If the remote port returns within the dev_loss_tmo value (and matches
according to the target id binding type), the port structure will be
reused. If it is no longer a SCSI target, the target will be torn
down. If it continues to be a SCSI target, then the target will be
unblocked (allowing i/o to be resumed), and a scan will be activated
to ensure that all luns are detected.</p>
</div></blockquote>
<p>Called from normal process context only - cannot be called from interrupt.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_remote_port_rolechg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_remote_port_rolechg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">roles</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_rolechg" title="Link to this definition">¶</a><br /></dt>
<dd><p>notifies the fc transport that the roles on a remote may have changed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*rport</span></code></dt><dd><p>The remote port that changed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">roles</span></code></dt><dd><p>New roles for this port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport that the
roles on a remote port may have changed. The largest effect of this is
if a port now becomes a FCP Target, it must be allocated a
scsi target id.  If the port is no longer a FCP target, any
scsi target id value assigned to it will persist in case the
role changes back to include FCP Target. No changes in the scsi
midlayer will be invoked if the role changes (in the expectation
that the role will be resumed. If it doesn’t normal error processing
will take place).</p>
<p>Should not be called from interrupt context.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_block_rport">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_block_rport</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_block_rport" title="Link to this definition">¶</a><br /></dt>
<dd><p>Block SCSI eh thread for blocked fc_rport.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*rport</span></code></dt><dd><p>Remote port that scsi_eh is trying to recover.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine can be called from a FC LLD scsi_eh callback. It
blocks the scsi_eh thread until the fc_rport leaves the
FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is
necessary to avoid the scsi_eh failing recovery actions for blocked
rports which would lead to offlined SCSI devices.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.</dt><dd><p>FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
passed back to scsi_eh.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_block_scsi_eh">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_block_scsi_eh</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmnd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_block_scsi_eh" title="Link to this definition">¶</a><br /></dt>
<dd><p>Block SCSI eh thread for blocked fc_rport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmnd</span></code></dt><dd><p>SCSI command that scsi_eh is trying to recover</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine can be called from a FC LLD scsi_eh callback. It
blocks the scsi_eh thread until the fc_rport leaves the
FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is
necessary to avoid the scsi_eh failing recovery actions for blocked
rports which would lead to offlined SCSI devices.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.</dt><dd><p>FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
passed back to scsi_eh.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_vport_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_vport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fc_vport_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">channel</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_vport_identifiers</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_vport_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Admin App or LLDD requests creation of a vport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host the virtual port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>channel on shost port connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_vport_identifiers</span> <span class="pre">*ids</span></code></dt><dd><p>The world wide names, FC4 port roles, etc for
the virtual port.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fc_vport_terminate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fc_vport_terminate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fc_vport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_vport_terminate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Admin App or LLDD requests termination of a vport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_vport</span> <span class="pre">*vport</span></code></dt><dd><p>fc_vport to be terminated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the LLDD vport_delete() function, then deallocates and removes
the vport from the shost and object tree.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
</section>
<section id="iscsi-transport-class">
<h4>iSCSI transport class<a class="headerlink" href="#iscsi-transport-class" title="Link to this heading">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_iscsi.c defines transport
attributes for the iSCSI class, which sends SCSI packets over TCP/IP
connections.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_lookup_endpoint">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_endpoint</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_lookup_endpoint</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_lookup_endpoint" title="Link to this definition">¶</a><br /></dt>
<dd><p>get ep from handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">handle</span></code></dt><dd><p>endpoint handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must do a iscsi_put_endpoint.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_create_flashnode_sess">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_bus_flash_session</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_create_flashnode_sess</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_transport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transport</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dd_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_flashnode_sess" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add flashnode session entry in sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of flashnode to add in sysfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*transport</span></code></dt><dd><p>pointer to transport data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>total size to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a sysfs entry for the flashnode session attributes</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to allocated flashnode sess on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_create_flashnode_conn">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_bus_flash_conn</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_create_flashnode_conn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_bus_flash_session</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fnode_sess</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_transport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">transport</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dd_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_flashnode_conn" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add flashnode conn entry in sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*fnode_sess</span></code></dt><dd><p>pointer to the parent flashnode session entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*transport</span></code></dt><dd><p>pointer to transport data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>total size to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a sysfs entry for the flashnode connection attributes</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to allocated flashnode conn on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_find_flashnode_sess">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_find_flashnode_sess</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="n"><span class="pre">device_match_t</span></span><span class="w"> </span><span class="n"><span class="pre">fn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_find_flashnode_sess" title="Link to this definition">¶</a><br /></dt>
<dd><p>finds flashnode session entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to data containing value to use for comparison</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_match_t</span> <span class="pre">fn</span></code></dt><dd><p>function pointer that does actual comparison</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the flashnode session object comparing the data passed using logic
defined in passed function pointer</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to found flashnode session device object on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_find_flashnode_conn">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_find_flashnode_conn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_bus_flash_session</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fnode_sess</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_find_flashnode_conn" title="Link to this definition">¶</a><br /></dt>
<dd><p>finds flashnode connection entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*fnode_sess</span></code></dt><dd><p>pointer to parent flashnode session entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the flashnode connection object comparing the data passed using logic
defined in passed function pointer</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to found flashnode connection device object on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_destroy_flashnode_sess">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_destroy_flashnode_sess</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_bus_flash_session</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fnode_sess</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_flashnode_sess" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroy flashnode session entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*fnode_sess</span></code></dt><dd><p>pointer to flashnode session entry to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deletes the flashnode session entry and all children flashnode connection
entries from sysfs</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_destroy_all_flashnode">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_destroy_all_flashnode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_all_flashnode" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroy all flashnode session entries</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys all the flashnode session entries and all corresponding children
flashnode connection entries from sysfs</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_block_scsi_eh">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_block_scsi_eh</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_block_scsi_eh" title="Link to this definition">¶</a><br /></dt>
<dd><p>block scsi eh until session state has transistioned</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>scsi cmd passed to scsi eh handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the session is down this function will wait for the recovery
timer to fire or for the session to be logged back in. If the
recovery timer fires then FAST_IO_FAIL is returned. The caller
should pass this error value to the scsi eh.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_unblock_session">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_unblock_session</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_cls_session</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_unblock_session" title="Link to this definition">¶</a><br /></dt>
<dd><p>set a session as logged in and start IO.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*session</span></code></dt><dd><p>iscsi session</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark a session as ready to accept IO.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_force_destroy_session">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_force_destroy_session</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_cls_session</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_force_destroy_session" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroy a session from the kernel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*session</span></code></dt><dd><p>session to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Force the destruction of a session from the kernel. This should only be
used when userspace is no longer running during system shutdown.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_alloc_conn">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_cls_conn</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_alloc_conn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_cls_session</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dd_size</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">cid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_alloc_conn" title="Link to this definition">¶</a><br /></dt>
<dd><p>alloc iscsi class connection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*session</span></code></dt><dd><p>iscsi cls session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>private driver data size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">cid</span></code></dt><dd><p>connection id</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_add_conn">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_add_conn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_cls_conn</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_add_conn" title="Link to this definition">¶</a><br /></dt>
<dd><p>add iscsi class connection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi cls connection</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will expose iscsi_cls_conn to sysfs so make sure the related
resources for sysfs attributes are initialized before calling this.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_remove_conn">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_remove_conn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_cls_conn</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_remove_conn" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove iscsi class connection from sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi cls connection</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove iscsi_cls_conn from sysfs, and wait for previous
read/write of iscsi_cls_conn’s attributes in sysfs to finish.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iscsi_session_event">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iscsi_session_event</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_cls_session</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">session</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">iscsi_uevent_e</span></span><span class="w"> </span><span class="n"><span class="pre">event</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_session_event" title="Link to this definition">¶</a><br /></dt>
<dd><p>send session destr. completion event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*session</span></code></dt><dd><p>iscsi class session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iscsi_uevent_e</span> <span class="pre">event</span></code></dt><dd><p>type of event</p>
</dd>
</dl>
</div>
</section>
<section id="serial-attached-scsi-sas-transport-class">
<h4>Serial Attached SCSI (SAS) transport class<a class="headerlink" href="#serial-attached-scsi-sas-transport-class" title="Link to this heading">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_sas.c defines transport
attributes for Serial Attached SCSI, a variant of SATA aimed at large
high-end systems.</p>
<p>The SAS transport class contains common code to deal with SAS HBAs, an
approximated representation of SAS topologies in the driver model, and
various sysfs attributes to expose these topologies and management
interfaces to userspace.</p>
<p>In addition to the basic SCSI core objects this transport class
introduces two additional intermediate objects: The SAS PHY as
represented by struct sas_phy defines an “outgoing” PHY on a SAS HBA or
Expander, and the SAS remote PHY represented by struct sas_rphy defines
an “incoming” PHY on a SAS Expander or end device. Note that this is
purely a software concept, the underlying hardware for a PHY and a
remote PHY is the exactly the same.</p>
<p>There is no concept of a SAS port in this code, users can see what PHYs
form a wide port based on the port_identifier attribute, which is the
same for all PHYs in a port.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_remove_children">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_remove_children</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_remove_children" title="Link to this definition">¶</a><br /></dt>
<dd><p>tear down a devices SAS data structures</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device belonging to the sas object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SAS PHYs and remote PHYs for a given object</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_remove_host">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_remove_host</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_remove_host" title="Link to this definition">¶</a><br /></dt>
<dd><p>tear down a Scsi_Host’s SAS data structures</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Scsi Host that is torn down</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SAS PHYs and remote PHYs for a given Scsi_Host and remove the
Scsi_Host as well.</p>
<p><strong>Note</strong></p>
<p>Do not call <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a> on the Scsi_Host any more, as it is
already removed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_get_address">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_get_address</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_get_address" title="Link to this definition">¶</a><br /></dt>
<dd><p>return the SAS address of the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the SAS address of the scsi device</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_tlr_supported">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_tlr_supported</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_tlr_supported" title="Link to this definition">¶</a><br /></dt>
<dd><p>checking TLR bit in vpd 0x90</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check Transport Layer Retries are supported or not.
If vpd page 0x90 is present, TRL is supported.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_disable_tlr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_disable_tlr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_disable_tlr" title="Link to this definition">¶</a><br /></dt>
<dd><p>setting TLR flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Seting tlr_enabled flag to 0.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_enable_tlr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_enable_tlr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_enable_tlr" title="Link to this definition">¶</a><br /></dt>
<dd><p>setting TLR flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Seting tlr_enabled flag 1.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_ata_ncq_prio_supported">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_ata_ncq_prio_supported</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_ata_ncq_prio_supported" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check for ATA NCQ command priority support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if an ATA device supports NCQ priority using VPD page 89h (ATA
Information). Since this VPD page is implemented only for ATA devices,
this function always returns false for SCSI devices.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_phy_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_phy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sas_phy_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">number</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocates and initialize a SAS PHY structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>Parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">number</span></code></dt><dd><p>Phy index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS PHY structure.  It will be added in the device tree
below the device specified by <strong>parent</strong>, which has to be either a Scsi_Host
or sas_rphy.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_phy_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_phy_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_phy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">phy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a SAS PHY to the device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>The PHY to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a SAS PHY to the rest of the system.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_phy_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_phy_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_phy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">phy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a SAS PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>SAS PHY to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS PHY.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a PHY that has not
successfully been added using <a class="reference internal" href="#c.sas_phy_add" title="sas_phy_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_phy_add()</span></code></a>.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_phy_delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_phy_delete</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_phy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">phy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_delete" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove SAS PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>SAS PHY to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS PHY.  If the SAS PHY has an
associated remote PHY it is removed before.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_is_sas_phy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_is_sas_phy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_phy" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> represents a SAS PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS PHY, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_port_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sas_port_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">port_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate and initialize a SAS port structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">port_id</span></code></dt><dd><p>port number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a SAS port structure.  It will be added to the device tree
below the device specified by <strong>parent</strong> which must be either a Scsi_Host
or a sas_expander_device.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_port_alloc_num">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sas_port_alloc_num</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_alloc_num" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate and initialize a SAS port structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a SAS port structure and a number to go with it.  This
interface is really for adapters where the port number has no
meansing, so the sas class should manage them.  It will be added to
the device tree below the device specified by <strong>parent</strong> which must be
either a Scsi_Host or a sas_expander_device.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_port_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_port_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a SAS port to the device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>port to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>publishes a port to the rest of the system</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_port_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_port_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a SAS PORT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>SAS PORT to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS PORT.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a PORT that has not
successfully been added using <a class="reference internal" href="#c.sas_port_add" title="sas_port_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_port_add()</span></code></a>.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_port_delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_port_delete</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_delete" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove SAS PORT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>SAS PORT to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS PORT.  If the SAS PORT has an
associated phys, unlink them from the port as well.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_is_sas_port">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_is_sas_port</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> represents a SAS port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS Port, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_port_get_phy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_phy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sas_port_get_phy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_get_phy" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to take a reference on a port member</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>port to check</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_port_add_phy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_port_add_phy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_phy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">phy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_add_phy" title="Link to this definition">¶</a><br /></dt>
<dd><p>add another phy to a port to form a wide port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>port to add the phy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>phy to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a port is initially created, it is empty (has no phys).  All
ports must have at least one phy to operated, and all wide ports
must have at least two.  The current code makes no difference
between ports and wide ports, but the only object that can be
connected to a remote device is a port, so ports must be formed on
all devices with phys if they’re connected to anything.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_port_delete_phy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_port_delete_phy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_phy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">phy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_delete_phy" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a phy from a port or wide port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>port to remove the phy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>phy to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is used for tearing down ports again.  It must be
done to every port or wide port before calling sas_port_delete.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_end_device_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_rphy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sas_end_device_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_end_device_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate an rphy for an end device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*parent</span></code></dt><dd><p>which port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS remote PHY structure, connected to <strong>parent</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_expander_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_rphy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sas_expander_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">sas_device_type</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_expander_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate an rphy for an end device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*parent</span></code></dt><dd><p>which port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">sas_device_type</span> <span class="pre">type</span></code></dt><dd><p>SAS_EDGE_EXPANDER_DEVICE or SAS_FANOUT_EXPANDER_DEVICE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS remote PHY structure, connected to <strong>parent</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_rphy_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_rphy_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_rphy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rphy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a SAS remote PHY to the device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>The remote PHY to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a SAS remote PHY to the rest of the system.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_rphy_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_rphy_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_rphy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rphy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>SAS remote PHY to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS remote PHY.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a remote
PHY that has not successfully been added using
<a class="reference internal" href="#c.sas_rphy_add" title="sas_rphy_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_rphy_add()</span></code></a> (or has been <a class="reference internal" href="#c.sas_rphy_remove" title="sas_rphy_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_rphy_remove()</span></code></a>’d)</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_rphy_delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_rphy_delete</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_rphy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rphy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_delete" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove and free SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>SAS remote PHY to remove and free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS remote PHY and frees it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_rphy_unlink">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_rphy_unlink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_rphy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rphy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_unlink" title="Link to this definition">¶</a><br /></dt>
<dd><p>unlink SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>SAS remote phy to unlink from its parent port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes port reference to an rphy</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_rphy_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_rphy_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_rphy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rphy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>SAS remote phy to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS remote PHY.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scsi_is_sas_rphy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scsi_is_sas_rphy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_rphy" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> represents a SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS remote PHY, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_attach_transport">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_transport_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sas_attach_transport</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sas_function_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ft</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_attach_transport" title="Link to this definition">¶</a><br /></dt>
<dd><p>instantiate SAS transport template</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_function_template</span> <span class="pre">*ft</span></code></dt><dd><p>SAS transport class function template</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sas_release_transport">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sas_release_transport</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_transport_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_release_transport" title="Link to this definition">¶</a><br /></dt>
<dd><p>release SAS transport template instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_transport_template</span> <span class="pre">*t</span></code></dt><dd><p>transport template instance</p>
</dd>
</dl>
</div>
</section>
<section id="sata-transport-class">
<h4>SATA transport class<a class="headerlink" href="#sata-transport-class" title="Link to this heading">¶</a></h4>
<p>The SATA transport is handled by libata, which has its own book of
documentation in this directory.</p>
</section>
<section id="parallel-scsi-spi-transport-class">
<h4>Parallel SCSI (SPI) transport class<a class="headerlink" href="#parallel-scsi-spi-transport-class" title="Link to this heading">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_spi.c defines transport
attributes for traditional (fast/wide/ultra) SCSI busses.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.spi_dv_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_dv_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_dv_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Do Domain Validation on the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to validate</p>
<p>Performs the domain validation on the given device in the
current execution thread.  Since DV operations may sleep,
the current thread must have user context.  Also no SCSI
related locks that would deadlock I/O issued by the DV may
be held.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.spi_schedule_dv_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_schedule_dv_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_schedule_dv_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>schedule domain validation to occur on the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>The device to validate</p>
<p>Identical to <a class="reference internal" href="#c.spi_dv_device" title="spi_dv_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_dv_device()</span></code></a> above, except that the DV will be
scheduled to occur in a workqueue later.  All memory allocations
are atomic, so may be called from any context including those holding
SCSI locks.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.spi_display_xfer_agreement">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_display_xfer_agreement</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_target</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">starget</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_display_xfer_agreement" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print the current target transfer agreement</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>The target for which to display the agreement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each SPI port is required to maintain a transfer agreement for each
other port on the bus.  This function prints a one-line summary of
the current agreement; more detailed information is available in sysfs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.spi_populate_tag_msg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">spi_populate_tag_msg</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_populate_tag_msg" title="Link to this definition">¶</a><br /></dt>
<dd><p>place a tag message in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>pointer to the area to place the tag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>pointer to the scsi command for the tag</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>designed to create the correct type of tag message for the
particular request.  Returns the size of the tag message.
May return 0 if TCQ is disabled for this device.</p>
</div></blockquote>
</div>
</section>
<section id="scsi-rdma-srp-transport-class">
<h4>SCSI RDMA (SRP) transport class<a class="headerlink" href="#scsi-rdma-srp-transport-class" title="Link to this heading">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_srp.c defines transport
attributes for SCSI over Remote Direct Memory Access.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_tmo_valid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_tmo_valid</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">reconnect_delay</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">fast_io_fail_tmo</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">dev_loss_tmo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_tmo_valid" title="Link to this definition">¶</a><br /></dt>
<dd><p>check timeout combination validity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reconnect_delay</span></code></dt><dd><p>Reconnect delay in seconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fast_io_fail_tmo</span></code></dt><dd><p>Fast I/O fail timeout in seconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">dev_loss_tmo</span></code></dt><dd><p>Device loss timeout in seconds.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The combination of the timeout parameters must be such that SCSI commands
are finished in a reasonable time. Hence do not allow the fast I/O fail
timeout to exceed SCSI_DEVICE_BLOCK_MAX_TIMEOUT nor allow dev_loss_tmo to
exceed that limit if failing I/O fast has been disabled. Furthermore, these
parameters must be such that multipath can detect failed paths timely.
Hence do not allow all three parameters to be disabled simultaneously.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_start_tl_fail_timers">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_start_tl_fail_timers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_start_tl_fail_timers" title="Link to this definition">¶</a><br /></dt>
<dd><p>start the transport layer failure timers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the transport layer fast I/O failure and device loss timers. Do not
modify a timer that was already started.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_reconnect_rport">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_reconnect_rport</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_reconnect_rport" title="Link to this definition">¶</a><br /></dt>
<dd><p>reconnect to an SRP target port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blocks SCSI command queueing before invoking reconnect() such that
queuecommand() won’t be invoked concurrently with reconnect() from outside
the SCSI EH. This is important since a reconnect() implementation may
reallocate resources needed by queuecommand().</p>
<p><strong>Notes</strong></p>
<ul class="simple">
<li><p>This function neither waits until outstanding requests have finished nor
tries to abort these. It is the responsibility of the reconnect()
function to finish outstanding commands before reconnecting to the target
port.</p></li>
<li><p>It is the responsibility of the caller to ensure that the resources
reallocated by the reconnect() function won’t be used while this function
is in progress. One possible strategy is to invoke this function from
the context of the SCSI EH thread only. Another possible strategy is to
lock the rport mutex inside each SCSI LLD callback that can be invoked by
the SCSI EH (the scsi_host_template.eh_*() functions and also the
scsi_host_template.queuecommand() function).</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_timed_out">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_timeout_action</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_timed_out</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_cmnd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_timed_out" title="Link to this definition">¶</a><br /></dt>
<dd><p>SRP transport intercept of the SCSI timeout EH</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>SCSI command.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a timeout occurs while an rport is in the blocked state, ask the SCSI
EH to continue waiting (SCSI_EH_RESET_TIMER). Otherwise let the SCSI core
handle the timeout (SCSI_EH_NOT_HANDLED).</p>
<p><strong>Note</strong></p>
<p>This function is called from soft-IRQ context and with the request
queue lock held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_rport_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_rport_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>increment rport reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_rport_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_rport_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrement rport reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_rport_add">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">srp_rport_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_rport_identifiers</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a SRP remote port to the device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host the remote port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport_identifiers</span> <span class="pre">*ids</span></code></dt><dd><p>The port id for the remote port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a port to the rest of the system.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_rport_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_rport_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_del" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a SRP remote port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP remote port to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SRP remote port.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_remove_host">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_remove_host</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Scsi_Host</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shost</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_remove_host" title="Link to this definition">¶</a><br /></dt>
<dd><p>tear down a Scsi_Host’s SRP data structures</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Scsi Host that is torn down</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SRP remote ports for a given Scsi_Host.
Must be called just before scsi_remove_host for SRP HBAs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_stop_rport_timers">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_stop_rport_timers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_rport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rport</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_stop_rport_timers" title="Link to this definition">¶</a><br /></dt>
<dd><p>stop the transport layer recovery timers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP remote port for which to stop the timers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called after <a class="reference internal" href="#c.srp_remove_host" title="srp_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">srp_remove_host()</span></code></a> and <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>. The caller
must hold a reference on the rport (rport-&gt;dev) and on the SCSI host
(rport-&gt;dev.parent).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_attach_transport">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_transport_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">srp_attach_transport</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srp_function_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ft</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_attach_transport" title="Link to this definition">¶</a><br /></dt>
<dd><p>instantiate SRP transport template</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_function_template</span> <span class="pre">*ft</span></code></dt><dd><p>SRP transport class function template</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srp_release_transport">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srp_release_transport</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scsi_transport_template</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_release_transport" title="Link to this definition">¶</a><br /></dt>
<dd><p>release SRP transport template instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_transport_template</span> <span class="pre">*t</span></code></dt><dd><p>transport template instance</p>
</dd>
</dl>
</div>
</section>
</section>
</section>
<section id="scsi-lower-layer">
<h2>SCSI lower layer<a class="headerlink" href="#scsi-lower-layer" title="Link to this heading">¶</a></h2>
<section id="host-bus-adapter-transport-types">
<h3>Host Bus Adapter transport types<a class="headerlink" href="#host-bus-adapter-transport-types" title="Link to this heading">¶</a></h3>
<p>Many modern device controllers use the SCSI command set as a protocol to
communicate with their devices through many different types of physical
connections.</p>
<p>In SCSI language a bus capable of carrying SCSI commands is called a
“transport”, and a controller connecting to such a bus is called a “host
bus adapter” (HBA).</p>
<section id="debug-transport">
<h4>Debug transport<a class="headerlink" href="#debug-transport" title="Link to this heading">¶</a></h4>
<p>The file drivers/scsi/scsi_debug.c simulates a host adapter with a
variable number of disks (or disk like devices) attached, sharing a
common amount of RAM. Does a lot of checking to make sure that we are
not getting blocks mixed up, and panics the kernel if anything out of
the ordinary is seen.</p>
<p>To be more realistic, the simulated devices have the transport
attributes of SAS disks.</p>
<p>For documentation see <a class="reference external" href="http://sg.danny.cz/sg/scsi_debug.html">http://sg.danny.cz/sg/scsi_debug.html</a></p>
</section>
<section id="todo">
<h4>todo<a class="headerlink" href="#todo" title="Link to this heading">¶</a></h4>
<p>Parallel (fast/wide/ultra) SCSI, USB, SATA, SAS, Fibre Channel,
FireWire, ATAPI devices, Infiniband, Parallel ports,
netlink...</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/scsi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>