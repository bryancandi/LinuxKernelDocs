<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>TTY Driver and TTY Operations &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="TTY Port" href="tty_port.html" />
    <link rel="prev" title="TTY" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../coco/index.html">Confidential Computing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../extcon.html">Extcon Device Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/tty/tty_driver.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="tty-driver-and-tty-operations">
<h1>TTY Driver and TTY Operations<a class="headerlink" href="#tty-driver-and-tty-operations" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#allocation" id="id1">Allocation</a></p>
<ul>
<li><p><a class="reference internal" href="#tty-driver-flags" id="id2">TTY Driver Flags</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#registration" id="id3">Registration</a></p>
<ul>
<li><p><a class="reference internal" href="#registering-devices" id="id4">Registering Devices</a></p></li>
<li><p><a class="reference internal" href="#linking-devices-to-ports" id="id5">Linking Devices to Ports</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tty-driver-reference" id="id6">TTY Driver Reference</a></p></li>
<li><p><a class="reference internal" href="#tty-operations-reference" id="id7">TTY Operations Reference</a></p></li>
</ul>
</nav>
<section id="allocation">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Allocation</a><a class="headerlink" href="#allocation" title="Link to this heading">¶</a></h2>
<p>The first thing a driver needs to do is to allocate a <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a>. This
is done by <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a> (or <a class="reference internal" href="#c.__tty_alloc_driver" title="__tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">__tty_alloc_driver()</span></code></a>). Next, the newly
allocated structure is filled with information. See <a class="reference internal" href="#tty-driver-reference">TTY Driver Reference</a> at
the end of this document on what actually shall be filled in.</p>
<p>The allocation routines expect a number of devices the driver can handle at
most and flags. Flags are those starting <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_</span></code> listed and described
in <a class="reference internal" href="#tty-driver-flags">TTY Driver Flags</a> below.</p>
<p>When the driver is about to be freed, <a class="reference internal" href="#c.tty_driver_kref_put" title="tty_driver_kref_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_driver_kref_put()</span></code></a> is called on that.
It will decrements the reference count and if it reaches zero, the driver is
freed.</p>
<p>For reference, both allocation and deallocation functions are explained here in
detail:</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.tty_alloc_driver">
<span class="sig-name descname"><span class="n"><span class="pre">tty_alloc_driver</span></span></span><a class="headerlink" href="#c.tty_alloc_driver" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">tty_alloc_driver</span> <span class="pre">(lines,</span> <span class="pre">flags)</span></code></p>
<blockquote>
<div><p>allocate tty driver</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lines</span></code></dt><dd><p>count of lines this driver can handle at most</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>some of <a class="reference internal" href="#c.tty_driver_flag" title="tty_driver_flag"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">tty_driver_flag</span></code></a>, will be set in driver-&gt;flags</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a> or a PTR-encoded error (use <a class="reference internal" href="../../core-api/kernel-api.html#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> and friends).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__tty_alloc_driver">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__tty_alloc_driver</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lines</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__tty_alloc_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate tty driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">lines</span></code></dt><dd><p>count of lines this driver can handle at most</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module which is responsible for this driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>some of <a class="reference internal" href="#c.tty_driver_flag" title="tty_driver_flag"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">tty_driver_flag</span></code></a>, will be set in driver-&gt;flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should not be called directly, <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a> should be used
instead.</p>
<p><strong>Return</strong></p>
<p><a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a> or a PTR-encoded error (use <a class="reference internal" href="../../core-api/kernel-api.html#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> and friends).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_driver_kref_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tty_driver_kref_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_driver_kref_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>drop a reference to a tty driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>driver of which to drop the reference</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The final put will destroy and free up the driver.</p>
</div>
<section id="tty-driver-flags">
<h3><a class="toc-backref" href="#id2" role="doc-backlink">TTY Driver Flags</a><a class="headerlink" href="#tty-driver-flags" title="Link to this heading">¶</a></h3>
<p>Here comes the documentation of flags accepted by <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a> (or
<a class="reference internal" href="#c.__tty_alloc_driver" title="__tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">__tty_alloc_driver()</span></code></a>):</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.tty_driver_flag">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tty_driver_flag</span></span></span><a class="headerlink" href="#c.tty_driver_flag" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>TTY Driver Flags</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_INSTALLED</span></code></dt><dd><p>Whether this driver was succesfully installed. This is a tty internal
flag. Do not touch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_RESET_TERMIOS</span></code></dt><dd><p>Requests the tty layer to reset the termios setting when the last
process has closed the device. Used for PTYs, in particular.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_REAL_RAW</span></code></dt><dd><p>Indicates that the driver will guarantee not to set any special
character handling flags if this is set for the tty:</p>
<p><code class="docutils literal notranslate"><span class="pre">(IGNBRK</span> <span class="pre">||</span> <span class="pre">(!BRKINT</span> <span class="pre">&amp;&amp;</span> <span class="pre">!PARMRK))</span> <span class="pre">&amp;&amp;</span> <span class="pre">(IGNPAR</span> <span class="pre">||</span> <span class="pre">!INPCK)</span></code></p>
<p>That is, if there is no reason for the driver to
send notifications of parity and break characters up to the line
driver, it won’t do so.  This allows the line driver to optimize for
this case if this flag is set.  (Note that there is also a promise, if
the above case is true, not to signal overruns, either.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code></dt><dd><p>The individual tty devices need to be registered with a call to
<a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a> when the device is found in the system and
unregistered with a call to <a class="reference internal" href="#c.tty_unregister_device" title="tty_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_unregister_device()</span></code></a> so the devices will
be show up properly in sysfs.  If not set, all <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_driver.num</span></code></a> entries
will be created by the tty core in sysfs when <a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a> is
called.  This is to be used by drivers that have tty devices that can
appear and disappear while the main tty driver is registered with the
tty core.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DEVPTS_MEM</span></code></dt><dd><p>Don’t use the standard arrays (<a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_driver.ttys</span></code></a> and
<a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_driver.termios</span></code></a>), instead use dynamic memory keyed through the
devpts filesystem. This is only applicable to the PTY driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_HARDWARE_BREAK</span></code></dt><dd><p>Hardware handles break signals. Pass the requested timeout to the
<a class="reference internal" href="#c.tty_operations" title="tty_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_operations.break_ctl</span></code></a> instead of using a simple on/off interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_ALLOC</span></code></dt><dd><p>Do not allocate structures which are needed per line for this driver
(<a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_driver.ports</span></code></a>) as it would waste memory. The driver will take
care. This is only applicable to the PTY driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_UNNUMBERED_NODE</span></code></dt><dd><p>Do not create numbered <code class="docutils literal notranslate"><span class="pre">/dev</span></code> nodes. For example, create
<code class="docutils literal notranslate"><span class="pre">/dev/ttyprintk</span></code> and not <code class="docutils literal notranslate"><span class="pre">/dev/ttyprintk0</span></code>. Applicable only when a
driver for a single tty device is being allocated.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These are flags passed to <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a>.</p>
</section>
</section>
<hr class="docutils" />
<section id="registration">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Registration</a><a class="headerlink" href="#registration" title="Link to this heading">¶</a></h2>
<p>When a <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a> is allocated and filled in, it can be registered using
<a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a>. It is recommended to pass <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code> in
flags of <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a>. If it is not passed, <em>all</em> devices are also
registered during <a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a> and the following paragraph of
registering devices can be skipped for such drivers. However, the <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">tty_port</span></code></a> part in <a class="reference internal" href="#registering-devices">Registering Devices</a> is still relevant there.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_register_driver">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tty_register_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_register_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a tty driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>driver to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a tty driver to register itself.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_unregister_driver">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tty_unregister_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_unregister_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a tty driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>driver to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a tty driver to unregister itself.</p>
</div>
<section id="registering-devices">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Registering Devices</a><a class="headerlink" href="#registering-devices" title="Link to this heading">¶</a></h3>
<p>Every TTY device shall be backed by a <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span></code></a>. Usually, TTY drivers
embed tty_port into device’s private structures. Further details about handling
tty_port can be found in <a class="reference internal" href="tty_port.html"><span class="doc">TTY Port</span></a>. The driver is also recommended to use
tty_port’s reference counting by tty_port_get() and <a class="reference internal" href="tty_port.html#c.tty_port_put" title="tty_port_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_put()</span></code></a>. The final
put is supposed to free the tty_port including the device’s private struct.</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code> was passed as flags to <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a>,
TTY driver is supposed to register every device discovered in the system
(the latter is preferred). This is performed by <a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a>. Or by
<a class="reference internal" href="#c.tty_register_device_attr" title="tty_register_device_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device_attr()</span></code></a> if the driver wants to expose some information
through struct attribute_group. Both of them register <code class="docutils literal notranslate"><span class="pre">index</span></code>’th device and
upon return, the device can be opened. There are also preferred tty_port
variants described in <a class="reference internal" href="#linking-devices-to-ports">Linking Devices to Ports</a> later. It is up to driver to
manage free indices and choosing the right one. The TTY layer only refuses to
register more devices than passed to <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a>.</p>
<p>When the device is opened, the TTY layer allocates <a class="reference internal" href="tty_struct.html#c.tty_struct" title="tty_struct"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_struct</span></code></a> and starts
calling operations from <code class="xref c c-member docutils literal notranslate"><span class="pre">tty_driver.ops</span></code>, see <a class="reference internal" href="#tty-operations-reference">TTY Operations
Reference</a>.</p>
<p>The registration routines are documented as follows:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_register_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_register_device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">tty_register_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_register_device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_register_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the tty driver that describes the tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>the index in the tty driver for this tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>a <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> that is associated with this tty device.
This field is optional, if there is no known <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>
for this tty device it can be set to NULL safely.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call is required to be made to register an individual tty device
if the tty driver’s flags have the <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code> bit set.  If
that bit is not set, this function should not be called by a tty
driver.</p>
<p>Locking: ??</p>
<p><strong>Return</strong></p>
<p>A pointer to the <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> for this tty device (or
ERR_PTR(-EFOO) on error).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_register_device_attr">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_register_device_attr" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">tty_register_device_attr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_register_device_attr" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drvdata</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">attribute_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr_grp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_register_device_attr" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the tty driver that describes the tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>the index in the tty driver for this tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>a <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> that is associated with this tty device.
This field is optional, if there is no known <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>
for this tty device it can be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> safely.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*drvdata</span></code></dt><dd><p>Driver data to be set to device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**attr_grp</span></code></dt><dd><p>Attribute group to be set on device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call is required to be made to register an individual tty device if the
tty driver’s flags have the <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code> bit set. If that bit is
not set, this function should not be called by a tty driver.</p>
<p>Locking: ??</p>
<p><strong>Return</strong></p>
<p>A pointer to the <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> for this tty device (or
ERR_PTR(-EFOO) on error).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_unregister_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tty_unregister_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_unregister_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the tty driver that describes the tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>the index in the tty driver for this tty device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a tty device is registered with a call to <a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a> then
this function must be called when the tty device is gone.</p>
<p>Locking: ??</p>
</div>
</section>
<hr class="docutils" />
<section id="linking-devices-to-ports">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Linking Devices to Ports</a><a class="headerlink" href="#linking-devices-to-ports" title="Link to this heading">¶</a></h3>
<p>As stated earlier, every TTY device shall have a <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span></code></a> assigned to
it. It must be known to the TTY layer at <code class="xref c c-member docutils literal notranslate"><span class="pre">tty_driver.ops.install()</span></code>
at latest.  There are few helpers to <em>link</em> the two. Ideally, the driver uses
<a class="reference internal" href="#c.tty_port_register_device" title="tty_port_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_register_device()</span></code></a> or <a class="reference internal" href="#c.tty_port_register_device_attr" title="tty_port_register_device_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_register_device_attr()</span></code></a> instead of
<a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a> and <a class="reference internal" href="#c.tty_register_device_attr" title="tty_register_device_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device_attr()</span></code></a> at the registration time.
This way, the driver needs not care about linking later on.</p>
<p>If that is not possible, the driver still can link the tty_port to a specific
index <em>before</em> the actual registration by <a class="reference internal" href="#c.tty_port_link_device" title="tty_port_link_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_link_device()</span></code></a>. If it still
does not fit, <a class="reference internal" href="tty_port.html#c.tty_port_install" title="tty_port_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_install()</span></code></a> can be used from the
<code class="xref c c-member docutils literal notranslate"><span class="pre">tty_driver.ops.install</span></code> hook as a last resort. The last one is
dedicated mostly for in-memory devices like PTY where tty_ports are allocated
on demand.</p>
<p>The linking routines are documented here:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_port_link_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tty_port_link_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><span class="n"><span class="pre">tty_port</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_port_link_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>link tty and tty_port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span> <span class="pre">*port</span></code></dt><dd><p>tty_port of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>tty_driver for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>index of the tty</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provide the tty layer with a link from a tty (specified by <strong>index</strong>) to a
tty_port (<strong>port</strong>). Use this only if neither <a class="reference internal" href="#c.tty_port_register_device" title="tty_port_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_register_device()</span></code></a> nor
<a class="reference internal" href="tty_port.html#c.tty_port_install" title="tty_port_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_install()</span></code></a> is used in the driver. If used, this has to be called
before <a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_port_register_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_port_register_device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">tty_port_register_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><span class="n"><span class="pre">tty_port</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_port_register_device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_port_register_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>register tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span> <span class="pre">*port</span></code></dt><dd><p>tty_port of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>tty_driver for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>index of the tty</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>parent if exists, otherwise NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the same as <a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a> except the provided <strong>port</strong> is linked
to a concrete tty specified by <strong>index</strong>. Use this or <a class="reference internal" href="tty_port.html#c.tty_port_install" title="tty_port_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_install()</span></code></a> (or
both). Call <a class="reference internal" href="#c.tty_port_link_device" title="tty_port_link_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_link_device()</span></code></a> as a last resort.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.tty_port_register_device_attr">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_port_register_device_attr" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">tty_port_register_device_attr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><span class="n"><span class="pre">tty_port</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_driver" title="tty_driver"><span class="n"><span class="pre">tty_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.tty_port_register_device_attr" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drvdata</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">attribute_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr_grp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_port_register_device_attr" title="Link to this definition">¶</a><br /></dt>
<dd><p>register tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span> <span class="pre">*port</span></code></dt><dd><p>tty_port of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>tty_driver for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>index of the tty</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>parent if exists, otherwise NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*drvdata</span></code></dt><dd><p>Driver data to be set to device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**attr_grp</span></code></dt><dd><p>Attribute group to be set on device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the same as <a class="reference internal" href="#c.tty_register_device_attr" title="tty_register_device_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device_attr()</span></code></a> except the provided <strong>port</strong> is
linked to a concrete tty specified by <strong>index</strong>. Use this or <a class="reference internal" href="tty_port.html#c.tty_port_install" title="tty_port_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_install()</span></code></a>
(or both). Call <a class="reference internal" href="#c.tty_port_link_device" title="tty_port_link_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_link_device()</span></code></a> as a last resort.</p>
</div>
</section>
</section>
<hr class="docutils" />
<section id="tty-driver-reference">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">TTY Driver Reference</a><a class="headerlink" href="#tty-driver-reference" title="Link to this heading">¶</a></h2>
<p>All members of <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a> are documented here. The required members are
noted at the end. <a class="reference internal" href="#c.tty_operations" title="tty_operations"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_operations</span></code></a> are documented next.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.tty_driver">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tty_driver</span></span></span><a class="headerlink" href="#c.tty_driver" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>driver for TTY devices</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tty_driver {
    struct kref kref;
    struct cdev **cdevs;
    struct module   *owner;
    const char      *driver_name;
    const char      *name;
    int name_base;
    int major;
    int minor_start;
    unsigned int    num;
    enum tty_driver_type type;
    enum tty_driver_subtype subtype;
    struct ktermios init_termios;
    unsigned long   flags;
    struct proc_dir_entry *proc_entry;
    struct tty_driver *other;
    struct tty_struct **ttys;
    struct tty_port **ports;
    struct ktermios **termios;
    void *driver_state;
    const struct tty_operations *ops;
    struct list_head tty_drivers;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>reference counting. Reaching zero frees all the internals and the
driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cdevs</span></code></dt><dd><p>allocated/registered character /dev devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>modules owning this driver. Used drivers cannot be rmmod’ed.
Automatically set by <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_name</span></code></dt><dd><p>name of the driver used in /proc/tty</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>used for constructing /dev node name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_base</span></code></dt><dd><p>used as a number base for constructing /dev node name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">major</span></code></dt><dd><p>major /dev device number (zero for autoassignment)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor_start</span></code></dt><dd><p>the first minor /dev device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt><dd><p>number of devices allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of tty driver (enum tty_driver_type)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subtype</span></code></dt><dd><p>subtype of tty driver (enum tty_driver_subtype)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_termios</span></code></dt><dd><p>termios to set to each tty initially (e.g. <code class="docutils literal notranslate"><span class="pre">tty_std_termios</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>tty driver flags (<code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proc_entry</span></code></dt><dd><p>proc fs entry, used internally</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">other</span></code></dt><dd><p>driver of the linked tty; only used for the PTY driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ttys</span></code></dt><dd><p>array of active <a class="reference internal" href="tty_struct.html#c.tty_struct" title="tty_struct"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_struct</span></code></a>, set by <a class="reference internal" href="tty_struct.html#c.tty_standard_install" title="tty_standard_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_standard_install()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ports</span></code></dt><dd><p>array of <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span></code></a>; can be set during initialization by
<a class="reference internal" href="#c.tty_port_link_device" title="tty_port_link_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_link_device()</span></code></a> and similar</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">termios</span></code></dt><dd><p>storage for termios at each TTY close for the next open</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_state</span></code></dt><dd><p>pointer to driver’s arbitrary data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>driver hooks for TTYs. Set them using tty_set_operations(). Use <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">tty_port</span></code></a> helpers in them as much as possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tty_drivers</span></code></dt><dd><p>used internally to link tty_drivers together</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The usual handling of <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a> is to allocate it by
<a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a>, set up all the necessary members, and register it by
<a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a>. At last, the driver is torn down by calling
<a class="reference internal" href="#c.tty_unregister_driver" title="tty_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_unregister_driver()</span></code></a> followed by <a class="reference internal" href="#c.tty_driver_kref_put" title="tty_driver_kref_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_driver_kref_put()</span></code></a>.</p>
<p>The fields required to be set before calling <a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a> include
<strong>driver_name</strong>, <strong>name</strong>, <strong>type</strong>, <strong>subtype</strong>, <strong>init_termios</strong>, and <strong>ops</strong>.</p>
</section>
<hr class="docutils" />
<section id="tty-operations-reference">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">TTY Operations Reference</a><a class="headerlink" href="#tty-operations-reference" title="Link to this heading">¶</a></h2>
<p>When a TTY is registered, these driver hooks can be invoked by the TTY layer:</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.tty_operations">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tty_operations</span></span></span><a class="headerlink" href="#c.tty_operations" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>interface between driver and tty</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tty_operations {
    struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx);
    int (*install)(struct tty_driver *driver, struct tty_struct *tty);
    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
    int (*open)(struct tty_struct * tty, struct file * filp);
    void (*close)(struct tty_struct * tty, struct file * filp);
    void (*shutdown)(struct tty_struct *tty);
    void (*cleanup)(struct tty_struct *tty);
    ssize_t (*write)(struct tty_struct *tty, const u8 *buf, size_t count);
    int (*put_char)(struct tty_struct *tty, u8 ch);
    void (*flush_chars)(struct tty_struct *tty);
    unsigned int (*write_room)(struct tty_struct *tty);
    unsigned int (*chars_in_buffer)(struct tty_struct *tty);
    int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
    long (*compat_ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
    void (*set_termios)(struct tty_struct *tty, const struct ktermios *old);
    void (*throttle)(struct tty_struct * tty);
    void (*unthrottle)(struct tty_struct * tty);
    void (*stop)(struct tty_struct *tty);
    void (*start)(struct tty_struct *tty);
    void (*hangup)(struct tty_struct *tty);
    int (*break_ctl)(struct tty_struct *tty, int state);
    void (*flush_buffer)(struct tty_struct *tty);
    int (*ldisc_ok)(struct tty_struct *tty, int ldisc);
    void (*set_ldisc)(struct tty_struct *tty);
    void (*wait_until_sent)(struct tty_struct *tty, int timeout);
    void (*send_xchar)(struct tty_struct *tty, u8 ch);
    int (*tiocmget)(struct tty_struct *tty);
    int (*tiocmset)(struct tty_struct *tty, unsigned int set, unsigned int clear);
    int (*resize)(struct tty_struct *tty, struct winsize *ws);
    int (*get_icount)(struct tty_struct *tty, struct serial_icounter_struct *icount);
    int (*get_serial)(struct tty_struct *tty, struct serial_struct *p);
    int (*set_serial)(struct tty_struct *tty, struct serial_struct *p);
    void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);
#ifdef CONFIG_CONSOLE_POLL;
    int (*poll_init)(struct tty_driver *driver, int line, char *options);
    int (*poll_get_char)(struct tty_driver *driver, int line);
    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
#endif;
    int (*proc_show)(struct seq_file *m, void *driver);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">lookup</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_struct</span> <span class="pre">*()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*self,</span> <span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*,</span>
<span class="pre">int</span> <span class="pre">idx)</span></code></p>
<p>Return the tty device corresponding to <strong>idx</strong>, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is not
one currently in use and an <code class="docutils literal notranslate"><span class="pre">ERR_PTR</span></code> value on error. Called under
<code class="docutils literal notranslate"><span class="pre">tty_mutex</span></code> (for now!)</p>
<p>Optional method. Default behaviour is to use the <strong>self-&gt;ttys</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">install</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*self,</span> <span class="pre">struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>Install a new <strong>tty</strong> into the <strong>self</strong>’s internal tables. Used in
conjunction with <strong>lookup</strong> and <strong>remove</strong> methods.</p>
<p>Optional method. Default behaviour is to use the <strong>self-&gt;ttys</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*self,</span> <span class="pre">struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>Remove a closed <strong>tty</strong> from the <strong>self</strong>’s internal tables. Used in
conjunction with <strong>lookup</strong> and <strong>remove</strong> methods.</p>
<p>Optional method. Default behaviour is to use the <strong>self-&gt;ttys</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*)</span></code></p>
<p>This routine is called when a particular <strong>tty</strong> device is opened. This
routine is mandatory; if this routine is not filled in, the attempted
open will fail with <code class="docutils literal notranslate"><span class="pre">ENODEV</span></code>.</p>
<p>Required method. Called with tty lock held. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*)</span></code></p>
<p>This routine is called when a particular <strong>tty</strong> device is closed. At the
point of return from this call the driver must make no further ldisc
calls of any kind.</p>
<p>Remark: called even if the corresponding <strong>open()</strong> failed.</p>
<p>Required method. Called with tty lock held. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine is called under the tty lock when a particular <strong>tty</strong> device
is closed for the last time. It executes before the <strong>tty</strong> resources
are freed so may execute while another function holds a <strong>tty</strong> kref.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine is called asynchronously when a particular <strong>tty</strong> device
is closed for the last time freeing up the resources. This is
actually the second part of shutdown for routines that might sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*buf,</span> <span class="pre">size_t</span> <span class="pre">count)</span></code></p>
<p>This routine is called by the kernel to write a series (<strong>count</strong>) of
characters (<strong>buf</strong>) to the <strong>tty</strong> device. The characters may come from
user space or kernel space.  This routine will return the
number of characters actually accepted for writing.</p>
<p>May occur in parallel in special cases. Because this includes panic
paths drivers generally shouldn’t try and do clever locking here.</p>
<p>Optional: Required for writable devices. May not sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">put_char</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">u8</span> <span class="pre">ch)</span></code></p>
<p>This routine is called by the kernel to write a single character <strong>ch</strong> to
the <strong>tty</strong> device. If the kernel uses this routine, it must call the
<strong>flush_chars()</strong> routine (if defined) when it is done stuffing characters
into the driver. If there is no room in the queue, the character is
ignored.</p>
<p>Optional: Kernel will use the <strong>write</strong> method if not provided. Do not
call this function directly, call <a class="reference internal" href="tty_struct.html#c.tty_put_char" title="tty_put_char"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_put_char()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush_chars</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine is called by the kernel after it has written a
series of characters to the tty device using <strong>put_char()</strong>.</p>
<p>Optional. Do not call this function directly, call
tty_driver_flush_chars().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_room</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine returns the numbers of characters the <strong>tty</strong> driver
will accept for queuing to be written.  This number is subject
to change as output buffers get emptied, or if the output flow
control is acted.</p>
<p>The ldisc is responsible for being intelligent about multi-threading of
write_room/write calls</p>
<p>Required if <strong>write</strong> method is provided else not needed. Do not call this
function directly, call <a class="reference internal" href="tty_ioctl.html#c.tty_write_room" title="tty_write_room"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_write_room()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chars_in_buffer</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine returns the number of characters in the device private
output queue. Used in <a class="reference internal" href="tty_ioctl.html#c.tty_wait_until_sent" title="tty_wait_until_sent"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_wait_until_sent()</span></code></a> and for poll()
implementation.</p>
<p>Optional: if not provided, it is assumed there is no queue on the
device. Do not call this function directly, call <a class="reference internal" href="tty_ioctl.html#c.tty_chars_in_buffer" title="tty_chars_in_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_chars_in_buffer()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span>
<span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg)</span></code></p>
<p>This routine allows the <strong>tty</strong> driver to implement device-specific
ioctls. If the ioctl number passed in <strong>cmd</strong> is not recognized by the
driver, it should return <code class="docutils literal notranslate"><span class="pre">ENOIOCTLCMD</span></code>.</p>
<p>Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_ioctl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span>
<span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg)</span></code></p>
<p>Implement ioctl processing for 32 bit process on 64 bit system.</p>
<p>Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_termios</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*old)</span></code></p>
<p>This routine allows the <strong>tty</strong> driver to be notified when device’s
termios settings have changed. New settings are in <strong>tty-&gt;termios</strong>.
Previous settings are passed in the <strong>old</strong> argument.</p>
<p>The API is defined such that the driver should return the actual modes
selected. This means that the driver is responsible for modifying any
bits in <strong>tty-&gt;termios</strong> it cannot fulfill to indicate the actual modes
being used.</p>
<p>Optional. Called under the <strong>tty-&gt;termios_rwsem</strong>. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">throttle</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that input buffers for the line
discipline are close to full, and it should somehow signal that no more
characters should be sent to the <strong>tty</strong>.</p>
<p>Serialization including with <strong>unthrottle()</strong> is the job of the ldisc
layer.</p>
<p>Optional: Always invoke via <a class="reference internal" href="tty_ioctl.html#c.tty_throttle_safe" title="tty_throttle_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_throttle_safe()</span></code></a>. Called under the
<strong>tty-&gt;termios_rwsem</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unthrottle</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that it should signal that
characters can now be sent to the <strong>tty</strong> without fear of overrunning the
input buffers of the line disciplines.</p>
<p>Optional. Always invoke via <a class="reference internal" href="tty_ioctl.html#c.tty_unthrottle" title="tty_unthrottle"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_unthrottle()</span></code></a>. Called under the
<strong>tty-&gt;termios_rwsem</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that it should stop outputting
characters to the tty device.</p>
<p>Called with <strong>tty-&gt;flow.lock</strong> held. Serialized with <strong><a class="reference internal" href="../../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a></strong> method.</p>
<p>Optional. Always invoke via <a class="reference internal" href="tty_struct.html#c.stop_tty" title="stop_tty"><code class="xref c c-func docutils literal notranslate"><span class="pre">stop_tty()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that it resumed sending
characters to the <strong>tty</strong> device.</p>
<p>Called with <strong>tty-&gt;flow.lock</strong> held. Serialized with <a class="reference internal" href="../../networking/ieee802154.html#c.stop" title="stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">stop()</span></code></a> method.</p>
<p>Optional. Always invoke via <a class="reference internal" href="tty_struct.html#c.start_tty" title="start_tty"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_tty()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hangup</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that it should hang up the <strong>tty</strong>
device.</p>
<p>Optional. Called with tty lock held.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">break_ctl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">int</span> <span class="pre">state)</span></code></p>
<p>This optional routine requests the <strong>tty</strong> driver to turn on or off BREAK
status on the RS-232 port. If <strong>state</strong> is -1, then the BREAK status
should be turned on; if <strong>state</strong> is 0, then BREAK should be turned off.</p>
<p>If this routine is implemented, the high-level tty driver will handle
the following ioctls: <code class="docutils literal notranslate"><span class="pre">TCSBRK</span></code>, <code class="docutils literal notranslate"><span class="pre">TCSBRKP</span></code>, <code class="docutils literal notranslate"><span class="pre">TIOCSBRK</span></code>, <code class="docutils literal notranslate"><span class="pre">TIOCCBRK</span></code>.</p>
<p>If the driver sets <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_HARDWARE_BREAK</span></code> in <a class="reference internal" href="#c.tty_alloc_driver" title="tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_alloc_driver()</span></code></a>,
then the interface will also be called with actual times and the
hardware is expected to do the delay work itself. 0 and -1 are still
used for on/off.</p>
<p>Optional: Required for <code class="docutils literal notranslate"><span class="pre">TCSBRK</span></code>/<code class="docutils literal notranslate"><span class="pre">BRKP</span></code>/etc. handling. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush_buffer</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine discards device private output buffer. Invoked on close,
hangup, to implement <code class="docutils literal notranslate"><span class="pre">TCOFLUSH</span></code> ioctl and similar.</p>
<p>Optional: if not provided, it is assumed there is no queue on the
device. Do not call this function directly, call
<a class="reference internal" href="tty_ioctl.html#c.tty_driver_flush_buffer" title="tty_driver_flush_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_driver_flush_buffer()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ldisc_ok</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">int</span> <span class="pre">ldisc)</span></code></p>
<p>This routine allows the <strong>tty</strong> driver to decide if it can deal
with a particular <strong>ldisc</strong>.</p>
<p>Optional. Called under the <strong>tty-&gt;ldisc_sem</strong> and <strong>tty-&gt;termios_rwsem</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_ldisc</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine allows the <strong>tty</strong> driver to be notified when the device’s
line discipline is being changed. At the point this is done the
discipline is not yet usable.</p>
<p>Optional. Called under the <strong>tty-&gt;ldisc_sem</strong> and <strong>tty-&gt;termios_rwsem</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_until_sent</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">int</span> <span class="pre">timeout)</span></code></p>
<p>This routine waits until the device has written out all of the
characters in its transmitter FIFO. Or until <strong>timeout</strong> (in jiffies) is
reached.</p>
<p>Optional: If not provided, the device is assumed to have no FIFO.
Usually correct to invoke via <a class="reference internal" href="tty_ioctl.html#c.tty_wait_until_sent" title="tty_wait_until_sent"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_wait_until_sent()</span></code></a>. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_xchar</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">u8</span> <span class="pre">ch)</span></code></p>
<p>This routine is used to send a high-priority XON/XOFF character (<strong>ch</strong>)
to the <strong>tty</strong> device.</p>
<p>Optional: If not provided, then the <strong>write</strong> method is called under
the <strong>tty-&gt;atomic_write_lock</strong> to keep it serialized with the ldisc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tiocmget</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine is used to obtain the modem status bits from the <strong>tty</strong>
driver.</p>
<p>Optional: If not provided, then <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> is returned from the <code class="docutils literal notranslate"><span class="pre">TIOCMGET</span></code>
ioctl. Do not call this function directly, call <a class="reference internal" href="tty_internals.html#c.tty_tiocmget" title="tty_tiocmget"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_tiocmget()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tiocmset</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span>
<span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">set,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">clear)</span></code></p>
<p>This routine is used to set the modem status bits to the <strong>tty</strong> driver.
First, <strong>clear</strong> bits should be cleared, then <strong>set</strong> bits set.</p>
<p>Optional: If not provided, then <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> is returned from the <code class="docutils literal notranslate"><span class="pre">TIOCMSET</span></code>
ioctl. Do not call this function directly, call <a class="reference internal" href="tty_internals.html#c.tty_tiocmset" title="tty_tiocmset"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_tiocmset()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resize</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">winsize</span> <span class="pre">*ws)</span></code></p>
<p>Called when a termios request is issued which changes the requested
terminal geometry to <strong>ws</strong>.</p>
<p>Optional: the default action is to update the termios structure
without error. This is usually the correct behaviour. Drivers should
not force errors here if they are not resizable objects (e.g. a serial
line). See <a class="reference internal" href="tty_struct.html#c.tty_do_resize" title="tty_do_resize"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_do_resize()</span></code></a> if you need to wrap the standard method
in your own logic -- the usual case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_icount</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span>
<span class="pre">struct</span> <span class="pre">serial_icounter</span> <span class="pre">*icount)</span></code></p>
<p>Called when the <strong>tty</strong> device receives a <code class="docutils literal notranslate"><span class="pre">TIOCGICOUNT</span></code> ioctl. Passed a
kernel structure <strong>icount</strong> to complete.</p>
<p>Optional: called only if provided, otherwise <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> will be returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_serial</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">serial_struct</span> <span class="pre">*p)</span></code></p>
<p>Called when the <strong>tty</strong> device receives a <code class="docutils literal notranslate"><span class="pre">TIOCGSERIAL</span></code> ioctl. Passed a
kernel structure <strong>p</strong> (<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_struct</span></code>) to complete.</p>
<p>Optional: called only if provided, otherwise <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> will be returned.
Do not call this function directly, call tty_tiocgserial().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_serial</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">serial_struct</span> <span class="pre">*p)</span></code></p>
<p>Called when the <strong>tty</strong> device receives a <code class="docutils literal notranslate"><span class="pre">TIOCSSERIAL</span></code> ioctl. Passed a
kernel structure <strong>p</strong> (<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_struct</span></code>) to set the values from.</p>
<p>Optional: called only if provided, otherwise <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> will be returned.
Do not call this function directly, call tty_tiocsserial().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">show_fdinfo</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m)</span></code></p>
<p>Called when the <strong>tty</strong> device file descriptor receives a fdinfo request
from VFS (to show in /proc/&lt;pid&gt;/fdinfo/). <strong>m</strong> should be filled with
information.</p>
<p>Optional: called only if provided, otherwise nothing is written to <strong>m</strong>.
Do not call this function directly, call tty_show_fdinfo().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_init</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver,</span> <span class="pre">int</span> <span class="pre">line,</span> <span class="pre">char</span> <span class="pre">*options)</span></code></p>
<p>kgdboc support (<a class="reference internal" href="../../process/debugging/kgdb.html"><span class="doc">Using kgdb, kdb and the kernel debugger internals</span></a>). This routine is
called to initialize the HW for later use by calling <strong>poll_get_char</strong> or
<strong>poll_put_char</strong>.</p>
<p>Optional: called only if provided, otherwise skipped as a non-polling
driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_get_char</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver,</span> <span class="pre">int</span> <span class="pre">line)</span></code></p>
<p>kgdboc support (see <strong>poll_init</strong>). <strong>driver</strong> should read a character from a
tty identified by <strong>line</strong> and return it.</p>
<p>Optional: called only if <strong>poll_init</strong> provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_put_char</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver,</span> <span class="pre">int</span> <span class="pre">line,</span> <span class="pre">char</span> <span class="pre">ch)</span></code></p>
<p>kgdboc support (see <strong>poll_init</strong>). <strong>driver</strong> should write character <strong>ch</strong> to
a tty identified by <strong>line</strong>.</p>
<p>Optional: called only if <strong>poll_init</strong> provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proc_show</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">seq_file</span> <span class="pre">*m,</span> <span class="pre">void</span> <span class="pre">*driver)</span></code></p>
<p>Driver <strong>driver</strong> (cast to <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a>) can show additional info in
/proc/tty/driver/&lt;driver_name&gt;. It is enough to fill in the information
into <strong>m</strong>.</p>
<p>Optional: called only if provided, otherwise no /proc entry created.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure defines the interface between the low-level tty driver and
the tty routines. These routines can be defined. Unless noted otherwise,
they are optional, and can be filled in with a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/tty/tty_driver.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>