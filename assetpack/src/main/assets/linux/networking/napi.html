<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>NAPI &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Common Networking Struct Cachelines" href="net_cachelines/index.html" />
    <link rel="prev" title="Multi-PF Netdev" href="multi-pf-netdev.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l3"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/napi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="napi">
<span id="id1"></span><h1>NAPI<a class="headerlink" href="#napi" title="Link to this heading">¶</a></h1>
<p>NAPI is the event handling mechanism used by the Linux networking stack.
The name NAPI no longer stands for anything in particular <a class="footnote-reference brackets" href="#id3" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>In basic operation the device notifies the host about new events
via an interrupt.
The host then schedules a NAPI instance to process the events.
The device may also be polled for events via NAPI without receiving
interrupts first (<a class="reference internal" href="#poll"><span class="std std-ref">busy polling</span></a>).</p>
<p>NAPI processing usually happens in the software interrupt context,
but there is an option to use <a class="reference internal" href="#threaded"><span class="std std-ref">separate kernel threads</span></a>
for NAPI processing.</p>
<p>All in all NAPI abstracts away from the drivers the context and configuration
of event (packet Rx and Tx) processing.</p>
<section id="driver-api">
<h2>Driver API<a class="headerlink" href="#driver-api" title="Link to this heading">¶</a></h2>
<p>The two most important elements of NAPI are the struct napi_struct
and the associated poll method. struct napi_struct holds the state
of the NAPI instance while the method is the driver-specific event
handler. The method will typically free Tx packets that have been
transmitted and process newly received packets.</p>
<section id="control-api">
<span id="drv-ctrl"></span><h3>Control API<a class="headerlink" href="#control-api" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="kapi.html#c.netif_napi_add" title="netif_napi_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_add()</span></code></a> and <a class="reference internal" href="kapi.html#c.netif_napi_del" title="netif_napi_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_del()</span></code></a> add/remove a NAPI instance
from the system. The instances are attached to the netdevice passed
as argument (and will be deleted automatically when netdevice is
unregistered). Instances are added in a disabled state.</p>
<p><a class="reference internal" href="kapi.html#c.napi_enable" title="napi_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_enable()</span></code></a> and <a class="reference internal" href="kapi.html#c.napi_disable" title="napi_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_disable()</span></code></a> manage the disabled state.
A disabled NAPI can’t be scheduled and its poll method is guaranteed
to not be invoked. <a class="reference internal" href="kapi.html#c.napi_disable" title="napi_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_disable()</span></code></a> waits for ownership of the NAPI
instance to be released.</p>
<p>The control APIs are not idempotent. Control API calls are safe against
concurrent use of datapath APIs but an incorrect sequence of control API
calls may result in crashes, deadlocks, or race conditions. For example,
calling <a class="reference internal" href="kapi.html#c.napi_disable" title="napi_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_disable()</span></code></a> multiple times in a row will deadlock.</p>
</section>
<section id="datapath-api">
<h3>Datapath API<a class="headerlink" href="#datapath-api" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="kapi.html#c.napi_schedule" title="napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule()</span></code></a> is the basic method of scheduling a NAPI poll.
Drivers should call this function in their interrupt handler
(see <a class="reference internal" href="#drv-sched"><span class="std std-ref">Scheduling and IRQ masking</span></a> for more info). A successful call to <a class="reference internal" href="kapi.html#c.napi_schedule" title="napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule()</span></code></a>
will take ownership of the NAPI instance.</p>
<p>Later, after NAPI is scheduled, the driver’s poll method will be
called to process the events/packets. The method takes a <code class="docutils literal notranslate"><span class="pre">budget</span></code>
argument - drivers can process completions for any number of Tx
packets but should only process up to <code class="docutils literal notranslate"><span class="pre">budget</span></code> number of
Rx packets. Rx processing is usually much more expensive.</p>
<p>In other words for Rx processing the <code class="docutils literal notranslate"><span class="pre">budget</span></code> argument limits how many
packets driver can process in a single poll. Rx specific APIs like page
pool or XDP cannot be used at all when <code class="docutils literal notranslate"><span class="pre">budget</span></code> is 0.
skb Tx processing should happen regardless of the <code class="docutils literal notranslate"><span class="pre">budget</span></code>, but if
the argument is 0 driver cannot call any XDP (or page pool) APIs.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">budget</span></code> argument may be 0 if core tries to only process
skb Tx completions and no Rx or XDP packets.</p>
</div>
<p>The poll method returns the amount of work done. If the driver still
has outstanding work to do (e.g. <code class="docutils literal notranslate"><span class="pre">budget</span></code> was exhausted)
the poll method should return exactly <code class="docutils literal notranslate"><span class="pre">budget</span></code>. In that case,
the NAPI instance will be serviced/polled again (without the
need to be scheduled).</p>
<p>If event processing has been completed (all outstanding packets
processed) the poll method should call <a class="reference internal" href="kapi.html#c.napi_complete_done" title="napi_complete_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_complete_done()</span></code></a>
before returning. <a class="reference internal" href="kapi.html#c.napi_complete_done" title="napi_complete_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_complete_done()</span></code></a> releases the ownership
of the instance.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The case of finishing all events and using exactly <code class="docutils literal notranslate"><span class="pre">budget</span></code>
must be handled carefully. There is no way to report this
(rare) condition to the stack, so the driver must either
not call <a class="reference internal" href="kapi.html#c.napi_complete_done" title="napi_complete_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_complete_done()</span></code></a> and wait to be called again,
or return <code class="docutils literal notranslate"><span class="pre">budget</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">budget</span></code> is 0 <a class="reference internal" href="kapi.html#c.napi_complete_done" title="napi_complete_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_complete_done()</span></code></a> should never be called.</p>
</div>
</section>
<section id="call-sequence">
<h3>Call sequence<a class="headerlink" href="#call-sequence" title="Link to this heading">¶</a></h3>
<p>Drivers should not make assumptions about the exact sequencing
of calls. The poll method may be called without the driver scheduling
the instance (unless the instance is disabled). Similarly,
it’s not guaranteed that the poll method will be called, even
if <a class="reference internal" href="kapi.html#c.napi_schedule" title="napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule()</span></code></a> succeeded (e.g. if the instance gets disabled).</p>
<p>As mentioned in the <a class="reference internal" href="#drv-ctrl"><span class="std std-ref">Control API</span></a> section - <a class="reference internal" href="kapi.html#c.napi_disable" title="napi_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_disable()</span></code></a> and subsequent
calls to the poll method only wait for the ownership of the instance
to be released, not for the poll method to exit. This means that
drivers should avoid accessing any data structures after calling
<a class="reference internal" href="kapi.html#c.napi_complete_done" title="napi_complete_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_complete_done()</span></code></a>.</p>
</section>
<section id="scheduling-and-irq-masking">
<span id="drv-sched"></span><h3>Scheduling and IRQ masking<a class="headerlink" href="#scheduling-and-irq-masking" title="Link to this heading">¶</a></h3>
<p>Drivers should keep the interrupts masked after scheduling
the NAPI instance - until NAPI polling finishes any further
interrupts are unnecessary.</p>
<p>Drivers which have to mask the interrupts explicitly (as opposed
to IRQ being auto-masked by the device) should use the <a class="reference internal" href="kapi.html#c.napi_schedule_prep" title="napi_schedule_prep"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule_prep()</span></code></a>
and <a class="reference internal" href="kapi.html#c.__napi_schedule" title="__napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">__napi_schedule()</span></code></a> calls:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mydrv_mask_rxtx_irq</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* schedule after masking to avoid races */</span>
<span class="w">    </span><span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>IRQ should only be unmasked after a successful call to <a class="reference internal" href="kapi.html#c.napi_complete_done" title="napi_complete_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_complete_done()</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">budget</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">napi_complete_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span><span class="w"> </span><span class="n">work_done</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mydrv_unmask_rxtx_irq</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">work_done</span><span class="p">,</span><span class="w"> </span><span class="n">budget</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="kapi.html#c.napi_schedule_irqoff" title="napi_schedule_irqoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule_irqoff()</span></code></a> is a variant of <a class="reference internal" href="kapi.html#c.napi_schedule" title="napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule()</span></code></a> which takes advantage
of guarantees given by being invoked in IRQ context (no need to
mask interrupts). <a class="reference internal" href="kapi.html#c.napi_schedule_irqoff" title="napi_schedule_irqoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule_irqoff()</span></code></a> will fall back to <a class="reference internal" href="kapi.html#c.napi_schedule" title="napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule()</span></code></a> if
IRQs are threaded (such as if <code class="docutils literal notranslate"><span class="pre">PREEMPT_RT</span></code> is enabled).</p>
</section>
<section id="instance-to-queue-mapping">
<h3>Instance to queue mapping<a class="headerlink" href="#instance-to-queue-mapping" title="Link to this heading">¶</a></h3>
<p>Modern devices have multiple NAPI instances (struct napi_struct) per
interface. There is no strong requirement on how the instances are
mapped to queues and interrupts. NAPI is primarily a polling/processing
abstraction without specific user-facing semantics. That said, most networking
devices end up using NAPI in fairly similar ways.</p>
<p>NAPI instances most often correspond 1:1:1 to interrupts and queue pairs
(queue pair is a set of a single Rx and single Tx queue).</p>
<p>In less common cases a NAPI instance may be used for multiple queues
or Rx and Tx queues can be serviced by separate NAPI instances on a single
core. Regardless of the queue assignment, however, there is usually still
a 1:1 mapping between NAPI instances and interrupts.</p>
<p>It’s worth noting that the ethtool API uses a “channel” terminology where
each channel can be either <code class="docutils literal notranslate"><span class="pre">rx</span></code>, <code class="docutils literal notranslate"><span class="pre">tx</span></code> or <code class="docutils literal notranslate"><span class="pre">combined</span></code>. It’s not clear
what constitutes a channel; the recommended interpretation is to understand
a channel as an IRQ/NAPI which services queues of a given type. For example,
a configuration of 1 <code class="docutils literal notranslate"><span class="pre">rx</span></code>, 1 <code class="docutils literal notranslate"><span class="pre">tx</span></code> and 1 <code class="docutils literal notranslate"><span class="pre">combined</span></code> channel is expected
to utilize 3 interrupts, 2 Rx and 2 Tx queues.</p>
</section>
<section id="persistent-napi-config">
<h3>Persistent NAPI config<a class="headerlink" href="#persistent-napi-config" title="Link to this heading">¶</a></h3>
<p>Drivers often allocate and free NAPI instances dynamically. This leads to loss
of NAPI-related user configuration each time NAPI instances are reallocated.
The <a class="reference internal" href="kapi.html#c.netif_napi_add_config" title="netif_napi_add_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_add_config()</span></code></a> API prevents this loss of configuration by
associating each NAPI instance with a persistent NAPI configuration based on
a driver defined index value, like a queue number.</p>
<p>Using this API allows for persistent NAPI IDs (among other settings), which can
be beneficial to userspace programs using <code class="docutils literal notranslate"><span class="pre">SO_INCOMING_NAPI_ID</span></code>. See the
sections below for other NAPI configuration settings.</p>
<p>Drivers should try to use <a class="reference internal" href="kapi.html#c.netif_napi_add_config" title="netif_napi_add_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_add_config()</span></code></a> whenever possible.</p>
</section>
</section>
<section id="user-api">
<h2>User API<a class="headerlink" href="#user-api" title="Link to this heading">¶</a></h2>
<p>User interactions with NAPI depend on NAPI instance ID. The instance IDs
are only visible to the user thru the <code class="docutils literal notranslate"><span class="pre">SO_INCOMING_NAPI_ID</span></code> socket option.</p>
<p>Users can query NAPI IDs for a device or device queue using netlink. This can
be done programmatically in a user application or by using a script included in
the kernel source tree: <code class="docutils literal notranslate"><span class="pre">tools/net/ynl/pyynl/cli.py</span></code>.</p>
<p>For example, using the script to dump all of the queues for a device (which
will reveal each queue’s NAPI ID):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>kernel-source/tools/net/ynl/pyynl/cli.py<span class="w"> </span><span class="se">\</span>
<span class="w">          </span>--spec<span class="w"> </span>Documentation/netlink/specs/netdev.yaml<span class="w"> </span><span class="se">\</span>
<span class="w">          </span>--dump<span class="w"> </span>queue-get<span class="w"> </span><span class="se">\</span>
<span class="w">          </span>--json<span class="o">=</span><span class="s1">&#39;{&quot;ifindex&quot;: 2}&#39;</span>
</pre></div>
</div>
<p>See <code class="docutils literal notranslate"><span class="pre">Documentation/netlink/specs/netdev.yaml</span></code> for more details on
available operations and attributes.</p>
<section id="software-irq-coalescing">
<h3>Software IRQ coalescing<a class="headerlink" href="#software-irq-coalescing" title="Link to this heading">¶</a></h3>
<p>NAPI does not perform any explicit event coalescing by default.
In most scenarios batching happens due to IRQ coalescing which is done
by the device. There are cases where software coalescing is helpful.</p>
<p>NAPI can be configured to arm a repoll timer instead of unmasking
the hardware interrupts as soon as all packets are processed.
The <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> sysfs configuration of the netdevice
is reused to control the delay of the timer, while
<code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> controls the number of consecutive empty polls
before NAPI gives up and goes back to using hardware IRQs.</p>
<p>The above parameters can also be set on a per-NAPI basis using netlink via
netdev-genl. When used with netlink and configured on a per-NAPI basis, the
parameters mentioned above use hyphens instead of underscores:
<code class="docutils literal notranslate"><span class="pre">gro-flush-timeout</span></code> and <code class="docutils literal notranslate"><span class="pre">napi-defer-hard-irqs</span></code>.</p>
<p>Per-NAPI configuration can be done programmatically in a user application
or by using a script included in the kernel source tree:
<code class="docutils literal notranslate"><span class="pre">tools/net/ynl/pyynl/cli.py</span></code>.</p>
<p>For example, using the script:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>kernel-source/tools/net/ynl/pyynl/cli.py<span class="w"> </span><span class="se">\</span>
<span class="w">          </span>--spec<span class="w"> </span>Documentation/netlink/specs/netdev.yaml<span class="w"> </span><span class="se">\</span>
<span class="w">          </span>--do<span class="w"> </span>napi-set<span class="w"> </span><span class="se">\</span>
<span class="w">          </span>--json<span class="o">=</span><span class="s1">&#39;{&quot;id&quot;: 345,</span>
<span class="s1">                   &quot;defer-hard-irqs&quot;: 111,</span>
<span class="s1">                   &quot;gro-flush-timeout&quot;: 11111}&#39;</span>
</pre></div>
</div>
<p>Similarly, the parameter <code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code> can be set using netlink
via netdev-genl. There is no global sysfs parameter for this value.</p>
<p><code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code> is used to determine how long an application can
completely suspend IRQs. It is used in combination with SO_PREFER_BUSY_POLL,
which can be set on a per-epoll context basis with <code class="docutils literal notranslate"><span class="pre">EPIOCSPARAMS</span></code> ioctl.</p>
</section>
<section id="busy-polling">
<span id="poll"></span><h3>Busy polling<a class="headerlink" href="#busy-polling" title="Link to this heading">¶</a></h3>
<p>Busy polling allows a user process to check for incoming packets before
the device interrupt fires. As is the case with any busy polling it trades
off CPU cycles for lower latency (production uses of NAPI busy polling
are not well known).</p>
<p>Busy polling is enabled by either setting <code class="docutils literal notranslate"><span class="pre">SO_BUSY_POLL</span></code> on
selected sockets or using the global <code class="docutils literal notranslate"><span class="pre">net.core.busy_poll</span></code> and
<code class="docutils literal notranslate"><span class="pre">net.core.busy_read</span></code> sysctls. An io_uring API for NAPI busy polling
also exists.</p>
</section>
<section id="epoll-based-busy-polling">
<h3>epoll-based busy polling<a class="headerlink" href="#epoll-based-busy-polling" title="Link to this heading">¶</a></h3>
<p>It is possible to trigger packet processing directly from calls to
<code class="docutils literal notranslate"><span class="pre">epoll_wait</span></code>. In order to use this feature, a user application must ensure
all file descriptors which are added to an epoll context have the same NAPI ID.</p>
<p>If the application uses a dedicated acceptor thread, the application can obtain
the NAPI ID of the incoming connection using SO_INCOMING_NAPI_ID and then
distribute that file descriptor to a worker thread. The worker thread would add
the file descriptor to its epoll context. This would ensure each worker thread
has an epoll context with FDs that have the same NAPI ID.</p>
<p>Alternatively, if the application uses SO_REUSEPORT, a bpf or ebpf program can
be inserted to distribute incoming connections to threads such that each thread
is only given incoming connections with the same NAPI ID. Care must be taken to
carefully handle cases where a system may have multiple NICs.</p>
<p>In order to enable busy polling, there are two choices:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/proc/sys/net/core/busy_poll</span></code> can be set with a time in useconds to busy
loop waiting for events. This is a system-wide setting and will cause all
epoll-based applications to busy poll when they call epoll_wait. This may
not be desirable as many applications may not have the need to busy poll.</p></li>
<li><p>Applications using recent kernels can issue an ioctl on the epoll context
file descriptor to set (<code class="docutils literal notranslate"><span class="pre">EPIOCSPARAMS</span></code>) or get (<code class="docutils literal notranslate"><span class="pre">EPIOCGPARAMS</span></code>) <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">epoll_params</span></code>:, which user programs can define as follows:</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">epoll_params</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">busy_poll_usecs</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">busy_poll_budget</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">prefer_busy_poll</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* pad the struct to a multiple of 64bits */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">__pad</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="irq-mitigation">
<h3>IRQ mitigation<a class="headerlink" href="#irq-mitigation" title="Link to this heading">¶</a></h3>
<p>While busy polling is supposed to be used by low latency applications,
a similar mechanism can be used for IRQ mitigation.</p>
<p>Very high request-per-second applications (especially routing/forwarding
applications and especially applications using AF_XDP sockets) may not
want to be interrupted until they finish processing a request or a batch
of packets.</p>
<p>Such applications can pledge to the kernel that they will perform a busy
polling operation periodically, and the driver should keep the device IRQs
permanently masked. This mode is enabled by using the <code class="docutils literal notranslate"><span class="pre">SO_PREFER_BUSY_POLL</span></code>
socket option. To avoid system misbehavior the pledge is revoked
if <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> passes without any busy poll call. For epoll-based
busy polling applications, the <code class="docutils literal notranslate"><span class="pre">prefer_busy_poll</span></code> field of <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">epoll_params</span></code> can be set to 1 and the <code class="docutils literal notranslate"><span class="pre">EPIOCSPARAMS</span></code> ioctl can be issued to
enable this mode. See the above section for more details.</p>
<p>The NAPI budget for busy polling is lower than the default (which makes
sense given the low latency intention of normal busy polling). This is
not the case with IRQ mitigation, however, so the budget can be adjusted
with the <code class="docutils literal notranslate"><span class="pre">SO_BUSY_POLL_BUDGET</span></code> socket option. For epoll-based busy polling
applications, the <code class="docutils literal notranslate"><span class="pre">busy_poll_budget</span></code> field can be adjusted to the desired value
in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">epoll_params</span></code> and set on a specific epoll context using the <code class="docutils literal notranslate"><span class="pre">EPIOCSPARAMS</span></code>
ioctl. See the above section for more details.</p>
<p>It is important to note that choosing a large value for <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code>
will defer IRQs to allow for better batch processing, but will induce latency
when the system is not fully loaded. Choosing a small value for
<code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> can cause interference of the user application which is
attempting to busy poll by device IRQs and softirq processing. This value
should be chosen carefully with these tradeoffs in mind. epoll-based busy
polling applications may be able to mitigate how much user processing happens
by choosing an appropriate value for <code class="docutils literal notranslate"><span class="pre">maxevents</span></code>.</p>
<p>Users may want to consider an alternate approach, IRQ suspension, to help deal
with these tradeoffs.</p>
</section>
<section id="irq-suspension">
<h3>IRQ suspension<a class="headerlink" href="#irq-suspension" title="Link to this heading">¶</a></h3>
<p>IRQ suspension is a mechanism wherein device IRQs are masked while epoll
triggers NAPI packet processing.</p>
<p>While application calls to epoll_wait successfully retrieve events, the kernel will
defer the IRQ suspension timer. If the kernel does not retrieve any events
while busy polling (for example, because network traffic levels subsided), IRQ
suspension is disabled and the IRQ mitigation strategies described above are
engaged.</p>
<p>This allows users to balance CPU consumption with network processing
efficiency.</p>
<p>To use this mechanism:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The per-NAPI config parameter <code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code> should be set to the
maximum time (in nanoseconds) the application can have its IRQs
suspended. This is done using netlink, as described above. This timeout
serves as a safety mechanism to restart IRQ driver interrupt processing if
the application has stalled. This value should be chosen so that it covers
the amount of time the user application needs to process data from its
call to epoll_wait, noting that applications can control how much data
they retrieve by setting <code class="docutils literal notranslate"><span class="pre">max_events</span></code> when calling epoll_wait.</p></li>
<li><p>The sysfs parameter or per-NAPI config parameters <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code>
and <code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> can be set to low values. They will be used
to defer IRQs after busy poll has found no data.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">prefer_busy_poll</span></code> flag must be set to true. This can be done using
the <code class="docutils literal notranslate"><span class="pre">EPIOCSPARAMS</span></code> ioctl as described above.</p></li>
<li><p>The application uses epoll as described above to trigger NAPI packet
processing.</p></li>
</ol>
</div></blockquote>
<p>As mentioned above, as long as subsequent calls to epoll_wait return events to
userland, the <code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code> is deferred and IRQs are disabled. This
allows the application to process data without interference.</p>
<p>Once a call to epoll_wait results in no events being found, IRQ suspension is
automatically disabled and the <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> and
<code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> mitigation mechanisms take over.</p>
<p>It is expected that <code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code> will be set to a value much larger
than <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> as <code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code> should suspend IRQs for
the duration of one userland processing cycle.</p>
<p>While it is not strictly necessary to use <code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> and
<code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> to use IRQ suspension, their use is strongly
recommended.</p>
<p>IRQ suspension causes the system to alternate between polling mode and
irq-driven packet delivery. During busy periods, <code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code>
overrides <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> and keeps the system busy polling, but when
epoll finds no events, the setting of <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> and
<code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> determine the next step.</p>
<p>There are essentially three possible loops for network processing and
packet delivery:</p>
<ol class="arabic simple">
<li><p>hardirq -&gt; softirq -&gt; napi poll; basic interrupt delivery</p></li>
<li><p>timer -&gt; softirq -&gt; napi poll; deferred irq processing</p></li>
<li><p>epoll -&gt; busy-poll -&gt; napi poll; busy looping</p></li>
</ol>
<p>Loop 2 can take control from Loop 1, if <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> and
<code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> are set.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> and <code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> are set, Loops 2
and 3 “wrestle” with each other for control.</p>
<p>During busy periods, <code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code> is used as timer in Loop 2,
which essentially tilts network processing in favour of Loop 3.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> and <code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> are not set, Loop 3
cannot take control from Loop 1.</p>
<p>Therefore, setting <code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code> and <code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code> is
the recommended usage, because otherwise setting <code class="docutils literal notranslate"><span class="pre">irq-suspend-timeout</span></code>
might not have any discernible effect.</p>
</section>
<section id="threaded-napi">
<span id="threaded"></span><h3>Threaded NAPI<a class="headerlink" href="#threaded-napi" title="Link to this heading">¶</a></h3>
<p>Threaded NAPI is an operating mode that uses dedicated kernel
threads rather than software IRQ context for NAPI processing.
The configuration is per netdevice and will affect all
NAPI instances of that device. Each NAPI instance will spawn a separate
thread (called <code class="docutils literal notranslate"><span class="pre">napi/${ifc-name}-${napi-id}</span></code>).</p>
<p>It is recommended to pin each kernel thread to a single CPU, the same
CPU as the CPU which services the interrupt. Note that the mapping
between IRQs and NAPI instances may not be trivial (and is driver
dependent). The NAPI instance IDs will be assigned in the opposite
order than the process IDs of the kernel threads.</p>
<p>Threaded NAPI is controlled by writing 0/1 to the <code class="docutils literal notranslate"><span class="pre">threaded</span></code> file in
netdev’s sysfs directory.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>NAPI was originally referred to as New API in 2.4 Linux.</p>
</aside>
</aside>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/networking/napi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>