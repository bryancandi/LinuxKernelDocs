<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Page Pool API &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PHY Abstraction Layer" href="phy.html" />
    <link rel="prev" title="NET_FAILOVER" href="net_failover.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l3"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/page_pool.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="page-pool-api">
<h1>Page Pool API<a class="headerlink" href="#page-pool-api" title="Link to this heading">¶</a></h1>
<p>The page_pool allocator is optimized for recycling page or page fragment used
by skb packet and xdp frame.</p>
<p>Basic use involves replacing any <a class="reference internal" href="../core-api/mm-api.html#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a> calls with page_pool_alloc(),
which allocate memory with or without page splitting depending on the
requested memory size.</p>
<p>If the driver knows that it always requires full pages or its allocations are
always smaller than half a page, it can use one of the more specific API
calls:</p>
<p>1. page_pool_alloc_pages(): allocate memory without page splitting when
driver knows that the memory it need is always bigger than half of the page
allocated from page pool. There is no cache line dirtying for ‘struct page’
when a page is recycled back to the page pool.</p>
<p>2. page_pool_alloc_frag(): allocate memory with page splitting when driver
knows that the memory it need is always smaller than or equal to half of the
page allocated from page pool. Page splitting enables memory saving and thus
avoids TLB/cache miss for data access, but there also is some cost to
implement page splitting, mainly some cache line dirtying/bouncing for
‘struct page’ and atomic operation for page-&gt;pp_ref_count.</p>
<p>The API keeps track of in-flight pages, in order to let API users know when
it is safe to free a page_pool object, the API users must call
<a class="reference internal" href="#c.page_pool_put_page" title="page_pool_put_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_pool_put_page()</span></code></a> or <a class="reference internal" href="#c.page_pool_free_va" title="page_pool_free_va"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_pool_free_va()</span></code></a> to free the page_pool object, or
attach the page_pool object to a page_pool-aware object like skbs marked with
skb_mark_for_recycle().</p>
<p><a class="reference internal" href="#c.page_pool_put_page" title="page_pool_put_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_pool_put_page()</span></code></a> may be called multiple times on the same page if a page
is split into multiple fragments. For the last fragment, it will either
recycle the page, or in case of page-&gt;_refcount &gt; 1, it will release the DMA
mapping and in-flight state accounting.</p>
<p>dma_sync_single_range_for_device() is only called for the last fragment when
page_pool is created with PP_FLAG_DMA_SYNC_DEV flag, so it depends on the
last freed fragment to do the sync_for_device operation for all fragments in
the same page when a page is split. The API user must setup pool-&gt;p.max_len
and pool-&gt;p.offset correctly and ensure that <a class="reference internal" href="#c.page_pool_put_page" title="page_pool_put_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_pool_put_page()</span></code></a> is called
with dma_sync_size being -1 for fragment API.</p>
<section id="architecture-overview">
<h2>Architecture overview<a class="headerlink" href="#architecture-overview" title="Link to this heading">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+------------------+
|       Driver     |
+------------------+
        ^
        |
        |
        |
        v
+--------------------------------------------+
|                request memory              |
+--------------------------------------------+
    ^                                  ^
    |                                  |
    | Pool empty                       | Pool has entries
    |                                  |
    v                                  v
+-----------------------+     +------------------------+
| alloc (and map) pages |     |  get page from cache   |
+-----------------------+     +------------------------+
                                ^                    ^
                                |                    |
                                | cache available    | No entries, refill
                                |                    | from ptr-ring
                                |                    |
                                v                    v
                      +-----------------+     +------------------+
                      |   Fast cache    |     |  ptr-ring cache  |
                      +-----------------+     +------------------+
</pre></div>
</div>
</section>
<section id="monitoring">
<h2>Monitoring<a class="headerlink" href="#monitoring" title="Link to this heading">¶</a></h2>
<p>Information about page pools on the system can be accessed via the netdev
genetlink family (see Documentation/netlink/specs/netdev.yaml).</p>
</section>
<section id="api-interface">
<h2>API interface<a class="headerlink" href="#api-interface" title="Link to this heading">¶</a></h2>
<p>The number of pools created <strong>must</strong> match the number of hardware queues
unless hardware restrictions make that impossible. This would otherwise beat the
purpose of page pool, which is allocate pages fast from cache without locking.
This lockless guarantee naturally comes from running under a NAPI softirq.
The protection doesn’t strictly have to be NAPI, any guarantee that allocating
a page will cause no race conditions is enough.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_pool_params" title="page_pool_params"><span class="n"><span class="pre">page_pool_params</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a page pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page_pool_params</span> <span class="pre">*params</span></code></dt><dd><p>parameters, see <a class="reference internal" href="#c.page_pool_params" title="page_pool_params"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool_params</span></code></a></p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.page_pool_params">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_params</span></span></span><a class="headerlink" href="#c.page_pool_params" title="Link to this definition">¶</a><br /></dt>
<dd><p>page pool parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct page_pool_params {
    struct page_pool_params_fast  fast;
    unsigned int    order;
    unsigned int    pool_size;
    int nid;
    struct device   *dev;
    struct napi_struct *napi;
    enum dma_data_direction dma_dir;
    unsigned int    max_len;
    unsigned int    offset;
    struct page_pool_params_slow  slow;
    STRUCT_GROUP( struct net_device *netdev;
    unsigned int queue_idx;
    unsigned int    flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fast</span></code></dt><dd><p>params accessed frequently on hotpath</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">order</span></code></dt><dd><p>2^order pages on allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pool_size</span></code></dt><dd><p>size of the ptr_ring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nid</span></code></dt><dd><p>NUMA node id to allocate from pages from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device, for DMA pre-mapping purposes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">napi</span></code></dt><dd><p>NAPI which is the sole consumer of pages, otherwise NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_dir</span></code></dt><dd><p>DMA mapping direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_len</span></code></dt><dd><p>max DMA sync memory size for PP_FLAG_DMA_SYNC_DEV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>DMA sync address offset for PP_FLAG_DMA_SYNC_DEV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slow</span></code></dt><dd><p>params with slowpath access only (initialization and Netlink)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev</span></code></dt><dd><p>netdev this pool will serve (leave as NULL if none or multiple)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue_idx</span></code></dt><dd><p>queue idx this page_pool is being created for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>PP_FLAG_DMA_MAP, PP_FLAG_DMA_SYNC_DEV, PP_FLAG_SYSTEM_POOL,
PP_FLAG_ALLOW_UNREADABLE_NETMEM.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_dev_alloc_pages">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_dev_alloc_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_dev_alloc_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a page.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a page from the page allocator or page_pool caches.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_dev_alloc_frag">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_dev_alloc_frag</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">offset</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_dev_alloc_frag" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a page fragment.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*offset</span></code></dt><dd><p>offset to the allocated page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>requested size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a page fragment from the page allocator or page_pool caches.</p>
<p><strong>Return</strong></p>
<p>allocated page fragment, otherwise return NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_dev_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_dev_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">offset</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_dev_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a page or a page fragment.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*offset</span></code></dt><dd><p>offset to the allocated page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*size</span></code></dt><dd><p>in as the requested size, out as the allocated size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a page or a page fragment from the page allocator or page_pool caches
depending on the requested size in order to allocate memory with least memory
utilization and performance penalty.</p>
<p><strong>Return</strong></p>
<p>allocated page or page fragment, otherwise return NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_dev_alloc_va">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_dev_alloc_va</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_dev_alloc_va" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a page or a page fragment and return its va.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*size</span></code></dt><dd><p>in as the requested size, out as the allocated size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is just a thin wrapper around the page_pool_alloc() API, and
it returns va of the allocated page or page fragment.</p>
<p><strong>Return</strong></p>
<p>the va for the allocated page or page fragment, otherwise return NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_get_dma_dir">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">dma_data_direction</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_get_dma_dir</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_get_dma_dir" title="Link to this definition">¶</a><br /></dt>
<dd><p>Retrieve the stored DMA direction.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which page was allocated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the stored dma direction. A driver might decide to store this locally
and avoid the extra cache line from page_pool to determine the direction.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_put_page">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_put_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_pool_put_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dma_sync_size</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">allow_direct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_put_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a reference to a page pool page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which page was allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to release a reference on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dma_sync_size</span></code></dt><dd><p>how much of the page may have been touched by the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">allow_direct</span></code></dt><dd><p>released by the consumer, allow lockless caching</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The outcome of this depends on the page refcnt. If the driver bumps
the refcnt &gt; 1 this will unmap the page. If the page refcnt is 1
the allocator owns the page and will try to recycle it in one of the pool
caches. If PP_FLAG_DMA_SYNC_DEV is set, the page will be synced for_device
using dma_sync_single_range_for_device().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_put_full_page">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_put_full_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_pool_put_full_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">allow_direct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_put_full_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a reference on a page pool page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which page was allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to release a reference on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">allow_direct</span></code></dt><dd><p>released by the consumer, allow lockless caching</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.page_pool_put_page" title="page_pool_put_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_pool_put_page()</span></code></a>, but will DMA sync the entire memory area
as configured in <a class="reference internal" href="#c.page_pool_params" title="page_pool_params"><code class="xref c c-type docutils literal notranslate"><span class="pre">page_pool_params.max_len</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_recycle_direct">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_recycle_direct</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_pool_recycle_direct" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_recycle_direct" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a reference on a page pool page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which page was allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to release a reference on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.page_pool_put_full_page" title="page_pool_put_full_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_pool_put_full_page()</span></code></a> but caller must guarantee safe context
(e.g NAPI), since it will recycle the page directly into the pool fast cache.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_free_va">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_free_va</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">va</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">allow_direct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_free_va" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a va into the page_pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which va was allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*va</span></code></dt><dd><p>va to be freed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">allow_direct</span></code></dt><dd><p>freed by the consumer, allow lockless caching</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free a va allocated from page_pool_allo_va().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_get_dma_addr">
<span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_get_dma_addr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_pool_get_dma_addr" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_get_dma_addr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Retrieve the stored DMA address.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page allocated from a page pool</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fetch the DMA address of the page. The page pool to which the page belongs
must had been created with PP_FLAG_DMA_MAP.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pool_get_stats">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_get_stats</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_pool_stats" title="page_pool_stats"><span class="n"><span class="pre">page_pool_stats</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">stats</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pool_get_stats" title="Link to this definition">¶</a><br /></dt>
<dd><p>fetch page pool stats</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool from which page was allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool_stats</span> <span class="pre">*stats</span></code></dt><dd><p><a class="reference internal" href="#c.page_pool_stats" title="page_pool_stats"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool_stats</span></code></a> to fill in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve statistics about the page_pool. This API is only available
if the kernel has been configured with <code class="docutils literal notranslate"><span class="pre">CONFIG_PAGE_POOL_STATS=y</span></code>.
A pointer to a caller allocated <a class="reference internal" href="#c.page_pool_stats" title="page_pool_stats"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool_stats</span></code></a> structure
is passed to this API which is filled in. The caller can then report
those stats to the user (perhaps via ethtool, debugfs, etc.).</p>
</div>
<section id="dma-sync">
<h3>DMA sync<a class="headerlink" href="#dma-sync" title="Link to this heading">¶</a></h3>
<p>Driver is always responsible for syncing the pages for the CPU.
Drivers may choose to take care of syncing for the device as well
or set the <code class="docutils literal notranslate"><span class="pre">PP_FLAG_DMA_SYNC_DEV</span></code> flag to request that pages
allocated from the page pool are already synced for the device.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">PP_FLAG_DMA_SYNC_DEV</span></code> is set, the driver must inform the core what portion
of the buffer has to be synced. This allows the core to avoid syncing the entire
page when the drivers knows that the device only accessed a portion of the page.</p>
<p>Most drivers will reserve headroom in front of the frame. This part
of the buffer is not touched by the device, so to avoid syncing
it drivers can set the <code class="docutils literal notranslate"><span class="pre">offset</span></code> field in <a class="reference internal" href="#c.page_pool_params" title="page_pool_params"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool_params</span></code></a>
appropriately.</p>
<p>For pages recycled on the XDP xmit and skb paths the page pool will
use the <code class="docutils literal notranslate"><span class="pre">max_len</span></code> member of <a class="reference internal" href="#c.page_pool_params" title="page_pool_params"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool_params</span></code></a> to decide how
much of the page needs to be synced (starting at <code class="docutils literal notranslate"><span class="pre">offset</span></code>).
When directly freeing pages in the driver (<a class="reference internal" href="#c.page_pool_put_page" title="page_pool_put_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_pool_put_page()</span></code></a>)
the <code class="docutils literal notranslate"><span class="pre">dma_sync_size</span></code> argument specifies how much of the buffer needs
to be synced.</p>
<p>If in doubt set <code class="docutils literal notranslate"><span class="pre">offset</span></code> to 0, <code class="docutils literal notranslate"><span class="pre">max_len</span></code> to <code class="docutils literal notranslate"><span class="pre">PAGE_SIZE</span></code> and
pass -1 as <code class="docutils literal notranslate"><span class="pre">dma_sync_size</span></code>. That combination of arguments is always
correct.</p>
<p>Note that the syncing parameters are for the entire page.
This is important to remember when using fragments (<code class="docutils literal notranslate"><span class="pre">PP_FLAG_PAGE_FRAG</span></code>),
where allocated buffers may be smaller than a full page.
Unless the driver author really understands page pool internals
it’s recommended to always use <code class="docutils literal notranslate"><span class="pre">offset</span> <span class="pre">=</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">max_len</span> <span class="pre">=</span> <span class="pre">PAGE_SIZE</span></code>
with fragmented page pools.</p>
</section>
<section id="stats-api-and-structures">
<h3>Stats API and structures<a class="headerlink" href="#stats-api-and-structures" title="Link to this heading">¶</a></h3>
<p>If the kernel is configured with <code class="docutils literal notranslate"><span class="pre">CONFIG_PAGE_POOL_STATS=y</span></code>, the API
<a class="reference internal" href="#c.page_pool_get_stats" title="page_pool_get_stats"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_pool_get_stats()</span></code></a> and structures described below are available.
It takes a  pointer to a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool</span></code> and a pointer to a <a class="reference internal" href="#c.page_pool_stats" title="page_pool_stats"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">page_pool_stats</span></code></a> allocated by the caller.</p>
<p>Older drivers expose page pool statistics via ethtool or debugfs.
The same statistics are accessible via the netlink netdev family
in a driver-independent fashion.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.page_pool_alloc_stats">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_alloc_stats</span></span></span><a class="headerlink" href="#c.page_pool_alloc_stats" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocation statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct page_pool_alloc_stats {
    u64 fast;
    u64 slow;
    u64 slow_high_order;
    u64 empty;
    u64 refill;
    u64 waive;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fast</span></code></dt><dd><p>successful fast path allocations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slow</span></code></dt><dd><p>slow path order-0 allocations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slow_high_order</span></code></dt><dd><p>slow path high order allocations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">empty</span></code></dt><dd><p>ptr ring is empty, so a slow path allocation was forced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refill</span></code></dt><dd><p>an allocation which triggered a refill of the cache</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">waive</span></code></dt><dd><p>pages obtained from the ptr ring that cannot be added to
the cache due to a NUMA mismatch</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.page_pool_recycle_stats">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_recycle_stats</span></span></span><a class="headerlink" href="#c.page_pool_recycle_stats" title="Link to this definition">¶</a><br /></dt>
<dd><p>recycling (freeing) statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct page_pool_recycle_stats {
    u64 cached;
    u64 cache_full;
    u64 ring;
    u64 ring_full;
    u64 released_refcnt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cached</span></code></dt><dd><p>recycling placed page in the page pool cache</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache_full</span></code></dt><dd><p>page pool cache was full</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ring</span></code></dt><dd><p>page placed into the ptr ring</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ring_full</span></code></dt><dd><p>page released from page pool because the ptr ring was full</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">released_refcnt</span></code></dt><dd><p>page released (and not recycled) because refcnt &gt; 1</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.page_pool_stats">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pool_stats</span></span></span><a class="headerlink" href="#c.page_pool_stats" title="Link to this definition">¶</a><br /></dt>
<dd><p>combined page pool use statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct page_pool_stats {
    struct page_pool_alloc_stats alloc_stats;
    struct page_pool_recycle_stats recycle_stats;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">alloc_stats</span></code></dt><dd><p>see <a class="reference internal" href="#c.page_pool_alloc_stats" title="page_pool_alloc_stats"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool_alloc_stats</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">recycle_stats</span></code></dt><dd><p>see <a class="reference internal" href="#c.page_pool_recycle_stats" title="page_pool_recycle_stats"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_pool_recycle_stats</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Wrapper struct for combining page pool stats with different storage
requirements.</p>
</section>
</section>
<section id="coding-examples">
<h2>Coding examples<a class="headerlink" href="#coding-examples" title="Link to this heading">¶</a></h2>
<section id="registration">
<h3>Registration<a class="headerlink" href="#registration" title="Link to this heading">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Page pool registration */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">page_pool_params</span><span class="w"> </span><span class="n">pp_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">xdp_rxq_info</span><span class="w"> </span><span class="n">xdp_rxq</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>

<span class="n">pp_params</span><span class="p">.</span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="cm">/* internal DMA mapping in page_pool */</span>
<span class="n">pp_params</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PP_FLAG_DMA_MAP</span><span class="p">;</span>
<span class="n">pp_params</span><span class="p">.</span><span class="n">pool_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DESC_NUM</span><span class="p">;</span>
<span class="n">pp_params</span><span class="p">.</span><span class="n">nid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUMA_NO_NODE</span><span class="p">;</span>
<span class="n">pp_params</span><span class="p">.</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
<span class="n">pp_params</span><span class="p">.</span><span class="n">napi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">napi</span><span class="p">;</span><span class="w"> </span><span class="cm">/* only if locking is tied to NAPI */</span>
<span class="n">pp_params</span><span class="p">.</span><span class="n">dma_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xdp_prog</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">DMA_BIDIRECTIONAL</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
<span class="n">page_pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">page_pool_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pp_params</span><span class="p">);</span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xdp_rxq_info_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xdp_rxq</span><span class="p">,</span><span class="w"> </span><span class="n">ndev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">err_out</span><span class="p">;</span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xdp_rxq_info_reg_mem_model</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xdp_rxq</span><span class="p">,</span><span class="w"> </span><span class="n">MEM_TYPE_PAGE_POOL</span><span class="p">,</span><span class="w"> </span><span class="n">page_pool</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">err_out</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="napi-poller">
<h3>NAPI poller<a class="headerlink" href="#napi-poller" title="Link to this heading">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* NAPI Rx poller */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">dma_data_direction</span><span class="w"> </span><span class="n">dma_dir</span><span class="p">;</span>

<span class="n">dma_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">page_pool_get_dma_dir</span><span class="p">(</span><span class="n">dring</span><span class="o">-&gt;</span><span class="n">page_pool</span><span class="p">);</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">done</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">budget</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">some</span><span class="w"> </span><span class="n">error</span><span class="p">)</span>
<span class="w">        </span><span class="n">page_pool_recycle_direct</span><span class="p">(</span><span class="n">page_pool</span><span class="p">,</span><span class="w"> </span><span class="n">page</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">packet_is_xdp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">XDP_DROP</span><span class="o">:</span>
<span class="w">            </span><span class="n">page_pool_recycle_direct</span><span class="p">(</span><span class="n">page_pool</span><span class="p">,</span><span class="w"> </span><span class="n">page</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="n">packet_is_skb</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">skb_mark_for_recycle</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="w">        </span><span class="n">new_page</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">page_pool_dev_alloc_pages</span><span class="p">(</span><span class="n">page_pool</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="stats">
<h3>Stats<a class="headerlink" href="#stats" title="Link to this heading">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef CONFIG_PAGE_POOL_STATS</span>
<span class="cm">/* retrieve stats */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">page_pool_stats</span><span class="w"> </span><span class="n">stats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">page_pool_get_stats</span><span class="p">(</span><span class="n">page_pool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stats</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* perhaps the driver reports statistics with ethool */</span>
<span class="w">        </span><span class="n">ethtool_print_allocation_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="p">.</span><span class="n">alloc_stats</span><span class="p">);</span>
<span class="w">        </span><span class="n">ethtool_print_recycle_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="p">.</span><span class="n">recycle_stats</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
<section id="driver-unload">
<h3>Driver unload<a class="headerlink" href="#driver-unload" title="Link to this heading">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Driver unload */</span>
<span class="n">page_pool_put_full_page</span><span class="p">(</span><span class="n">page_pool</span><span class="p">,</span><span class="w"> </span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="n">xdp_rxq_info_unreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xdp_rxq</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/networking/page_pool.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>