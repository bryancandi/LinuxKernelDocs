<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>J1939 Documentation &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux Networking and Network Devices APIs" href="kapi.html" />
    <link rel="prev" title="ISO 15765-2 (ISO-TP)" href="iso15765-2.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l3"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/j1939.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="j1939-documentation">
<h1>J1939 Documentation<a class="headerlink" href="#j1939-documentation" title="Link to this heading">¶</a></h1>
<section id="overview-what-is-j1939">
<h2>Overview / What Is J1939<a class="headerlink" href="#overview-what-is-j1939" title="Link to this heading">¶</a></h2>
<p>SAE J1939 defines a higher layer protocol on CAN. It implements a more
sophisticated addressing scheme and extends the maximum packet size above 8
bytes. Several derived specifications exist, which differ from the original
J1939 on the application level, like MilCAN A, NMEA2000, and especially
ISO-11783 (ISOBUS). This last one specifies the so-called ETP (Extended
Transport Protocol), which has been included in this implementation. This
results in a maximum packet size of ((2 ^ 24) - 1) * 7 bytes == 111 MiB.</p>
<section id="specifications-used">
<h3>Specifications used<a class="headerlink" href="#specifications-used" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>SAE J1939-21 : data link layer</p></li>
<li><p>SAE J1939-81 : network management</p></li>
<li><p>ISO 11783-6  : Virtual Terminal (Extended Transport Protocol)</p></li>
</ul>
</section>
</section>
<section id="motivation">
<span id="j1939-motivation"></span><h2>Motivation<a class="headerlink" href="#motivation" title="Link to this heading">¶</a></h2>
<p>Given the fact there’s something like SocketCAN with an API similar to BSD
sockets, we found some reasons to justify a kernel implementation for the
addressing and transport methods used by J1939.</p>
<ul class="simple">
<li><p><strong>Addressing:</strong> when a process on an ECU communicates via J1939, it should
not necessarily know its source address. Although, at least one process per
ECU should know the source address. Other processes should be able to reuse
that address. This way, address parameters for different processes
cooperating for the same ECU, are not duplicated. This way of working is
closely related to the UNIX concept, where programs do just one thing and do
it well.</p></li>
<li><p><strong>Dynamic addressing:</strong> Address Claiming in J1939 is time critical.
Furthermore, data transport should be handled properly during the address
negotiation. Putting this functionality in the kernel eliminates it as a
requirement for _every_ user space process that communicates via J1939. This
results in a consistent J1939 bus with proper addressing.</p></li>
<li><p><strong>Transport:</strong> both TP &amp; ETP reuse some PGNs to relay big packets over them.
Different processes may thus use the same TP &amp; ETP PGNs without actually
knowing it. The individual TP &amp; ETP sessions _must_ be serialized
(synchronized) between different processes. The kernel solves this problem
properly and eliminates the serialization (synchronization) as a requirement
for _every_ user space process that communicates via J1939.</p></li>
</ul>
<p>J1939 defines some other features (relaying, gateway, fast packet transport,
...). In-kernel code for these would not contribute to protocol stability.
Therefore, these parts are left to user space.</p>
<p>The J1939 sockets operate on CAN network devices (see SocketCAN). Any J1939
user space library operating on CAN raw sockets will still operate properly.
Since such a library does not communicate with the in-kernel implementation, care
must be taken that these two do not interfere. In practice, this means they
cannot share ECU addresses. A single ECU (or virtual ECU) address is used by
the library exclusively, or by the in-kernel system exclusively.</p>
</section>
<section id="j1939-concepts">
<h2>J1939 concepts<a class="headerlink" href="#j1939-concepts" title="Link to this heading">¶</a></h2>
<section id="data-sent-to-the-j1939-stack">
<h3>Data Sent to the J1939 Stack<a class="headerlink" href="#data-sent-to-the-j1939-stack" title="Link to this heading">¶</a></h3>
<p>The data buffers sent to the J1939 stack from user space are not CAN frames
themselves. Instead, they are payloads that the J1939 stack converts into
proper CAN frames based on the size of the buffer and the type of transfer. The
size of the buffer influences how the stack processes the data and determines
the internal code path used for the transfer.</p>
<p><strong>Handling of Different Buffer Sizes:</strong></p>
<ul class="simple">
<li><p><strong>Buffers with a size of 8 bytes or less:</strong></p>
<ul>
<li><p>These are handled as simple sessions internally within the stack.</p></li>
<li><p>The stack converts the buffer directly into a single CAN frame without
fragmentation.</p></li>
<li><p>This type of transfer does not require an actual client (receiver) on the
receiving side.</p></li>
</ul>
</li>
<li><p><strong>Buffers up to 1785 bytes:</strong></p>
<ul>
<li><p>These are automatically handled as J1939 Transport Protocol (TP) transfers.</p></li>
<li><p>Internally, the stack splits the buffer into multiple 8-byte CAN frames.</p></li>
<li><p>TP transfers can be unicast or broadcast.</p></li>
<li><p><strong>Broadcast TP:</strong> Does not require a receiver on the other side and can be
used in broadcast scenarios.</p></li>
<li><p><strong>Unicast TP:</strong> Requires an active receiver (client) on the other side to
acknowledge the transfer.</p></li>
</ul>
</li>
<li><p><strong>Buffers from 1786 bytes up to 111 MiB:</strong></p>
<ul>
<li><p>These are handled as ISO 11783 Extended Transport Protocol (ETP) transfers.</p></li>
<li><p>ETP transfers are used for larger payloads and are split into multiple CAN
frames internally.</p></li>
<li><p><strong>ETP transfers (unicast):</strong> Require a receiver on the other side to
process the incoming data and acknowledge each step of the transfer.</p></li>
<li><p>ETP transfers cannot be broadcast like TP transfers, and always require a
receiver for operation.</p></li>
</ul>
</li>
</ul>
<p><strong>Non-Blocking Operation with `MSG_DONTWAIT`:</strong></p>
<p>The J1939 stack supports non-blocking operation when used in combination with
the <cite>MSG_DONTWAIT</cite> flag. In this mode, the stack attempts to take as much data
as the available memory for the socket allows. It returns the amount of data
that was successfully taken, and it is the responsibility of user space to
monitor this value and handle partial transfers.</p>
<ul class="simple">
<li><p>If the stack cannot take the entire buffer, it returns the number of bytes
successfully taken, and user space should handle the remainder.</p></li>
<li><p><strong>Error handling:</strong> When using <cite>MSG_DONTWAIT</cite>, the user must rely on the
error queue to detect transfer errors. See the <strong>SO_J1939_ERRQUEUE</strong> section
for details on how to subscribe to error notifications. Without the error
queue, there is no other way for user space to be notified of transfer errors
during non-blocking operations.</p></li>
</ul>
<p><strong>Behavior and Requirements:</strong></p>
<ul class="simple">
<li><p><strong>Simple transfers (&lt;= 8 bytes):</strong> Do not require a receiver on the other
side, making them easy to send without needing address claiming or
coordination with a destination.</p></li>
<li><p><strong>Unicast TP/ETP:</strong> Requires a receiver on the other side to complete the
transfer. The receiver must acknowledge the transfer for the session to
proceed successfully.</p></li>
<li><p><strong>Broadcast TP:</strong> Allows sending data without a receiver, but only works for
TP transfers. ETP cannot be broadcast and always needs a receiving client.</p></li>
</ul>
<p>These different behaviors depend heavily on the size of the buffer provided to
the stack, and the appropriate transport mechanism (TP or ETP) is selected
based on the payload size. The stack automatically manages the fragmentation
and reassembly of large payloads and ensures that the correct CAN frames are
generated and transmitted for each session.</p>
</section>
<section id="pgn">
<h3>PGN<a class="headerlink" href="#pgn" title="Link to this heading">¶</a></h3>
<p>The J1939 protocol uses the 29-bit CAN identifier with the following structure:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head" colspan="3"><p>29 bit CAN-ID</p></th>
</tr>
<tr class="row-even"><th class="head" colspan="3"><p>Bit positions within the CAN-ID</p></th>
</tr>
<tr class="row-odd"><th class="head"><p>28 ... 26</p></th>
<th class="head"><p>25 ... 8</p></th>
<th class="head"><p>7 ... 0</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Priority</p></td>
<td><p>PGN</p></td>
<td><p>SA (Source Address)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The PGN (Parameter Group Number) is a number to identify a packet. The PGN
is composed as follows:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head" colspan="4"><p>PGN</p></th>
</tr>
<tr class="row-even"><th class="head" colspan="4"><p>Bit positions within the CAN-ID</p></th>
</tr>
<tr class="row-odd"><th class="head"><p>25</p></th>
<th class="head"><p>24</p></th>
<th class="head"><p>23 ... 16</p></th>
<th class="head"><p>15 ... 8</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>R (Reserved)</p></td>
<td><p>DP (Data Page)</p></td>
<td><p>PF (PDU Format)</p></td>
<td><p>PS (PDU Specific)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In J1939-21 distinction is made between PDU1 format (where PF &lt; 240) and PDU2
format (where PF &gt;= 240). Furthermore, when using the PDU2 format, the PS-field
contains a so-called Group Extension, which is part of the PGN. When using PDU2
format, the Group Extension is set in the PS-field.</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>PDU1 Format (specific) (peer to peer)</p></th>
</tr>
<tr class="row-even"><th class="head" colspan="2"><p>Bit positions within the CAN-ID</p></th>
</tr>
<tr class="row-odd"><th class="head"><p>23 ... 16</p></th>
<th class="head"><p>15 ... 8</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>00h ... EFh</p></td>
<td><p>DA (Destination address)</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>PDU2 Format (global) (broadcast)</p></th>
</tr>
<tr class="row-even"><th class="head" colspan="2"><p>Bit positions within the CAN-ID</p></th>
</tr>
<tr class="row-odd"><th class="head"><p>23 ... 16</p></th>
<th class="head"><p>15 ... 8</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F0h ... FFh</p></td>
<td><p>GE (Group Extension)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>On the other hand, when using PDU1 format, the PS-field contains a so-called
Destination Address, which is _not_ part of the PGN. When communicating a PGN
from user space to kernel (or vice versa) and PDU1 format is used, the PS-field
of the PGN shall be set to zero. The Destination Address shall be set
elsewhere.</p>
<p>Regarding PGN mapping to 29-bit CAN identifier, the Destination Address shall
be get/set from/to the appropriate bits of the identifier by the kernel.</p>
</section>
<section id="addressing">
<h3>Addressing<a class="headerlink" href="#addressing" title="Link to this heading">¶</a></h3>
<p>Both static and dynamic addressing methods can be used.</p>
<p>For static addresses, no extra checks are made by the kernel and provided
addresses are considered right. This responsibility is for the OEM or system
integrator.</p>
<p>For dynamic addressing, so-called Address Claiming, extra support is foreseen
in the kernel. In J1939 any ECU is known by its 64-bit NAME. At the moment of
a successful address claim, the kernel keeps track of both NAME and source
address being claimed. This serves as a base for filter schemes. By default,
packets with a destination that is not locally will be rejected.</p>
<p>Mixed mode packets (from a static to a dynamic address or vice versa) are
allowed. The BSD sockets define separate API calls for getting/setting the
local &amp; remote address and are applicable for J1939 sockets.</p>
</section>
<section id="filtering">
<h3>Filtering<a class="headerlink" href="#filtering" title="Link to this heading">¶</a></h3>
<p>J1939 defines white list filters per socket that a user can set in order to
receive a subset of the J1939 traffic. Filtering can be based on:</p>
<ul class="simple">
<li><p>SA</p></li>
<li><p>SOURCE_NAME</p></li>
<li><p>PGN</p></li>
</ul>
<p>When multiple filters are in place for a single socket, and a packet comes in
that matches several of those filters, the packet is only received once for
that socket.</p>
</section>
</section>
<section id="how-to-use-j1939">
<h2>How to Use J1939<a class="headerlink" href="#how-to-use-j1939" title="Link to this heading">¶</a></h2>
<section id="api-calls">
<h3>API Calls<a class="headerlink" href="#api-calls" title="Link to this heading">¶</a></h3>
<p>On CAN, you first need to open a socket for communicating over a CAN network.
To use J1939, <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;linux/can/j1939.h&gt;</span></code>. From there, <code class="docutils literal notranslate"><span class="pre">&lt;linux/can.h&gt;</span></code> will be
included too. To open a socket, use:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">PF_CAN</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="n">CAN_J1939</span><span class="p">);</span>
</pre></div>
</div>
<p>J1939 does use <code class="docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code> sockets. In the J1939 specification, connections are
mentioned in the context of transport protocol sessions. These still deliver
packets to the other end (using several CAN packets). <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code> is not
supported.</p>
<p>After the successful creation of the socket, you would normally use the <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code> system call to bind the socket to a CAN interface. After
binding and/or connecting the socket, you can <code class="docutils literal notranslate"><span class="pre">read(2)</span></code> and <code class="docutils literal notranslate"><span class="pre">write(2)</span></code> from/to the
socket or use <code class="docutils literal notranslate"><span class="pre">send(2)</span></code>, <code class="docutils literal notranslate"><span class="pre">sendto(2)</span></code>, <code class="docutils literal notranslate"><span class="pre">sendmsg(2)</span></code> and the <code class="docutils literal notranslate"><span class="pre">recv*()</span></code> counterpart
operations on the socket as usual. There are also J1939 specific socket options
described below.</p>
<p>In order to send data, a <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> must have been successful. <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> assigns a
local address to a socket.</p>
<p>Different from CAN is that the payload data is just the data that get sends,
without its header info. The header info is derived from the sockaddr supplied
to <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code>, <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code>, <code class="docutils literal notranslate"><span class="pre">sendto(2)</span></code> and <code class="docutils literal notranslate"><span class="pre">recvfrom(2)</span></code>. A <code class="docutils literal notranslate"><span class="pre">write(2)</span></code> with size 4 will
result in a packet with 4 bytes.</p>
<p>The sockaddr structure has extensions for use with J1939 as specified below:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_can</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">sa_family_t</span><span class="w"> </span><span class="n">can_family</span><span class="p">;</span>
<span class="w">   </span><span class="kt">int</span><span class="w">         </span><span class="n">can_ifindex</span><span class="p">;</span>
<span class="w">   </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="n">__u64</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">                  </span><span class="cm">/* pgn:</span>
<span class="cm">                   * 8 bit: PS in PDU2 case, else 0</span>
<span class="cm">                   * 8 bit: PF</span>
<span class="cm">                   * 1 bit: DP</span>
<span class="cm">                   * 1 bit: reserved</span>
<span class="cm">                   */</span>
<span class="w">         </span><span class="n">__u32</span><span class="w"> </span><span class="n">pgn</span><span class="p">;</span>
<span class="w">         </span><span class="n">__u8</span><span class="w">  </span><span class="n">addr</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="n">j1939</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="n">can_addr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">can_family</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">can_ifindex</span></code> serve the same purpose as for other SocketCAN sockets.</p>
<p><code class="docutils literal notranslate"><span class="pre">can_addr.j1939.pgn</span></code> specifies the PGN (max 0x3ffff). Individual bits are
specified above.</p>
<p><code class="docutils literal notranslate"><span class="pre">can_addr.j1939.name</span></code> contains the 64-bit J1939 NAME.</p>
<p><code class="docutils literal notranslate"><span class="pre">can_addr.j1939.addr</span></code> contains the address.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> system call assigns the local address, i.e. the source address when
sending packages. If a PGN during <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> is set, it’s used as a RX filter.
I.e. only packets with a matching PGN are received. If an ADDR or NAME is set
it is used as a receive filter, too. It will match the destination NAME or ADDR
of the incoming packet. The NAME filter will work only if appropriate Address
Claiming for this name was done on the CAN bus and registered/cached by the
kernel.</p>
<p>On the other hand <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code> assigns the remote address, i.e. the destination
address. The PGN from <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code> is used as the default PGN when sending
packets. If ADDR or NAME is set it will be used as the default destination ADDR
or NAME. Further a set ADDR or NAME during <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code> is used as a receive
filter. It will match the source NAME or ADDR of the incoming packet.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">write(2)</span></code> and <code class="docutils literal notranslate"><span class="pre">send(2)</span></code> will send a packet with local address from <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> and the
remote address from <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code>. Use <code class="docutils literal notranslate"><span class="pre">sendto(2)</span></code> to overwrite the destination
address.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">can_addr.j1939.name</span></code> is set (!= 0) the NAME is looked up by the kernel and
the corresponding ADDR is used. If <code class="docutils literal notranslate"><span class="pre">can_addr.j1939.name</span></code> is not set (== 0),
<code class="docutils literal notranslate"><span class="pre">can_addr.j1939.addr</span></code> is used.</p>
<p>When creating a socket, reasonable defaults are set. Some options can be
modified with <code class="docutils literal notranslate"><span class="pre">setsockopt(2)</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">getsockopt(2)</span></code>.</p>
<p>RX path related options:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SO_J1939_FILTER</span></code> - configure array of filters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SO_J1939_PROMISC</span></code> - disable filters set by <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> and <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code></p></li>
</ul>
<p>By default no broadcast packets can be send or received. To enable sending or
receiving broadcast packets use the socket option <code class="docutils literal notranslate"><span class="pre">SO_BROADCAST</span></code>:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_BROADCAST</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</pre></div>
</div>
<p>The following diagram illustrates the RX path:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>               +--------------------+
               |  incoming packet   |
               +--------------------+
                         |
                         V
               +--------------------+
               | SO_J1939_PROMISC?  |
               +--------------------+
                        |  |
                    no  |  | yes
                        |  |
              .---------&#39;  `---------.
              |                      |
+---------------------------+        |
| bind() + connect() +      |        |
| SOCK_BROADCAST filter     |        |
+---------------------------+        |
              |                      |
              |&lt;---------------------&#39;
              V
+---------------------------+
|      SO_J1939_FILTER      |
+---------------------------+
              |
              V
+---------------------------+
|        socket recv()      |
+---------------------------+
</pre></div>
</div>
<p>TX path related options:
<code class="docutils literal notranslate"><span class="pre">SO_J1939_SEND_PRIO</span></code> - change default send priority for the socket</p>
<section id="message-flags-during-send-and-related-system-calls">
<h4>Message Flags during send() and Related System Calls<a class="headerlink" href="#message-flags-during-send-and-related-system-calls" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">send(2)</span></code>, <code class="docutils literal notranslate"><span class="pre">sendto(2)</span></code> and <code class="docutils literal notranslate"><span class="pre">sendmsg(2)</span></code> take a ‘flags’ argument. Currently
supported flags are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MSG_DONTWAIT</span></code>, i.e. non-blocking operation.</p></li>
</ul>
</section>
<section id="recvmsg-2">
<h4>recvmsg(2)<a class="headerlink" href="#recvmsg-2" title="Link to this heading">¶</a></h4>
<p>In most cases <code class="docutils literal notranslate"><span class="pre">recvmsg(2)</span></code> is needed if you want to extract more information than
<code class="docutils literal notranslate"><span class="pre">recvfrom(2)</span></code> can provide. For example package priority and timestamp. The
Destination Address, name and packet priority (if applicable) are attached to
the msghdr in the <code class="docutils literal notranslate"><span class="pre">recvmsg(2)</span></code> call. They can be extracted using <code class="docutils literal notranslate"><span class="pre">cmsg(3)</span></code> macros,
with <code class="docutils literal notranslate"><span class="pre">cmsg_level</span> <span class="pre">==</span> <span class="pre">SOL_J1939</span> <span class="pre">&amp;&amp;</span> <span class="pre">cmsg_type</span> <span class="pre">==</span> <span class="pre">SCM_J1939_DEST_ADDR</span></code>,
<code class="docutils literal notranslate"><span class="pre">SCM_J1939_DEST_NAME</span></code> or <code class="docutils literal notranslate"><span class="pre">SCM_J1939_PRIO</span></code>. The returned data is a <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code> for
<code class="docutils literal notranslate"><span class="pre">priority</span></code> and <code class="docutils literal notranslate"><span class="pre">dst_addr</span></code>, and <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code> for <code class="docutils literal notranslate"><span class="pre">dst_name</span></code>.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">priority</span><span class="p">,</span><span class="w"> </span><span class="n">dst_addr</span><span class="p">;</span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">dst_name</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">cmsg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CMSG_FIRSTHDR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span><span class="w"> </span><span class="n">cmsg</span><span class="p">;</span><span class="w"> </span><span class="n">cmsg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CMSG_NXTHDR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">cmsg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_level</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">SOL_CAN_J1939</span><span class="p">:</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SCM_J1939_DEST_ADDR</span><span class="p">)</span>
<span class="w">                        </span><span class="n">dst_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">CMSG_DATA</span><span class="p">(</span><span class="n">cmsg</span><span class="p">);</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SCM_J1939_DEST_NAME</span><span class="p">)</span>
<span class="w">                        </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_name</span><span class="p">,</span><span class="w"> </span><span class="n">CMSG_DATA</span><span class="p">(</span><span class="n">cmsg</span><span class="p">),</span><span class="w"> </span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">CMSG_LEN</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SCM_J1939_PRIO</span><span class="p">)</span>
<span class="w">                        </span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">CMSG_DATA</span><span class="p">(</span><span class="n">cmsg</span><span class="p">);</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="setsockopt-2">
<h4>setsockopt(2)<a class="headerlink" href="#setsockopt-2" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">setsockopt(2)</span></code> function is used to configure various socket-level
options for J1939 communication. The following options are supported:</p>
<section id="so-j1939-filter">
<h5><code class="docutils literal notranslate"><span class="pre">SO_J1939_FILTER</span></code><a class="headerlink" href="#so-j1939-filter" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">SO_J1939_FILTER</span></code> option is essential when the default behavior of
<code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> and <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code> is insufficient for specific use cases. By
default, <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> and <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code> allow a socket to be associated with a
single unicast or broadcast address. However, there are scenarios where finer
control over the incoming messages is required, such as filtering by Parameter
Group Number (PGN) rather than by addresses.</p>
<p>For example, in a system where multiple types of J1939 messages are being
transmitted, a process might only be interested in a subset of those messages,
such as specific PGNs, and not want to receive all messages destined for its
address or broadcast to the bus.</p>
<p>By applying the <code class="docutils literal notranslate"><span class="pre">SO_J1939_FILTER</span></code> option, you can filter messages based on:</p>
<ul class="simple">
<li><p><strong>Source Address (SA)</strong>: Filter messages coming from specific source
addresses.</p></li>
<li><p><strong>Source Name</strong>: Filter messages coming from ECUs with specific NAME
identifiers.</p></li>
<li><p><strong>Parameter Group Number (PGN)</strong>: Focus on receiving messages with specific
PGNs, filtering out irrelevant ones.</p></li>
</ul>
<p>This filtering mechanism is particularly useful when:</p>
<ul class="simple">
<li><p>You want to receive a subset of messages based on their PGNs, even if the
address is the same.</p></li>
<li><p>You need to handle both broadcast and unicast messages but only care about
certain message types or parameters.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> and <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code> functions only allow binding to a single
address, which might not be sufficient if the process needs to handle multiple
PGNs but does not want to open multiple sockets.</p></li>
</ul>
<p>To remove existing filters, you can pass <code class="docutils literal notranslate"><span class="pre">optval</span> <span class="pre">==</span> <span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">optlen</span> <span class="pre">==</span> <span class="pre">0</span></code>
to <code class="docutils literal notranslate"><span class="pre">setsockopt(2)</span></code>. This will clear all currently set filters. If you want to
<strong>update</strong> the set of filters, you must pass the updated filter set to
<code class="docutils literal notranslate"><span class="pre">setsockopt(2)</span></code>, as the new filter set will <strong>replace</strong> the old one entirely.
This behavior ensures that any previous filter configuration is discarded and
only the new set is applied.</p>
<p>Example of removing all filters:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_CAN_J1939</span><span class="p">,</span><span class="w"> </span><span class="n">SO_J1939_FILTER</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Maximum number of filters:</strong> The maximum amount of filters that can be
applied using <code class="docutils literal notranslate"><span class="pre">SO_J1939_FILTER</span></code> is defined by <code class="docutils literal notranslate"><span class="pre">J1939_FILTER_MAX</span></code>, which is
set to 512. This means you can configure up to 512 individual filters to match
your specific filtering needs.</p>
<p>Practical use case: <strong>Monitoring Address Claiming</strong></p>
<p>One practical use case is monitoring the J1939 address claiming process by
filtering for specific PGNs related to address claiming. This allows a process
to monitor and handle address claims without processing unrelated messages.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">j1939_filter</span><span class="w"> </span><span class="n">filt</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_ADDRESS_CLAIMED</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pgn_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_PDU1_MAX</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_REQUEST</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pgn_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_PDU1_MAX</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_ADDRESS_COMMANDED</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">pgn_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_MAX</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_CAN_J1939</span><span class="p">,</span><span class="w"> </span><span class="n">SO_J1939_FILTER</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filt</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">filt</span><span class="p">));</span>
</pre></div>
</div>
<p>In this example, the socket will only receive messages with the PGNs related to
address claiming: <code class="docutils literal notranslate"><span class="pre">J1939_PGN_ADDRESS_CLAIMED</span></code>, <code class="docutils literal notranslate"><span class="pre">J1939_PGN_REQUEST</span></code>, and
<code class="docutils literal notranslate"><span class="pre">J1939_PGN_ADDRESS_COMMANDED</span></code>. This is particularly useful in scenarios where
you want to monitor and process address claims without being overwhelmed by
other traffic on the J1939 network.</p>
</section>
<section id="so-j1939-promisc">
<h5><code class="docutils literal notranslate"><span class="pre">SO_J1939_PROMISC</span></code><a class="headerlink" href="#so-j1939-promisc" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">SO_J1939_PROMISC</span></code> option enables socket-level promiscuous mode. When
this option is enabled, the socket will receive all J1939 traffic, regardless
of any filters set by <code class="docutils literal notranslate"><span class="pre">bind()</span></code> or <code class="docutils literal notranslate"><span class="pre">connect()</span></code>. This is analogous to
enabling promiscuous mode for an Ethernet interface, where all traffic on the
network segment is captured.</p>
<p>However, <strong>`SO_J1939_FILTER` has a higher priority</strong> compared to
<code class="docutils literal notranslate"><span class="pre">SO_J1939_PROMISC</span></code>. This means that even in promiscuous mode, you can reduce
the number of packets received by applying specific filters with
<cite>SO_J1939_FILTER</cite>. The filters will limit which packets are passed to the
socket, allowing for more refined traffic selection while promiscuous mode is
active.</p>
<p>The acceptable value size for this option is <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span></code>, and the value is
only differentiated between <cite>0</cite> and non-zero. A value of <cite>0</cite> disables
promiscuous mode, while any non-zero value enables it.</p>
<p>This combination can be useful for debugging or monitoring specific types of
traffic while still capturing a broad set of messages.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_CAN_J1939</span><span class="p">,</span><span class="w"> </span><span class="n">SO_J1939_PROMISC</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</pre></div>
</div>
<p>In this example, setting <code class="docutils literal notranslate"><span class="pre">value</span></code> to any non-zero value (e.g., <cite>1</cite>) enables
promiscuous mode, allowing the socket to receive all J1939 traffic on the
network.</p>
</section>
<section id="so-broadcast">
<h5><code class="docutils literal notranslate"><span class="pre">SO_BROADCAST</span></code><a class="headerlink" href="#so-broadcast" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">SO_BROADCAST</span></code> option enables the sending and receiving of broadcast
messages. By default, broadcast messages are disabled for J1939 sockets. When
this option is enabled, the socket will be allowed to send and receive
broadcast packets on the J1939 network.</p>
<p>Due to the nature of the CAN bus as a shared medium, all messages transmitted
on the bus are visible to all participants. In the context of J1939,
broadcasting refers to using a specific destination address field, where the
destination address is set to a value that indicates the message is intended
for all participants (usually a global address such as 0xFF). Enabling the
broadcast option allows the socket to send and receive such broadcast messages.</p>
<p>The acceptable value size for this option is <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span></code>, and the value is
only differentiated between <cite>0</cite> and non-zero. A value of <cite>0</cite> disables the
ability to send and receive broadcast messages, while any non-zero value
enables it.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_BROADCAST</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</pre></div>
</div>
<p>In this example, setting <code class="docutils literal notranslate"><span class="pre">value</span></code> to any non-zero value (e.g., <cite>1</cite>) enables
the socket to send and receive broadcast messages.</p>
</section>
<section id="so-j1939-send-prio">
<h5><code class="docutils literal notranslate"><span class="pre">SO_J1939_SEND_PRIO</span></code><a class="headerlink" href="#so-j1939-send-prio" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">SO_J1939_SEND_PRIO</span></code> option sets the priority of outgoing J1939 messages
for the socket. In J1939, messages can have different priorities, and lower
numerical values indicate higher priority. This option allows the user to
control the priority of messages sent from the socket by adjusting the priority
bits in the CAN identifier.</p>
<p>The acceptable value <strong>size</strong> for this option is <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span></code>, and the value
is expected to be in the range of 0 to 7, where <cite>0</cite> is the highest priority,
and <cite>7</cite> is the lowest. By default, the priority is set to <cite>6</cite> if this option is
not explicitly configured.</p>
<p>Note that the priority values <cite>0</cite> and <cite>1</cite> can only be set if the process has
the <cite>CAP_NET_ADMIN</cite> capability. These are reserved for high-priority traffic
and require administrative privileges.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">prio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">  </span><span class="c1">// Priority value between 0 (highest) and 7 (lowest)</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_CAN_J1939</span><span class="p">,</span><span class="w"> </span><span class="n">SO_J1939_SEND_PRIO</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prio</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">prio</span><span class="p">));</span>
</pre></div>
</div>
<p>In this example, the priority is set to <cite>3</cite>, meaning the outgoing messages will
be sent with a moderate priority level.</p>
</section>
<section id="so-j1939-errqueue">
<h5><code class="docutils literal notranslate"><span class="pre">SO_J1939_ERRQUEUE</span></code><a class="headerlink" href="#so-j1939-errqueue" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">SO_J1939_ERRQUEUE</span></code> option enables the socket to receive error messages
from the error queue, providing diagnostic information about transmission
failures, protocol violations, or other issues that occur during J1939
communication. Once this option is set, user space is required to handle
<code class="docutils literal notranslate"><span class="pre">MSG_ERRQUEUE</span></code> messages.</p>
<p>Setting <code class="docutils literal notranslate"><span class="pre">SO_J1939_ERRQUEUE</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code> will purge any currently present error
messages in the error queue. When enabled, error messages can be retrieved
using the <code class="docutils literal notranslate"><span class="pre">recvmsg(2)</span></code> system call.</p>
<p>When subscribing to the error queue, the following error events can be
accessed:</p>
<ul class="simple">
<li><p><strong>``J1939_EE_INFO_TX_ABORT``</strong>: Transmission abort errors.</p></li>
<li><p><strong>``J1939_EE_INFO_RX_RTS``</strong>: Reception of RTS (Request to Send) control
frames.</p></li>
<li><p><strong>``J1939_EE_INFO_RX_DPO``</strong>: Reception of data packets with Data Page Offset
(DPO).</p></li>
<li><p><strong>``J1939_EE_INFO_RX_ABORT``</strong>: Reception abort errors.</p></li>
</ul>
<p>The error queue can be used to correlate errors with specific message transfer
sessions using the session ID (<code class="docutils literal notranslate"><span class="pre">tskey</span></code>). The session ID is assigned via the
<code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_OPT_ID</span></code> flag, which is set by enabling the
<code class="docutils literal notranslate"><span class="pre">SO_TIMESTAMPING</span></code> option.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">SO_J1939_ERRQUEUE</span></code> is activated, the user is required to pull messages
from the error queue, meaning that using plain <code class="docutils literal notranslate"><span class="pre">recv(2)</span></code> is not sufficient
anymore. The user must use <code class="docutils literal notranslate"><span class="pre">recvmsg(2)</span></code> with appropriate flags to handle
error messages. Failure to do so can result in the socket becoming blocked with
unprocessed error messages in the queue.</p>
<p>It is <strong>recommended</strong> that <code class="docutils literal notranslate"><span class="pre">SO_J1939_ERRQUEUE</span></code> be used in combination with
<code class="docutils literal notranslate"><span class="pre">SO_TIMESTAMPING</span></code> in most cases. This enables proper error handling along
with session tracking and timestamping, providing a more detailed analysis of
message transfers and errors.</p>
<p>The acceptable value <strong>size</strong> for this option is <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span></code>, and the value
is only differentiated between <code class="docutils literal notranslate"><span class="pre">0</span></code> and non-zero. A value of <code class="docutils literal notranslate"><span class="pre">0</span></code> disables
error queue reception and purges any existing error messages, while any
non-zero value enables it.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// Enable error queue reception</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_CAN_J1939</span><span class="p">,</span><span class="w"> </span><span class="n">SO_J1939_ERRQUEUE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">enable</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">enable</span><span class="p">));</span>

<span class="c1">// Enable timestamping with session tracking via tskey</span>
<span class="kt">int</span><span class="w"> </span><span class="n">timestamping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SOF_TIMESTAMPING_OPT_ID</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SOF_TIMESTAMPING_TX_ACK</span><span class="w"> </span><span class="o">|</span>
<span class="w">                   </span><span class="n">SOF_TIMESTAMPING_TX_SCHED</span><span class="w"> </span><span class="o">|</span>
<span class="w">                   </span><span class="n">SOF_TIMESTAMPING_RX_SOFTWARE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SOF_TIMESTAMPING_OPT_CMSG</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_TIMESTAMPING</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">timestamping</span><span class="p">,</span>
<span class="w">           </span><span class="k">sizeof</span><span class="p">(</span><span class="n">timestamping</span><span class="p">));</span>
</pre></div>
</div>
<p>When enabled, error messages can be retrieved using <code class="docutils literal notranslate"><span class="pre">recvmsg(2)</span></code>. By
combining <code class="docutils literal notranslate"><span class="pre">SO_J1939_ERRQUEUE</span></code> with <code class="docutils literal notranslate"><span class="pre">SO_TIMESTAMPING</span></code> (with
<code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_OPT_ID</span></code> and <code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_OPT_CMSG</span></code> enabled), the
user can track message transfers, retrieve precise timestamps, and correlate
errors with specific sessions.</p>
<p>For more information on enabling timestamps and session tracking, refer to the
<cite>SO_TIMESTAMPING</cite> section.</p>
</section>
<section id="so-timestamping">
<h5><code class="docutils literal notranslate"><span class="pre">SO_TIMESTAMPING</span></code><a class="headerlink" href="#so-timestamping" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">SO_TIMESTAMPING</span></code> option allows the socket to receive timestamps for
various events related to message transmissions and receptions in J1939. This
option is often used in combination with <code class="docutils literal notranslate"><span class="pre">SO_J1939_ERRQUEUE</span></code> to provide
detailed diagnostic information, session tracking, and precise timing data for
message transfers.</p>
<p>In J1939, all payloads provided by user space, regardless of size, are
processed by the kernel as <strong>sessions</strong>. This includes both single-frame
messages (up to 8 bytes) and multi-frame protocols such as the Transport
Protocol (TP) and Extended Transport Protocol (ETP). Even for small,
single-frame messages, the kernel creates a session to manage the transmission
and reception. The concept of sessions allows the kernel to manage various
aspects of the protocol, such as reassembling multi-frame messages and tracking
the status of transmissions.</p>
<p>When receiving extended error messages from the error queue, the error
information is delivered through a <cite>struct sock_extended_err</cite>, accessible via
the control message (<code class="docutils literal notranslate"><span class="pre">cmsg</span></code>) retrieved using the <code class="docutils literal notranslate"><span class="pre">recvmsg(2)</span></code> system call.</p>
<p>There are two typical origins for the extended error messages in J1939:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_origin</span> <span class="pre">==</span> <span class="pre">SO_EE_ORIGIN_TIMESTAMPING</span></code>:</p>
<p>In this case, the <cite>serr-&gt;ee_info</cite> field will contain one of the following
timestamp types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SCM_TSTAMP_SCHED</span></code>: This timestamp is valid for Extended Transport
Protocol (ETP) transfers and simple transfers (8 bytes or less). It
indicates when a message or set of frames has been scheduled for
transmission.</p>
<ul>
<li><p>For simple transfers (8 bytes or less), it marks the point when the
message is queued and ready to be sent onto the CAN bus.</p></li>
<li><p>For ETP transfers, it is sent after receiving a CTS (Clear to Send)
frame on the sender side, indicating that a new set of frames has been
scheduled for transmission.</p></li>
<li><p>The Transport Protocol (TP) case is currently not implemented for this
timestamp.</p></li>
<li><p>On the receiver side, the counterpart to this event for ETP is
represented by the <code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_DPO</span></code> message, which indicates the
reception of a Data Page Offset (DPO) control frame.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCM_TSTAMP_ACK</span></code>: This timestamp indicates the acknowledgment of the
message or session.</p>
<ul>
<li><p>For simple transfers (8 bytes or less), it marks when the message has
been sent and an echo confirmation has been received from the CAN
controller, indicating that the frame was transmitted onto the bus.</p></li>
<li><p>For multi-frame transfers (TP or ETP), it signifies that the entire
session has been acknowledged, typically after receiving the End of
Message Acknowledgment (EOMA) packet.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_origin</span> <span class="pre">==</span> <span class="pre">SO_EE_ORIGIN_LOCAL</span></code>:</p>
<p>In this case, the <cite>serr-&gt;ee_info</cite> field will contain one of the following
J1939 stack-specific message types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_TX_ABORT</span></code>: This message indicates that the transmission
of a message or session was aborted. The cause of the abort can come from
various sources:</p>
<ul>
<li><p><strong>CAN stack failure</strong>: The J1939 stack was unable to pass the frame to
the CAN framework for transmission.</p></li>
<li><p><strong>Echo failure</strong>: The J1939 stack did not receive an echo confirmation
from the CAN controller, meaning the frame may not have been successfully
transmitted to the CAN bus.</p></li>
<li><p><strong>Protocol-level issues</strong>: For multi-frame transfers (TP/ETP), this
could include protocol-related errors, such as an abort signaled by the
receiver or a timeout at the protocol level, which causes the session to
terminate prematurely.</p></li>
<li><p>The corresponding error code is stored in <code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_data</span></code>
(<code class="docutils literal notranslate"><span class="pre">session-&gt;err</span></code> on kernel side), providing additional details about
the specific reason for the abort.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_RTS</span></code>: This message indicates that the J1939 stack has
received a Request to Send (RTS) control frame, signaling the start of a
multi-frame transfer using the Transport Protocol (TP) or Extended
Transport Protocol (ETP).</p>
<ul>
<li><p>It informs the receiver that the sender is ready to transmit a
multi-frame message and includes details about the total message size
and the number of frames to be sent.</p></li>
<li><p>Statistics such as <code class="docutils literal notranslate"><span class="pre">J1939_NLA_TOTAL_SIZE</span></code>, <code class="docutils literal notranslate"><span class="pre">J1939_NLA_PGN</span></code>,
<code class="docutils literal notranslate"><span class="pre">J1939_NLA_SRC_NAME</span></code>, and <code class="docutils literal notranslate"><span class="pre">J1939_NLA_DEST_NAME</span></code> are provided along
with the <code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_RTS</span></code> message, giving detailed information
about the incoming transfer.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_DPO</span></code>: This message indicates that the J1939 stack has
received a Data Page Offset (DPO) control frame, which is part of the
Extended Transport Protocol (ETP).</p>
<ul>
<li><p>The DPO frame signals the continuation of an ETP multi-frame message by
indicating the offset position in the data being transferred. It helps
the receiver manage large data sets by identifying which portion of the
message is being received.</p></li>
<li><p>It is typically paired with a corresponding <code class="docutils literal notranslate"><span class="pre">SCM_TSTAMP_SCHED</span></code> event
on the sender side, which indicates when the next set of frames is
scheduled for transmission.</p></li>
<li><p>This event includes statistics such as <code class="docutils literal notranslate"><span class="pre">J1939_NLA_BYTES_ACKED</span></code>, which
tracks the number of bytes acknowledged up to that point in the session.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_ABORT</span></code>: This message indicates that the reception of a
multi-frame message (Transport Protocol or Extended Transport Protocol) has
been aborted.</p>
<ul>
<li><p>The abort can be triggered by protocol-level errors such as timeouts, an
unexpected frame, or a specific abort request from the sender.</p></li>
<li><p>This message signals that the receiver cannot continue processing the
transfer, and the session is terminated.</p></li>
<li><p>The corresponding error code is stored in <code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_data</span></code>
(<code class="docutils literal notranslate"><span class="pre">session-&gt;err</span></code> on kernel side ), providing further details about the
reason for the abort, such as protocol violations or timeouts.</p></li>
<li><p>After receiving this message, the receiver discards the partially received
frames, and the multi-frame session is considered incomplete.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>In both cases, if <code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_OPT_ID</span></code> is enabled, <code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_data</span></code>
will be set to the session’s unique identifier (<code class="docutils literal notranslate"><span class="pre">session-&gt;tskey</span></code>). This
allows user space to track message transfers by their session identifier across
multiple frames or stages.</p>
<p>In all other cases, <code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_errno</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">ENOMSG</span></code>, except for
the <code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_TX_ABORT</span></code> and <code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_ABORT</span></code> cases, where the
kernel sets <code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_data</span></code> to the error stored in <code class="docutils literal notranslate"><span class="pre">session-&gt;err</span></code>.  All
protocol-specific errors are converted to standard kernel error values and
stored in <code class="docutils literal notranslate"><span class="pre">session-&gt;err</span></code>. These error values are unified across system calls
and <code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_errno</span></code>.  Some of the known error values are described in the
<cite>Error Codes in the J1939 Stack</cite> section.</p>
<p>When the <cite>J1939_EE_INFO_RX_RTS</cite> message is provided, it will include the
following statistics for multi-frame messages (TP and ETP):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_NLA_TOTAL_SIZE</span></code>: Total size of the message in the session.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_NLA_PGN</span></code>: Parameter Group Number (PGN) identifying the message type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_NLA_SRC_NAME</span></code>: 64-bit name of the source ECU.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_NLA_DEST_NAME</span></code>: 64-bit name of the destination ECU.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_NLA_SRC_ADDR</span></code>: 8-bit source address of the sending ECU.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_NLA_DEST_ADDR</span></code>: 8-bit destination address of the receiving ECU.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>For other messages (including single-frame messages), only the following
statistic is included:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">J1939_NLA_BYTES_ACKED</span></code>: Number of bytes successfully acknowledged in the
session.</p></li>
</ul>
</li>
</ul>
<p>The key flags for <code class="docutils literal notranslate"><span class="pre">SO_TIMESTAMPING</span></code> include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_OPT_ID</span></code>: Enables the use of a unique session identifier
(<code class="docutils literal notranslate"><span class="pre">tskey</span></code>) for each transfer. This identifier helps track message transfers
and errors as distinct sessions in user space. When this option is enabled,
<code class="docutils literal notranslate"><span class="pre">serr-&gt;ee_data</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">session-&gt;tskey</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_OPT_CMSG</span></code>: Sends timestamp information through control
messages (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scm_timestamping</span></code>), allowing the application to retrieve
timestamps alongside the data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_TX_SCHED</span></code>: Provides the timestamp for when a message is
scheduled for transmission (<code class="docutils literal notranslate"><span class="pre">SCM_TSTAMP_SCHED</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_TX_ACK</span></code>: Provides the timestamp for when a message
transmission is fully acknowledged (<code class="docutils literal notranslate"><span class="pre">SCM_TSTAMP_ACK</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_RX_SOFTWARE</span></code>: Provides timestamps for reception-related
events (e.g., <code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_RTS</span></code>, <code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_DPO</span></code>,
<code class="docutils literal notranslate"><span class="pre">J1939_EE_INFO_RX_ABORT</span></code>).</p></li>
</ul>
<p>These flags enable detailed monitoring of message lifecycles, including
transmission scheduling, acknowledgments, reception timestamps, and gathering
detailed statistics about the communication session, especially for multi-frame
payloads like TP and ETP.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Enable timestamping with various options, including session tracking and</span>
<span class="c1">// statistics</span>
<span class="kt">int</span><span class="w"> </span><span class="n">sock_opt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SOF_TIMESTAMPING_OPT_CMSG</span><span class="w"> </span><span class="o">|</span>
<span class="w">               </span><span class="n">SOF_TIMESTAMPING_TX_ACK</span><span class="w"> </span><span class="o">|</span>
<span class="w">               </span><span class="n">SOF_TIMESTAMPING_TX_SCHED</span><span class="w"> </span><span class="o">|</span>
<span class="w">               </span><span class="n">SOF_TIMESTAMPING_OPT_ID</span><span class="w"> </span><span class="o">|</span>
<span class="w">               </span><span class="n">SOF_TIMESTAMPING_RX_SOFTWARE</span><span class="p">;</span>

<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_TIMESTAMPING</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sock_opt</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sock_opt</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="dynamic-addressing">
<h3>Dynamic Addressing<a class="headerlink" href="#dynamic-addressing" title="Link to this heading">¶</a></h3>
<p>Distinction has to be made between using the claimed address and doing an
address claim. To use an already claimed address, one has to fill in the
<code class="docutils literal notranslate"><span class="pre">j1939.name</span></code> member and provide it to <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code>. If the name had claimed an address
earlier, all further messages being sent will use that address. And the
<code class="docutils literal notranslate"><span class="pre">j1939.addr</span></code> member will be ignored.</p>
<p>An exception on this is PGN 0x0ee00. This is the “Address Claim/Cannot Claim
Address” message and the kernel will use the <code class="docutils literal notranslate"><span class="pre">j1939.addr</span></code> member for that PGN if
necessary.</p>
<p>To claim an address following code example can be used:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_can</span><span class="w"> </span><span class="n">baddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_CAN</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_addr</span><span class="p">.</span><span class="n">j1939</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_IDLE_ADDR</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_NO_PGN</span><span class="p">,</span><span class="w">    </span><span class="cm">/* to disable bind() rx filter for PGN */</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_ifindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">if_nametoindex</span><span class="p">(</span><span class="s">&quot;can0&quot;</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">baddr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">baddr</span><span class="p">));</span>

<span class="cm">/* for Address Claiming broadcast must be allowed */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_BROADCAST</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

<span class="cm">/* configured advanced RX filter with PGN needed for Address Claiming */</span>
<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">j1939_filter</span><span class="w"> </span><span class="n">filt</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_ADDRESS_CLAIMED</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_PDU1_MAX</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_REQUEST</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_PDU1_MAX</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_ADDRESS_COMMANDED</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_MAX</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="p">};</span>

<span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_CAN_J1939</span><span class="p">,</span><span class="w"> </span><span class="n">SO_J1939_FILTER</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">filt</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">filt</span><span class="p">));</span>

<span class="kt">uint64_t</span><span class="w"> </span><span class="n">dat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htole64</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_can</span><span class="w"> </span><span class="n">saddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_CAN</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_addr</span><span class="p">.</span><span class="n">j1939</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_PGN_ADDRESS_CLAIMED</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_NO_ADDR</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* Afterwards do a sendto(2) with data set to the NAME (Little Endian). If the</span>
<span class="cm"> * NAME provided, does not match the j1939.name provided to bind(2), EPROTO</span>
<span class="cm"> * will be returned.</span>
<span class="cm"> */</span>
<span class="n">sendto</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">dat</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">dat</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">saddr</span><span class="p">));</span>
</pre></div>
</div>
<p>If no-one else contests the address claim within 250ms after transmission, the
kernel marks the NAME-SA assignment as valid. The valid assignment will be kept
among other valid NAME-SA assignments. From that point, any socket bound to the
NAME can send packets.</p>
<p>If another ECU claims the address, the kernel will mark the NAME-SA expired.
No socket bound to the NAME can send packets (other than address claims). To
claim another address, some socket bound to NAME, must <code class="docutils literal notranslate"><span class="pre">bind(2)</span></code> again, but with
only <code class="docutils literal notranslate"><span class="pre">j1939.addr</span></code> changed to the new SA, and must then send a valid address claim
packet. This restarts the state machine in the kernel (and any other
participant on the bus) for this NAME.</p>
<p><code class="docutils literal notranslate"><span class="pre">can-utils</span></code> also include the <code class="docutils literal notranslate"><span class="pre">j1939acd</span></code> tool, so it can be used as code example or as
default Address Claiming daemon.</p>
</section>
<section id="send-examples">
<h3>Send Examples<a class="headerlink" href="#send-examples" title="Link to this heading">¶</a></h3>
<section id="static-addressing">
<h4>Static Addressing<a class="headerlink" href="#static-addressing" title="Link to this heading">¶</a></h4>
<p>This example will send a PGN (0x12300) from SA 0x20 to DA 0x30.</p>
<p>Bind:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_can</span><span class="w"> </span><span class="n">baddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_CAN</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_addr</span><span class="p">.</span><span class="n">j1939</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_NO_NAME</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x20</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_NO_PGN</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_ifindex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">if_nametoindex</span><span class="p">(</span><span class="s">&quot;can0&quot;</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">baddr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">baddr</span><span class="p">));</span>
</pre></div>
</div>
<p>Now, the socket ‘sock’ is bound to the SA 0x20. Since no <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code> was called,
at this point we can use only <code class="docutils literal notranslate"><span class="pre">sendto(2)</span></code> or <code class="docutils literal notranslate"><span class="pre">sendmsg(2)</span></code>.</p>
<p>Send:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_can</span><span class="w"> </span><span class="n">saddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_CAN</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">can_addr</span><span class="p">.</span><span class="n">j1939</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J1939_NO_NAME</span><span class="p">;</span>
<span class="w">                </span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x30</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">pgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12300</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="p">};</span>

<span class="n">sendto</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">dat</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">dat</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">saddr</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
<section id="error-codes-in-the-j1939-stack">
<h3>Error Codes in the J1939 Stack<a class="headerlink" href="#error-codes-in-the-j1939-stack" title="Link to this heading">¶</a></h3>
<p>This section lists all potential kernel error codes that can be exposed to user
space when interacting with the J1939 stack. It includes both standard error
codes and those derived from protocol-specific abort codes.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code>: Operation would block; retry may succeed. One common reason is
that an active TP or ETP session exists, and an attempt was made to start a
new overlapping TP or ETP session between the same peers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENETDOWN</span></code>: Network is down. This occurs when the CAN interface is switched
to the “down” state.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>: No buffer space available. This error occurs when the CAN
interface’s transmit (TX) queue is full, and no more messages can be queued.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOVERFLOW</span></code>: Value too large for defined data type. In J1939, this can
happen if the requested data lies outside of the queued buffer. For example,
if a CTS (Clear to Send) requests an offset not available in the kernel buffer
because user space did not provide enough data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>: Device or resource is busy. For example, this occurs if an
identical session is already active and the stack is unable to recover from
the condition.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EACCES</span></code>: Permission denied. This error can occur, for example, when
attempting to send broadcast messages, but the socket is not configured with
<code class="docutils literal notranslate"><span class="pre">SO_BROADCAST</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EADDRNOTAVAIL</span></code>: Address not available. This error occurs in cases such as:</p>
<ul>
<li><p>When attempting to use <code class="docutils literal notranslate"><span class="pre">getsockname(2)</span></code> to retrieve the peer’s address,
but the socket is not connected.</p></li>
<li><p>When trying to send data to or from a NAME, but address claiming for the
NAME was not performed or detected by the stack.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBADFD</span></code>: File descriptor in bad state. This error can occur if:</p>
<ul>
<li><p>Attempting to send data to an unbound socket.</p></li>
<li><p>The socket is bound but has no source name, and the source address is
<code class="docutils literal notranslate"><span class="pre">J1939_NO_ADDR</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">can_ifindex</span></code> is incorrect.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">EFAULT</span></code>: Bad address. Occurs mostly when the stack can’t copy from or to a
sockptr, when there is insufficient data from user space, or when the buffer
provided by user space is not large enough for the requested data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINTR</span></code>: A signal occurred before any data was transmitted; see <code class="docutils literal notranslate"><span class="pre">signal(7)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>: Invalid argument passed. For example:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">msg-&gt;msg_namelen</span></code> is less than <code class="docutils literal notranslate"><span class="pre">J1939_MIN_NAMELEN</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addr-&gt;can_family</span></code> is not equal to <code class="docutils literal notranslate"><span class="pre">AF_CAN</span></code>.</p></li>
<li><p>An incorrect PGN was provided.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENODEV</span></code>: No such device. This happens when the CAN network device cannot
be found for the provided <code class="docutils literal notranslate"><span class="pre">can_ifindex</span></code> or if <code class="docutils literal notranslate"><span class="pre">can_ifindex</span></code> is 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>: Out of memory. Typically related to issues with memory allocation
in the stack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOPROTOOPT</span></code>: Protocol not available. This can occur when using
<code class="docutils literal notranslate"><span class="pre">getsockopt(2)</span></code> or <code class="docutils literal notranslate"><span class="pre">setsockopt(2)</span></code> if the requested socket option is not
available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EDESTADDRREQ</span></code>: Destination address required. This error occurs:</p>
<ul>
<li><p>In the case of <code class="docutils literal notranslate"><span class="pre">connect(2)</span></code>, if the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*uaddr</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p></li>
<li><p>In the case of <code class="docutils literal notranslate"><span class="pre">send*(2)</span></code>, if there is an attempt to send an ETP message
to a broadcast address.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">EDOM</span></code>: Argument out of domain. This error may happen if attempting to send
a TP or ETP message to a PGN that is reserved for control PGNs for TP or ETP
operations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EIO</span></code>: I/O error. This can occur if the amount of data provided to the
socket for a TP or ETP session does not match the announced amount of data for
the session.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOENT</span></code>: No such file or directory. This can happen when the stack
attempts to transfer CTS or EOMA but cannot find a matching receiving socket
anymore.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOIOCTLCMD</span></code>: No ioctls are available for the socket layer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EPERM</span></code>: Operation not permitted. For example, this can occur if a
requested action requires <code class="docutils literal notranslate"><span class="pre">CAP_NET_ADMIN</span></code> privileges.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENETUNREACH</span></code>: Network unreachable. Most likely, this occurs when frames
cannot be transmitted to the CAN bus.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ETIME</span></code>: Timer expired. This can happen if a timeout occurs while
attempting to send a simple message, for example, when an echo message from
the controller is not received.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EPROTO</span></code>: Protocol error.</p>
<ul>
<li><p>Used for various protocol-level errors in J1939, including:</p>
<ul>
<li><p>Duplicate sequence number.</p></li>
<li><p>Unexpected EDPO or ECTS packet.</p></li>
<li><p>Invalid PGN or offset in EDPO/ECTS.</p></li>
<li><p>Number of EDPO packets exceeded CTS allowance.</p></li>
<li><p>Any other protocol-level error.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">EMSGSIZE</span></code>: Message too long.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOMSG</span></code>: No message available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EALREADY</span></code>: The ECU is already engaged in one or more connection-managed
sessions and cannot support another.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EHOSTUNREACH</span></code>: A timeout occurred, and the session was aborted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EBADMSG</span></code>: CTS (Clear to Send) messages were received during an active data
transfer, causing an abort.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTRECOVERABLE</span></code>: The maximum retransmission request limit was reached,
and the session cannot recover.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENOTCONN</span></code>: An unexpected data transfer packet was received.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EILSEQ</span></code>: A bad sequence number was received, and the software could not
recover.</p></li>
</ul>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/networking/j1939.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>