<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Process Addresses &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Boot Memory" href="bootmem.html" />
    <link rel="prev" title="Page Tables" href="page_tables.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer’s API guide</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/mm/process_addrs.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="process-addresses">
<h1>Process Addresses<a class="headerlink" href="#process-addresses" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>Userland memory ranges are tracked by the kernel via Virtual Memory Areas or
‘VMA’s of type <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code>.</p>
<p>Each VMA describes a virtually contiguous memory range with identical
attributes, each described by a <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code>
object. Userland access outside of VMAs is invalid except in the case where an
adjacent stack VMA could be extended to contain the accessed address.</p>
<p>All VMAs are contained within one and only one virtual address space, described
by a <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span></code> object which is referenced by all tasks (that is,
threads) which share the virtual address space. We refer to this as the
<code class="xref c c-struct docutils literal notranslate"><span class="pre">mm</span></code>.</p>
<p>Each mm object contains a maple tree data structure which describes all VMAs
within the virtual address space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An exception to this is the ‘gate’ VMA which is provided by
architectures which use <code class="xref c c-struct docutils literal notranslate"><span class="pre">vsyscall</span></code> and is a global static
object which does not belong to any specific mm.</p>
</div>
<section id="locking">
<h2>Locking<a class="headerlink" href="#locking" title="Link to this heading">¶</a></h2>
<p>The kernel is designed to be highly scalable against concurrent read operations
on VMA <strong>metadata</strong> so a complicated set of locks are required to ensure memory
corruption does not occur.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Locking VMAs for their metadata does not have any impact on the memory
they describe nor the page tables that map them.</p>
</div>
<section id="terminology">
<h3>Terminology<a class="headerlink" href="#terminology" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>mmap locks</strong> - Each MM has a read/write semaphore <code class="xref c c-member docutils literal notranslate"><span class="pre">mmap_lock</span></code>
which locks at a process address space granularity which can be acquired via
<code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_read_lock()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_lock()</span></code> and variants.</p></li>
<li><p><strong>VMA locks</strong> - The VMA lock is at VMA granularity (of course) which behaves
as a read/write semaphore in practice. A VMA read lock is obtained via
<code class="xref c c-func docutils literal notranslate"><span class="pre">lock_vma_under_rcu()</span></code> (and unlocked via <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_end_read()</span></code>) and a
write lock via <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_write()</span></code> (all VMA write locks are unlocked
automatically when the mmap write lock is released). To take a VMA write lock
you <strong>must</strong> have already acquired an <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_lock()</span></code>.</p></li>
<li><p><strong>rmap locks</strong> - When trying to access VMAs through the reverse mapping via a
<code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span></code> or <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_vma</span></code> object
(reachable from a folio via <code class="xref c c-member docutils literal notranslate"><span class="pre">folio-&gt;mapping</span></code>). VMAs must be stabilised via
<code class="xref c c-func docutils literal notranslate"><span class="pre">anon_vma_[try]lock_read()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">anon_vma_[try]lock_write()</span></code> for
anonymous memory and <code class="xref c c-func docutils literal notranslate"><span class="pre">i_mmap_[try]lock_read()</span></code> or
<code class="xref c c-func docutils literal notranslate"><span class="pre">i_mmap_[try]lock_write()</span></code> for file-backed memory. We refer to these
locks as the reverse mapping locks, or ‘rmap locks’ for brevity.</p></li>
</ul>
<p>We discuss page table locks separately in the dedicated section below.</p>
<p>The first thing <strong>any</strong> of these locks achieve is to <strong>stabilise</strong> the VMA
within the MM tree. That is, guaranteeing that the VMA object will not be
deleted from under you nor modified (except for some specific fields
described below).</p>
<p>Stabilising a VMA also keeps the address space described by it around.</p>
</section>
<section id="lock-usage">
<h3>Lock usage<a class="headerlink" href="#lock-usage" title="Link to this heading">¶</a></h3>
<p>If you want to <strong>read</strong> VMA metadata fields or just keep the VMA stable, you
must do one of the following:</p>
<ul class="simple">
<li><p>Obtain an mmap read lock at the MM granularity via <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_read_lock()</span></code> (or a
suitable variant), unlocking it with a matching <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_read_unlock()</span></code> when
you’re done with the VMA, <em>or</em></p></li>
<li><p>Try to obtain a VMA read lock via <code class="xref c c-func docutils literal notranslate"><span class="pre">lock_vma_under_rcu()</span></code>. This tries to
acquire the lock atomically so might fail, in which case fall-back logic is
required to instead obtain an mmap read lock if this returns <code class="xref c c-macro docutils literal notranslate"><span class="pre">NULL</span></code>,
<em>or</em></p></li>
<li><p>Acquire an rmap lock before traversing the locked interval tree (whether
anonymous or file-backed) to obtain the required VMA.</p></li>
</ul>
<p>If you want to <strong>write</strong> VMA metadata fields, then things vary depending on the
field (we explore each VMA field in detail below). For the majority you must:</p>
<ul class="simple">
<li><p>Obtain an mmap write lock at the MM granularity via <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_lock()</span></code> (or a
suitable variant), unlocking it with a matching <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_unlock()</span></code> when
you’re done with the VMA, <em>and</em></p></li>
<li><p>Obtain a VMA write lock via <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_write()</span></code> for each VMA you wish to
modify, which will be released automatically when <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_unlock()</span></code> is
called.</p></li>
<li><p>If you want to be able to write to <strong>any</strong> field, you must also hide the VMA
from the reverse mapping by obtaining an <strong>rmap write lock</strong>.</p></li>
</ul>
<p>VMA locks are special in that you must obtain an mmap <strong>write</strong> lock <strong>first</strong>
in order to obtain a VMA <strong>write</strong> lock. A VMA <strong>read</strong> lock however can be
obtained without any other lock (<code class="xref c c-func docutils literal notranslate"><span class="pre">lock_vma_under_rcu()</span></code> will acquire then
release an RCU lock to lookup the VMA for you).</p>
<p>This constrains the impact of writers on readers, as a writer can interact with
one VMA while a reader interacts with another simultaneously.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The primary users of VMA read locks are page fault handlers, which
means that without a VMA write lock, page faults will run concurrent with
whatever you are doing.</p>
</div>
<p>Examining all valid lock states:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>mmap lock</p></th>
<th class="head"><p>VMA lock</p></th>
<th class="head"><p>rmap lock</p></th>
<th class="head"><p>Stable?</p></th>
<th class="head"><p>Read?</p></th>
<th class="head"><p>Write most?</p></th>
<th class="head"><p>Write all?</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>R</p></td>
<td><p>-</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-even"><td><p>-</p></td>
<td><p>-</p></td>
<td><p>R/W</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-odd"><td><p>R/W</p></td>
<td><p>-/R</p></td>
<td><p>-/R/W</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-even"><td><p>W</p></td>
<td><p>W</p></td>
<td><p>-/R</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-odd"><td><p>W</p></td>
<td><p>W</p></td>
<td><p>W</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>While it’s possible to obtain a VMA lock while holding an mmap read lock,
attempting to do the reverse is invalid as it can result in deadlock - if
another task already holds an mmap write lock and attempts to acquire a VMA
write lock that will deadlock on the VMA read lock.</p>
</div>
<p>All of these locks behave as read/write semaphores in practice, so you can
obtain either a read or a write lock for each of these.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generally speaking, a read/write semaphore is a class of lock which
permits concurrent readers. However a write lock can only be obtained
once all readers have left the critical region (and pending readers
made to wait).</p>
<p>This renders read locks on a read/write semaphore concurrent with other
readers and write locks exclusive against all others holding the semaphore.</p>
</div>
<section id="vma-fields">
<h4>VMA fields<a class="headerlink" href="#vma-fields" title="Link to this heading">¶</a></h4>
<p>We can subdivide <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> fields by their purpose, which makes it
easier to explore their locking characteristics:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We exclude VMA lock-specific fields here to avoid confusion, as these
are in effect an internal implementation detail.</p>
</div>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Virtual layout fields</span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Write lock</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_start</span></code></p></td>
<td><p>Inclusive start virtual address of range
VMA describes.</p></td>
<td><p>mmap write,
VMA write,
rmap write.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_end</span></code></p></td>
<td><p>Exclusive end virtual address of range
VMA describes.</p></td>
<td><p>mmap write,
VMA write,
rmap write.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_pgoff</span></code></p></td>
<td><p>Describes the page offset into the file,
the original page offset within the
virtual address space (prior to any
<code class="xref c c-func docutils literal notranslate"><span class="pre">mremap()</span></code>), or PFN if a PFN map
and the architecture does not support
<code class="xref c c-macro docutils literal notranslate"><span class="pre">CONFIG_ARCH_HAS_PTE_SPECIAL</span></code>.</p></td>
<td><p>mmap write,
VMA write,
rmap write.</p></td>
</tr>
</tbody>
</table>
<p>These fields describes the size, start and end of the VMA, and as such cannot be
modified without first being hidden from the reverse mapping since these fields
are used to locate VMAs within the reverse mapping interval trees.</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Core fields</span><a class="headerlink" href="#id2" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Write lock</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_mm</span></code></p></td>
<td><p>Containing mm_struct.</p></td>
<td><p>None - written once on
initial map.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_page_prot</span></code></p></td>
<td><p>Architecture-specific page table
protection bits determined from VMA
flags.</p></td>
<td><p>mmap write, VMA write.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_flags</span></code></p></td>
<td><p>Read-only access to VMA flags describing
attributes of the VMA, in union with
private writable
<code class="xref c c-member docutils literal notranslate"><span class="pre">__vm_flags</span></code>.</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">__vm_flags</span></code></p></td>
<td><p>Private, writable access to VMA flags
field, updated by
<code class="xref c c-func docutils literal notranslate"><span class="pre">vm_flags_*()</span></code> functions.</p></td>
<td><p>mmap write, VMA write.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_file</span></code></p></td>
<td><p>If the VMA is file-backed, points to a
<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a> object describing the
underlying file, if anonymous then
<code class="xref c c-macro docutils literal notranslate"><span class="pre">NULL</span></code>.</p></td>
<td><p>None - written once on
initial map.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_ops</span></code></p></td>
<td><p>If the VMA is file-backed, then either
the driver or file-system provides a
<code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_operations_struct</span></code>
object describing callbacks to be
invoked on VMA lifetime events.</p></td>
<td><p>None - Written once on
initial map by
<code class="xref c c-func docutils literal notranslate"><span class="pre">f_ops-&gt;mmap()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_private_data</span></code></p></td>
<td><p>A <code class="xref c c-member docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> field for
driver-specific metadata.</p></td>
<td><p>Handled by driver.</p></td>
</tr>
</tbody>
</table>
<p>These are the core fields which describe the MM the VMA belongs to and its attributes.</p>
<table class="docutils align-default" id="id3">
<caption><span class="caption-text">Config-specific fields</span><a class="headerlink" href="#id3" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Configuration option</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Write lock</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">anon_name</span></code></p></td>
<td><p>CONFIG_ANON_VMA_NAME</p></td>
<td><p>A field for storing a
<code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_vma_name</span></code>
object providing a name for anonymous
mappings, or <code class="xref c c-macro docutils literal notranslate"><span class="pre">NULL</span></code> if none
is set or the VMA is file-backed. The
underlying object is reference counted
and can be shared across multiple VMAs
for scalability.</p></td>
<td><p>mmap write,
VMA write.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">swap_readahead_info</span></code></p></td>
<td><p>CONFIG_SWAP</p></td>
<td><p>Metadata used by the swap mechanism
to perform readahead. This field is
accessed atomically.</p></td>
<td><p>mmap read,
swap-specific
lock.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_policy</span></code></p></td>
<td><p>CONFIG_NUMA</p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">mempolicy</span></code> object which
describes the NUMA behaviour of the
VMA. The underlying object is reference
counted.</p></td>
<td><p>mmap write,
VMA write.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">numab_state</span></code></p></td>
<td><p>CONFIG_NUMA_BALANCING</p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">vma_numab_state</span></code> object which
describes the current state of
NUMA balancing in relation to this VMA.
Updated under mmap read lock by
<code class="xref c c-func docutils literal notranslate"><span class="pre">task_numa_work()</span></code>.</p></td>
<td><p>mmap read,
numab-specific
lock.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">vm_userfaultfd_ctx</span></code></p></td>
<td><p>CONFIG_USERFAULTFD</p></td>
<td><p>Userfaultfd context wrapper object of
type <code class="xref c c-type docutils literal notranslate"><span class="pre">vm_userfaultfd_ctx</span></code>,
either of zero size if userfaultfd is
disabled, or containing a pointer
to an underlying
<code class="xref c c-type docutils literal notranslate"><span class="pre">userfaultfd_ctx</span></code> object which
describes userfaultfd metadata.</p></td>
<td><p>mmap write,
VMA write.</p></td>
</tr>
</tbody>
</table>
<p>These fields are present or not depending on whether the relevant kernel
configuration option is set.</p>
<table class="docutils align-default" id="id4">
<caption><span class="caption-text">Reverse mapping fields</span><a class="headerlink" href="#id4" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Write lock</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">shared.rb</span></code></p></td>
<td><p>A red/black tree node used, if the
mapping is file-backed, to place the VMA
in the
<code class="xref c c-member docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space-&gt;i_mmap</span></code>
red/black interval tree.</p></td>
<td><p>mmap write, VMA write,
i_mmap write.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">shared.rb_subtree_last</span></code></p></td>
<td><p>Metadata used for management of the
interval tree if the VMA is file-backed.</p></td>
<td><p>mmap write, VMA write,
i_mmap write.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">anon_vma_chain</span></code></p></td>
<td><p>List of pointers to both forked/CoW’d
<code class="xref c c-type docutils literal notranslate"><span class="pre">anon_vma</span></code> objects and
<code class="xref c c-member docutils literal notranslate"><span class="pre">vma-&gt;anon_vma</span></code> if it is
non-<code class="xref c c-macro docutils literal notranslate"><span class="pre">NULL</span></code>.</p></td>
<td><p>mmap read, anon_vma write.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-member docutils literal notranslate"><span class="pre">anon_vma</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">anon_vma</span></code> object used by
anonymous folios mapped exclusively to
this VMA. Initially set by
<code class="xref c c-func docutils literal notranslate"><span class="pre">anon_vma_prepare()</span></code> serialised
by the <code class="xref c c-macro docutils literal notranslate"><span class="pre">page_table_lock</span></code>. This
is set as soon as any page is faulted in.</p></td>
<td><p>When <code class="xref c c-macro docutils literal notranslate"><span class="pre">NULL</span></code> and
setting non-<code class="xref c c-macro docutils literal notranslate"><span class="pre">NULL</span></code>:
mmap read, page_table_lock.</p>
<p>When non-<code class="xref c c-macro docutils literal notranslate"><span class="pre">NULL</span></code> and
setting <code class="xref c c-macro docutils literal notranslate"><span class="pre">NULL</span></code>:
mmap write, VMA write,
anon_vma write.</p>
</td>
</tr>
</tbody>
</table>
<p>These fields are used to both place the VMA within the reverse mapping, and for
anonymous mappings, to be able to access both related <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_vma</span></code> objects
and the <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_vma</span></code> in which folios mapped exclusively to this VMA should
reside.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a file-backed mapping is mapped with <code class="xref c c-macro docutils literal notranslate"><span class="pre">MAP_PRIVATE</span></code> set
then it can be in both the <code class="xref c c-type docutils literal notranslate"><span class="pre">anon_vma</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">i_mmap</span></code>
trees at the same time, so all of these fields might be utilised at
once.</p>
</div>
</section>
</section>
<section id="page-tables">
<h3>Page tables<a class="headerlink" href="#page-tables" title="Link to this heading">¶</a></h3>
<p>We won’t speak exhaustively on the subject but broadly speaking, page tables map
virtual addresses to physical ones through a series of page tables, each of
which contain entries with physical addresses for the next page table level
(along with flags), and at the leaf level the physical addresses of the
underlying physical data pages or a special entry such as a swap entry,
migration entry or other special marker. Offsets into these pages are provided
by the virtual address itself.</p>
<p>In Linux these are divided into five levels - PGD, P4D, PUD, PMD and PTE. Huge
pages might eliminate one or two of these levels, but when this is the case we
typically refer to the leaf level as the PTE level regardless.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In instances where the architecture supports fewer page tables than
five the kernel cleverly ‘folds’ page table levels, that is stubbing
out functions related to the skipped levels. This allows us to
conceptually act as if there were always five levels, even if the
compiler might, in practice, eliminate any code relating to missing
ones.</p>
</div>
<p>There are four key operations typically performed on page tables:</p>
<ol class="arabic simple">
<li><p><strong>Traversing</strong> page tables - Simply reading page tables in order to traverse
them. This only requires that the VMA is kept stable, so a lock which
establishes this suffices for traversal (there are also lockless variants
which eliminate even this requirement, such as <code class="xref c c-func docutils literal notranslate"><span class="pre">gup_fast()</span></code>).</p></li>
<li><p><strong>Installing</strong> page table mappings - Whether creating a new mapping or
modifying an existing one in such a way as to change its identity. This
requires that the VMA is kept stable via an mmap or VMA lock (explicitly not
rmap locks).</p></li>
<li><p><strong>Zapping/unmapping</strong> page table entries - This is what the kernel calls
clearing page table mappings at the leaf level only, whilst leaving all page
tables in place. This is a very common operation in the kernel performed on
file truncation, the <code class="xref c c-macro docutils literal notranslate"><span class="pre">MADV_DONTNEED</span></code> operation via
<code class="xref c c-func docutils literal notranslate"><span class="pre">madvise()</span></code>, and others. This is performed by a number of functions
including <code class="xref c c-func docutils literal notranslate"><span class="pre">unmap_mapping_range()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">unmap_mapping_pages()</span></code>.
The VMA need only be kept stable for this operation.</p></li>
<li><p><strong>Freeing</strong> page tables - When finally the kernel removes page tables from a
userland process (typically via <code class="xref c c-func docutils literal notranslate"><span class="pre">free_pgtables()</span></code>) extreme care must
be taken to ensure this is done safely, as this logic finally frees all page
tables in the specified range, ignoring existing leaf entries (it assumes the
caller has both zapped the range and prevented any further faults or
modifications within it).</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Modifying mappings for reclaim or migration is performed under rmap
lock as it, like zapping, does not fundamentally modify the identity
of what is being mapped.</p>
</div>
<p><strong>Traversing</strong> and <strong>zapping</strong> ranges can be performed holding any one of the
locks described in the terminology section above - that is the mmap lock, the
VMA lock or either of the reverse mapping locks.</p>
<p>That is - as long as you keep the relevant VMA <strong>stable</strong> - you are good to go
ahead and perform these operations on page tables (though internally, kernel
operations that perform writes also acquire internal page table locks to
serialise - see the page table implementation detail section for more details).</p>
<p>When <strong>installing</strong> page table entries, the mmap or VMA lock must be held to
keep the VMA stable. We explore why this is in the page table locking details
section below.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Page tables are normally only traversed in regions covered by VMAs.
If you want to traverse page tables in areas that might not be
covered by VMAs, heavier locking is required.
See <code class="xref c c-func docutils literal notranslate"><span class="pre">walk_page_range_novma()</span></code> for details.</p>
</div>
<p><strong>Freeing</strong> page tables is an entirely internal memory management operation and
has special requirements (see the page freeing section below for more details).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When <strong>freeing</strong> page tables, it must not be possible for VMAs
containing the ranges those page tables map to be accessible via
the reverse mapping.</p>
<p>The <code class="xref c c-func docutils literal notranslate"><span class="pre">free_pgtables()</span></code> function removes the relevant VMAs
from the reverse mappings, but no other VMAs can be permitted to be
accessible and span the specified range.</p>
</div>
</section>
<section id="lock-ordering">
<h3>Lock ordering<a class="headerlink" href="#lock-ordering" title="Link to this heading">¶</a></h3>
<p>As we have multiple locks across the kernel which may or may not be taken at the
same time as explicit mm or VMA locks, we have to be wary of lock inversion, and
the <strong>order</strong> in which locks are acquired and released becomes very important.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lock inversion occurs when two threads need to acquire multiple locks,
but in doing so inadvertently cause a mutual deadlock.</p>
<p>For example, consider thread 1 which holds lock A and tries to acquire lock B,
while thread 2 holds lock B and tries to acquire lock A.</p>
<p>Both threads are now deadlocked on each other. However, had they attempted to
acquire locks in the same order, one would have waited for the other to
complete its work and no deadlock would have occurred.</p>
</div>
<p>The opening comment in <code class="xref c c-macro docutils literal notranslate"><span class="pre">mm/rmap.c</span></code> describes in detail the required
ordering of locks within memory management code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>inode-&gt;i_rwsem        (while writing or truncating, not reading or faulting)
  mm-&gt;mmap_lock
    mapping-&gt;invalidate_lock (in filemap_fault)
      folio_lock
        hugetlbfs_i_mmap_rwsem_key (in huge_pmd_share, see hugetlbfs below)
          vma_start_write
            mapping-&gt;i_mmap_rwsem
              anon_vma-&gt;rwsem
                mm-&gt;page_table_lock or pte_lock
                  swap_lock (in swap_duplicate, swap_info_get)
                    mmlist_lock (in mmput, drain_mmlist and others)
                    mapping-&gt;private_lock (in block_dirty_folio)
                        i_pages lock (widely used)
                          lruvec-&gt;lru_lock (in folio_lruvec_lock_irq)
                    inode-&gt;i_lock (in set_page_dirty&#39;s __mark_inode_dirty)
                    bdi.wb-&gt;list_lock (in set_page_dirty&#39;s __mark_inode_dirty)
                      sb_lock (within inode_lock in fs/fs-writeback.c)
                      i_pages lock (widely used, in set_page_dirty,
                                in arch-dependent flush_dcache_mmap_lock,
                                within bdi.wb-&gt;list_lock in __sync_single_inode)
</pre></div>
</div>
<p>There is also a file-system specific lock ordering comment located at the top of
<code class="xref c c-macro docutils literal notranslate"><span class="pre">mm/filemap.c</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-&gt;i_mmap_rwsem                        (truncate_pagecache)
  -&gt;private_lock                      (__free_pte-&gt;block_dirty_folio)
    -&gt;swap_lock                       (exclusive_swap_page, others)
      -&gt;i_pages lock

-&gt;i_rwsem
  -&gt;invalidate_lock                   (acquired by fs in truncate path)
    -&gt;i_mmap_rwsem                    (truncate-&gt;unmap_mapping_range)

-&gt;mmap_lock
  -&gt;i_mmap_rwsem
    -&gt;page_table_lock or pte_lock     (various, mainly in memory.c)
      -&gt;i_pages lock                  (arch-dependent flush_dcache_mmap_lock)

-&gt;mmap_lock
  -&gt;invalidate_lock                   (filemap_fault)
    -&gt;lock_page                       (filemap_fault, access_process_vm)

-&gt;i_rwsem                             (generic_perform_write)
  -&gt;mmap_lock                         (fault_in_readable-&gt;do_page_fault)

bdi-&gt;wb.list_lock
  sb_lock                             (fs/fs-writeback.c)
  -&gt;i_pages lock                      (__sync_single_inode)

-&gt;i_mmap_rwsem
  -&gt;anon_vma.lock                     (vma_merge)

-&gt;anon_vma.lock
  -&gt;page_table_lock or pte_lock       (anon_vma_prepare and various)

-&gt;page_table_lock or pte_lock
  -&gt;swap_lock                         (try_to_unmap_one)
  -&gt;private_lock                      (try_to_unmap_one)
  -&gt;i_pages lock                      (try_to_unmap_one)
  -&gt;lruvec-&gt;lru_lock                  (follow_page_mask-&gt;mark_page_accessed)
  -&gt;lruvec-&gt;lru_lock                  (check_pte_range-&gt;folio_isolate_lru)
  -&gt;private_lock                      (folio_remove_rmap_pte-&gt;set_page_dirty)
  -&gt;i_pages lock                      (folio_remove_rmap_pte-&gt;set_page_dirty)
  bdi.wb-&gt;list_lock                   (folio_remove_rmap_pte-&gt;set_page_dirty)
  -&gt;inode-&gt;i_lock                     (folio_remove_rmap_pte-&gt;set_page_dirty)
  bdi.wb-&gt;list_lock                   (zap_pte_range-&gt;set_page_dirty)
  -&gt;inode-&gt;i_lock                     (zap_pte_range-&gt;set_page_dirty)
  -&gt;private_lock                      (zap_pte_range-&gt;block_dirty_folio)
</pre></div>
</div>
<p>Please check the current state of these comments which may have changed since
the time of writing of this document.</p>
</section>
</section>
<section id="locking-implementation-details">
<h2>Locking Implementation Details<a class="headerlink" href="#locking-implementation-details" title="Link to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Locking rules for PTE-level page tables are very different from
locking rules for page tables at other levels.</p>
</div>
<section id="page-table-locking-details">
<h3>Page table locking details<a class="headerlink" href="#page-table-locking-details" title="Link to this heading">¶</a></h3>
<p>In addition to the locks described in the terminology section above, we have
additional locks dedicated to page tables:</p>
<ul class="simple">
<li><p><strong>Higher level page table locks</strong> - Higher level page tables, that is PGD, P4D
and PUD each make use of the process address space granularity
<code class="xref c c-member docutils literal notranslate"><span class="pre">mm-&gt;page_table_lock</span></code> lock when modified.</p></li>
<li><p><strong>Fine-grained page table locks</strong> - PMDs and PTEs each have fine-grained locks
either kept within the folios describing the page tables or allocated
separated and pointed at by the folios if <code class="xref c c-macro docutils literal notranslate"><span class="pre">ALLOC_SPLIT_PTLOCKS</span></code> is
set. The PMD spin lock is obtained via <code class="xref c c-func docutils literal notranslate"><span class="pre">pmd_lock()</span></code>, however PTEs are
mapped into higher memory (if a 32-bit system) and carefully locked via
<code class="xref c c-func docutils literal notranslate"><span class="pre">pte_offset_map_lock()</span></code>.</p></li>
</ul>
<p>These locks represent the minimum required to interact with each page table
level, but there are further requirements.</p>
<p>Importantly, note that on a <strong>traversal</strong> of page tables, sometimes no such
locks are taken. However, at the PTE level, at least concurrent page table
deletion must be prevented (using RCU) and the page table must be mapped into
high memory, see below.</p>
<p>Whether care is taken on reading the page table entries depends on the
architecture, see the section on atomicity below.</p>
<section id="locking-rules">
<h4>Locking rules<a class="headerlink" href="#locking-rules" title="Link to this heading">¶</a></h4>
<p>We establish basic locking rules when interacting with page tables:</p>
<ul class="simple">
<li><p>When changing a page table entry the page table lock for that page table
<strong>must</strong> be held, except if you can safely assume nobody can access the page
tables concurrently (such as on invocation of <code class="xref c c-func docutils literal notranslate"><span class="pre">free_pgtables()</span></code>).</p></li>
<li><p>Reads from and writes to page table entries must be <em>appropriately</em>
atomic. See the section on atomicity below for details.</p></li>
<li><p>Populating previously empty entries requires that the mmap or VMA locks are
held (read or write), doing so with only rmap locks would be dangerous (see
the warning below).</p></li>
<li><p>As mentioned previously, zapping can be performed while simply keeping the VMA
stable, that is holding any one of the mmap, VMA or rmap locks.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Populating previously empty entries is dangerous as, when unmapping
VMAs, <code class="xref c c-func docutils literal notranslate"><span class="pre">vms_clear_ptes()</span></code> has a window of time between
zapping (via <code class="xref c c-func docutils literal notranslate"><span class="pre">unmap_vmas()</span></code>) and freeing page tables (via
<code class="xref c c-func docutils literal notranslate"><span class="pre">free_pgtables()</span></code>), where the VMA is still visible in the
rmap tree. <code class="xref c c-func docutils literal notranslate"><span class="pre">free_pgtables()</span></code> assumes that the zap has
already been performed and removes PTEs unconditionally (along with
all other page tables in the freed range), so installing new PTE
entries could leak memory and also cause other unexpected and
dangerous behaviour.</p>
</div>
<p>There are additional rules applicable when moving page tables, which we discuss
in the section on this topic below.</p>
<p>PTE-level page tables are different from page tables at other levels, and there
are extra requirements for accessing them:</p>
<ul class="simple">
<li><p>On 32-bit architectures, they may be in high memory (meaning they need to be
mapped into kernel memory to be accessible).</p></li>
<li><p>When empty, they can be unlinked and RCU-freed while holding an mmap lock or
rmap lock for reading in combination with the PTE and PMD page table locks.
In particular, this happens in <code class="xref c c-func docutils literal notranslate"><span class="pre">retract_page_tables()</span></code> when handling
<code class="xref c c-macro docutils literal notranslate"><span class="pre">MADV_COLLAPSE</span></code>.
So accessing PTE-level page tables requires at least holding an RCU read lock;
but that only suffices for readers that can tolerate racing with concurrent
page table updates such that an empty PTE is observed (in a page table that
has actually already been detached and marked for RCU freeing) while another
new page table has been installed in the same location and filled with
entries. Writers normally need to take the PTE lock and revalidate that the
PMD entry still refers to the same PTE-level page table.
If the writer does not care whether it is the same PTE-level page table, it
can take the PMD lock and revalidate that the contents of pmd entry still meet
the requirements. In particular, this also happens in <code class="xref c c-func docutils literal notranslate"><span class="pre">retract_page_tables()</span></code>
when handling <code class="xref c c-macro docutils literal notranslate"><span class="pre">MADV_COLLAPSE</span></code>.</p></li>
</ul>
<p>To access PTE-level page tables, a helper like <code class="xref c c-func docutils literal notranslate"><span class="pre">pte_offset_map_lock()</span></code> or
<code class="xref c c-func docutils literal notranslate"><span class="pre">pte_offset_map()</span></code> can be used depending on stability requirements.
These map the page table into kernel memory if required, take the RCU lock, and
depending on variant, may also look up or acquire the PTE lock.
See the comment on <code class="xref c c-func docutils literal notranslate"><span class="pre">__pte_offset_map_lock()</span></code>.</p>
</section>
<section id="atomicity">
<h4>Atomicity<a class="headerlink" href="#atomicity" title="Link to this heading">¶</a></h4>
<p>Regardless of page table locks, the MMU hardware concurrently updates accessed
and dirty bits (perhaps more, depending on architecture). Additionally, page
table traversal operations in parallel (though holding the VMA stable) and
functionality like GUP-fast locklessly traverses (that is reads) page tables,
without even keeping the VMA stable at all.</p>
<p>When performing a page table traversal and keeping the VMA stable, whether a
read must be performed once and only once or not depends on the architecture
(for instance x86-64 does not require any special precautions).</p>
<p>If a write is being performed, or if a read informs whether a write takes place
(on an installation of a page table entry say, for instance in
<code class="xref c c-func docutils literal notranslate"><span class="pre">__pud_install()</span></code>), special care must always be taken. In these cases we
can never assume that page table locks give us entirely exclusive access, and
must retrieve page table entries once and only once.</p>
<p>If we are reading page table entries, then we need only ensure that the compiler
does not rearrange our loads. This is achieved via <code class="xref c c-func docutils literal notranslate"><span class="pre">pXXp_get()</span></code>
functions - <code class="xref c c-func docutils literal notranslate"><span class="pre">pgdp_get()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">p4dp_get()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">pudp_get()</span></code>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">pmdp_get()</span></code>, and <code class="xref c c-func docutils literal notranslate"><span class="pre">ptep_get()</span></code>.</p>
<p>Each of these uses <code class="xref c c-func docutils literal notranslate"><span class="pre">READ_ONCE()</span></code> to guarantee that the compiler reads
the page table entry only once.</p>
<p>However, if we wish to manipulate an existing page table entry and care about
the previously stored data, we must go further and use an hardware atomic
operation as, for example, in <code class="xref c c-func docutils literal notranslate"><span class="pre">ptep_get_and_clear()</span></code>.</p>
<p>Equally, operations that do not rely on the VMA being held stable, such as
GUP-fast (see <code class="xref c c-func docutils literal notranslate"><span class="pre">gup_fast()</span></code> and its various page table level handlers like
<code class="xref c c-func docutils literal notranslate"><span class="pre">gup_fast_pte_range()</span></code>), must very carefully interact with page table
entries, using functions such as <code class="xref c c-func docutils literal notranslate"><span class="pre">ptep_get_lockless()</span></code> and equivalent for
higher level page table levels.</p>
<p>Writes to page table entries must also be appropriately atomic, as established
by <code class="xref c c-func docutils literal notranslate"><span class="pre">set_pXX()</span></code> functions - <code class="xref c c-func docutils literal notranslate"><span class="pre">set_pgd()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">set_p4d()</span></code>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">set_pud()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">set_pmd()</span></code>, and <code class="xref c c-func docutils literal notranslate"><span class="pre">set_pte()</span></code>.</p>
<p>Equally functions which clear page table entries must be appropriately atomic,
as in <code class="xref c c-func docutils literal notranslate"><span class="pre">pXX_clear()</span></code> functions - <code class="xref c c-func docutils literal notranslate"><span class="pre">pgd_clear()</span></code>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">p4d_clear()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">pud_clear()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">pmd_clear()</span></code>, and
<code class="xref c c-func docutils literal notranslate"><span class="pre">pte_clear()</span></code>.</p>
</section>
<section id="page-table-installation">
<h4>Page table installation<a class="headerlink" href="#page-table-installation" title="Link to this heading">¶</a></h4>
<p>Page table installation is performed with the VMA held stable explicitly by an
mmap or VMA lock in read or write mode (see the warning in the locking rules
section for details as to why).</p>
<p>When allocating a P4D, PUD or PMD and setting the relevant entry in the above
PGD, P4D or PUD, the <code class="xref c c-member docutils literal notranslate"><span class="pre">mm-&gt;page_table_lock</span></code> must be held. This is
acquired in <code class="xref c c-func docutils literal notranslate"><span class="pre">__p4d_alloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">__pud_alloc()</span></code> and
<code class="xref c c-func docutils literal notranslate"><span class="pre">__pmd_alloc()</span></code> respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">__pmd_alloc()</span></code> actually invokes <code class="xref c c-func docutils literal notranslate"><span class="pre">pud_lock()</span></code> and
<code class="xref c c-func docutils literal notranslate"><span class="pre">pud_lockptr()</span></code> in turn, however at the time of writing it ultimately
references the <code class="xref c c-member docutils literal notranslate"><span class="pre">mm-&gt;page_table_lock</span></code>.</p>
</div>
<p>Allocating a PTE will either use the <code class="xref c c-member docutils literal notranslate"><span class="pre">mm-&gt;page_table_lock</span></code> or, if
<code class="xref c c-macro docutils literal notranslate"><span class="pre">USE_SPLIT_PMD_PTLOCKS</span></code> is defined, a lock embedded in the PMD
physical page metadata in the form of a <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ptdesc</span></code>, acquired by
<code class="xref c c-func docutils literal notranslate"><span class="pre">pmd_ptdesc()</span></code> called from <code class="xref c c-func docutils literal notranslate"><span class="pre">pmd_lock()</span></code> and ultimately
<code class="xref c c-func docutils literal notranslate"><span class="pre">__pte_alloc()</span></code>.</p>
<p>Finally, modifying the contents of the PTE requires special treatment, as the
PTE page table lock must be acquired whenever we want stable and exclusive
access to entries contained within a PTE, especially when we wish to modify
them.</p>
<p>This is performed via <code class="xref c c-func docutils literal notranslate"><span class="pre">pte_offset_map_lock()</span></code> which carefully checks to
ensure that the PTE hasn’t changed from under us, ultimately invoking
<code class="xref c c-func docutils literal notranslate"><span class="pre">pte_lockptr()</span></code> to obtain a spin lock at PTE granularity contained within
the <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ptdesc</span></code> associated with the physical PTE page. The lock
must be released via <code class="xref c c-func docutils literal notranslate"><span class="pre">pte_unmap_unlock()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are some variants on this, such as
<code class="xref c c-func docutils literal notranslate"><span class="pre">pte_offset_map_rw_nolock()</span></code> when we know we hold the PTE stable but
for brevity we do not explore this.  See the comment for
<code class="xref c c-func docutils literal notranslate"><span class="pre">__pte_offset_map_lock()</span></code> for more details.</p>
</div>
<p>When modifying data in ranges we typically only wish to allocate higher page
tables as necessary, using these locks to avoid races or overwriting anything,
and set/clear data at the PTE level as required (for instance when page faulting
or zapping).</p>
<p>A typical pattern taken when traversing page table entries to install a new
mapping is to optimistically determine whether the page table entry in the table
above is empty, if so, only then acquiring the page table lock and checking
again to see if it was allocated underneath us.</p>
<p>This allows for a traversal with page table locks only being taken when
required. An example of this is <code class="xref c c-func docutils literal notranslate"><span class="pre">__pud_alloc()</span></code>.</p>
<p>At the leaf page table, that is the PTE, we can’t entirely rely on this pattern
as we have separate PMD and PTE locks and a THP collapse for instance might have
eliminated the PMD entry as well as the PTE from under us.</p>
<p>This is why <code class="xref c c-func docutils literal notranslate"><span class="pre">__pte_offset_map_lock()</span></code> locklessly retrieves the PMD entry
for the PTE, carefully checking it is as expected, before acquiring the
PTE-specific lock, and then <em>again</em> checking that the PMD entry is as expected.</p>
<p>If a THP collapse (or similar) were to occur then the lock on both pages would
be acquired, so we can ensure this is prevented while the PTE lock is held.</p>
<p>Installing entries this way ensures mutual exclusion on write.</p>
</section>
<section id="page-table-freeing">
<h4>Page table freeing<a class="headerlink" href="#page-table-freeing" title="Link to this heading">¶</a></h4>
<p>Tearing down page tables themselves is something that requires significant
care. There must be no way that page tables designated for removal can be
traversed or referenced by concurrent tasks.</p>
<p>It is insufficient to simply hold an mmap write lock and VMA lock (which will
prevent racing faults, and rmap operations), as a file-backed mapping can be
truncated under the <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space-&gt;i_mmap_rwsem</span></code> alone.</p>
<p>As a result, no VMA which can be accessed via the reverse mapping (either
through the <code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_vma-&gt;rb_root</span></code> or the <code class="xref c c-member docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">address_space-&gt;i_mmap</span></code> interval trees) can have its page tables torn down.</p>
<p>The operation is typically performed via <code class="xref c c-func docutils literal notranslate"><span class="pre">free_pgtables()</span></code>, which assumes
either the mmap write lock has been taken (as specified by its
<code class="xref c c-member docutils literal notranslate"><span class="pre">mm_wr_locked</span></code> parameter), or that the VMA is already unreachable.</p>
<p>It carefully removes the VMA from all reverse mappings, however it’s important
that no new ones overlap these or any route remain to permit access to addresses
within the range whose page tables are being torn down.</p>
<p>Additionally, it assumes that a zap has already been performed and steps have
been taken to ensure that no further page table entries can be installed between
the zap and the invocation of <code class="xref c c-func docutils literal notranslate"><span class="pre">free_pgtables()</span></code>.</p>
<p>Since it is assumed that all such steps have been taken, page table entries are
cleared without page table locks (in the <code class="xref c c-func docutils literal notranslate"><span class="pre">pgd_clear()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">p4d_clear()</span></code>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">pud_clear()</span></code>, and <code class="xref c c-func docutils literal notranslate"><span class="pre">pmd_clear()</span></code> functions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible for leaf page tables to be torn down independent of
the page tables above it as is done by
<code class="xref c c-func docutils literal notranslate"><span class="pre">retract_page_tables()</span></code>, which is performed under the i_mmap
read lock, PMD, and PTE page table locks, without this level of care.</p>
</div>
</section>
<section id="page-table-moving">
<h4>Page table moving<a class="headerlink" href="#page-table-moving" title="Link to this heading">¶</a></h4>
<p>Some functions manipulate page table levels above PMD (that is PUD, P4D and PGD
page tables). Most notable of these is <code class="xref c c-func docutils literal notranslate"><span class="pre">mremap()</span></code>, which is capable of
moving higher level page tables.</p>
<p>In these instances, it is required that <strong>all</strong> locks are taken, that is
the mmap lock, the VMA lock and the relevant rmap locks.</p>
<p>You can observe this in the <code class="xref c c-func docutils literal notranslate"><span class="pre">mremap()</span></code> implementation in the functions
<code class="xref c c-func docutils literal notranslate"><span class="pre">take_rmap_locks()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">drop_rmap_locks()</span></code> which perform the rmap
side of lock acquisition, invoked ultimately by <code class="xref c c-func docutils literal notranslate"><span class="pre">move_page_tables()</span></code>.</p>
</section>
</section>
<section id="vma-lock-internals">
<h3>VMA lock internals<a class="headerlink" href="#vma-lock-internals" title="Link to this heading">¶</a></h3>
<section id="overview">
<h4>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h4>
<p>VMA read locking is entirely optimistic - if the lock is contended or a competing
write has started, then we do not obtain a read lock.</p>
<p>A VMA <strong>read</strong> lock is obtained by <code class="xref c c-func docutils literal notranslate"><span class="pre">lock_vma_under_rcu()</span></code>, which first
calls <code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code> to ensure that the VMA is looked up in an RCU
critical section, then attempts to VMA lock it via <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_read()</span></code>,
before releasing the RCU lock via <code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code>.</p>
<p>In cases when the user already holds mmap read lock, <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_read_locked()</span></code>
and <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_read_locked_nested()</span></code> can be used. These functions do not
fail due to lock contention but the caller should still check their return values
in case they fail for other reasons.</p>
<p>VMA read locks increment <code class="xref c c-member docutils literal notranslate"><span class="pre">vma.vm_refcnt</span></code> reference counter for their
duration and the caller of <code class="xref c c-func docutils literal notranslate"><span class="pre">lock_vma_under_rcu()</span></code> must drop it via
<code class="xref c c-func docutils literal notranslate"><span class="pre">vma_end_read()</span></code>.</p>
<p>VMA <strong>write</strong> locks are acquired via <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_write()</span></code> in instances where a
VMA is about to be modified, unlike <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_read()</span></code> the lock is always
acquired. An mmap write lock <strong>must</strong> be held for the duration of the VMA write
lock, releasing or downgrading the mmap write lock also releases the VMA write
lock so there is no <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_end_write()</span></code> function.</p>
<p>Note that when write-locking a VMA lock, the <code class="xref c c-member docutils literal notranslate"><span class="pre">vma.vm_refcnt</span></code> is temporarily
modified so that readers can detect the presense of a writer. The reference counter is
restored once the vma sequence number used for serialisation is updated.</p>
<p>This ensures the semantics we require - VMA write locks provide exclusive write
access to the VMA.</p>
</section>
<section id="implementation-details">
<h4>Implementation details<a class="headerlink" href="#implementation-details" title="Link to this heading">¶</a></h4>
<p>The VMA lock mechanism is designed to be a lightweight means of avoiding the use
of the heavily contended mmap lock. It is implemented using a combination of a
reference counter and sequence numbers belonging to the containing
<code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span></code> and the VMA.</p>
<p>Read locks are acquired via <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_read()</span></code>, which is an optimistic
operation, i.e. it tries to acquire a read lock but returns false if it is
unable to do so. At the end of the read operation, <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_end_read()</span></code> is
called to release the VMA read lock.</p>
<p>Invoking <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_read()</span></code> requires that <code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code> has
been called first, establishing that we are in an RCU critical section upon VMA
read lock acquisition. Once acquired, the RCU lock can be released as it is only
required for lookup. This is abstracted by <code class="xref c c-func docutils literal notranslate"><span class="pre">lock_vma_under_rcu()</span></code> which
is the interface a user should use.</p>
<p>Writing requires the mmap to be write-locked and the VMA lock to be acquired via
<code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_write()</span></code>, however the write lock is released by the termination or
downgrade of the mmap write lock so no <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_end_write()</span></code> is required.</p>
<p>All this is achieved by the use of per-mm and per-VMA sequence counts, which are
used in order to reduce complexity, especially for operations which write-lock
multiple VMAs at once.</p>
<p>If the mm sequence count, <code class="xref c c-member docutils literal notranslate"><span class="pre">mm-&gt;mm_lock_seq</span></code> is equal to the VMA
sequence count <code class="xref c c-member docutils literal notranslate"><span class="pre">vma-&gt;vm_lock_seq</span></code> then the VMA is write-locked. If
they differ, then it is not.</p>
<p>Each time the mmap write lock is released in <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_unlock()</span></code> or
<code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_downgrade()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_end_write_all()</span></code> is invoked which
also increments <code class="xref c c-member docutils literal notranslate"><span class="pre">mm-&gt;mm_lock_seq</span></code> via
<code class="xref c c-func docutils literal notranslate"><span class="pre">mm_lock_seqcount_end()</span></code>.</p>
<p>This way, we ensure that, regardless of the VMA’s sequence number, a write lock
is never incorrectly indicated and that when we release an mmap write lock we
efficiently release <strong>all</strong> VMA write locks contained within the mmap at the
same time.</p>
<p>Since the mmap write lock is exclusive against others who hold it, the automatic
release of any VMA locks on its release makes sense, as you would never want to
keep VMAs locked across entirely separate write operations. It also maintains
correct lock ordering.</p>
<p>Each time a VMA read lock is acquired, we increment <code class="xref c c-member docutils literal notranslate"><span class="pre">vma.vm_refcnt</span></code>
reference counter and check that the sequence count of the VMA does not match
that of the mm.</p>
<p>If it does, the read lock fails and <code class="xref c c-member docutils literal notranslate"><span class="pre">vma.vm_refcnt</span></code> is dropped.
If it does not, we keep the reference counter raised, excluding writers, but
permitting other readers, who can also obtain this lock under RCU.</p>
<p>Importantly, maple tree operations performed in <code class="xref c c-func docutils literal notranslate"><span class="pre">lock_vma_under_rcu()</span></code>
are also RCU safe, so the whole read lock operation is guaranteed to function
correctly.</p>
<p>On the write side, we set a bit in <code class="xref c c-member docutils literal notranslate"><span class="pre">vma.vm_refcnt</span></code> which can’t be
modified by readers and wait for all readers to drop their reference count.
Once there are no readers, the VMA’s sequence number is set to match that of
the mm. During this entire operation mmap write lock is held.</p>
<p>This way, if any read locks are in effect, <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_write()</span></code> will sleep
until these are finished and mutual exclusion is achieved.</p>
<p>After setting the VMA’s sequence number, the bit in <code class="xref c c-member docutils literal notranslate"><span class="pre">vma.vm_refcnt</span></code>
indicating a writer is cleared. From this point on, VMA’s sequence number will
indicate VMA’s write-locked state until mmap write lock is dropped or downgraded.</p>
<p>This clever combination of a reference counter and sequence count allows for
fast RCU-based per-VMA lock acquisition (especially on page fault, though
utilised elsewhere) with minimal complexity around lock ordering.</p>
</section>
</section>
<section id="mmap-write-lock-downgrading">
<h3>mmap write lock downgrading<a class="headerlink" href="#mmap-write-lock-downgrading" title="Link to this heading">¶</a></h3>
<p>When an mmap write lock is held one has exclusive access to resources within the
mmap (with the usual caveats about requiring VMA write locks to avoid races with
tasks holding VMA read locks).</p>
<p>It is then possible to <strong>downgrade</strong> from a write lock to a read lock via
<code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_downgrade()</span></code> which, similar to <code class="xref c c-func docutils literal notranslate"><span class="pre">mmap_write_unlock()</span></code>,
implicitly terminates all VMA write locks via <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_end_write_all()</span></code>, but
importantly does not relinquish the mmap lock while downgrading, therefore
keeping the locked virtual address space stable.</p>
<p>An interesting consequence of this is that downgraded locks are exclusive
against any other task possessing a downgraded lock (since a racing task would
have to acquire a write lock first to downgrade it, and the downgraded lock
prevents a new write lock from being obtained until the original lock is
released).</p>
<p>For clarity, we map read (R)/downgraded write (D)/write (W) locks against one
another showing which locks exclude the others:</p>
<table class="docutils align-default" id="id5">
<caption><span class="caption-text">Lock exclusivity</span><a class="headerlink" href="#id5" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 25.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head stub"></th>
<th class="head"><p>R</p></th>
<th class="head"><p>D</p></th>
<th class="head"><p>W</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><th class="stub"><p>R</p></th>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><th class="stub"><p>D</p></th>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><th class="stub"><p>W</p></th>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
</tbody>
</table>
<p>Here a Y indicates the locks in the matching row/column are mutually exclusive,
and N indicates that they are not.</p>
</section>
<section id="stack-expansion">
<h3>Stack expansion<a class="headerlink" href="#stack-expansion" title="Link to this heading">¶</a></h3>
<p>Stack expansion throws up additional complexities in that we cannot permit there
to be racing page faults, as a result we invoke <code class="xref c c-func docutils literal notranslate"><span class="pre">vma_start_write()</span></code> to
prevent this in <code class="xref c c-func docutils literal notranslate"><span class="pre">expand_downwards()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">expand_upwards()</span></code>.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/mm/process_addrs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>