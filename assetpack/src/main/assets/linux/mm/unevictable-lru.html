<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Unevictable LRU Infrastructure &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Virtually Mapped Kernel Stack Support" href="vmalloced-kernel-stacks.html" />
    <link rel="prev" title="Transparent Hugepage Support" href="transhuge.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer’s API guide</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/mm/unevictable-lru.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="unevictable-lru-infrastructure">
<h1>Unevictable LRU Infrastructure<a class="headerlink" href="#unevictable-lru-infrastructure" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#the-unevictable-lru" id="id2">The Unevictable LRU</a></p>
<ul>
<li><p><a class="reference internal" href="#the-unevictable-lru-folio-list" id="id3">The Unevictable LRU Folio List</a></p></li>
<li><p><a class="reference internal" href="#memory-control-group-interaction" id="id4">Memory Control Group Interaction</a></p></li>
<li><p><a class="reference internal" href="#marking-address-spaces-unevictable" id="id5">Marking Address Spaces Unevictable</a></p></li>
<li><p><a class="reference internal" href="#detecting-unevictable-pages" id="id6">Detecting Unevictable Pages</a></p></li>
<li><p><a class="reference internal" href="#vmscan-s-handling-of-unevictable-folios" id="id7">Vmscan’s Handling of Unevictable Folios</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mlocked-pages" id="id8">MLOCKED Pages</a></p>
<ul>
<li><p><a class="reference internal" href="#history" id="id9">History</a></p></li>
<li><p><a class="reference internal" href="#basic-management" id="id10">Basic Management</a></p></li>
<li><p><a class="reference internal" href="#mlock-mlock2-mlockall-system-call-handling" id="id11">mlock()/mlock2()/mlockall() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#filtering-special-vmas" id="id12">Filtering Special VMAs</a></p></li>
<li><p><a class="reference internal" href="#munlock-munlockall-system-call-handling" id="id13">munlock()/munlockall() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#migrating-mlocked-pages" id="id14">Migrating MLOCKED Pages</a></p></li>
<li><p><a class="reference internal" href="#compacting-mlocked-pages" id="id15">Compacting MLOCKED Pages</a></p></li>
<li><p><a class="reference internal" href="#mlocking-transparent-huge-pages" id="id16">MLOCKING Transparent Huge Pages</a></p></li>
<li><p><a class="reference internal" href="#mmap-map-locked-system-call-handling" id="id17">mmap(MAP_LOCKED) System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#munmap-exit-exec-system-call-handling" id="id18">munmap()/exit()/exec() System Call Handling</a></p></li>
<li><p><a class="reference internal" href="#truncating-mlocked-pages" id="id19">Truncating MLOCKED Pages</a></p></li>
<li><p><a class="reference internal" href="#page-reclaim-in-shrink-list" id="id20">Page Reclaim in shrink_*_list()</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This document describes the Linux memory manager’s “Unevictable LRU”
infrastructure and the use of this to manage several types of “unevictable”
folios.</p>
<p>The document attempts to provide the overall rationale behind this mechanism
and the rationale for some of the design decisions that drove the
implementation.  The latter design rationale is discussed in the context of an
implementation description.  Admittedly, one can obtain the implementation
details - the “what does it do?” - by reading the code.  One hopes that the
descriptions below add value by provide the answer to “why does it do that?”.</p>
</section>
<section id="the-unevictable-lru">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">The Unevictable LRU</a><a class="headerlink" href="#the-unevictable-lru" title="Link to this heading">¶</a></h2>
<p>The Unevictable LRU facility adds an additional LRU list to track unevictable
folios and to hide these folios from vmscan.  This mechanism is based on a patch
by Larry Woodman of Red Hat to address several scalability problems with folio
reclaim in Linux.  The problems have been observed at customer sites on large
memory x86_64 systems.</p>
<p>To illustrate this with an example, a non-NUMA x86_64 platform with 128GB of
main memory will have over 32 million 4k pages in a single node.  When a large
fraction of these pages are not evictable for any reason [see below], vmscan
will spend a lot of time scanning the LRU lists looking for the small fraction
of pages that are evictable.  This can result in a situation where all CPUs are
spending 100% of their time in vmscan for hours or days on end, with the system
completely unresponsive.</p>
<p>The unevictable list addresses the following classes of unevictable pages:</p>
<blockquote>
<div><ul class="simple">
<li><p>Those owned by ramfs.</p></li>
<li><p>Those owned by tmpfs with the noswap mount option.</p></li>
<li><p>Those mapped into SHM_LOCK’d shared memory regions.</p></li>
<li><p>Those mapped into VM_LOCKED [mlock()ed] VMAs.</p></li>
</ul>
</div></blockquote>
<p>The infrastructure may also be able to handle other conditions that make pages
unevictable, either by definition or by circumstance, in the future.</p>
<section id="the-unevictable-lru-folio-list">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">The Unevictable LRU Folio List</a><a class="headerlink" href="#the-unevictable-lru-folio-list" title="Link to this heading">¶</a></h3>
<p>The Unevictable LRU folio list is a lie.  It was never an LRU-ordered
list, but a companion to the LRU-ordered anonymous and file, active and
inactive folio lists; and now it is not even a folio list.  But following
familiar convention, here in this document and in the source, we often
imagine it as a fifth LRU folio list.</p>
<p>The Unevictable LRU infrastructure consists of an additional, per-node, LRU list
called the “unevictable” list and an associated folio flag, PG_unevictable, to
indicate that the folio is being managed on the unevictable list.</p>
<p>The PG_unevictable flag is analogous to, and mutually exclusive with, the
PG_active flag in that it indicates on which LRU list a folio resides when
PG_lru is set.</p>
<p>The Unevictable LRU infrastructure maintains unevictable folios as if they were
on an additional LRU list for a few reasons:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>We get to “treat unevictable folios just like we treat other folios in the
system - which means we get to use the same code to manipulate them, the
same code to isolate them (for migrate, etc.), the same code to keep track
of the statistics, etc...” [Rik van Riel]</p></li>
<li><p>We want to be able to migrate unevictable folios between nodes for memory
defragmentation, workload management and memory hotplug.  The Linux kernel
can only migrate folios that it can successfully isolate from the LRU
lists (or “Movable” folios: outside of consideration here).  If we were to
maintain folios elsewhere than on an LRU-like list, where they can be
detected by <a class="reference internal" href="../core-api/mm-api.html#c.folio_isolate_lru" title="folio_isolate_lru"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_isolate_lru()</span></code></a>, we would prevent their migration.</p></li>
</ol>
</div></blockquote>
<p>The unevictable list does not differentiate between file-backed and
anonymous, swap-backed folios.  This differentiation is only important
while the folios are, in fact, evictable.</p>
<p>The unevictable list benefits from the “arrayification” of the per-node LRU
lists and statistics originally proposed and posted by Christoph Lameter.</p>
</section>
<section id="memory-control-group-interaction">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Memory Control Group Interaction</a><a class="headerlink" href="#memory-control-group-interaction" title="Link to this heading">¶</a></h3>
<p>The unevictable LRU facility interacts with the memory control group [aka
memory controller; see <a class="reference internal" href="../admin-guide/cgroup-v1/memory.html"><span class="doc">Memory Resource Controller</span></a>] by
extending the lru_list enum.</p>
<p>The memory controller data structure automatically gets a per-node unevictable
list as a result of the “arrayification” of the per-node LRU lists (one per
lru_list enum element).  The memory controller tracks the movement of pages to
and from the unevictable list.</p>
<p>When a memory control group comes under memory pressure, the controller will
not attempt to reclaim pages on the unevictable list.  This has a couple of
effects:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Because the pages are “hidden” from reclaim on the unevictable list, the
reclaim process can be more efficient, dealing only with pages that have a
chance of being reclaimed.</p></li>
<li><p>On the other hand, if too many of the pages charged to the control group
are unevictable, the evictable portion of the working set of the tasks in
the control group may not fit into the available memory.  This can cause
the control group to thrash or to OOM-kill tasks.</p></li>
</ol>
</div></blockquote>
</section>
<section id="marking-address-spaces-unevictable">
<span id="mark-addr-space-unevict"></span><h3><a class="toc-backref" href="#id5" role="doc-backlink">Marking Address Spaces Unevictable</a><a class="headerlink" href="#marking-address-spaces-unevictable" title="Link to this heading">¶</a></h3>
<p>For facilities such as ramfs none of the pages attached to the address space
may be evicted.  To prevent eviction of any such pages, the AS_UNEVICTABLE
address space flag is provided, and this can be manipulated by a filesystem
using a number of wrapper functions:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">mapping_set_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Mark the address space as being completely unevictable.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">mapping_clear_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Mark the address space as being evictable.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mapping_unevictable(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping);</span></code></p>
<blockquote>
<div><p>Query the address space, and return true if it is completely
unevictable.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>These are currently used in three places in the kernel:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>By ramfs to mark the address spaces of its inodes when they are created,
and this mark remains for the life of the inode.</p></li>
<li><p>By SYSV SHM to mark SHM_LOCK’d address spaces until SHM_UNLOCK is called.
Note that SHM_LOCK is not required to page in the locked pages if they’re
swapped out; the application must touch the pages manually if it wants to
ensure they’re in memory.</p></li>
<li><p>By the i915 driver to mark pinned address space until it’s unpinned. The
amount of unevictable memory marked by i915 driver is roughly the bounded
object size in debugfs/dri/0/i915_gem_objects.</p></li>
</ol>
</div></blockquote>
</section>
<section id="detecting-unevictable-pages">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Detecting Unevictable Pages</a><a class="headerlink" href="#detecting-unevictable-pages" title="Link to this heading">¶</a></h3>
<p>The function folio_evictable() in mm/internal.h determines whether a folio is
evictable or not using the query function outlined above [see section
<a class="reference internal" href="#mark-addr-space-unevict"><span class="std std-ref">Marking address spaces unevictable</span></a>]
to check the AS_UNEVICTABLE flag.</p>
<p>For address spaces that are so marked after being populated (as SHM regions
might be), the lock action (e.g. SHM_LOCK) can be lazy, and need not populate
the page tables for the region as does, for example, mlock(), nor need it make
any special effort to push any pages in the SHM_LOCK’d area to the unevictable
list.  Instead, vmscan will do this if and when it encounters the folios during
a reclamation scan.</p>
<p>On an unlock action (such as SHM_UNLOCK), the unlocker (e.g. shmctl()) must scan
the pages in the region and “rescue” them from the unevictable list if no other
condition is keeping them unevictable.  If an unevictable region is destroyed,
the pages are also “rescued” from the unevictable list in the process of
freeing them.</p>
<p>folio_evictable() also checks for mlocked folios by calling
folio_test_mlocked(), which is set when a folio is faulted into a
VM_LOCKED VMA, or found in a VMA being VM_LOCKED.</p>
</section>
<section id="vmscan-s-handling-of-unevictable-folios">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Vmscan’s Handling of Unevictable Folios</a><a class="headerlink" href="#vmscan-s-handling-of-unevictable-folios" title="Link to this heading">¶</a></h3>
<p>If unevictable folios are culled in the fault path, or moved to the unevictable
list at mlock() or mmap() time, vmscan will not encounter the folios until they
have become evictable again (via munlock() for example) and have been “rescued”
from the unevictable list.  However, there may be situations where we decide,
for the sake of expediency, to leave an unevictable folio on one of the regular
active/inactive LRU lists for vmscan to deal with.  vmscan checks for such
folios in all of the shrink_{active|inactive|folio}_list() functions and will
“cull” such folios that it encounters: that is, it diverts those folios to the
unevictable list for the memory cgroup and node being scanned.</p>
<p>There may be situations where a folio is mapped into a VM_LOCKED VMA,
but the folio does not have the mlocked flag set.  Such folios will make
it all the way to shrink_active_list() or shrink_folio_list() where they
will be detected when vmscan walks the reverse map in <a class="reference internal" href="../core-api/mm-api.html#c.folio_referenced" title="folio_referenced"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_referenced()</span></code></a>
or <a class="reference internal" href="../core-api/mm-api.html#c.try_to_unmap" title="try_to_unmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_to_unmap()</span></code></a>.  The folio is culled to the unevictable list when it
is released by the shrinker.</p>
<p>To “cull” an unevictable folio, vmscan simply puts the folio back on
the LRU list using <a class="reference internal" href="../core-api/mm-api.html#c.folio_putback_lru" title="folio_putback_lru"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_putback_lru()</span></code></a> - the inverse operation to
<a class="reference internal" href="../core-api/mm-api.html#c.folio_isolate_lru" title="folio_isolate_lru"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_isolate_lru()</span></code></a> - after dropping the folio lock.  Because the
condition which makes the folio unevictable may change once the folio
is unlocked, __pagevec_lru_add_fn() will recheck the unevictable state
of a folio before placing it on the unevictable list.</p>
</section>
</section>
<section id="mlocked-pages">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">MLOCKED Pages</a><a class="headerlink" href="#mlocked-pages" title="Link to this heading">¶</a></h2>
<p>The unevictable folio list is also useful for mlock(), in addition to ramfs and
SYSV SHM.  Note that mlock() is only available in CONFIG_MMU=y situations; in
NOMMU situations, all mappings are effectively mlocked.</p>
<section id="history">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">History</a><a class="headerlink" href="#history" title="Link to this heading">¶</a></h3>
<p>The “Unevictable mlocked Pages” infrastructure is based on work originally
posted by Nick Piggin in an RFC patch entitled “mm: mlocked pages off LRU”.
Nick posted his patch as an alternative to a patch posted by Christoph Lameter
to achieve the same objective: hiding mlocked pages from vmscan.</p>
<p>In Nick’s patch, he used one of the struct page LRU list link fields as a count
of VM_LOCKED VMAs that map the page (Rik van Riel had the same idea three years
earlier).  But this use of the link field for a count prevented the management
of the pages on an LRU list, and thus mlocked pages were not migratable as
<a class="reference internal" href="../core-api/mm-api.html#c.folio_isolate_lru" title="folio_isolate_lru"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_isolate_lru()</span></code></a> could not detect them, and the LRU list link field was not
available to the migration subsystem.</p>
<p>Nick resolved this by putting mlocked pages back on the LRU list before
attempting to isolate them, thus abandoning the count of VM_LOCKED VMAs.  When
Nick’s patch was integrated with the Unevictable LRU work, the count was
replaced by walking the reverse map when munlocking, to determine whether any
other VM_LOCKED VMAs still mapped the page.</p>
<p>However, walking the reverse map for each page when munlocking was ugly and
inefficient, and could lead to catastrophic contention on a file’s rmap lock,
when many processes which had it mlocked were trying to exit.  In 5.18, the
idea of keeping mlock_count in Unevictable LRU list link field was revived and
put to work, without preventing the migration of mlocked pages.  This is why
the “Unevictable LRU list” cannot be a linked list of pages now; but there was
no use for that linked list anyway - though its size is maintained for meminfo.</p>
</section>
<section id="basic-management">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Basic Management</a><a class="headerlink" href="#basic-management" title="Link to this heading">¶</a></h3>
<p>mlocked pages - pages mapped into a VM_LOCKED VMA - are a class of unevictable
pages.  When such a page has been “noticed” by the memory management subsystem,
the folio is marked with the PG_mlocked flag.  This can be manipulated using
folio_set_mlocked() and folio_clear_mlocked() functions.</p>
<p>A PG_mlocked page will be placed on the unevictable list when it is added to
the LRU.  Such pages can be “noticed” by memory management in several places:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>in the mlock()/mlock2()/mlockall() system call handlers;</p></li>
<li><p>in the mmap() system call handler when mmapping a region with the
MAP_LOCKED flag;</p></li>
<li><p>mmapping a region in a task that has called mlockall() with the MCL_FUTURE
flag;</p></li>
<li><p>in the fault path and when a VM_LOCKED stack segment is expanded; or</p></li>
<li><p>as mentioned above, in vmscan:shrink_folio_list() when attempting to
reclaim a page in a VM_LOCKED VMA by <a class="reference internal" href="../core-api/mm-api.html#c.folio_referenced" title="folio_referenced"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_referenced()</span></code></a> or <a class="reference internal" href="../core-api/mm-api.html#c.try_to_unmap" title="try_to_unmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_to_unmap()</span></code></a>.</p></li>
</ol>
</div></blockquote>
<p>mlocked pages become unlocked and rescued from the unevictable list when:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>mapped in a range unlocked via the munlock()/munlockall() system calls;</p></li>
<li><p>munmap()’d out of the last VM_LOCKED VMA that maps the page, including
unmapping at task exit;</p></li>
<li><p>when the page is truncated from the last VM_LOCKED VMA of an mmapped file;
or</p></li>
<li><p>before a page is COW’d in a VM_LOCKED VMA.</p></li>
</ol>
</div></blockquote>
</section>
<section id="mlock-mlock2-mlockall-system-call-handling">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">mlock()/mlock2()/mlockall() System Call Handling</a><a class="headerlink" href="#mlock-mlock2-mlockall-system-call-handling" title="Link to this heading">¶</a></h3>
<p>mlock(), mlock2() and mlockall() system call handlers proceed to mlock_fixup()
for each VMA in the range specified by the call.  In the case of mlockall(),
this is the entire active address space of the task.  Note that mlock_fixup()
is used for both mlocking and munlocking a range of memory.  A call to mlock()
an already VM_LOCKED VMA, or to munlock() a VMA that is not VM_LOCKED, is
treated as a no-op and mlock_fixup() simply returns.</p>
<p>If the VMA passes some filtering as described in “Filtering Special VMAs”
below, mlock_fixup() will attempt to merge the VMA with its neighbors or split
off a subset of the VMA if the range does not cover the entire VMA.  Any pages
already present in the VMA are then marked as mlocked by mlock_folio() via
mlock_pte_range() via walk_page_range() via mlock_vma_pages_range().</p>
<p>Before returning from the system call, do_mlock() or mlockall() will call
__mm_populate() to fault in the remaining pages via get_user_pages() and to
mark those pages as mlocked as they are faulted.</p>
<p>Note that the VMA being mlocked might be mapped with PROT_NONE.  In this case,
get_user_pages() will be unable to fault in the pages.  That’s okay.  If pages
do end up getting faulted into this VM_LOCKED VMA, they will be handled in the
fault path - which is also how mlock2()’s MLOCK_ONFAULT areas are handled.</p>
<p>For each PTE (or PMD) being faulted into a VMA, the page add rmap function
calls mlock_vma_folio(), which calls mlock_folio() when the VMA is VM_LOCKED
(unless it is a PTE mapping of a part of a transparent huge page).  Or when
it is a newly allocated anonymous page, <a class="reference internal" href="../core-api/mm-api.html#c.folio_add_lru_vma" title="folio_add_lru_vma"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_add_lru_vma()</span></code></a> calls
mlock_new_folio() instead: similar to mlock_folio(), but can make better
judgments, since this page is held exclusively and known not to be on LRU yet.</p>
<p>mlock_folio() sets PG_mlocked immediately, then places the page on the CPU’s
mlock folio batch, to batch up the rest of the work to be done under lru_lock by
__mlock_folio().  __mlock_folio() sets PG_unevictable, initializes mlock_count
and moves the page to unevictable state (“the unevictable LRU”, but with
mlock_count in place of LRU threading).  Or if the page was already PG_lru
and PG_unevictable and PG_mlocked, it simply increments the mlock_count.</p>
<p>But in practice that may not work ideally: the page may not yet be on an LRU, or
it may have been temporarily isolated from LRU.  In such cases the mlock_count
field cannot be touched, but will be set to 0 later when __munlock_folio()
returns the page to “LRU”.  Races prohibit mlock_count from being set to 1 then:
rather than risk stranding a page indefinitely as unevictable, always err with
mlock_count on the low side, so that when munlocked the page will be rescued to
an evictable LRU, then perhaps be mlocked again later if vmscan finds it in a
VM_LOCKED VMA.</p>
</section>
<section id="filtering-special-vmas">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Filtering Special VMAs</a><a class="headerlink" href="#filtering-special-vmas" title="Link to this heading">¶</a></h3>
<p>mlock_fixup() filters several classes of “special” VMAs:</p>
<ol class="arabic simple">
<li><p>VMAs with VM_IO or VM_PFNMAP set are skipped entirely.  The pages behind
these mappings are inherently pinned, so we don’t need to mark them as
mlocked.  In any case, most of the pages have no struct page in which to so
mark the page.  Because of this, get_user_pages() will fail for these VMAs,
so there is no sense in attempting to visit them.</p></li>
<li><p>VMAs mapping hugetlbfs page are already effectively pinned into memory.  We
neither need nor want to mlock() these pages.  But __mm_populate() includes
hugetlbfs ranges, allocating the huge pages and populating the PTEs.</p></li>
<li><p>VMAs with VM_DONTEXPAND are generally userspace mappings of kernel pages,
such as the VDSO page, relay channel pages, etc.  These pages are inherently
unevictable and are not managed on the LRU lists.  __mm_populate() includes
these ranges, populating the PTEs if not already populated.</p></li>
<li><p>VMAs with VM_MIXEDMAP set are not marked VM_LOCKED, but __mm_populate()
includes these ranges, populating the PTEs if not already populated.</p></li>
</ol>
<p>Note that for all of these special VMAs, mlock_fixup() does not set the
VM_LOCKED flag.  Therefore, we won’t have to deal with them later during
munlock(), munmap() or task exit.  Neither does mlock_fixup() account these
VMAs against the task’s “locked_vm”.</p>
</section>
<section id="munlock-munlockall-system-call-handling">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">munlock()/munlockall() System Call Handling</a><a class="headerlink" href="#munlock-munlockall-system-call-handling" title="Link to this heading">¶</a></h3>
<p>The munlock() and munlockall() system calls are handled by the same
mlock_fixup() function as mlock(), mlock2() and mlockall() system calls are.
If called to munlock an already munlocked VMA, mlock_fixup() simply returns.
Because of the VMA filtering discussed above, VM_LOCKED will not be set in
any “special” VMAs.  So, those VMAs will be ignored for munlock.</p>
<p>If the VMA is VM_LOCKED, mlock_fixup() again attempts to merge or split off the
specified range.  All pages in the VMA are then munlocked by munlock_folio() via
mlock_pte_range() via walk_page_range() via mlock_vma_pages_range() - the same
function used when mlocking a VMA range, with new flags for the VMA indicating
that it is munlock() being performed.</p>
<p>munlock_folio() uses the mlock pagevec to batch up work to be done
under lru_lock by  __munlock_folio().  __munlock_folio() decrements the
folio’s mlock_count, and when that reaches 0 it clears the mlocked flag
and clears the unevictable flag, moving the folio from unevictable state
to the inactive LRU.</p>
<p>But in practice that may not work ideally: the folio may not yet have reached
“the unevictable LRU”, or it may have been temporarily isolated from it.  In
those cases its mlock_count field is unusable and must be assumed to be 0: so
that the folio will be rescued to an evictable LRU, then perhaps be mlocked
again later if vmscan finds it in a VM_LOCKED VMA.</p>
</section>
<section id="migrating-mlocked-pages">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Migrating MLOCKED Pages</a><a class="headerlink" href="#migrating-mlocked-pages" title="Link to this heading">¶</a></h3>
<p>A page that is being migrated has been isolated from the LRU lists and is held
locked across unmapping of the page, updating the page’s address space entry
and copying the contents and state, until the page table entry has been
replaced with an entry that refers to the new page.  Linux supports migration
of mlocked pages and other unevictable pages.  PG_mlocked is cleared from the
the old page when it is unmapped from the last VM_LOCKED VMA, and set when the
new page is mapped in place of migration entry in a VM_LOCKED VMA.  If the page
was unevictable because mlocked, PG_unevictable follows PG_mlocked; but if the
page was unevictable for other reasons, PG_unevictable is copied explicitly.</p>
<p>Note that page migration can race with mlocking or munlocking of the same page.
There is mostly no problem since page migration requires unmapping all PTEs of
the old page (including munlock where VM_LOCKED), then mapping in the new page
(including mlock where VM_LOCKED).  The page table locks provide sufficient
synchronization.</p>
<p>However, since mlock_vma_pages_range() starts by setting VM_LOCKED on a VMA,
before mlocking any pages already present, if one of those pages were migrated
before mlock_pte_range() reached it, it would get counted twice in mlock_count.
To prevent that, mlock_vma_pages_range() temporarily marks the VMA as VM_IO,
so that mlock_vma_folio() will skip it.</p>
<p>To complete page migration, we place the old and new pages back onto the LRU
afterwards.  The “unneeded” page - old page on success, new page on failure -
is freed when the reference count held by the migration process is released.</p>
</section>
<section id="compacting-mlocked-pages">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Compacting MLOCKED Pages</a><a class="headerlink" href="#compacting-mlocked-pages" title="Link to this heading">¶</a></h3>
<p>The memory map can be scanned for compactable regions and the default behavior
is to let unevictable pages be moved.  /proc/sys/vm/compact_unevictable_allowed
controls this behavior (see <a class="reference internal" href="../admin-guide/sysctl/vm.html"><span class="doc">Documentation for /proc/sys/vm/</span></a>).  The work
of compaction is mostly handled by the page migration code and the same work
flow as described in Migrating MLOCKED Pages will apply.</p>
</section>
<section id="mlocking-transparent-huge-pages">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">MLOCKING Transparent Huge Pages</a><a class="headerlink" href="#mlocking-transparent-huge-pages" title="Link to this heading">¶</a></h3>
<p>A transparent huge page is represented by a single entry on an LRU list.
Therefore, we can only make unevictable an entire compound page, not
individual subpages.</p>
<p>If a user tries to mlock() part of a huge page, and no user mlock()s the
whole of the huge page, we want the rest of the page to be reclaimable.</p>
<p>We cannot just split the page on partial mlock() as split_huge_page() can
fail and a new intermittent failure mode for the syscall is undesirable.</p>
<p>We handle this by keeping PTE-mlocked huge pages on evictable LRU lists:
the PMD on the border of a VM_LOCKED VMA will be split into a PTE table.</p>
<p>This way the huge page is accessible for vmscan.  Under memory pressure the
page will be split, subpages which belong to VM_LOCKED VMAs will be moved
to the unevictable LRU and the rest can be reclaimed.</p>
<p>/proc/meminfo’s Unevictable and Mlocked amounts do not include those parts
of a transparent huge page which are mapped only by PTEs in VM_LOCKED VMAs.</p>
</section>
<section id="mmap-map-locked-system-call-handling">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">mmap(MAP_LOCKED) System Call Handling</a><a class="headerlink" href="#mmap-map-locked-system-call-handling" title="Link to this heading">¶</a></h3>
<p>In addition to the mlock(), mlock2() and mlockall() system calls, an application
can request that a region of memory be mlocked by supplying the MAP_LOCKED flag
to the mmap() call.  There is one important and subtle difference here, though.
mmap() + mlock() will fail if the range cannot be faulted in (e.g. because
mm_populate fails) and returns with ENOMEM while mmap(MAP_LOCKED) will not fail.
The mmapped area will still have properties of the locked area - pages will not
get swapped out - but major page faults to fault memory in might still happen.</p>
<p>Furthermore, any mmap() call or brk() call that expands the heap by a task
that has previously called mlockall() with the MCL_FUTURE flag will result
in the newly mapped memory being mlocked.  Before the unevictable/mlock
changes, the kernel simply called make_pages_present() to allocate pages
and populate the page table.</p>
<p>To mlock a range of memory under the unevictable/mlock infrastructure,
the mmap() handler and task address space expansion functions call
populate_vma_page_range() specifying the vma and the address range to mlock.</p>
</section>
<section id="munmap-exit-exec-system-call-handling">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">munmap()/exit()/exec() System Call Handling</a><a class="headerlink" href="#munmap-exit-exec-system-call-handling" title="Link to this heading">¶</a></h3>
<p>When unmapping an mlocked region of memory, whether by an explicit call to
munmap() or via an internal unmap from exit() or exec() processing, we must
munlock the pages if we’re removing the last VM_LOCKED VMA that maps the pages.
Before the unevictable/mlock changes, mlocking did not mark the pages in any
way, so unmapping them required no processing.</p>
<p>For each PTE (or PMD) being unmapped from a VMA, folio_remove_rmap_*() calls
munlock_vma_folio(), which calls munlock_folio() when the VMA is VM_LOCKED
(unless it was a PTE mapping of a part of a transparent huge page).</p>
<p>munlock_folio() uses the mlock pagevec to batch up work to be done
under lru_lock by  __munlock_folio().  __munlock_folio() decrements the
folio’s mlock_count, and when that reaches 0 it clears the mlocked flag
and clears the unevictable flag, moving the folio from unevictable state
to the inactive LRU.</p>
<p>But in practice that may not work ideally: the folio may not yet have reached
“the unevictable LRU”, or it may have been temporarily isolated from it.  In
those cases its mlock_count field is unusable and must be assumed to be 0: so
that the folio will be rescued to an evictable LRU, then perhaps be mlocked
again later if vmscan finds it in a VM_LOCKED VMA.</p>
</section>
<section id="truncating-mlocked-pages">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Truncating MLOCKED Pages</a><a class="headerlink" href="#truncating-mlocked-pages" title="Link to this heading">¶</a></h3>
<p>File truncation or hole punching forcibly unmaps the deleted pages from
userspace; truncation even unmaps and deletes any private anonymous pages
which had been Copied-On-Write from the file pages now being truncated.</p>
<p>Mlocked pages can be munlocked and deleted in this way: like with munmap(),
for each PTE (or PMD) being unmapped from a VMA, folio_remove_rmap_*() calls
munlock_vma_folio(), which calls munlock_folio() when the VMA is VM_LOCKED
(unless it was a PTE mapping of a part of a transparent huge page).</p>
<p>However, if there is a racing munlock(), since mlock_vma_pages_range() starts
munlocking by clearing VM_LOCKED from a VMA, before munlocking all the pages
present, if one of those pages were unmapped by truncation or hole punch before
mlock_pte_range() reached it, it would not be recognized as mlocked by this VMA,
and would not be counted out of mlock_count.  In this rare case, a page may
still appear as PG_mlocked after it has been fully unmapped: and it is left to
<a class="reference internal" href="../core-api/mm-api.html#c.release_pages" title="release_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">release_pages()</span></code></a> (or __page_cache_release()) to clear it and update statistics
before freeing (this event is counted in /proc/vmstat unevictable_pgs_cleared,
which is usually 0).</p>
</section>
<section id="page-reclaim-in-shrink-list">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Page Reclaim in shrink_*_list()</a><a class="headerlink" href="#page-reclaim-in-shrink-list" title="Link to this heading">¶</a></h3>
<p>vmscan’s shrink_active_list() culls any obviously unevictable pages -
i.e. !page_evictable(page) pages - diverting those to the unevictable list.
However, shrink_active_list() only sees unevictable pages that made it onto the
active/inactive LRU lists.  Note that these pages do not have PG_unevictable
set - otherwise they would be on the unevictable list and shrink_active_list()
would never see them.</p>
<p>Some examples of these unevictable pages on the LRU lists are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>ramfs pages that have been placed on the LRU lists when first allocated.</p></li>
<li><p>SHM_LOCK’d shared memory pages.  shmctl(SHM_LOCK) does not attempt to
allocate or fault in the pages in the shared memory region.  This happens
when an application accesses the page the first time after SHM_LOCK’ing
the segment.</p></li>
<li><p>pages still mapped into VM_LOCKED VMAs, which should be marked mlocked,
but events left mlock_count too low, so they were munlocked too early.</p></li>
</ol>
</div></blockquote>
<p>vmscan’s shrink_inactive_list() and shrink_folio_list() also divert obviously
unevictable pages found on the inactive lists to the appropriate memory cgroup
and node unevictable list.</p>
<p>rmap’s folio_referenced_one(), called via vmscan’s shrink_active_list() or
shrink_folio_list(), and rmap’s try_to_unmap_one() called via shrink_folio_list(),
check for (3) pages still mapped into VM_LOCKED VMAs, and call mlock_vma_folio()
to correct them.  Such pages are culled to the unevictable list when released
by the shrinker.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/mm/unevictable-lru.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>