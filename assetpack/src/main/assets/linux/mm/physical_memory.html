<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Physical Memory &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Page Tables" href="page_tables.html" />
    <link rel="prev" title="Memory Management Documentation" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer’s API guide</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/mm/physical_memory.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../translations/zh_CN/mm/physical_memory.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="physical-memory">
<h1>Physical Memory<a class="headerlink" href="#physical-memory" title="Link to this heading">¶</a></h1>
<p>Linux is available for a wide range of architectures so there is a need for an
architecture-independent abstraction to represent the physical memory. This
chapter describes the structures used to manage physical memory in a running
system.</p>
<p>The first principal concept prevalent in the memory management is
<a class="reference external" href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">Non-Uniform Memory Access (NUMA)</a>.
With multi-core and multi-socket machines, memory may be arranged into banks
that incur a different cost to access depending on the “distance” from the
processor. For example, there might be a bank of memory assigned to each CPU or
a bank of memory very suitable for DMA near peripheral devices.</p>
<p>Each bank is called a node and the concept is represented under Linux by a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pglist_data</span></code> even if the architecture is UMA. This structure is
always referenced by its typedef <code class="docutils literal notranslate"><span class="pre">pg_data_t</span></code>. A <code class="docutils literal notranslate"><span class="pre">pg_data_t</span></code> structure
for a particular node can be referenced by <code class="docutils literal notranslate"><span class="pre">NODE_DATA(nid)</span></code> macro where
<code class="docutils literal notranslate"><span class="pre">nid</span></code> is the ID of that node.</p>
<p>For NUMA architectures, the node structures are allocated by the architecture
specific code early during boot. Usually, these structures are allocated
locally on the memory bank they represent. For UMA architectures, only one
static <code class="docutils literal notranslate"><span class="pre">pg_data_t</span></code> structure called <code class="docutils literal notranslate"><span class="pre">contig_page_data</span></code> is used. Nodes will
be discussed further in Section <a class="reference internal" href="#nodes"><span class="std std-ref">Nodes</span></a></p>
<p>The entire physical address space is partitioned into one or more blocks
called zones which represent ranges within memory. These ranges are usually
determined by architectural constraints for accessing the physical memory.
The memory range within a node that corresponds to a particular zone is
described by a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zone</span></code>. Each zone has
one of the types described below.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code> and <code class="docutils literal notranslate"><span class="pre">ZONE_DMA32</span></code> historically represented memory suitable for
DMA by peripheral devices that cannot access all of the addressable
memory. For many years there are better more and robust interfaces to get
memory with DMA specific requirements (<a class="reference internal" href="../core-api/dma-api.html"><span class="doc">Dynamic DMA mapping using the generic device</span></a>),
but <code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code> and <code class="docutils literal notranslate"><span class="pre">ZONE_DMA32</span></code> still represent memory ranges that have
restrictions on how they can be accessed.
Depending on the architecture, either of these zone types or even they both
can be disabled at build time using <code class="docutils literal notranslate"><span class="pre">CONFIG_ZONE_DMA</span></code> and
<code class="docutils literal notranslate"><span class="pre">CONFIG_ZONE_DMA32</span></code> configuration options. Some 64-bit platforms may need
both zones as they support peripherals with different DMA addressing
limitations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> is for normal memory that can be accessed by the kernel all
the time. DMA operations can be performed on pages in this zone if the DMA
devices support transfers to all addressable memory. <code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> is
always enabled.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ZONE_HIGHMEM</span></code> is the part of the physical memory that is not covered by a
permanent mapping in the kernel page tables. The memory in this zone is only
accessible to the kernel using temporary mappings. This zone is available
only on some 32-bit architectures and is enabled with <code class="docutils literal notranslate"><span class="pre">CONFIG_HIGHMEM</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code> is for normal accessible memory, just like <code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code>.
The difference is that the contents of most pages in <code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code> is
movable. That means that while virtual addresses of these pages do not
change, their content may move between different physical pages. Often
<code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code> is populated during memory hotplug, but it may be
also populated on boot using one of <code class="docutils literal notranslate"><span class="pre">kernelcore</span></code>, <code class="docutils literal notranslate"><span class="pre">movablecore</span></code> and
<code class="docutils literal notranslate"><span class="pre">movable_node</span></code> kernel command line parameters. See
<a class="reference internal" href="page_migration.html"><span class="doc">Page migration</span></a> and
<a class="reference internal" href="../admin-guide/mm/memory-hotplug.html"><span class="doc">Memory Hot(Un)Plug</span></a> for additional details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ZONE_DEVICE</span></code> represents memory residing on devices such as PMEM and GPU.
It has different characteristics than RAM zone types and it exists to provide
<a class="reference internal" href="#pages"><span class="std std-ref">struct page</span></a> and memory map services for device driver
identified physical address ranges. <code class="docutils literal notranslate"><span class="pre">ZONE_DEVICE</span></code> is enabled with
configuration option <code class="docutils literal notranslate"><span class="pre">CONFIG_ZONE_DEVICE</span></code>.</p></li>
</ul>
<p>It is important to note that many kernel operations can only take place using
<code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> so it is the most performance critical zone. Zones are
discussed further in Section <a class="reference internal" href="#zones"><span class="std std-ref">Zones</span></a>.</p>
<p>The relation between node and zone extents is determined by the physical memory
map reported by the firmware, architectural constraints for memory addressing
and certain parameters in the kernel command line.</p>
<p>For example, with 32-bit kernel on an x86 UMA machine with 2 Gbytes of RAM the
entire memory will be on node 0 and there will be three zones: <code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code>,
<code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> and <code class="docutils literal notranslate"><span class="pre">ZONE_HIGHMEM</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0                                                            2G
+-------------------------------------------------------------+
|                            node 0                           |
+-------------------------------------------------------------+

0         16M                    896M                        2G
+----------+-----------------------+--------------------------+
| ZONE_DMA |      ZONE_NORMAL      |       ZONE_HIGHMEM       |
+----------+-----------------------+--------------------------+
</pre></div>
</div>
<p>With a kernel built with <code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code> disabled and <code class="docutils literal notranslate"><span class="pre">ZONE_DMA32</span></code> enabled and
booted with <code class="docutils literal notranslate"><span class="pre">movablecore=80%</span></code> parameter on an arm64 machine with 16 Gbytes of
RAM equally split between two nodes, there will be <code class="docutils literal notranslate"><span class="pre">ZONE_DMA32</span></code>,
<code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> and <code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code> on node 0, and <code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> and
<code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code> on node 1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1G                                9G                         17G
+--------------------------------+ +--------------------------+
|              node 0            | |          node 1          |
+--------------------------------+ +--------------------------+

1G       4G        4200M          9G          9320M          17G
+---------+----------+-----------+ +------------+-------------+
|  DMA32  |  NORMAL  |  MOVABLE  | |   NORMAL   |   MOVABLE   |
+---------+----------+-----------+ +------------+-------------+
</pre></div>
</div>
<p>Memory banks may belong to interleaving nodes. In the example below an x86
machine has 16 Gbytes of RAM in 4 memory banks, even banks belong to node 0
and odd banks belong to node 1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0              4G              8G             12G            16G
+-------------+ +-------------+ +-------------+ +-------------+
|    node 0   | |    node 1   | |    node 0   | |    node 1   |
+-------------+ +-------------+ +-------------+ +-------------+

0   16M      4G
+-----+-------+ +-------------+ +-------------+ +-------------+
| DMA | DMA32 | |    NORMAL   | |    NORMAL   | |    NORMAL   |
+-----+-------+ +-------------+ +-------------+ +-------------+
</pre></div>
</div>
<p>In this case node 0 will span from 0 to 12 Gbytes and node 1 will span from
4 to 16 Gbytes.</p>
<section id="nodes">
<span id="id1"></span><h2>Nodes<a class="headerlink" href="#nodes" title="Link to this heading">¶</a></h2>
<p>As we have mentioned, each node in memory is described by a <code class="docutils literal notranslate"><span class="pre">pg_data_t</span></code> which
is a typedef for a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pglist_data</span></code>. When allocating a page, by default
Linux uses a node-local allocation policy to allocate memory from the node
closest to the running CPU. As processes tend to run on the same CPU, it is
likely the memory from the current node will be used. The allocation policy can
be controlled by users as described in
<a class="reference internal" href="../admin-guide/mm/numa_memory_policy.html"><span class="doc">NUMA Memory Policy</span></a>.</p>
<p>Most NUMA architectures maintain an array of pointers to the node
structures. The actual structures are allocated early during boot when
architecture specific code parses the physical memory map reported by the
firmware. The bulk of the node initialization happens slightly later in the
boot process by free_area_init() function, described later in Section
<a class="reference internal" href="#initialization"><span class="std std-ref">Initialization</span></a>.</p>
<p>Along with the node structures, kernel maintains an array of <code class="docutils literal notranslate"><span class="pre">nodemask_t</span></code>
bitmasks called <code class="docutils literal notranslate"><span class="pre">node_states</span></code>. Each bitmask in this array represents a set of
nodes with particular properties as defined by <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">node_states</span></code>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">N_POSSIBLE</span></code></dt><dd><p>The node could become online at some point.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N_ONLINE</span></code></dt><dd><p>The node is online.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N_NORMAL_MEMORY</span></code></dt><dd><p>The node has regular memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N_HIGH_MEMORY</span></code></dt><dd><p>The node has regular or high memory. When <code class="docutils literal notranslate"><span class="pre">CONFIG_HIGHMEM</span></code> is disabled
aliased to <code class="docutils literal notranslate"><span class="pre">N_NORMAL_MEMORY</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N_MEMORY</span></code></dt><dd><p>The node has memory(regular, high, movable)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N_CPU</span></code></dt><dd><p>The node has one or more CPUs</p>
</dd>
</dl>
<p>For each node that has a property described above, the bit corresponding to the
node ID in the <code class="docutils literal notranslate"><span class="pre">node_states[&lt;property&gt;]</span></code> bitmask is set.</p>
<p>For example, for node 2 with normal memory and CPUs, bit 2 will be set in</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>node_states[N_POSSIBLE]
node_states[N_ONLINE]
node_states[N_NORMAL_MEMORY]
node_states[N_HIGH_MEMORY]
node_states[N_MEMORY]
node_states[N_CPU]
</pre></div>
</div>
<p>For various operations possible with nodemasks please refer to
<code class="docutils literal notranslate"><span class="pre">include/linux/nodemask.h</span></code>.</p>
<p>Among other things, nodemasks are used to provide macros for node traversal,
namely <code class="docutils literal notranslate"><span class="pre">for_each_node()</span></code> and <code class="docutils literal notranslate"><span class="pre">for_each_online_node()</span></code>.</p>
<p>For instance, to call a function foo() for each online node:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for_each_online_node(nid) {
        pg_data_t *pgdat = NODE_DATA(nid);

        foo(pgdat);
}
</pre></div>
</div>
<section id="node-structure">
<h3>Node structure<a class="headerlink" href="#node-structure" title="Link to this heading">¶</a></h3>
<p>The nodes structure <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pglist_data</span></code> is declared in
<code class="docutils literal notranslate"><span class="pre">include/linux/mmzone.h</span></code>. Here we briefly describe fields of this
structure:</p>
<section id="general">
<h4>General<a class="headerlink" href="#general" title="Link to this heading">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node_zones</span></code></dt><dd><p>The zones for this node.  Not all of the zones may be populated, but it is
the full list. It is referenced by this node’s node_zonelists as well as
other node’s node_zonelists.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_zonelists</span></code></dt><dd><p>The list of all zones in all nodes. This list defines the order of zones
that allocations are preferred from. The <code class="docutils literal notranslate"><span class="pre">node_zonelists</span></code> is set up by
<code class="docutils literal notranslate"><span class="pre">build_zonelists()</span></code> in <code class="docutils literal notranslate"><span class="pre">mm/page_alloc.c</span></code> during the initialization of
core memory management structures.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_zones</span></code></dt><dd><p>Number of populated zones in this node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_mem_map</span></code></dt><dd><p>For UMA systems that use FLATMEM memory model the 0’s node
<code class="docutils literal notranslate"><span class="pre">node_mem_map</span></code> is array of struct pages representing each physical frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_page_ext</span></code></dt><dd><p>For UMA systems that use FLATMEM memory model the 0’s node
<code class="docutils literal notranslate"><span class="pre">node_page_ext</span></code> is array of extensions of struct pages. Available only
in the kernels built with <code class="docutils literal notranslate"><span class="pre">CONFIG_PAGE_EXTENSION</span></code> enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_start_pfn</span></code></dt><dd><p>The page frame number of the starting page frame in this node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_present_pages</span></code></dt><dd><p>Total number of physical pages present in this node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_spanned_pages</span></code></dt><dd><p>Total size of physical page range, including holes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_size_lock</span></code></dt><dd><p>A lock that protects the fields defining the node extents. Only defined when
at least one of <code class="docutils literal notranslate"><span class="pre">CONFIG_MEMORY_HOTPLUG</span></code> or
<code class="docutils literal notranslate"><span class="pre">CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></code> configuration options are enabled.
<code class="docutils literal notranslate"><span class="pre">pgdat_resize_lock()</span></code> and <code class="docutils literal notranslate"><span class="pre">pgdat_resize_unlock()</span></code> are provided to
manipulate <code class="docutils literal notranslate"><span class="pre">node_size_lock</span></code> without checking for <code class="docutils literal notranslate"><span class="pre">CONFIG_MEMORY_HOTPLUG</span></code>
or <code class="docutils literal notranslate"><span class="pre">CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_id</span></code></dt><dd><p>The Node ID (NID) of the node, starts at 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">totalreserve_pages</span></code></dt><dd><p>This is a per-node reserve of pages that are not available to userspace
allocations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first_deferred_pfn</span></code></dt><dd><p>If memory initialization on large machines is deferred then this is the first
PFN that needs to be initialized. Defined only when
<code class="docutils literal notranslate"><span class="pre">CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></code> is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deferred_split_queue</span></code></dt><dd><p>Per-node queue of huge pages that their split was deferred. Defined only when <code class="docutils literal notranslate"><span class="pre">CONFIG_TRANSPARENT_HUGEPAGE</span></code> is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__lruvec</span></code></dt><dd><p>Per-node lruvec holding LRU lists and related parameters. Used only when
memory cgroups are disabled. It should not be accessed directly, use
<code class="docutils literal notranslate"><span class="pre">mem_cgroup_lruvec()</span></code> to look up lruvecs instead.</p>
</dd>
</dl>
</section>
<section id="reclaim-control">
<h4>Reclaim control<a class="headerlink" href="#reclaim-control" title="Link to this heading">¶</a></h4>
<p>See also <a class="reference internal" href="page_reclaim.html"><span class="doc">Page Reclaim</span></a>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kswapd</span></code></dt><dd><p>Per-node instance of kswapd kernel thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kswapd_wait</span></code>, <code class="docutils literal notranslate"><span class="pre">pfmemalloc_wait</span></code>, <code class="docutils literal notranslate"><span class="pre">reclaim_wait</span></code></dt><dd><p>Workqueues used to synchronize memory reclaim tasks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_writeback_throttled</span></code></dt><dd><p>Number of tasks that are throttled waiting on dirty pages to clean.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_reclaim_start</span></code></dt><dd><p>Number of pages written while reclaim is throttled waiting for writeback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kswapd_order</span></code></dt><dd><p>Controls the order kswapd tries to reclaim</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kswapd_highest_zoneidx</span></code></dt><dd><p>The highest zone index to be reclaimed by kswapd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kswapd_failures</span></code></dt><dd><p>Number of runs kswapd was unable to reclaim any pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_unmapped_pages</span></code></dt><dd><p>Minimal number of unmapped file backed pages that cannot be reclaimed.
Determined by <code class="docutils literal notranslate"><span class="pre">vm.min_unmapped_ratio</span></code> sysctl. Only defined when
<code class="docutils literal notranslate"><span class="pre">CONFIG_NUMA</span></code> is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_slab_pages</span></code></dt><dd><p>Minimal number of SLAB pages that cannot be reclaimed. Determined by
<code class="docutils literal notranslate"><span class="pre">vm.min_slab_ratio</span> <span class="pre">sysctl</span></code>. Only defined when <code class="docutils literal notranslate"><span class="pre">CONFIG_NUMA</span></code> is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags controlling reclaim behavior.</p>
</dd>
</dl>
</section>
<section id="compaction-control">
<h4>Compaction control<a class="headerlink" href="#compaction-control" title="Link to this heading">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kcompactd_max_order</span></code></dt><dd><p>Page order that kcompactd should try to achieve.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kcompactd_highest_zoneidx</span></code></dt><dd><p>The highest zone index to be compacted by kcompactd.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kcompactd_wait</span></code></dt><dd><p>Workqueue used to synchronize memory compaction tasks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kcompactd</span></code></dt><dd><p>Per-node instance of kcompactd kernel thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proactive_compact_trigger</span></code></dt><dd><p>Determines if proactive compaction is enabled. Controlled by
<code class="docutils literal notranslate"><span class="pre">vm.compaction_proactiveness</span></code> sysctl.</p>
</dd>
</dl>
</section>
<section id="statistics">
<h4>Statistics<a class="headerlink" href="#statistics" title="Link to this heading">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">per_cpu_nodestats</span></code></dt><dd><p>Per-CPU VM statistics for the node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_stat</span></code></dt><dd><p>VM statistics for the node.</p>
</dd>
</dl>
</section>
</section>
</section>
<section id="zones">
<span id="id2"></span><h2>Zones<a class="headerlink" href="#zones" title="Link to this heading">¶</a></h2>
<p>As we have mentioned, each zone in memory is described by a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zone</span></code>
which is an element of the <code class="docutils literal notranslate"><span class="pre">node_zones</span></code> array of the node it belongs to.
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zone</span></code> is the core data structure of the page allocator. A zone
represents a range of physical memory and may have holes.</p>
<p>The page allocator uses the GFP flags, see <a class="reference internal" href="../core-api/mm-api.html#mm-api-gfp-flags"><span class="std std-ref">Memory Allocation Controls</span></a>, specified by
a memory allocation to determine the highest zone in a node from which the
memory allocation can allocate memory. The page allocator first allocates memory
from that zone, if the page allocator can’t allocate the requested amount of
memory from the zone, it will allocate memory from the next lower zone in the
node, the process continues up to and including the lowest zone. For example, if
a node contains <code class="docutils literal notranslate"><span class="pre">ZONE_DMA32</span></code>, <code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> and <code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code> and the
highest zone of a memory allocation is <code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code>, the order of the zones
from which the page allocator allocates memory is <code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code> &gt;
<code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> &gt; <code class="docutils literal notranslate"><span class="pre">ZONE_DMA32</span></code>.</p>
<p>At runtime, free pages in a zone are in the Per-CPU Pagesets (PCP) or free areas
of the zone. The Per-CPU Pagesets are a vital mechanism in the kernel’s memory
management system. By handling most frequent allocations and frees locally on
each CPU, the Per-CPU Pagesets improve performance and scalability, especially
on systems with many cores. The page allocator in the kernel employs a two-step
strategy for memory allocation, starting with the Per-CPU Pagesets before
falling back to the buddy allocator. Pages are transferred between the Per-CPU
Pagesets and the global free areas (managed by the buddy allocator) in batches.
This minimizes the overhead of frequent interactions with the global buddy
allocator.</p>
<p>Architecture specific code calls free_area_init() to initializes zones.</p>
<section id="zone-structure">
<h3>Zone structure<a class="headerlink" href="#zone-structure" title="Link to this heading">¶</a></h3>
<p>The zones structure <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zone</span></code> is defined in <code class="docutils literal notranslate"><span class="pre">include/linux/mmzone.h</span></code>.
Here we briefly describe fields of this structure:</p>
<section id="id3">
<h4>General<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_watermark</span></code></dt><dd><p>The watermarks for this zone. When the amount of free pages in a zone is below
the min watermark, boosting is ignored, an allocation may trigger direct
reclaim and direct compaction, it is also used to throttle direct reclaim.
When the amount of free pages in a zone is below the low watermark, kswapd is
woken up. When the amount of free pages in a zone is above the high watermark,
kswapd stops reclaiming (a zone is balanced) when the
<code class="docutils literal notranslate"><span class="pre">NUMA_BALANCING_MEMORY_TIERING</span></code> bit of <code class="docutils literal notranslate"><span class="pre">sysctl_numa_balancing_mode</span></code> is not
set. The promo watermark is used for memory tiering and NUMA balancing. When
the amount of free pages in a zone is above the promo watermark, kswapd stops
reclaiming when the <code class="docutils literal notranslate"><span class="pre">NUMA_BALANCING_MEMORY_TIERING</span></code> bit of
<code class="docutils literal notranslate"><span class="pre">sysctl_numa_balancing_mode</span></code> is set. The watermarks are set by
<code class="docutils literal notranslate"><span class="pre">__setup_per_zone_wmarks()</span></code>. The min watermark is calculated according to
<code class="docutils literal notranslate"><span class="pre">vm.min_free_kbytes</span></code> sysctl. The other three watermarks are set according
to the distance between two watermarks. The distance itself is calculated
taking <code class="docutils literal notranslate"><span class="pre">vm.watermark_scale_factor</span></code> sysctl into account.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watermark_boost</span></code></dt><dd><p>The number of pages which are used to boost watermarks to increase reclaim
pressure to reduce the likelihood of future fallbacks and wake kswapd now
as the node may be balanced overall and kswapd will not wake naturally.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_reserved_highatomic</span></code></dt><dd><p>The number of pages which are reserved for high-order atomic allocations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_free_highatomic</span></code></dt><dd><p>The number of free pages in reserved highatomic pageblocks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lowmem_reserve</span></code></dt><dd><p>The array of the amounts of the memory reserved in this zone for memory
allocations. For example, if the highest zone a memory allocation can
allocate memory from is <code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code>, the amount of memory reserved in
this zone for this allocation is <code class="docutils literal notranslate"><span class="pre">lowmem_reserve[ZONE_MOVABLE]</span></code> when
attempting to allocate memory from this zone. This is a mechanism the page
allocator uses to prevent allocations which could use <code class="docutils literal notranslate"><span class="pre">highmem</span></code> from using
too much <code class="docutils literal notranslate"><span class="pre">lowmem</span></code>. For some specialised workloads on <code class="docutils literal notranslate"><span class="pre">highmem</span></code> machines,
it is dangerous for the kernel to allow process memory to be allocated from
the <code class="docutils literal notranslate"><span class="pre">lowmem</span></code> zone. This is because that memory could then be pinned via the
<code class="docutils literal notranslate"><span class="pre">mlock()</span></code> system call, or by unavailability of swapspace.
<code class="docutils literal notranslate"><span class="pre">vm.lowmem_reserve_ratio</span></code> sysctl determines how aggressive the kernel is in
defending these lower zones. This array is recalculated by
<code class="docutils literal notranslate"><span class="pre">setup_per_zone_lowmem_reserve()</span></code> at runtime if <code class="docutils literal notranslate"><span class="pre">vm.lowmem_reserve_ratio</span></code>
sysctl changes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>The index of the node this zone belongs to. Available only when
<code class="docutils literal notranslate"><span class="pre">CONFIG_NUMA</span></code> is enabled because there is only one zone in a UMA system.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zone_pgdat</span></code></dt><dd><p>Pointer to the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pglist_data</span></code> of the node this zone belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">per_cpu_pageset</span></code></dt><dd><p>Pointer to the Per-CPU Pagesets (PCP) allocated and initialized by
<code class="docutils literal notranslate"><span class="pre">setup_zone_pageset()</span></code>. By handling most frequent allocations and frees
locally on each CPU, PCP improves performance and scalability on systems with
many cores.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pageset_high_min</span></code></dt><dd><p>Copied to the <code class="docutils literal notranslate"><span class="pre">high_min</span></code> of the Per-CPU Pagesets for faster access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pageset_high_max</span></code></dt><dd><p>Copied to the <code class="docutils literal notranslate"><span class="pre">high_max</span></code> of the Per-CPU Pagesets for faster access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pageset_batch</span></code></dt><dd><p>Copied to the <code class="docutils literal notranslate"><span class="pre">batch</span></code> of the Per-CPU Pagesets for faster access. The
<code class="docutils literal notranslate"><span class="pre">batch</span></code>, <code class="docutils literal notranslate"><span class="pre">high_min</span></code> and <code class="docutils literal notranslate"><span class="pre">high_max</span></code> of the Per-CPU Pagesets are used to
calculate the number of elements the Per-CPU Pagesets obtain from the buddy
allocator under a single hold of the lock for efficiency. They are also used
to decide if the Per-CPU Pagesets return pages to the buddy allocator in page
free process.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pageblock_flags</span></code></dt><dd><p>The pointer to the flags for the pageblocks in the zone (see
<code class="docutils literal notranslate"><span class="pre">include/linux/pageblock-flags.h</span></code> for flags list). The memory is allocated
in <code class="docutils literal notranslate"><span class="pre">setup_usemap()</span></code>. Each pageblock occupies <code class="docutils literal notranslate"><span class="pre">NR_PAGEBLOCK_BITS</span></code> bits.
Defined only when <code class="docutils literal notranslate"><span class="pre">CONFIG_FLATMEM</span></code> is enabled. The flags is stored in
<code class="docutils literal notranslate"><span class="pre">mem_section</span></code> when <code class="docutils literal notranslate"><span class="pre">CONFIG_SPARSEMEM</span></code> is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zone_start_pfn</span></code></dt><dd><p>The start pfn of the zone. It is initialized by
<code class="docutils literal notranslate"><span class="pre">calculate_node_totalpages()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">managed_pages</span></code></dt><dd><p>The present pages managed by the buddy system, which is calculated as:
<code class="docutils literal notranslate"><span class="pre">managed_pages</span></code> = <code class="docutils literal notranslate"><span class="pre">present_pages</span></code> - <code class="docutils literal notranslate"><span class="pre">reserved_pages</span></code>, <code class="docutils literal notranslate"><span class="pre">reserved_pages</span></code>
includes pages allocated by the memblock allocator. It should be used by page
allocator and vm scanner to calculate all kinds of watermarks and thresholds.
It is accessed using <code class="docutils literal notranslate"><span class="pre">atomic_long_xxx()</span></code> functions. It is initialized in
<code class="docutils literal notranslate"><span class="pre">free_area_init_core()</span></code> and then is reinitialized when memblock allocator
frees pages into buddy system.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spanned_pages</span></code></dt><dd><p>The total pages spanned by the zone, including holes, which is calculated as:
<code class="docutils literal notranslate"><span class="pre">spanned_pages</span></code> = <code class="docutils literal notranslate"><span class="pre">zone_end_pfn</span></code> - <code class="docutils literal notranslate"><span class="pre">zone_start_pfn</span></code>. It is initialized
by <code class="docutils literal notranslate"><span class="pre">calculate_node_totalpages()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">present_pages</span></code></dt><dd><p>The physical pages existing within the zone, which is calculated as:
<code class="docutils literal notranslate"><span class="pre">present_pages</span></code> = <code class="docutils literal notranslate"><span class="pre">spanned_pages</span></code> - <code class="docutils literal notranslate"><span class="pre">absent_pages</span></code> (pages in holes). It
may be used by memory hotplug or memory power management logic to figure out
unmanaged pages by checking (<code class="docutils literal notranslate"><span class="pre">present_pages</span></code> - <code class="docutils literal notranslate"><span class="pre">managed_pages</span></code>). Write
access to <code class="docutils literal notranslate"><span class="pre">present_pages</span></code> at runtime should be protected by
<code class="docutils literal notranslate"><span class="pre">mem_hotplug_begin/done()</span></code>. Any reader who can’t tolerant drift of
<code class="docutils literal notranslate"><span class="pre">present_pages</span></code> should use <code class="docutils literal notranslate"><span class="pre">get_online_mems()</span></code> to get a stable value. It
is initialized by <code class="docutils literal notranslate"><span class="pre">calculate_node_totalpages()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">present_early_pages</span></code></dt><dd><p>The present pages existing within the zone located on memory available since
early boot, excluding hotplugged memory. Defined only when
<code class="docutils literal notranslate"><span class="pre">CONFIG_MEMORY_HOTPLUG</span></code> is enabled and initialized by
<code class="docutils literal notranslate"><span class="pre">calculate_node_totalpages()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cma_pages</span></code></dt><dd><p>The pages reserved for CMA use. These pages behave like <code class="docutils literal notranslate"><span class="pre">ZONE_MOVABLE</span></code> when
they are not used for CMA. Defined only when <code class="docutils literal notranslate"><span class="pre">CONFIG_CMA</span></code> is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The name of the zone. It is a pointer to the corresponding element of
the <code class="docutils literal notranslate"><span class="pre">zone_names</span></code> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_isolate_pageblock</span></code></dt><dd><p>Number of isolated pageblocks. It is used to solve incorrect freepage counting
problem due to racy retrieving migratetype of pageblock. Protected by
<code class="docutils literal notranslate"><span class="pre">zone-&gt;lock</span></code>. Defined only when <code class="docutils literal notranslate"><span class="pre">CONFIG_MEMORY_ISOLATION</span></code> is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">span_seqlock</span></code></dt><dd><p>The seqlock to protect <code class="docutils literal notranslate"><span class="pre">zone_start_pfn</span></code> and <code class="docutils literal notranslate"><span class="pre">spanned_pages</span></code>. It is a
seqlock because it has to be read outside of <code class="docutils literal notranslate"><span class="pre">zone-&gt;lock</span></code>, and it is done in
the main allocator path. However, the seqlock is written quite infrequently.
Defined only when <code class="docutils literal notranslate"><span class="pre">CONFIG_MEMORY_HOTPLUG</span></code> is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initialized</span></code></dt><dd><p>The flag indicating if the zone is initialized. Set by
<code class="docutils literal notranslate"><span class="pre">init_currently_empty_zone()</span></code> during boot.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_area</span></code></dt><dd><p>The array of free areas, where each element corresponds to a specific order
which is a power of two. The buddy allocator uses this structure to manage
free memory efficiently. When allocating, it tries to find the smallest
sufficient block, if the smallest sufficient block is larger than the
requested size, it will be recursively split into the next smaller blocks
until the required size is reached. When a page is freed, it may be merged
with its buddy to form a larger block. It is initialized by
<code class="docutils literal notranslate"><span class="pre">zone_init_free_lists()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unaccepted_pages</span></code></dt><dd><p>The list of pages to be accepted. All pages on the list are <code class="docutils literal notranslate"><span class="pre">MAX_PAGE_ORDER</span></code>.
Defined only when <code class="docutils literal notranslate"><span class="pre">CONFIG_UNACCEPTED_MEMORY</span></code> is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>The zone flags. The least three bits are used and defined by
<code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">zone_flags</span></code>. <code class="docutils literal notranslate"><span class="pre">ZONE_BOOSTED_WATERMARK</span></code> (bit 0): zone recently boosted
watermarks. Cleared when kswapd is woken. <code class="docutils literal notranslate"><span class="pre">ZONE_RECLAIM_ACTIVE</span></code> (bit 1):
kswapd may be scanning the zone. <code class="docutils literal notranslate"><span class="pre">ZONE_BELOW_HIGH</span></code> (bit 2): zone is below
high watermark.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>The main lock that protects the internal data structures of the page allocator
specific to the zone, especially protects <code class="docutils literal notranslate"><span class="pre">free_area</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">percpu_drift_mark</span></code></dt><dd><p>When free pages are below this point, additional steps are taken when reading
the number of free pages to avoid per-cpu counter drift allowing watermarks
to be breached. It is updated in <code class="docutils literal notranslate"><span class="pre">refresh_zone_stat_thresholds()</span></code>.</p>
</dd>
</dl>
</section>
<section id="id4">
<h4>Compaction control<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">compact_cached_free_pfn</span></code></dt><dd><p>The PFN where compaction free scanner should start in the next scan.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compact_cached_migrate_pfn</span></code></dt><dd><p>The PFNs where compaction migration scanner should start in the next scan.
This array has two elements: the first one is used in <code class="docutils literal notranslate"><span class="pre">MIGRATE_ASYNC</span></code> mode,
and the other one is used in <code class="docutils literal notranslate"><span class="pre">MIGRATE_SYNC</span></code> mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compact_init_migrate_pfn</span></code></dt><dd><p>The initial migration PFN which is initialized to 0 at boot time, and to the
first pageblock with migratable pages in the zone after a full compaction
finishes. It is used to check if a scan is a whole zone scan or not.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compact_init_free_pfn</span></code></dt><dd><p>The initial free PFN which is initialized to 0 at boot time and to the last
pageblock with free <code class="docutils literal notranslate"><span class="pre">MIGRATE_MOVABLE</span></code> pages in the zone. It is used to check
if it is the start of a scan.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compact_considered</span></code></dt><dd><p>The number of compactions attempted since last failure. It is reset in
<code class="docutils literal notranslate"><span class="pre">defer_compaction()</span></code> when a compaction fails to result in a page allocation
success. It is increased by 1 in <code class="docutils literal notranslate"><span class="pre">compaction_deferred()</span></code> when a compaction
should be skipped. <code class="docutils literal notranslate"><span class="pre">compaction_deferred()</span></code> is called before
<code class="docutils literal notranslate"><span class="pre">compact_zone()</span></code> is called, <code class="docutils literal notranslate"><span class="pre">compaction_defer_reset()</span></code> is called when
<code class="docutils literal notranslate"><span class="pre">compact_zone()</span></code> returns <code class="docutils literal notranslate"><span class="pre">COMPACT_SUCCESS</span></code>, <code class="docutils literal notranslate"><span class="pre">defer_compaction()</span></code> is
called when <code class="docutils literal notranslate"><span class="pre">compact_zone()</span></code> returns <code class="docutils literal notranslate"><span class="pre">COMPACT_PARTIAL_SKIPPED</span></code> or
<code class="docutils literal notranslate"><span class="pre">COMPACT_COMPLETE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compact_defer_shift</span></code></dt><dd><p>The number of compactions skipped before trying again is
<code class="docutils literal notranslate"><span class="pre">1&lt;&lt;compact_defer_shift</span></code>. It is increased by 1 in <code class="docutils literal notranslate"><span class="pre">defer_compaction()</span></code>.
It is reset in <code class="docutils literal notranslate"><span class="pre">compaction_defer_reset()</span></code> when a direct compaction results
in a page allocation success. Its maximum value is <code class="docutils literal notranslate"><span class="pre">COMPACT_MAX_DEFER_SHIFT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compact_order_failed</span></code></dt><dd><p>The minimum compaction failed order. It is set in <code class="docutils literal notranslate"><span class="pre">compaction_defer_reset()</span></code>
when a compaction succeeds and in <code class="docutils literal notranslate"><span class="pre">defer_compaction()</span></code> when a compaction
fails to result in a page allocation success.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compact_blockskip_flush</span></code></dt><dd><p>Set to true when compaction migration scanner and free scanner meet, which
means the <code class="docutils literal notranslate"><span class="pre">PB_migrate_skip</span></code> bits should be cleared.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">contiguous</span></code></dt><dd><p>Set to true when the zone is contiguous (in other words, no hole).</p>
</dd>
</dl>
</section>
<section id="id5">
<h4>Statistics<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vm_stat</span></code></dt><dd><p>VM statistics for the zone. The items tracked are defined by
<code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">zone_stat_item</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_numa_event</span></code></dt><dd><p>VM NUMA event statistics for the zone. The items tracked are defined by
<code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">numa_stat_item</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">per_cpu_zonestats</span></code></dt><dd><p>Per-CPU VM statistics for the zone. It records VM statistics and VM NUMA event
statistics on a per-CPU basis. It reduces updates to the global <code class="docutils literal notranslate"><span class="pre">vm_stat</span></code>
and <code class="docutils literal notranslate"><span class="pre">vm_numa_event</span></code> fields of the zone to improve performance.</p>
</dd>
</dl>
</section>
</section>
</section>
<section id="pages">
<span id="id6"></span><h2>Pages<a class="headerlink" href="#pages" title="Link to this heading">¶</a></h2>
<div class="admonition-stub admonition">
<p class="admonition-title">Stub</p>
<p>This section is incomplete. Please list and describe the appropriate fields.</p>
</div>
</section>
<section id="folios">
<span id="id7"></span><h2>Folios<a class="headerlink" href="#folios" title="Link to this heading">¶</a></h2>
<div class="admonition-stub admonition">
<p class="admonition-title">Stub</p>
<p>This section is incomplete. Please list and describe the appropriate fields.</p>
</div>
</section>
<section id="initialization">
<span id="id8"></span><h2>Initialization<a class="headerlink" href="#initialization" title="Link to this heading">¶</a></h2>
<div class="admonition-stub admonition">
<p class="admonition-title">Stub</p>
<p>This section is incomplete. Please list and describe the appropriate fields.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/mm/physical_memory.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>