<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>2. Supported File Operations &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="3. Porting Your Filesystem" href="porting.html" />
    <link rel="prev" title="1. Library Design" href="design.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../nvme/index.html">NVMe Subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/filesystems/iomap/operations.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<span class="target" id="iomap-operations"></span><section id="supported-file-operations">
<h1><span class="section-number">2. </span>Supported File Operations<a class="headerlink" href="#supported-file-operations" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#buffered-i-o" id="id1">Buffered I/O</a></p>
<ul>
<li><p><a class="reference internal" href="#struct-address-space-operations" id="id2"><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space_operations</span></code></a></p></li>
<li><p><a class="reference internal" href="#struct-iomap-folio-ops" id="id3"><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap_folio_ops</span></code></a></p></li>
<li><p><a class="reference internal" href="#internal-per-folio-state" id="id4">Internal per-Folio State</a></p></li>
<li><p><a class="reference internal" href="#buffered-readahead-and-reads" id="id5">Buffered Readahead and Reads</a></p></li>
<li><p><a class="reference internal" href="#buffered-writes" id="id6">Buffered Writes</a></p>
<ul>
<li><p><a class="reference internal" href="#mmap-write-faults" id="id7">mmap Write Faults</a></p></li>
<li><p><a class="reference internal" href="#buffered-write-failures" id="id8">Buffered Write Failures</a></p></li>
<li><p><a class="reference internal" href="#zeroing-for-file-operations" id="id9">Zeroing for File Operations</a></p></li>
<li><p><a class="reference internal" href="#unsharing-reflinked-file-data" id="id10">Unsharing Reflinked File Data</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#truncation" id="id11">Truncation</a></p></li>
<li><p><a class="reference internal" href="#pagecache-writeback" id="id12">Pagecache Writeback</a></p>
<ul>
<li><p><a class="reference internal" href="#struct-iomap-writeback-ops" id="id13"><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap_writeback_ops</span></code></a></p></li>
<li><p><a class="reference internal" href="#pagecache-writeback-completion" id="id14">Pagecache Writeback Completion</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#direct-i-o" id="id15">Direct I/O</a></p>
<ul>
<li><p><a class="reference internal" href="#return-values" id="id16">Return Values</a></p></li>
<li><p><a class="reference internal" href="#direct-reads" id="id17">Direct Reads</a></p></li>
<li><p><a class="reference internal" href="#direct-writes" id="id18">Direct Writes</a></p></li>
<li><p><a class="reference internal" href="#struct-iomap-dio-ops" id="id19"><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap_dio_ops:</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#dax-i-o" id="id20">DAX I/O</a></p>
<ul>
<li><p><a class="reference internal" href="#fsdax-reads" id="id21">fsdax Reads</a></p></li>
<li><p><a class="reference internal" href="#fsdax-writes" id="id22">fsdax Writes</a></p>
<ul>
<li><p><a class="reference internal" href="#fsdax-mmap-faults" id="id23">fsdax mmap Faults</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fsdax-truncation-fallocate-and-unsharing" id="id24">fsdax Truncation, fallocate, and Unsharing</a></p></li>
<li><p><a class="reference internal" href="#fsdax-deduplication" id="id25">fsdax Deduplication</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#seeking-files" id="id26">Seeking Files</a></p>
<ul>
<li><p><a class="reference internal" href="#seek-data" id="id27">SEEK_DATA</a></p></li>
<li><p><a class="reference internal" href="#seek-hole" id="id28">SEEK_HOLE</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#swap-file-activation" id="id29">Swap File Activation</a></p></li>
<li><p><a class="reference internal" href="#file-space-mapping-reporting" id="id30">File Space Mapping Reporting</a></p>
<ul>
<li><p><a class="reference internal" href="#fs-ioc-fiemap" id="id31">FS_IOC_FIEMAP</a></p></li>
<li><p><a class="reference internal" href="#fibmap-deprecated" id="id32">FIBMAP (deprecated)</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>Below are a discussion of the high level file operations that iomap
implements.</p>
<section id="buffered-i-o">
<h2><a class="toc-backref" href="#id1" role="doc-backlink"><span class="section-number">2.1. </span>Buffered I/O</a><a class="headerlink" href="#buffered-i-o" title="Link to this heading">¶</a></h2>
<p>Buffered I/O is the default file I/O path in Linux.
File contents are cached in memory (“pagecache”) to satisfy reads and
writes.
Dirty cache will be written back to disk at some point that can be
forced via <code class="docutils literal notranslate"><span class="pre">fsync</span></code> and variants.</p>
<p>iomap implements nearly all the folio and pagecache management that
filesystems have to implement themselves under the legacy I/O model.
This means that the filesystem need not know the details of allocating,
mapping, managing uptodate and dirty state, or writeback of pagecache
folios.
Under the legacy I/O model, this was managed very inefficiently with
linked lists of buffer heads instead of the per-folio bitmaps that iomap
uses.
Unless the filesystem explicitly opts in to buffer heads, they will not
be used, which makes buffered I/O much more efficient, and the pagecache
maintainer much happier.</p>
<section id="struct-address-space-operations">
<h3><a class="toc-backref" href="#id2" role="doc-backlink"><span class="section-number">2.1.1. </span><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space_operations</span></code></a><a class="headerlink" href="#struct-address-space-operations" title="Link to this heading">¶</a></h3>
<p>The following iomap functions can be referenced directly from the
address space operations structure:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iomap_dirty_folio</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomap_release_folio</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomap_invalidate_folio</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomap_is_partially_uptodate</span></code></p></li>
</ul>
</div></blockquote>
<p>The following address space operations can be wrapped easily:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">read_folio</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">readahead</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">writepages</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bmap</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">swap_activate</span></code></p></li>
</ul>
</div></blockquote>
</section>
<section id="struct-iomap-folio-ops">
<h3><a class="toc-backref" href="#id3" role="doc-backlink"><span class="section-number">2.1.2. </span><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap_folio_ops</span></code></a><a class="headerlink" href="#struct-iomap-folio-ops" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> function for pagecache operations may set the
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap::folio_ops</span></code> field to an ops structure to override
default behaviors of iomap:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_folio_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_folio</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_iter</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span>
<span class="w">                               </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">put_folio</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">copied</span><span class="p">,</span>
<span class="w">                      </span><span class="k">struct</span><span class="w"> </span><span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="n">folio</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iomap_valid</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap</span><span class="w"> </span><span class="o">*</span><span class="n">iomap</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>iomap calls these functions:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">get_folio</span></code>: Called to allocate and return an active reference to
a locked folio prior to starting a write.
If this function is not provided, iomap will call
<code class="docutils literal notranslate"><span class="pre">iomap_get_folio</span></code>.
This could be used to <a class="reference external" href="https://lore.kernel.org/all/20190429220934.10415-5-agruenba&#64;redhat.com/">set up per-folio filesystem state</a>
for a write.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">put_folio</span></code>: Called to unlock and put a folio after a pagecache
operation completes.
If this function is not provided, iomap will <code class="docutils literal notranslate"><span class="pre">folio_unlock</span></code> and
<code class="docutils literal notranslate"><span class="pre">folio_put</span></code> on its own.
This could be used to <a class="reference external" href="https://lore.kernel.org/all/20180619164137.13720-6-hch&#64;lst.de/">commit per-folio filesystem state</a>
that was set up by <code class="docutils literal notranslate"><span class="pre">-&gt;get_folio</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomap_valid</span></code>: The filesystem may not hold locks between
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> and <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_end</span></code> because pagecache operations
can take folio locks, fault on userspace pages, initiate writeback
for memory reclamation, or engage in other time-consuming actions.
If a file’s space mapping data are mutable, it is possible that the
mapping for a particular pagecache folio can <a class="reference external" href="https://lore.kernel.org/all/20221123055812.747923-8-david&#64;fromorbit.com/">change in the time it
takes</a>
to allocate, install, and lock that folio.</p>
<p>For the pagecache, races can happen if writeback doesn’t take
<code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> or <code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code> and updates mapping information.
Races can also happen if the filesystem allows concurrent writes.
For such files, the mapping <em>must</em> be revalidated after the folio
lock has been taken so that iomap can manage the folio correctly.</p>
<p>fsdax does not need this revalidation because there’s no writeback
and no support for unwritten extents.</p>
<p>Filesystems subject to this kind of race must provide a
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_valid</span></code> function to decide if the mapping is still valid.
If the mapping is not valid, the mapping will be sampled again.</p>
<p>To support making the validity decision, the filesystem’s
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> function may set <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap::validity_cookie</span></code>
at the same time that it populates the other iomap fields.
A simple validation cookie implementation is a sequence counter.
If the filesystem bumps the sequence counter every time it modifies
the inode’s extent map, it can be placed in the <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">iomap::validity_cookie</span></code> during <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
If the value in the cookie is found to be different to the value
the filesystem holds when the mapping is passed back to
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_valid</span></code>, then the iomap should considered stale and the
validation failed.</p>
</li>
</ul>
</div></blockquote>
<p>These <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span></code> flags are significant for buffered I/O with iomap:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IOCB_NOWAIT</span></code>: Turns on <code class="docutils literal notranslate"><span class="pre">IOMAP_NOWAIT</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOCB_DONTCACHE</span></code>: Turns on <code class="docutils literal notranslate"><span class="pre">IOMAP_DONTCACHE</span></code>.</p></li>
</ul>
</div></blockquote>
</section>
<section id="internal-per-folio-state">
<h3><a class="toc-backref" href="#id4" role="doc-backlink"><span class="section-number">2.1.3. </span>Internal per-Folio State</a><a class="headerlink" href="#internal-per-folio-state" title="Link to this heading">¶</a></h3>
<p>If the fsblock size matches the size of a pagecache folio, it is assumed
that all disk I/O operations will operate on the entire folio.
The uptodate (memory contents are at least as new as what’s on disk) and
dirty (memory contents are newer than what’s on disk) status of the
folio are all that’s needed for this case.</p>
<p>If the fsblock size is less than the size of a pagecache folio, iomap
tracks the per-fsblock uptodate and dirty state itself.
This enables iomap to handle both “bs &lt; ps” <a class="reference external" href="https://lore.kernel.org/all/20230725122932.144426-1-ritesh.list&#64;gmail.com/">filesystems</a>
and large folios in the pagecache.</p>
<p>iomap internally tracks two state bits per fsblock:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uptodate</span></code>: iomap will try to keep folios fully up to date.
If there are read(ahead) errors, those fsblocks will not be marked
uptodate.
The folio itself will be marked uptodate when all fsblocks within the
folio are uptodate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dirty</span></code>: iomap will set the per-block dirty state when programs
write to the file.
The folio itself will be marked dirty when any fsblock within the
folio is dirty.</p></li>
</ul>
</div></blockquote>
<p>iomap also tracks the amount of read and write disk IOs that are in
flight.
This structure is much lighter weight than <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span></code>
because there is only one per folio, and the per-fsblock overhead is two
bits vs. 104 bytes.</p>
<p>Filesystems wishing to turn on large folios in the pagecache should call
<code class="docutils literal notranslate"><span class="pre">mapping_set_large_folios</span></code> when initializing the incore inode.</p>
</section>
<section id="buffered-readahead-and-reads">
<h3><a class="toc-backref" href="#id5" role="doc-backlink"><span class="section-number">2.1.4. </span>Buffered Readahead and Reads</a><a class="headerlink" href="#buffered-readahead-and-reads" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">iomap_readahead</span></code> function initiates readahead to the pagecache.
The <code class="docutils literal notranslate"><span class="pre">iomap_read_folio</span></code> function reads one folio’s worth of data into
the pagecache.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> will be set to zero.
The pagecache takes whatever locks it needs before calling the
filesystem.</p>
</section>
<section id="buffered-writes">
<h3><a class="toc-backref" href="#id6" role="doc-backlink"><span class="section-number">2.1.5. </span>Buffered Writes</a><a class="headerlink" href="#buffered-writes" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">iomap_file_buffered_write</span></code> function writes an <code class="docutils literal notranslate"><span class="pre">iocb</span></code> to the
pagecache.
<code class="docutils literal notranslate"><span class="pre">IOMAP_WRITE</span></code> or <code class="docutils literal notranslate"><span class="pre">IOMAP_WRITE</span></code> | <code class="docutils literal notranslate"><span class="pre">IOMAP_NOWAIT</span></code> will be passed as
the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
Callers commonly take <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in either shared or exclusive mode
before calling this function.</p>
<section id="mmap-write-faults">
<h4><a class="toc-backref" href="#id7" role="doc-backlink"><span class="section-number">2.1.5.1. </span>mmap Write Faults</a><a class="headerlink" href="#mmap-write-faults" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">iomap_page_mkwrite</span></code> function handles a write fault to a folio in
the pagecache.
<code class="docutils literal notranslate"><span class="pre">IOMAP_WRITE</span> <span class="pre">|</span> <span class="pre">IOMAP_FAULT</span></code> will be passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument
to <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
Callers commonly take the mmap <code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code> in shared or
exclusive mode before calling this function.</p>
</section>
<section id="buffered-write-failures">
<h4><a class="toc-backref" href="#id8" role="doc-backlink"><span class="section-number">2.1.5.2. </span>Buffered Write Failures</a><a class="headerlink" href="#buffered-write-failures" title="Link to this heading">¶</a></h4>
<p>After a short write to the pagecache, the areas not written will not
become marked dirty.
The filesystem must arrange to <a class="reference external" href="https://lore.kernel.org/all/20221123055812.747923-6-david&#64;fromorbit.com/">cancel</a>
such <a class="reference external" href="https://lore.kernel.org/linux-xfs/20220817093627.GZ3600936&#64;dread.disaster.area/">reservations</a>
because writeback will not consume the reservation.
The <code class="docutils literal notranslate"><span class="pre">iomap_write_delalloc_release</span></code> can be called from a
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_end</span></code> function to find all the clean areas of the folios
caching a fresh (<code class="docutils literal notranslate"><span class="pre">IOMAP_F_NEW</span></code>) delalloc mapping.
It takes the <code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code>.</p>
<p>The filesystem must supply a function <code class="docutils literal notranslate"><span class="pre">punch</span></code> to be called for
each file range in this state.
This function must <em>only</em> remove delayed allocation reservations, in
case another thread racing with the current thread writes successfully
to the same region and triggers writeback to flush the dirty data out to
disk.</p>
</section>
<section id="zeroing-for-file-operations">
<h4><a class="toc-backref" href="#id9" role="doc-backlink"><span class="section-number">2.1.5.3. </span>Zeroing for File Operations</a><a class="headerlink" href="#zeroing-for-file-operations" title="Link to this heading">¶</a></h4>
<p>Filesystems can call <code class="docutils literal notranslate"><span class="pre">iomap_zero_range</span></code> to perform zeroing of the
pagecache for non-truncation file operations that are not aligned to
the fsblock size.
<code class="docutils literal notranslate"><span class="pre">IOMAP_ZERO</span></code> will be passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
Callers typically hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> and <code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code> in exclusive
mode before calling this function.</p>
</section>
<section id="unsharing-reflinked-file-data">
<h4><a class="toc-backref" href="#id10" role="doc-backlink"><span class="section-number">2.1.5.4. </span>Unsharing Reflinked File Data</a><a class="headerlink" href="#unsharing-reflinked-file-data" title="Link to this heading">¶</a></h4>
<p>Filesystems can call <code class="docutils literal notranslate"><span class="pre">iomap_file_unshare</span></code> to force a file sharing
storage with another file to preemptively copy the shared data to newly
allocate storage.
<code class="docutils literal notranslate"><span class="pre">IOMAP_WRITE</span> <span class="pre">|</span> <span class="pre">IOMAP_UNSHARE</span></code> will be passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument
to <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
Callers typically hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> and <code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code> in exclusive
mode before calling this function.</p>
</section>
</section>
<section id="truncation">
<h3><a class="toc-backref" href="#id11" role="doc-backlink"><span class="section-number">2.1.6. </span>Truncation</a><a class="headerlink" href="#truncation" title="Link to this heading">¶</a></h3>
<p>Filesystems can call <code class="docutils literal notranslate"><span class="pre">iomap_truncate_page</span></code> to zero the bytes in the
pagecache from EOF to the end of the fsblock during a file truncation
operation.
<code class="docutils literal notranslate"><span class="pre">truncate_setsize</span></code> or <code class="docutils literal notranslate"><span class="pre">truncate_pagecache</span></code> will take care of
everything after the EOF block.
<code class="docutils literal notranslate"><span class="pre">IOMAP_ZERO</span></code> will be passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
Callers typically hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> and <code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code> in exclusive
mode before calling this function.</p>
</section>
<section id="pagecache-writeback">
<h3><a class="toc-backref" href="#id12" role="doc-backlink"><span class="section-number">2.1.7. </span>Pagecache Writeback</a><a class="headerlink" href="#pagecache-writeback" title="Link to this heading">¶</a></h3>
<p>Filesystems can call <code class="docutils literal notranslate"><span class="pre">iomap_writepages</span></code> to respond to a request to
write dirty pagecache folios to disk.
The <code class="docutils literal notranslate"><span class="pre">mapping</span></code> and <code class="docutils literal notranslate"><span class="pre">wbc</span></code> parameters should be passed unchanged.
The <code class="docutils literal notranslate"><span class="pre">wpc</span></code> pointer should be allocated by the filesystem and must
be initialized to zero.</p>
<p>The pagecache will lock each folio before trying to schedule it for
writeback.
It does not lock <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> or <code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code>.</p>
<p>The dirty bit will be cleared for all folios run through the
<code class="docutils literal notranslate"><span class="pre">-&gt;map_blocks</span></code> machinery described below even if the writeback fails.
This is to prevent dirty folio clots when storage devices fail; an
<code class="docutils literal notranslate"><span class="pre">-EIO</span></code> is recorded for userspace to collect via <code class="docutils literal notranslate"><span class="pre">fsync</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ops</span></code> structure must be specified and is as follows:</p>
<section id="struct-iomap-writeback-ops">
<h4><a class="toc-backref" href="#id13" role="doc-backlink"><span class="section-number">2.1.7.1. </span><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap_writeback_ops</span></code></a><a class="headerlink" href="#struct-iomap-writeback-ops" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_writeback_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">map_blocks</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_writepage_ctx</span><span class="w"> </span><span class="o">*</span><span class="n">wpc</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span>
<span class="w">                      </span><span class="n">loff_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">submit_ioend</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_writepage_ctx</span><span class="w"> </span><span class="o">*</span><span class="n">wpc</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">discard_folio</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">folio</span><span class="w"> </span><span class="o">*</span><span class="n">folio</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields are as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map_blocks</span></code>: Sets <code class="docutils literal notranslate"><span class="pre">wpc-&gt;iomap</span></code> to the space mapping of the file
range (in bytes) given by <code class="docutils literal notranslate"><span class="pre">offset</span></code> and <code class="docutils literal notranslate"><span class="pre">len</span></code>.
iomap calls this function for each dirty fs block in each dirty folio,
though it will <a class="reference external" href="https://lore.kernel.org/all/20231207072710.176093-15-hch&#64;lst.de/">reuse mappings</a>
for runs of contiguous dirty fsblocks within a folio.
Do not return <code class="docutils literal notranslate"><span class="pre">IOMAP_INLINE</span></code> mappings here; the <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_end</span></code>
function must deal with persisting written data.
Do not return <code class="docutils literal notranslate"><span class="pre">IOMAP_DELALLOC</span></code> mappings here; iomap currently
requires mapping to allocated space.
Filesystems can skip a potentially expensive mapping lookup if the
mappings have not changed.
This revalidation must be open-coded by the filesystem; it is
unclear if <code class="docutils literal notranslate"><span class="pre">iomap::validity_cookie</span></code> can be reused for this
purpose.
This function must be supplied by the filesystem.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">submit_ioend</span></code>: Allows the file systems to hook into writeback bio
submission.
This might include pre-write space accounting updates, or installing
a custom <code class="docutils literal notranslate"><span class="pre">-&gt;bi_end_io</span></code> function for internal purposes, such as
deferring the ioend completion to a workqueue to run metadata update
transactions from process context before submitting the bio.
This function is optional.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">discard_folio</span></code>: iomap calls this function after <code class="docutils literal notranslate"><span class="pre">-&gt;map_blocks</span></code>
fails to schedule I/O for any part of a dirty folio.
The function should throw away any reservations that may have been
made for the write.
The folio will be marked clean and an <code class="docutils literal notranslate"><span class="pre">-EIO</span></code> recorded in the
pagecache.
Filesystems can use this callback to <a class="reference external" href="https://lore.kernel.org/all/20201029163313.1766967-1-bfoster&#64;redhat.com/">remove</a>
delalloc reservations to avoid having delalloc reservations for
clean pagecache.
This function is optional.</p></li>
</ul>
</div></blockquote>
</section>
<section id="pagecache-writeback-completion">
<h4><a class="toc-backref" href="#id14" role="doc-backlink"><span class="section-number">2.1.7.2. </span>Pagecache Writeback Completion</a><a class="headerlink" href="#pagecache-writeback-completion" title="Link to this heading">¶</a></h4>
<p>To handle the bookkeeping that must happen after disk I/O for writeback
completes, iomap creates chains of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap_ioend</span></code> objects that
wrap the <code class="docutils literal notranslate"><span class="pre">bio</span></code> that is used to write pagecache data to disk.
By default, iomap finishes writeback ioends by clearing the writeback
bit on the folios attached to the <code class="docutils literal notranslate"><span class="pre">ioend</span></code>.
If the write failed, it will also set the error bits on the folios and
the address space.
This can happen in interrupt or process context, depending on the
storage device.</p>
<p>Filesystems that need to update internal bookkeeping (e.g. unwritten
extent conversions) should provide a <code class="docutils literal notranslate"><span class="pre">-&gt;submit_ioend</span></code> function to
set <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap_end::bio::bi_end_io</span></code> to its own function.
This function should call <code class="docutils literal notranslate"><span class="pre">iomap_finish_ioends</span></code> after finishing its
own work (e.g. unwritten extent conversion).</p>
<p>Some filesystems may wish to <a class="reference external" href="https://lore.kernel.org/all/20220120034733.221737-1-david&#64;fromorbit.com/">amortize the cost of running metadata
transactions</a>
for post-writeback updates by batching them.
They may also require transactions to run from process context, which
implies punting batches to a workqueue.
iomap ioends contain a <code class="docutils literal notranslate"><span class="pre">list_head</span></code> to enable batching.</p>
<p>Given a batch of ioends, iomap has a few helpers to assist with
amortization:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iomap_sort_ioends</span></code>: Sort all the ioends in the list by file
offset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomap_ioend_try_merge</span></code>: Given an ioend that is not in any list and
a separate list of sorted ioends, merge as many of the ioends from
the head of the list into the given ioend.
ioends can only be merged if the file range and storage addresses are
contiguous; the unwritten and shared status are the same; and the
write I/O outcome is the same.
The merged ioends become their own list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iomap_finish_ioends</span></code>: Finish an ioend that possibly has other
ioends linked to it.</p></li>
</ul>
</div></blockquote>
</section>
</section>
</section>
<section id="direct-i-o">
<h2><a class="toc-backref" href="#id15" role="doc-backlink"><span class="section-number">2.2. </span>Direct I/O</a><a class="headerlink" href="#direct-i-o" title="Link to this heading">¶</a></h2>
<p>In Linux, direct I/O is defined as file I/O that is issued directly to
storage, bypassing the pagecache.
The <code class="docutils literal notranslate"><span class="pre">iomap_dio_rw</span></code> function implements O_DIRECT (direct I/O) reads and
writes for files.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">iomap_dio_rw</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">iocb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iov_iter</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_ops</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">,</span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_dio_ops</span><span class="w"> </span><span class="o">*</span><span class="n">dops</span><span class="p">,</span>
<span class="w">                     </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dio_flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private</span><span class="p">,</span>
<span class="w">                     </span><span class="kt">size_t</span><span class="w"> </span><span class="n">done_before</span><span class="p">);</span>
</pre></div>
</div>
<p>The filesystem can provide the <code class="docutils literal notranslate"><span class="pre">dops</span></code> parameter if it needs to perform
extra work before or after the I/O is issued to storage.
The <code class="docutils literal notranslate"><span class="pre">done_before</span></code> parameter tells the how much of the request has
already been transferred.
It is used to continue a request asynchronously when <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c03098d4b9ad76bca2966a8769dcfe59f7f85103">part of the
request</a>
has already been completed synchronously.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">done_before</span></code> parameter should be set if writes for the <code class="docutils literal notranslate"><span class="pre">iocb</span></code>
have been initiated prior to the call.
The direction of the I/O is determined from the <code class="docutils literal notranslate"><span class="pre">iocb</span></code> passed in.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dio_flags</span></code> argument can be set to any combination of the
following values:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_DIO_FORCE_WAIT</span></code>: Wait for the I/O to complete even if the
kiocb is not synchronous.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_DIO_OVERWRITE_ONLY</span></code>: Perform a pure overwrite for this range
or fail with <code class="docutils literal notranslate"><span class="pre">-EAGAIN</span></code>.
This can be used by filesystems with complex unaligned I/O
write paths to provide an optimised fast path for unaligned writes.
If a pure overwrite can be performed, then serialisation against
other I/Os to the same filesystem block(s) is unnecessary as there is
no risk of stale data exposure or data loss.
If a pure overwrite cannot be performed, then the filesystem can
perform the serialisation steps needed to provide exclusive access
to the unaligned I/O range so that it can perform allocation and
sub-block zeroing safely.
Filesystems can use this flag to try to reduce locking contention,
but a lot of <a class="reference external" href="https://lore.kernel.org/linux-ext4/20230314130759.642710-1-bfoster&#64;redhat.com/">detailed checking</a>
is required to do it <a class="reference external" href="https://lore.kernel.org/linux-ext4/20230810165559.946222-1-bfoster&#64;redhat.com/">correctly</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_DIO_PARTIAL</span></code>: If a page fault occurs, return whatever
progress has already been made.
The caller may deal with the page fault and retry the operation.
If the caller decides to retry the operation, it should pass the
accumulated return values of all previous calls as the
<code class="docutils literal notranslate"><span class="pre">done_before</span></code> parameter to the next call.</p></li>
</ul>
</div></blockquote>
<p>These <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span></code> flags are significant for direct I/O with iomap:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IOCB_NOWAIT</span></code>: Turns on <code class="docutils literal notranslate"><span class="pre">IOMAP_NOWAIT</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOCB_SYNC</span></code>: Ensure that the device has persisted data to disk
before completing the call.
In the case of pure overwrites, the I/O may be issued with FUA
enabled.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOCB_HIPRI</span></code>: Poll for I/O completion instead of waiting for an
interrupt.
Only meaningful for asynchronous I/O, and only if the entire I/O can
be issued as a single <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOCB_DIO_CALLER_COMP</span></code>: Try to run I/O completion from the caller’s
process context.
See <code class="docutils literal notranslate"><span class="pre">linux/fs.h</span></code> for more details.</p></li>
</ul>
</div></blockquote>
<p>Filesystems should call <code class="docutils literal notranslate"><span class="pre">iomap_dio_rw</span></code> from <code class="docutils literal notranslate"><span class="pre">-&gt;read_iter</span></code> and
<code class="docutils literal notranslate"><span class="pre">-&gt;write_iter</span></code>, and set <code class="docutils literal notranslate"><span class="pre">FMODE_CAN_ODIRECT</span></code> in the <code class="docutils literal notranslate"><span class="pre">-&gt;open</span></code>
function for the file.
They should not set <code class="docutils literal notranslate"><span class="pre">-&gt;direct_IO</span></code>, which is deprecated.</p>
<p>If a filesystem wishes to perform its own work before direct I/O
completion, it should call <code class="docutils literal notranslate"><span class="pre">__iomap_dio_rw</span></code>.
If its return value is not an error pointer or a NULL pointer, the
filesystem should pass the return value to <code class="docutils literal notranslate"><span class="pre">iomap_dio_complete</span></code> after
finishing its internal work.</p>
<section id="return-values">
<h3><a class="toc-backref" href="#id16" role="doc-backlink"><span class="section-number">2.2.1. </span>Return Values</a><a class="headerlink" href="#return-values" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">iomap_dio_rw</span></code> can return one of the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>A non-negative number of bytes transferred.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ENOTBLK</span></code>: Fall back to buffered I/O.
iomap itself will return this value if it cannot invalidate the page
cache before issuing the I/O to storage.
The <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> or <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_end</span></code> functions may also return
this value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EIOCBQUEUED</span></code>: The asynchronous direct I/O request has been
queued and will be completed separately.</p></li>
<li><p>Any of the other negative error codes.</p></li>
</ul>
</div></blockquote>
</section>
<section id="direct-reads">
<h3><a class="toc-backref" href="#id17" role="doc-backlink"><span class="section-number">2.2.2. </span>Direct Reads</a><a class="headerlink" href="#direct-reads" title="Link to this heading">¶</a></h3>
<p>A direct I/O read initiates a read I/O from the storage device to the
caller’s buffer.
Dirty parts of the pagecache are flushed to storage before initiating
the read io.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> value for <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> will be <code class="docutils literal notranslate"><span class="pre">IOMAP_DIRECT</span></code> with
any combination of the following enhancements:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_NOWAIT</span></code>, as defined previously.</p></li>
</ul>
</div></blockquote>
<p>Callers commonly hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in shared mode before calling this
function.</p>
</section>
<section id="direct-writes">
<h3><a class="toc-backref" href="#id18" role="doc-backlink"><span class="section-number">2.2.3. </span>Direct Writes</a><a class="headerlink" href="#direct-writes" title="Link to this heading">¶</a></h3>
<p>A direct I/O write initiates a write I/O to the storage device from the
caller’s buffer.
Dirty parts of the pagecache are flushed to storage before initiating
the write io.
The pagecache is invalidated both before and after the write io.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> value for <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> will be <code class="docutils literal notranslate"><span class="pre">IOMAP_DIRECT</span> <span class="pre">|</span>
<span class="pre">IOMAP_WRITE</span></code> with any combination of the following enhancements:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_NOWAIT</span></code>, as defined previously.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_OVERWRITE_ONLY</span></code>: Allocating blocks and zeroing partial
blocks is not allowed.
The entire file range must map to a single written or unwritten
extent.
The file I/O range must be aligned to the filesystem block size
if the mapping is unwritten and the filesystem cannot handle zeroing
the unaligned regions without exposing stale contents.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_ATOMIC</span></code>: This write is being issued with torn-write
protection.
Torn-write protection may be provided based on HW-offload or by a
software mechanism provided by the filesystem.</p>
<p>For HW-offload based support, only a single bio can be created for the
write, and the write must not be split into multiple I/O requests, i.e.
flag REQ_ATOMIC must be set.
The file range to write must be aligned to satisfy the requirements
of both the filesystem and the underlying block device’s atomic
commit capabilities.
If filesystem metadata updates are required (e.g. unwritten extent
conversion or copy-on-write), all updates for the entire file range
must be committed atomically as well.
Untorn-writes may be longer than a single file block. In all cases,
the mapping start disk block must have at least the same alignment as
the write offset.
The filesystems must set IOMAP_F_ATOMIC_BIO to inform iomap core of an
untorn-write based on HW-offload.</p>
<p>For untorn-writes based on a software mechanism provided by the
filesystem, all the disk block alignment and single bio restrictions
which apply for HW-offload based untorn-writes do not apply.
The mechanism would typically be used as a fallback for when
HW-offload based untorn-writes may not be issued, e.g. the range of the
write covers multiple extents, meaning that it is not possible to issue
a single bio.
All filesystem metadata updates for the entire file range must be
committed atomically as well.</p>
</li>
</ul>
</div></blockquote>
<p>Callers commonly hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in shared or exclusive mode before
calling this function.</p>
</section>
<section id="struct-iomap-dio-ops">
<h3><a class="toc-backref" href="#id19" role="doc-backlink"><span class="section-number">2.2.4. </span><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iomap_dio_ops:</span></code></a><a class="headerlink" href="#struct-iomap-dio-ops" title="Link to this heading">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_dio_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">submit_io</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iomap_iter</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">bio</span><span class="w"> </span><span class="o">*</span><span class="n">bio</span><span class="p">,</span>
<span class="w">                      </span><span class="n">loff_t</span><span class="w"> </span><span class="n">file_offset</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">end_io</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">iocb</span><span class="p">,</span><span class="w"> </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">error</span><span class="p">,</span>
<span class="w">                  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bio_set</span><span class="w"> </span><span class="o">*</span><span class="n">bio_set</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields of this structure are as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">submit_io</span></code>: iomap calls this function when it has constructed a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> object for the I/O requested, and wishes to submit it
to the block device.
If no function is provided, <code class="docutils literal notranslate"><span class="pre">submit_bio</span></code> will be called directly.
Filesystems that would like to perform additional work before (e.g.
data replication for btrfs) should implement this function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">end_io</span></code>: This is called after the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> completes.
This function should perform post-write conversions of unwritten
extent mappings, handle write failures, etc.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument may be set to a combination of the following:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_DIO_UNWRITTEN</span></code>: The mapping was unwritten, so the ioend
should mark the extent as written.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_DIO_COW</span></code>: Writing to the space in the mapping required a
copy on write operation, so the ioend should switch mappings.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bio_set</span></code>: This allows the filesystem to provide a custom bio_set
for allocating direct I/O bios.
This enables filesystems to <a class="reference external" href="https://lore.kernel.org/all/20220505201115.937837-3-hch&#64;lst.de/">stash additional per-bio information</a>
for private use.
If this field is NULL, generic <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> objects will be used.</p></li>
</ul>
</div></blockquote>
<p>Filesystems that want to perform extra work after an I/O completion
should set a custom <code class="docutils literal notranslate"><span class="pre">-&gt;bi_end_io</span></code> function via <code class="docutils literal notranslate"><span class="pre">-&gt;submit_io</span></code>.
Afterwards, the custom endio function must call
<code class="docutils literal notranslate"><span class="pre">iomap_dio_bio_end_io</span></code> to finish the direct I/O.</p>
</section>
</section>
<section id="dax-i-o">
<h2><a class="toc-backref" href="#id20" role="doc-backlink"><span class="section-number">2.3. </span>DAX I/O</a><a class="headerlink" href="#dax-i-o" title="Link to this heading">¶</a></h2>
<p>Some storage devices can be directly mapped as memory.
These devices support a new access mode known as “fsdax” that allows
loads and stores through the CPU and memory controller.</p>
<section id="fsdax-reads">
<h3><a class="toc-backref" href="#id21" role="doc-backlink"><span class="section-number">2.3.1. </span>fsdax Reads</a><a class="headerlink" href="#fsdax-reads" title="Link to this heading">¶</a></h3>
<p>A fsdax read performs a memcpy from storage device to the caller’s
buffer.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> value for <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> will be <code class="docutils literal notranslate"><span class="pre">IOMAP_DAX</span></code> with any
combination of the following enhancements:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_NOWAIT</span></code>, as defined previously.</p></li>
</ul>
</div></blockquote>
<p>Callers commonly hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in shared mode before calling this
function.</p>
</section>
<section id="fsdax-writes">
<h3><a class="toc-backref" href="#id22" role="doc-backlink"><span class="section-number">2.3.2. </span>fsdax Writes</a><a class="headerlink" href="#fsdax-writes" title="Link to this heading">¶</a></h3>
<p>A fsdax write initiates a memcpy to the storage device from the caller’s
buffer.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> value for <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> will be <code class="docutils literal notranslate"><span class="pre">IOMAP_DAX</span> <span class="pre">|</span>
<span class="pre">IOMAP_WRITE</span></code> with any combination of the following enhancements:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_NOWAIT</span></code>, as defined previously.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IOMAP_OVERWRITE_ONLY</span></code>: The caller requires a pure overwrite to be
performed from this mapping.
This requires the filesystem extent mapping to already exist as an
<code class="docutils literal notranslate"><span class="pre">IOMAP_MAPPED</span></code> type and span the entire range of the write I/O
request.
If the filesystem cannot map this request in a way that allows the
iomap infrastructure to perform a pure overwrite, it must fail the
mapping operation with <code class="docutils literal notranslate"><span class="pre">-EAGAIN</span></code>.</p></li>
</ul>
</div></blockquote>
<p>Callers commonly hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in exclusive mode before calling this
function.</p>
<section id="fsdax-mmap-faults">
<h4><a class="toc-backref" href="#id23" role="doc-backlink"><span class="section-number">2.3.2.1. </span>fsdax mmap Faults</a><a class="headerlink" href="#fsdax-mmap-faults" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">dax_iomap_fault</span></code> function handles read and write faults to fsdax
storage.
For a read fault, <code class="docutils literal notranslate"><span class="pre">IOMAP_DAX</span> <span class="pre">|</span> <span class="pre">IOMAP_FAULT</span></code> will be passed as the
<code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
For a write fault, <code class="docutils literal notranslate"><span class="pre">IOMAP_DAX</span> <span class="pre">|</span> <span class="pre">IOMAP_FAULT</span> <span class="pre">|</span> <span class="pre">IOMAP_WRITE</span></code> will be
passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.</p>
<p>Callers commonly hold the same locks as they do to call their iomap
pagecache counterparts.</p>
</section>
</section>
<section id="fsdax-truncation-fallocate-and-unsharing">
<h3><a class="toc-backref" href="#id24" role="doc-backlink"><span class="section-number">2.3.3. </span>fsdax Truncation, fallocate, and Unsharing</a><a class="headerlink" href="#fsdax-truncation-fallocate-and-unsharing" title="Link to this heading">¶</a></h3>
<p>For fsdax files, the following functions are provided to replace their
iomap pagecache I/O counterparts.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to <code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code> are the same as the
pagecache counterparts, with <code class="docutils literal notranslate"><span class="pre">IOMAP_DAX</span></code> added.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dax_file_unshare</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dax_zero_range</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dax_truncate_page</span></code></p></li>
</ul>
</div></blockquote>
<p>Callers commonly hold the same locks as they do to call their iomap
pagecache counterparts.</p>
</section>
<section id="fsdax-deduplication">
<h3><a class="toc-backref" href="#id25" role="doc-backlink"><span class="section-number">2.3.4. </span>fsdax Deduplication</a><a class="headerlink" href="#fsdax-deduplication" title="Link to this heading">¶</a></h3>
<p>Filesystems implementing the <code class="docutils literal notranslate"><span class="pre">FIDEDUPERANGE</span></code> ioctl must call the
<code class="docutils literal notranslate"><span class="pre">dax_remap_file_range_prep</span></code> function with their own iomap read ops.</p>
</section>
</section>
<section id="seeking-files">
<h2><a class="toc-backref" href="#id26" role="doc-backlink"><span class="section-number">2.4. </span>Seeking Files</a><a class="headerlink" href="#seeking-files" title="Link to this heading">¶</a></h2>
<p>iomap implements the two iterating whence modes of the <code class="docutils literal notranslate"><span class="pre">llseek</span></code> system
call.</p>
<section id="seek-data">
<h3><a class="toc-backref" href="#id27" role="doc-backlink"><span class="section-number">2.4.1. </span>SEEK_DATA</a><a class="headerlink" href="#seek-data" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">iomap_seek_data</span></code> function implements the SEEK_DATA “whence” value
for llseek.
<code class="docutils literal notranslate"><span class="pre">IOMAP_REPORT</span></code> will be passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.</p>
<p>For unwritten mappings, the pagecache will be searched.
Regions of the pagecache with a folio mapped and uptodate fsblocks
within those folios will be reported as data areas.</p>
<p>Callers commonly hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in shared mode before calling this
function.</p>
</section>
<section id="seek-hole">
<h3><a class="toc-backref" href="#id28" role="doc-backlink"><span class="section-number">2.4.2. </span>SEEK_HOLE</a><a class="headerlink" href="#seek-hole" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">iomap_seek_hole</span></code> function implements the SEEK_HOLE “whence” value
for llseek.
<code class="docutils literal notranslate"><span class="pre">IOMAP_REPORT</span></code> will be passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.</p>
<p>For unwritten mappings, the pagecache will be searched.
Regions of the pagecache with no folio mapped, or a !uptodate fsblock
within a folio will be reported as sparse hole areas.</p>
<p>Callers commonly hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in shared mode before calling this
function.</p>
</section>
</section>
<section id="swap-file-activation">
<h2><a class="toc-backref" href="#id29" role="doc-backlink"><span class="section-number">2.5. </span>Swap File Activation</a><a class="headerlink" href="#swap-file-activation" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">iomap_swapfile_activate</span></code> function finds all the base-page aligned
regions in a file and sets them up as swap space.
The file will be <code class="docutils literal notranslate"><span class="pre">fsync()</span></code>’d before activation.
<code class="docutils literal notranslate"><span class="pre">IOMAP_REPORT</span></code> will be passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
All mappings must be mapped or unwritten; cannot be dirty or shared, and
cannot span multiple block devices.
Callers must hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in exclusive mode; this is already
provided by <code class="docutils literal notranslate"><span class="pre">swapon</span></code>.</p>
</section>
<section id="file-space-mapping-reporting">
<h2><a class="toc-backref" href="#id30" role="doc-backlink"><span class="section-number">2.6. </span>File Space Mapping Reporting</a><a class="headerlink" href="#file-space-mapping-reporting" title="Link to this heading">¶</a></h2>
<p>iomap implements two of the file space mapping system calls.</p>
<section id="fs-ioc-fiemap">
<h3><a class="toc-backref" href="#id31" role="doc-backlink"><span class="section-number">2.6.1. </span>FS_IOC_FIEMAP</a><a class="headerlink" href="#fs-ioc-fiemap" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">iomap_fiemap</span></code> function exports file extent mappings to userspace
in the format specified by the <code class="docutils literal notranslate"><span class="pre">FS_IOC_FIEMAP</span></code> ioctl.
<code class="docutils literal notranslate"><span class="pre">IOMAP_REPORT</span></code> will be passed as the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">-&gt;iomap_begin</span></code>.
Callers commonly hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in shared mode before calling this
function.</p>
</section>
<section id="fibmap-deprecated">
<h3><a class="toc-backref" href="#id32" role="doc-backlink"><span class="section-number">2.6.2. </span>FIBMAP (deprecated)</a><a class="headerlink" href="#fibmap-deprecated" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">iomap_bmap</span></code> implements FIBMAP.
The calling conventions are the same as for FIEMAP.
This function is only provided to maintain compatibility for filesystems
that implemented FIBMAP prior to conversion.
This ioctl is deprecated; do <strong>not</strong> add a FIBMAP implementation to
filesystems that do not have it.
Callers should probably hold <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code> in shared mode before calling
this function, but this is unclear.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/filesystems/iomap/operations.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>