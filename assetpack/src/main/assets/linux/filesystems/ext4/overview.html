<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>2. High Level Design &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="3. Global Structures" href="globals.html" />
    <link rel="prev" title="1. About this Book" href="about.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../nvme/index.html">NVMe Subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/filesystems/ext4/overview.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="high-level-design">
<h1><span class="section-number">2. </span>High Level Design<a class="headerlink" href="#high-level-design" title="Link to this heading">¶</a></h1>
<p>An ext4 file system is split into a series of block groups. To reduce
performance difficulties due to fragmentation, the block allocator tries
very hard to keep each file’s blocks within the same group, thereby
reducing seek times. The size of a block group is specified in
<code class="docutils literal notranslate"><span class="pre">sb.s_blocks_per_group</span></code> blocks, though it can also calculated as 8 *
<code class="docutils literal notranslate"><span class="pre">block_size_in_bytes</span></code>. With the default block size of 4KiB, each group
will contain 32,768 blocks, for a length of 128MiB. The number of block
groups is the size of the device divided by the size of a block group.</p>
<p>All fields in ext4 are written to disk in little-endian order. HOWEVER,
all fields in jbd2 (the journal) are written to disk in big-endian
order.</p>
<section id="blocks">
<h2><span class="section-number">2.1. </span>Blocks<a class="headerlink" href="#blocks" title="Link to this heading">¶</a></h2>
<p>ext4 allocates storage space in units of “blocks”. A block is a group of
sectors between 1KiB and 64KiB, and the number of sectors must be an
integral power of 2. Blocks are in turn grouped into larger units called
block groups. Block size is specified at mkfs time and typically is
4KiB. You may experience mounting problems if block size is greater than
page size (i.e. 64KiB blocks on a i386 which only has 4KiB memory
pages). By default a filesystem can contain 2^32 blocks; if the ‘64bit’
feature is enabled, then a filesystem can have 2^64 blocks. The location
of structures is stored in terms of the block number the structure lives
in and not the absolute offset on disk.</p>
<p>For 32-bit filesystems, limits are as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>1KiB</p></th>
<th class="head"><p>2KiB</p></th>
<th class="head"><p>4KiB</p></th>
<th class="head"><p>64KiB</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Blocks</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-odd"><td><p>Inodes</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-even"><td><p>File System Size</p></td>
<td><p>4TiB</p></td>
<td><p>8TiB</p></td>
<td><p>16TiB</p></td>
<td><p>256TiB</p></td>
</tr>
<tr class="row-odd"><td><p>Blocks Per Block Group</p></td>
<td><p>8,192</p></td>
<td><p>16,384</p></td>
<td><p>32,768</p></td>
<td><p>524,288</p></td>
</tr>
<tr class="row-even"><td><p>Inodes Per Block Group</p></td>
<td><p>8,192</p></td>
<td><p>16,384</p></td>
<td><p>32,768</p></td>
<td><p>524,288</p></td>
</tr>
<tr class="row-odd"><td><p>Block Group Size</p></td>
<td><p>8MiB</p></td>
<td><p>32MiB</p></td>
<td><p>128MiB</p></td>
<td><p>32GiB</p></td>
</tr>
<tr class="row-even"><td><p>Blocks Per File, Extents</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-odd"><td><p>Blocks Per File, Block Maps</p></td>
<td><p>16,843,020</p></td>
<td><p>134,480,396</p></td>
<td><p>1,074,791,436</p></td>
<td><p>4,398,314,962,956 (really 2^32 due to field size limitations)</p></td>
</tr>
<tr class="row-even"><td><p>File Size, Extents</p></td>
<td><p>4TiB</p></td>
<td><p>8TiB</p></td>
<td><p>16TiB</p></td>
<td><p>256TiB</p></td>
</tr>
<tr class="row-odd"><td><p>File Size, Block Maps</p></td>
<td><p>16GiB</p></td>
<td><p>256GiB</p></td>
<td><p>4TiB</p></td>
<td><p>256TiB</p></td>
</tr>
</tbody>
</table>
<p>For 64-bit filesystems, limits are as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>1KiB</p></th>
<th class="head"><p>2KiB</p></th>
<th class="head"><p>4KiB</p></th>
<th class="head"><p>64KiB</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Blocks</p></td>
<td><p>2^64</p></td>
<td><p>2^64</p></td>
<td><p>2^64</p></td>
<td><p>2^64</p></td>
</tr>
<tr class="row-odd"><td><p>Inodes</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-even"><td><p>File System Size</p></td>
<td><p>16ZiB</p></td>
<td><p>32ZiB</p></td>
<td><p>64ZiB</p></td>
<td><p>1YiB</p></td>
</tr>
<tr class="row-odd"><td><p>Blocks Per Block Group</p></td>
<td><p>8,192</p></td>
<td><p>16,384</p></td>
<td><p>32,768</p></td>
<td><p>524,288</p></td>
</tr>
<tr class="row-even"><td><p>Inodes Per Block Group</p></td>
<td><p>8,192</p></td>
<td><p>16,384</p></td>
<td><p>32,768</p></td>
<td><p>524,288</p></td>
</tr>
<tr class="row-odd"><td><p>Block Group Size</p></td>
<td><p>8MiB</p></td>
<td><p>32MiB</p></td>
<td><p>128MiB</p></td>
<td><p>32GiB</p></td>
</tr>
<tr class="row-even"><td><p>Blocks Per File, Extents</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
<td><p>2^32</p></td>
</tr>
<tr class="row-odd"><td><p>Blocks Per File, Block Maps</p></td>
<td><p>16,843,020</p></td>
<td><p>134,480,396</p></td>
<td><p>1,074,791,436</p></td>
<td><p>4,398,314,962,956 (really 2^32 due to field size limitations)</p></td>
</tr>
<tr class="row-even"><td><p>File Size, Extents</p></td>
<td><p>4TiB</p></td>
<td><p>8TiB</p></td>
<td><p>16TiB</p></td>
<td><p>256TiB</p></td>
</tr>
<tr class="row-odd"><td><p>File Size, Block Maps</p></td>
<td><p>16GiB</p></td>
<td><p>256GiB</p></td>
<td><p>4TiB</p></td>
<td><p>256TiB</p></td>
</tr>
</tbody>
</table>
<p>Note: Files not using extents (i.e. files using block maps) must be
placed within the first 2^32 blocks of a filesystem. Files with extents
must be placed within the first 2^48 blocks of a filesystem. It’s not
clear what happens with larger filesystems.</p>
</section>
<section id="layout">
<h2><span class="section-number">2.2. </span>Layout<a class="headerlink" href="#layout" title="Link to this heading">¶</a></h2>
<p>The layout of a standard block group is approximately as follows (each
of these fields is discussed in a separate section below):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12.5%" />
<col style="width: 12.5%" />
<col style="width: 12.5%" />
<col style="width: 12.5%" />
<col style="width: 12.5%" />
<col style="width: 12.5%" />
<col style="width: 12.5%" />
<col style="width: 12.5%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Group 0 Padding</p></th>
<th class="head"><p>ext4 Super Block</p></th>
<th class="head"><p>Group Descriptors</p></th>
<th class="head"><p>Reserved GDT Blocks</p></th>
<th class="head"><p>Data Block Bitmap</p></th>
<th class="head"><p>inode Bitmap</p></th>
<th class="head"><p>inode Table</p></th>
<th class="head"><p>Data Blocks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1024 bytes</p></td>
<td><p>1 block</p></td>
<td><p>many blocks</p></td>
<td><p>many blocks</p></td>
<td><p>1 block</p></td>
<td><p>1 block</p></td>
<td><p>many blocks</p></td>
<td><p>many more blocks</p></td>
</tr>
</tbody>
</table>
<p>For the special case of block group 0, the first 1024 bytes are unused,
to allow for the installation of x86 boot sectors and other oddities.
The superblock will start at offset 1024 bytes, whichever block that
happens to be (usually 0). However, if for some reason the block size =
1024, then block 0 is marked in use and the superblock goes in block 1.
For all other block groups, there is no padding.</p>
<p>The ext4 driver primarily works with the superblock and the group
descriptors that are found in block group 0. Redundant copies of the
superblock and group descriptors are written to some of the block groups
across the disk in case the beginning of the disk gets trashed, though
not all block groups necessarily host a redundant copy (see following
paragraph for more details). If the group does not have a redundant
copy, the block group begins with the data block bitmap. Note also that
when the filesystem is freshly formatted, mkfs will allocate “reserve
GDT block” space after the block group descriptors and before the start
of the block bitmaps to allow for future expansion of the filesystem. By
default, a filesystem is allowed to increase in size by a factor of
1024x over the original filesystem size.</p>
<p>The location of the inode table is given by <code class="docutils literal notranslate"><span class="pre">grp.bg_inode_table_*</span></code>. It
is continuous range of blocks large enough to contain
<code class="docutils literal notranslate"><span class="pre">sb.s_inodes_per_group</span> <span class="pre">*</span> <span class="pre">sb.s_inode_size</span></code> bytes.</p>
<p>As for the ordering of items in a block group, it is generally
established that the super block and the group descriptor table, if
present, will be at the beginning of the block group. The bitmaps and
the inode table can be anywhere, and it is quite possible for the
bitmaps to come after the inode table, or for both to be in different
groups (flex_bg). Leftover space is used for file data blocks, indirect
block maps, extent tree blocks, and extended attributes.</p>
</section>
<section id="flexible-block-groups">
<h2><span class="section-number">2.3. </span>Flexible Block Groups<a class="headerlink" href="#flexible-block-groups" title="Link to this heading">¶</a></h2>
<p>Starting in ext4, there is a new feature called flexible block groups
(flex_bg). In a flex_bg, several block groups are tied together as one
logical block group; the bitmap spaces and the inode table space in the
first block group of the flex_bg are expanded to include the bitmaps
and inode tables of all other block groups in the flex_bg. For example,
if the flex_bg size is 4, then group 0 will contain (in order) the
superblock, group descriptors, data block bitmaps for groups 0-3, inode
bitmaps for groups 0-3, inode tables for groups 0-3, and the remaining
space in group 0 is for file data. The effect of this is to group the
block group metadata close together for faster loading, and to enable
large files to be continuous on disk. Backup copies of the superblock
and group descriptors are always at the beginning of block groups, even
if flex_bg is enabled. The number of block groups that make up a
flex_bg is given by 2 ^ <code class="docutils literal notranslate"><span class="pre">sb.s_log_groups_per_flex</span></code>.</p>
</section>
<section id="meta-block-groups">
<h2><span class="section-number">2.4. </span>Meta Block Groups<a class="headerlink" href="#meta-block-groups" title="Link to this heading">¶</a></h2>
<p>Without the option META_BG, for safety concerns, all block group
descriptors copies are kept in the first block group. Given the default
128MiB(2^27 bytes) block group size and 64-byte group descriptors, ext4
can have at most 2^27/64 = 2^21 block groups. This limits the entire
filesystem size to 2^21 * 2^27 = 2^48bytes or 256TiB.</p>
<p>The solution to this problem is to use the metablock group feature
(META_BG), which is already in ext3 for all 2.6 releases. With the
META_BG feature, ext4 filesystems are partitioned into many metablock
groups. Each metablock group is a cluster of block groups whose group
descriptor structures can be stored in a single disk block. For ext4
filesystems with 4 KB block size, a single metablock group partition
includes 64 block groups, or 8 GiB of disk space. The metablock group
feature moves the location of the group descriptors from the congested
first block group of the whole filesystem into the first group of each
metablock group itself. The backups are in the second and last group of
each metablock group. This increases the 2^21 maximum block groups limit
to the hard limit 2^32, allowing support for a 512PiB filesystem.</p>
<p>The change in the filesystem format replaces the current scheme where
the superblock is followed by a variable-length set of block group
descriptors. Instead, the superblock and a single block group descriptor
block is placed at the beginning of the first, second, and last block
groups in a meta-block group. A meta-block group is a collection of
block groups which can be described by a single block group descriptor
block. Since the size of the block group descriptor structure is 64
bytes, a meta-block group contains 16 block groups for filesystems with
a 1KB block size, and 64 block groups for filesystems with a 4KB
blocksize. Filesystems can either be created using this new block group
descriptor layout, or existing filesystems can be resized on-line, and
the field s_first_meta_bg in the superblock will indicate the first
block group using this new layout.</p>
<p>Please see an important note about <code class="docutils literal notranslate"><span class="pre">BLOCK_UNINIT</span></code> in the section about
block and inode bitmaps.</p>
</section>
<section id="lazy-block-group-initialization">
<h2><span class="section-number">2.5. </span>Lazy Block Group Initialization<a class="headerlink" href="#lazy-block-group-initialization" title="Link to this heading">¶</a></h2>
<p>A new feature for ext4 are three block group descriptor flags that
enable mkfs to skip initializing other parts of the block group
metadata. Specifically, the INODE_UNINIT and BLOCK_UNINIT flags mean
that the inode and block bitmaps for that group can be calculated and
therefore the on-disk bitmap blocks are not initialized. This is
generally the case for an empty block group or a block group containing
only fixed-location block group metadata. The INODE_ZEROED flag means
that the inode table has been initialized; mkfs will unset this flag and
rely on the kernel to initialize the inode tables in the background.</p>
<p>By not writing zeroes to the bitmaps and inode table, mkfs time is
reduced considerably. Note the feature flag is RO_COMPAT_GDT_CSUM,
but the dumpe2fs output prints this as “uninit_bg”. They are the same
thing.</p>
</section>
<section id="special-inodes">
<h2><span class="section-number">2.6. </span>Special inodes<a class="headerlink" href="#special-inodes" title="Link to this heading">¶</a></h2>
<p>ext4 reserves some inode for special features, as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 7.9%" />
<col style="width: 92.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>inode Number</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Doesn’t exist; there is no inode 0.</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>List of defective blocks.</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>Root directory.</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>User quota.</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>Group quota.</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>Boot loader.</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>Undelete directory.</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>Reserved group descriptors inode. (“resize inode”)</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>Journal inode.</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>The “exclude” inode, for snapshots(?)</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>Replica inode, used for some non-upstream feature?</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>Traditional first non-reserved inode. Usually this is the lost+found directory. See s_first_ino in the superblock.</p></td>
</tr>
</tbody>
</table>
<p>Note that there are also some inodes allocated from non-reserved inode numbers
for other filesystem features which are not referenced from standard directory
hierarchy. These are generally reference from the superblock. They are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28.6%" />
<col style="width: 71.4%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Superblock field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>s_lpf_ino</p></td>
<td><p>Inode number of lost+found directory.</p></td>
</tr>
<tr class="row-odd"><td><p>s_prj_quota_inum</p></td>
<td><p>Inode number of quota file tracking project quotas</p></td>
</tr>
<tr class="row-even"><td><p>s_orphan_file_inum</p></td>
<td><p>Inode number of file tracking orphan inodes.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="block-and-inode-allocation-policy">
<h2><span class="section-number">2.7. </span>Block and Inode Allocation Policy<a class="headerlink" href="#block-and-inode-allocation-policy" title="Link to this heading">¶</a></h2>
<p>ext4 recognizes (better than ext3, anyway) that data locality is
generally a desirably quality of a filesystem. On a spinning disk,
keeping related blocks near each other reduces the amount of movement
that the head actuator and disk must perform to access a data block,
thus speeding up disk IO. On an SSD there of course are no moving parts,
but locality can increase the size of each transfer request while
reducing the total number of requests. This locality may also have the
effect of concentrating writes on a single erase block, which can speed
up file rewrites significantly. Therefore, it is useful to reduce
fragmentation whenever possible.</p>
<p>The first tool that ext4 uses to combat fragmentation is the multi-block
allocator. When a file is first created, the block allocator
speculatively allocates 8KiB of disk space to the file on the assumption
that the space will get written soon. When the file is closed, the
unused speculative allocations are of course freed, but if the
speculation is correct (typically the case for full writes of small
files) then the file data gets written out in a single multi-block
extent. A second related trick that ext4 uses is delayed allocation.
Under this scheme, when a file needs more blocks to absorb file writes,
the filesystem defers deciding the exact placement on the disk until all
the dirty buffers are being written out to disk. By not committing to a
particular placement until it’s absolutely necessary (the commit timeout
is hit, or sync() is called, or the kernel runs out of memory), the hope
is that the filesystem can make better location decisions.</p>
<p>The third trick that ext4 (and ext3) uses is that it tries to keep a
file’s data blocks in the same block group as its inode. This cuts down
on the seek penalty when the filesystem first has to read a file’s inode
to learn where the file’s data blocks live and then seek over to the
file’s data blocks to begin I/O operations.</p>
<p>The fourth trick is that all the inodes in a directory are placed in the
same block group as the directory, when feasible. The working assumption
here is that all the files in a directory might be related, therefore it
is useful to try to keep them all together.</p>
<p>The fifth trick is that the disk volume is cut up into 128MB block
groups; these mini-containers are used as outlined above to try to
maintain data locality. However, there is a deliberate quirk -- when a
directory is created in the root directory, the inode allocator scans
the block groups and puts that directory into the least heavily loaded
block group that it can find. This encourages directories to spread out
over a disk; as the top-level directory/file blobs fill up one block
group, the allocators simply move on to the next block group. Allegedly
this scheme evens out the loading on the block groups, though the author
suspects that the directories which are so unlucky as to land towards
the end of a spinning drive get a raw deal performance-wise.</p>
<p>Of course if all of these mechanisms fail, one can always use e4defrag
to defragment files.</p>
</section>
<section id="checksums">
<h2><span class="section-number">2.8. </span>Checksums<a class="headerlink" href="#checksums" title="Link to this heading">¶</a></h2>
<p>Starting in early 2012, metadata checksums were added to all major ext4
and jbd2 data structures. The associated feature flag is metadata_csum.
The desired checksum algorithm is indicated in the superblock, though as
of October 2012 the only supported algorithm is crc32c. Some data
structures did not have space to fit a full 32-bit checksum, so only the
lower 16 bits are stored. Enabling the 64bit feature increases the data
structure size so that full 32-bit checksums can be stored for many data
structures. However, existing 32-bit filesystems cannot be extended to
enable 64bit mode, at least not without the experimental resize2fs
patches to do so.</p>
<p>Existing filesystems can have checksumming added by running
<code class="docutils literal notranslate"><span class="pre">tune2fs</span> <span class="pre">-O</span> <span class="pre">metadata_csum</span></code> against the underlying device. If tune2fs
encounters directory blocks that lack sufficient empty space to add a
checksum, it will request that you run <code class="docutils literal notranslate"><span class="pre">e2fsck</span> <span class="pre">-D</span></code> to have the
directories rebuilt with checksums. This has the added benefit of
removing slack space from the directory files and rebalancing the htree
indexes. If you _ignore_ this step, your directories will not be
protected by a checksum!</p>
<p>The following table describes the data elements that go into each type
of checksum. The checksum function is whatever the superblock describes
(crc32c as of October 2013) unless noted otherwise.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25.6%" />
<col style="width: 10.3%" />
<col style="width: 64.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Metadata</p></th>
<th class="head"><p>Length</p></th>
<th class="head"><p>Ingredients</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Superblock</p></td>
<td><p>__le32</p></td>
<td><p>The entire superblock up to the checksum field. The UUID lives inside
the superblock.</p></td>
</tr>
<tr class="row-odd"><td><p>MMP</p></td>
<td><p>__le32</p></td>
<td><p>UUID + the entire MMP block up to the checksum field.</p></td>
</tr>
<tr class="row-even"><td><p>Extended Attributes</p></td>
<td><p>__le32</p></td>
<td><p>UUID + the entire extended attribute block. The checksum field is set to
zero.</p></td>
</tr>
<tr class="row-odd"><td><p>Directory Entries</p></td>
<td><p>__le32</p></td>
<td><p>UUID + inode number + inode generation + the directory block up to the
fake entry enclosing the checksum field.</p></td>
</tr>
<tr class="row-even"><td><p>HTREE Nodes</p></td>
<td><p>__le32</p></td>
<td><p>UUID + inode number + inode generation + all valid extents + HTREE tail.
The checksum field is set to zero.</p></td>
</tr>
<tr class="row-odd"><td><p>Extents</p></td>
<td><p>__le32</p></td>
<td><p>UUID + inode number + inode generation + the entire extent block up to
the checksum field.</p></td>
</tr>
<tr class="row-even"><td><p>Bitmaps</p></td>
<td><p>__le32 or __le16</p></td>
<td><p>UUID + the entire bitmap. Checksums are stored in the group descriptor,
and truncated if the group descriptor size is 32 bytes (i.e. ^64bit)</p></td>
</tr>
<tr class="row-odd"><td><p>Inodes</p></td>
<td><p>__le32</p></td>
<td><p>UUID + inode number + inode generation + the entire inode. The checksum
field is set to zero. Each inode has its own checksum.</p></td>
</tr>
<tr class="row-even"><td><p>Group Descriptors</p></td>
<td><p>__le16</p></td>
<td><p>If metadata_csum, then UUID + group number + the entire descriptor;
else if gdt_csum, then crc16(UUID + group number + the entire
descriptor). In all cases, only the lower 16 bits are stored.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="bigalloc">
<h2><span class="section-number">2.9. </span>Bigalloc<a class="headerlink" href="#bigalloc" title="Link to this heading">¶</a></h2>
<p>At the moment, the default size of a block is 4KiB, which is a commonly
supported page size on most MMU-capable hardware. This is fortunate, as
ext4 code is not prepared to handle the case where the block size
exceeds the page size. However, for a filesystem of mostly huge files,
it is desirable to be able to allocate disk blocks in units of multiple
blocks to reduce both fragmentation and metadata overhead. The
bigalloc feature provides exactly this ability.</p>
<p>The bigalloc feature (EXT4_FEATURE_RO_COMPAT_BIGALLOC) changes ext4 to
use clustered allocation, so that each bit in the ext4 block allocation
bitmap addresses a power of two number of blocks. For example, if the
file system is mainly going to be storing large files in the 4-32
megabyte range, it might make sense to set a cluster size of 1 megabyte.
This means that each bit in the block allocation bitmap now addresses
256 4k blocks. This shrinks the total size of the block allocation
bitmaps for a 2T file system from 64 megabytes to 256 kilobytes. It also
means that a block group addresses 32 gigabytes instead of 128 megabytes,
also shrinking the amount of file system overhead for metadata.</p>
<p>The administrator can set a block cluster size at mkfs time (which is
stored in the s_log_cluster_size field in the superblock); from then
on, the block bitmaps track clusters, not individual blocks. This means
that block groups can be several gigabytes in size (instead of just
128MiB); however, the minimum allocation unit becomes a cluster, not a
block, even for directories. TaoBao had a patchset to extend the “use
units of clusters instead of blocks” to the extent tree, though it is
not clear where those patches went-- they eventually morphed into
“extent tree v2” but that code has not landed as of May 2015.</p>
</section>
<section id="inline-data">
<h2><span class="section-number">2.10. </span>Inline Data<a class="headerlink" href="#inline-data" title="Link to this heading">¶</a></h2>
<p>The inline data feature was designed to handle the case that a file’s
data is so tiny that it readily fits inside the inode, which
(theoretically) reduces disk block consumption and reduces seeks. If the
file is smaller than 60 bytes, then the data are stored inline in
<code class="docutils literal notranslate"><span class="pre">inode.i_block</span></code>. If the rest of the file would fit inside the extended
attribute space, then it might be found as an extended attribute
“system.data” within the inode body (“ibody EA”). This of course
constrains the amount of extended attributes one can attach to an inode.
If the data size increases beyond i_block + ibody EA, a regular block
is allocated and the contents moved to that block.</p>
<p>Pending a change to compact the extended attribute key used to store
inline data, one ought to be able to store 160 bytes of data in a
256-byte inode (as of June 2015, when i_extra_isize is 28). Prior to
that, the limit was 156 bytes due to inefficient use of inode space.</p>
<p>The inline data feature requires the presence of an extended attribute
for “system.data”, even if the attribute value is zero length.</p>
<section id="inline-directories">
<h3><span class="section-number">2.10.1. </span>Inline Directories<a class="headerlink" href="#inline-directories" title="Link to this heading">¶</a></h3>
<p>The first four bytes of i_block are the inode number of the parent
directory. Following that is a 56-byte space for an array of directory
entries; see <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry</span></code>. If there is a “system.data”
attribute in the inode body, the EA value is an array of
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ext4_dir_entry</span></code> as well. Note that for inline directories, the
i_block and EA space are treated as separate dirent blocks; directory
entries cannot span the two.</p>
<p>Inline directory entries are not checksummed, as the inode checksum
should protect all inline data contents.</p>
</section>
</section>
<section id="large-extended-attribute-values">
<h2><span class="section-number">2.11. </span>Large Extended Attribute Values<a class="headerlink" href="#large-extended-attribute-values" title="Link to this heading">¶</a></h2>
<p>To enable ext4 to store extended attribute values that do not fit in the
inode or in the single extended attribute block attached to an inode,
the EA_INODE feature allows us to store the value in the data blocks of
a regular file inode. This “EA inode” is linked only from the extended
attribute name index and must not appear in a directory entry. The
inode’s i_atime field is used to store a checksum of the xattr value;
and i_ctime/i_version store a 64-bit reference count, which enables
sharing of large xattr values between multiple owning inodes. For
backward compatibility with older versions of this feature, the
i_mtime/i_generation <em>may</em> store a back-reference to the inode number
and i_generation of the <strong>one</strong> owning inode (in cases where the EA
inode is not referenced by multiple inodes) to verify that the EA inode
is the correct one being accessed.</p>
</section>
<section id="verity-files">
<h2><span class="section-number">2.12. </span>Verity files<a class="headerlink" href="#verity-files" title="Link to this heading">¶</a></h2>
<p>ext4 supports fs-verity, which is a filesystem feature that provides
Merkle tree based hashing for individual readonly files.  Most of
fs-verity is common to all filesystems that support it; see
<a class="reference internal" href="../fsverity.html#fsverity"><span class="std std-ref">Documentation/filesystems/fsverity.rst</span></a> for the
fs-verity documentation.  However, the on-disk layout of the verity
metadata is filesystem-specific.  On ext4, the verity metadata is
stored after the end of the file data itself, in the following format:</p>
<ul class="simple">
<li><p>Zero-padding to the next 65536-byte boundary.  This padding need not
actually be allocated on-disk, i.e. it may be a hole.</p></li>
<li><p>The Merkle tree, as documented in
<a class="reference internal" href="../fsverity.html#fsverity-merkle-tree"><span class="std std-ref">Documentation/filesystems/fsverity.rst</span></a>, with the tree levels stored in order from
root to leaf, and the tree blocks within each level stored in their
natural order.</p></li>
<li><p>Zero-padding to the next filesystem block boundary.</p></li>
<li><p>The verity descriptor, as documented in
<a class="reference internal" href="../fsverity.html#fsverity-descriptor"><span class="std std-ref">Documentation/filesystems/fsverity.rst</span></a>,
with optionally appended signature blob.</p></li>
<li><p>Zero-padding to the next offset that is 4 bytes before a filesystem
block boundary.</p></li>
<li><p>The size of the verity descriptor in bytes, as a 4-byte little
endian integer.</p></li>
</ul>
<p>Verity inodes have EXT4_VERITY_FL set, and they must use extents, i.e.
EXT4_EXTENTS_FL must be set and EXT4_INLINE_DATA_FL must be clear.
They can have EXT4_ENCRYPT_FL set, in which case the verity metadata
is encrypted as well as the data itself.</p>
<p>Verity files cannot have blocks allocated past the end of the verity
metadata.</p>
<p>Verity and DAX are not compatible and attempts to set both of these flags
on a file will fail.</p>
</section>
<section id="atomic-block-writes">
<span id="atomic-writes"></span><h2><span class="section-number">2.13. </span>Atomic Block Writes<a class="headerlink" href="#atomic-block-writes" title="Link to this heading">¶</a></h2>
<section id="introduction">
<h3><span class="section-number">2.13.1. </span>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h3>
<p>Atomic (untorn) block writes ensure that either the entire write is committed
to disk or none of it is. This prevents “torn writes” during power loss or
system crashes. The ext4 filesystem supports atomic writes (only with Direct
I/O) on regular files with extents, provided the underlying storage device
supports hardware atomic writes. This is supported in the following two ways:</p>
<ol class="arabic simple">
<li><p><strong>Single-fsblock Atomic Writes</strong>:
EXT4’s supports atomic write operations with a single filesystem block since
v6.13. In this the atomic write unit minimum and maximum sizes are both set
to filesystem blocksize.
e.g. doing atomic write of 16KB with 16KB filesystem blocksize on 64KB
pagesize system is possible.</p></li>
<li><p><strong>Multi-fsblock Atomic Writes with Bigalloc</strong>:
EXT4 now also supports atomic writes spanning multiple filesystem blocks
using a feature known as bigalloc. The atomic write unit’s minimum and
maximum sizes are determined by the filesystem block size and cluster size,
based on the underlying device’s supported atomic write unit limits.</p></li>
</ol>
</section>
<section id="requirements">
<h3><span class="section-number">2.13.2. </span>Requirements<a class="headerlink" href="#requirements" title="Link to this heading">¶</a></h3>
<p>Basic requirements for atomic writes in ext4:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The extents feature must be enabled (default for ext4)</p></li>
<li><p>The underlying block device must support atomic writes</p></li>
<li><p>For single-fsblock atomic writes:</p>
<ol class="arabic simple">
<li><p>A filesystem with appropriate block size (up to the page size)</p></li>
</ol>
</li>
<li><p>For multi-fsblock atomic writes:</p>
<ol class="arabic simple">
<li><p>The bigalloc feature must be enabled</p></li>
<li><p>The cluster size must be appropriately configured</p></li>
</ol>
</li>
</ol>
</div></blockquote>
<p>NOTE: EXT4 does not support software or COW based atomic write, which means
atomic writes on ext4 are only supported if underlying storage device supports
it.</p>
</section>
<section id="multi-fsblock-implementation-details">
<h3><span class="section-number">2.13.3. </span>Multi-fsblock Implementation Details<a class="headerlink" href="#multi-fsblock-implementation-details" title="Link to this heading">¶</a></h3>
<p>The bigalloc feature changes ext4 to allocate in units of multiple filesystem
blocks, also known as clusters. With bigalloc each bit within block bitmap
represents cluster (power of 2 number of blocks) rather than individual
filesystem blocks.
EXT4 supports multi-fsblock atomic writes with bigalloc, subject to the
following constraints. The minimum atomic write size is the larger of the fs
block size and the minimum hardware atomic write unit; and the maximum atomic
write size is smaller of the bigalloc cluster size and the maximum hardware
atomic write unit.  Bigalloc ensures that all allocations are aligned to the
cluster size, which satisfies the LBA alignment requirements of the hardware
device if the start of the partition/logical volume is itself aligned correctly.</p>
<p>Here is the block allocation strategy in bigalloc for atomic writes:</p>
<blockquote>
<div><ul class="simple">
<li><p>For regions with fully mapped extents, no additional work is needed</p></li>
<li><p>For append writes, a new mapped extent is allocated</p></li>
<li><p>For regions that are entirely holes, unwritten extent is created</p></li>
<li><p>For large unwritten extents, the extent gets split into two unwritten
extents of appropriate requested size</p></li>
<li><p>For mixed mapping regions (combinations of holes, unwritten extents, or
mapped extents), ext4_map_blocks() is called in a loop with
EXT4_GET_BLOCKS_ZERO flag to convert the region into a single contiguous
mapped extent by writing zeroes to it and converting any unwritten extents to
written, if found within the range.</p></li>
</ul>
</div></blockquote>
<p>Note: Writing on a single contiguous underlying extent, whether mapped or
unwritten, is not inherently problematic. However, writing to a mixed mapping
region (i.e. one containing a combination of mapped and unwritten extents)
must be avoided when performing atomic writes.</p>
<p>The reason is that, atomic writes when issued via pwritev2() with the RWF_ATOMIC
flag, requires that either all data is written or none at all. In the event of
a system crash or unexpected power loss during the write operation, the affected
region (when later read) must reflect either the complete old data or the
complete new data, but never a mix of both.</p>
<p>To enforce this guarantee, we ensure that the write target is backed by
a single, contiguous extent before any data is written. This is critical because
ext4 defers the conversion of unwritten extents to written extents until the I/O
completion path (typically in -&gt;end_io()). If a write is allowed to proceed over
a mixed mapping region (with mapped and unwritten extents) and a failure occurs
mid-write, the system could observe partially updated regions after reboot, i.e.
new data over mapped areas, and stale (old) data over unwritten extents that
were never marked written. This violates the atomicity and/or torn write
prevention guarantee.</p>
<p>To prevent such torn writes, ext4 proactively allocates a single contiguous
extent for the entire requested region in <code class="docutils literal notranslate"><span class="pre">ext4_iomap_alloc</span></code> via
<code class="docutils literal notranslate"><span class="pre">ext4_map_blocks_atomic()</span></code>. EXT4 also force commits the current journalling
transaction in case if allocation is done over mixed mapping. This ensures any
pending metadata updates (like unwritten to written extents conversion) in this
range are in consistent state with the file data blocks, before performing the
actual write I/O. If the commit fails, the whole I/O must be aborted to prevent
from any possible torn writes.
Only after this step, the actual data write operation is performed by the iomap.</p>
</section>
<section id="handling-split-extents-across-leaf-blocks">
<h3><span class="section-number">2.13.4. </span>Handling Split Extents Across Leaf Blocks<a class="headerlink" href="#handling-split-extents-across-leaf-blocks" title="Link to this heading">¶</a></h3>
<p>There can be a special edge case where we have logically and physically
contiguous extents stored in separate leaf nodes of the on-disk extent tree.
This occurs because on-disk extent tree merges only happens within the leaf
blocks except for a case where we have 2-level tree which can get merged and
collapsed entirely into the inode.
If such a layout exists and, in the worst case, the extent status cache entries
are reclaimed due to memory pressure, <code class="docutils literal notranslate"><span class="pre">ext4_map_blocks()</span></code> may never return
a single contiguous extent for these split leaf extents.</p>
<p>To address this edge case, a new get block flag
<code class="docutils literal notranslate"><span class="pre">EXT4_GET_BLOCKS_QUERY_LEAF_BLOCKS</span> <span class="pre">flag</span></code> is added to enhance the
<code class="docutils literal notranslate"><span class="pre">ext4_map_query_blocks()</span></code> lookup behavior.</p>
<p>This new get block flag allows <code class="docutils literal notranslate"><span class="pre">ext4_map_blocks()</span></code> to first check if there is
an entry in the extent status cache for the full range.
If not present, it consults the on-disk extent tree using
<code class="docutils literal notranslate"><span class="pre">ext4_map_query_blocks()</span></code>.
If the located extent is at the end of a leaf node, it probes the next logical
block (lblk) to detect a contiguous extent in the adjacent leaf.</p>
<p>For now only one additional leaf block is queried to maintain efficiency, as
atomic writes are typically constrained to small sizes
(e.g. [blocksize, clustersize]).</p>
</section>
<section id="handling-journal-transactions">
<h3><span class="section-number">2.13.5. </span>Handling Journal transactions<a class="headerlink" href="#handling-journal-transactions" title="Link to this heading">¶</a></h3>
<p>To support multi-fsblock atomic writes, we ensure enough journal credits are
reserved during:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Block allocation time in <code class="docutils literal notranslate"><span class="pre">ext4_iomap_alloc()</span></code>. We first query if there
could be a mixed mapping for the underlying requested range. If yes, then we
reserve credits of up to <code class="docutils literal notranslate"><span class="pre">m_len</span></code>, assuming every alternate block can be
an unwritten extent followed by a hole.</p></li>
<li><p>During <code class="docutils literal notranslate"><span class="pre">-&gt;end_io()</span></code> call, we make sure a single transaction is started for
doing unwritten-to-written conversion. The loop for conversion is mainly
only required to handle a split extent across leaf blocks.</p></li>
</ol>
</div></blockquote>
</section>
</section>
<section id="how-to">
<h2><span class="section-number">2.14. </span>How to<a class="headerlink" href="#how-to" title="Link to this heading">¶</a></h2>
<section id="creating-filesystems-with-atomic-write-support">
<h3><span class="section-number">2.14.1. </span>Creating Filesystems with Atomic Write Support<a class="headerlink" href="#creating-filesystems-with-atomic-write-support" title="Link to this heading">¶</a></h3>
<p>First check the atomic write units supported by block device.
See <a class="reference internal" href="#atomic-write-bdev-support"><span class="std std-ref">Hardware Support</span></a> for more details.</p>
<p>For single-fsblock atomic writes with a larger block size
(on systems with block size &lt; page size):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an ext4 filesystem with a 16KB block size</span>
<span class="c1"># (requires page size &gt;= 16KB)</span>
mkfs.ext4<span class="w"> </span>-b<span class="w"> </span><span class="m">16384</span><span class="w"> </span>/dev/device
</pre></div>
</div>
<p>For multi-fsblock atomic writes with bigalloc:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an ext4 filesystem with bigalloc and 64KB cluster size</span>
mkfs.ext4<span class="w"> </span>-F<span class="w"> </span>-O<span class="w"> </span>bigalloc<span class="w"> </span>-b<span class="w"> </span><span class="m">4096</span><span class="w"> </span>-C<span class="w"> </span><span class="m">65536</span><span class="w"> </span>/dev/device
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">-b</span></code> specifies the block size, <code class="docutils literal notranslate"><span class="pre">-C</span></code> specifies the cluster size in bytes,
and <code class="docutils literal notranslate"><span class="pre">-O</span> <span class="pre">bigalloc</span></code> enables the bigalloc feature.</p>
</section>
<section id="application-interface">
<h3><span class="section-number">2.14.2. </span>Application Interface<a class="headerlink" href="#application-interface" title="Link to this heading">¶</a></h3>
<p>Applications can use the <code class="docutils literal notranslate"><span class="pre">pwritev2()</span></code> system call with the <code class="docutils literal notranslate"><span class="pre">RWF_ATOMIC</span></code> flag
to perform atomic writes:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pwritev2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">iov</span><span class="p">,</span><span class="w"> </span><span class="n">iovcnt</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">RWF_ATOMIC</span><span class="p">);</span>
</pre></div>
</div>
<p>The write must be aligned to the filesystem’s block size and not exceed the
filesystem’s maximum atomic write unit size.
See <code class="docutils literal notranslate"><span class="pre">generic_atomic_write_valid()</span></code> for more details.</p>
<p><code class="docutils literal notranslate"><span class="pre">statx()</span></code> system call with <code class="docutils literal notranslate"><span class="pre">STATX_WRITE_ATOMIC</span></code> flag can provides following
details:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stx_atomic_write_unit_min</span></code>: Minimum size of an atomic write request.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stx_atomic_write_unit_max</span></code>: Maximum size of an atomic write request.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stx_atomic_write_segments_max</span></code>: Upper limit for segments. The number of
separate memory buffers that can be gathered into a write operation
(e.g., the iovcnt parameter for IOV_ITER). Currently, this is always set to one.</p></li>
</ul>
</div></blockquote>
<p>The STATX_ATTR_WRITE_ATOMIC flag in <code class="docutils literal notranslate"><span class="pre">statx-&gt;attributes</span></code> is set if atomic
writes are supported.</p>
</section>
</section>
<section id="hardware-support">
<span id="atomic-write-bdev-support"></span><h2><span class="section-number">2.15. </span>Hardware Support<a class="headerlink" href="#hardware-support" title="Link to this heading">¶</a></h2>
<p>The underlying storage device must support atomic write operations.
Modern NVMe and SCSI devices often provide this capability.
The Linux kernel exposes this information through sysfs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/block/&lt;device&gt;/queue/atomic_write_unit_min</span></code> - Minimum atomic write size</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/block/&lt;device&gt;/queue/atomic_write_unit_max</span></code> - Maximum atomic write size</p></li>
</ul>
<p>Nonzero values for these attributes indicate that the device supports
atomic writes.</p>
</section>
<section id="see-also">
<h2><span class="section-number">2.16. </span>See Also<a class="headerlink" href="#see-also" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="bigalloc.html"><span class="doc">Bigalloc</span></a> - Documentation on the bigalloc feature</p></li>
<li><p><a class="reference internal" href="allocators.html"><span class="doc">Block and Inode Allocation Policy</span></a> - Documentation on block allocation in ext4</p></li>
<li><p>Support for atomic block writes in 6.13:
<a class="reference external" href="https://lwn.net/Articles/1009298/">https://lwn.net/Articles/1009298/</a></p></li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/filesystems/ext4/overview.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>