<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Atomic Block Writes &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/filesystems/ext4/atomic_writes.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="atomic-block-writes">
<span id="atomic-writes"></span><h1>Atomic Block Writes<a class="headerlink" href="#atomic-block-writes" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Atomic (untorn) block writes ensure that either the entire write is committed
to disk or none of it is. This prevents “torn writes” during power loss or
system crashes. The ext4 filesystem supports atomic writes (only with Direct
I/O) on regular files with extents, provided the underlying storage device
supports hardware atomic writes. This is supported in the following two ways:</p>
<ol class="arabic simple">
<li><p><strong>Single-fsblock Atomic Writes</strong>:
EXT4’s supports atomic write operations with a single filesystem block since
v6.13. In this the atomic write unit minimum and maximum sizes are both set
to filesystem blocksize.
e.g. doing atomic write of 16KB with 16KB filesystem blocksize on 64KB
pagesize system is possible.</p></li>
<li><p><strong>Multi-fsblock Atomic Writes with Bigalloc</strong>:
EXT4 now also supports atomic writes spanning multiple filesystem blocks
using a feature known as bigalloc. The atomic write unit’s minimum and
maximum sizes are determined by the filesystem block size and cluster size,
based on the underlying device’s supported atomic write unit limits.</p></li>
</ol>
</section>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Link to this heading">¶</a></h2>
<p>Basic requirements for atomic writes in ext4:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The extents feature must be enabled (default for ext4)</p></li>
<li><p>The underlying block device must support atomic writes</p></li>
<li><p>For single-fsblock atomic writes:</p>
<ol class="arabic simple">
<li><p>A filesystem with appropriate block size (up to the page size)</p></li>
</ol>
</li>
<li><p>For multi-fsblock atomic writes:</p>
<ol class="arabic simple">
<li><p>The bigalloc feature must be enabled</p></li>
<li><p>The cluster size must be appropriately configured</p></li>
</ol>
</li>
</ol>
</div></blockquote>
<p>NOTE: EXT4 does not support software or COW based atomic write, which means
atomic writes on ext4 are only supported if underlying storage device supports
it.</p>
</section>
<section id="multi-fsblock-implementation-details">
<h2>Multi-fsblock Implementation Details<a class="headerlink" href="#multi-fsblock-implementation-details" title="Link to this heading">¶</a></h2>
<p>The bigalloc feature changes ext4 to allocate in units of multiple filesystem
blocks, also known as clusters. With bigalloc each bit within block bitmap
represents cluster (power of 2 number of blocks) rather than individual
filesystem blocks.
EXT4 supports multi-fsblock atomic writes with bigalloc, subject to the
following constraints. The minimum atomic write size is the larger of the fs
block size and the minimum hardware atomic write unit; and the maximum atomic
write size is smaller of the bigalloc cluster size and the maximum hardware
atomic write unit.  Bigalloc ensures that all allocations are aligned to the
cluster size, which satisfies the LBA alignment requirements of the hardware
device if the start of the partition/logical volume is itself aligned correctly.</p>
<p>Here is the block allocation strategy in bigalloc for atomic writes:</p>
<blockquote>
<div><ul class="simple">
<li><p>For regions with fully mapped extents, no additional work is needed</p></li>
<li><p>For append writes, a new mapped extent is allocated</p></li>
<li><p>For regions that are entirely holes, unwritten extent is created</p></li>
<li><p>For large unwritten extents, the extent gets split into two unwritten
extents of appropriate requested size</p></li>
<li><p>For mixed mapping regions (combinations of holes, unwritten extents, or
mapped extents), ext4_map_blocks() is called in a loop with
EXT4_GET_BLOCKS_ZERO flag to convert the region into a single contiguous
mapped extent by writing zeroes to it and converting any unwritten extents to
written, if found within the range.</p></li>
</ul>
</div></blockquote>
<p>Note: Writing on a single contiguous underlying extent, whether mapped or
unwritten, is not inherently problematic. However, writing to a mixed mapping
region (i.e. one containing a combination of mapped and unwritten extents)
must be avoided when performing atomic writes.</p>
<p>The reason is that, atomic writes when issued via pwritev2() with the RWF_ATOMIC
flag, requires that either all data is written or none at all. In the event of
a system crash or unexpected power loss during the write operation, the affected
region (when later read) must reflect either the complete old data or the
complete new data, but never a mix of both.</p>
<p>To enforce this guarantee, we ensure that the write target is backed by
a single, contiguous extent before any data is written. This is critical because
ext4 defers the conversion of unwritten extents to written extents until the I/O
completion path (typically in -&gt;end_io()). If a write is allowed to proceed over
a mixed mapping region (with mapped and unwritten extents) and a failure occurs
mid-write, the system could observe partially updated regions after reboot, i.e.
new data over mapped areas, and stale (old) data over unwritten extents that
were never marked written. This violates the atomicity and/or torn write
prevention guarantee.</p>
<p>To prevent such torn writes, ext4 proactively allocates a single contiguous
extent for the entire requested region in <code class="docutils literal notranslate"><span class="pre">ext4_iomap_alloc</span></code> via
<code class="docutils literal notranslate"><span class="pre">ext4_map_blocks_atomic()</span></code>. EXT4 also force commits the current journalling
transaction in case if allocation is done over mixed mapping. This ensures any
pending metadata updates (like unwritten to written extents conversion) in this
range are in consistent state with the file data blocks, before performing the
actual write I/O. If the commit fails, the whole I/O must be aborted to prevent
from any possible torn writes.
Only after this step, the actual data write operation is performed by the iomap.</p>
</section>
<section id="handling-split-extents-across-leaf-blocks">
<h2>Handling Split Extents Across Leaf Blocks<a class="headerlink" href="#handling-split-extents-across-leaf-blocks" title="Link to this heading">¶</a></h2>
<p>There can be a special edge case where we have logically and physically
contiguous extents stored in separate leaf nodes of the on-disk extent tree.
This occurs because on-disk extent tree merges only happens within the leaf
blocks except for a case where we have 2-level tree which can get merged and
collapsed entirely into the inode.
If such a layout exists and, in the worst case, the extent status cache entries
are reclaimed due to memory pressure, <code class="docutils literal notranslate"><span class="pre">ext4_map_blocks()</span></code> may never return
a single contiguous extent for these split leaf extents.</p>
<p>To address this edge case, a new get block flag
<code class="docutils literal notranslate"><span class="pre">EXT4_GET_BLOCKS_QUERY_LEAF_BLOCKS</span> <span class="pre">flag</span></code> is added to enhance the
<code class="docutils literal notranslate"><span class="pre">ext4_map_query_blocks()</span></code> lookup behavior.</p>
<p>This new get block flag allows <code class="docutils literal notranslate"><span class="pre">ext4_map_blocks()</span></code> to first check if there is
an entry in the extent status cache for the full range.
If not present, it consults the on-disk extent tree using
<code class="docutils literal notranslate"><span class="pre">ext4_map_query_blocks()</span></code>.
If the located extent is at the end of a leaf node, it probes the next logical
block (lblk) to detect a contiguous extent in the adjacent leaf.</p>
<p>For now only one additional leaf block is queried to maintain efficiency, as
atomic writes are typically constrained to small sizes
(e.g. [blocksize, clustersize]).</p>
</section>
<section id="handling-journal-transactions">
<h2>Handling Journal transactions<a class="headerlink" href="#handling-journal-transactions" title="Link to this heading">¶</a></h2>
<p>To support multi-fsblock atomic writes, we ensure enough journal credits are
reserved during:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Block allocation time in <code class="docutils literal notranslate"><span class="pre">ext4_iomap_alloc()</span></code>. We first query if there
could be a mixed mapping for the underlying requested range. If yes, then we
reserve credits of up to <code class="docutils literal notranslate"><span class="pre">m_len</span></code>, assuming every alternate block can be
an unwritten extent followed by a hole.</p></li>
<li><p>During <code class="docutils literal notranslate"><span class="pre">-&gt;end_io()</span></code> call, we make sure a single transaction is started for
doing unwritten-to-written conversion. The loop for conversion is mainly
only required to handle a split extent across leaf blocks.</p></li>
</ol>
</div></blockquote>
</section>
</section>
<section id="how-to">
<h1>How to<a class="headerlink" href="#how-to" title="Link to this heading">¶</a></h1>
<section id="creating-filesystems-with-atomic-write-support">
<h2>Creating Filesystems with Atomic Write Support<a class="headerlink" href="#creating-filesystems-with-atomic-write-support" title="Link to this heading">¶</a></h2>
<p>First check the atomic write units supported by block device.
See <a class="reference internal" href="overview.html#atomic-write-bdev-support"><span class="std std-ref">Hardware Support</span></a> for more details.</p>
<p>For single-fsblock atomic writes with a larger block size
(on systems with block size &lt; page size):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an ext4 filesystem with a 16KB block size</span>
<span class="c1"># (requires page size &gt;= 16KB)</span>
mkfs.ext4<span class="w"> </span>-b<span class="w"> </span><span class="m">16384</span><span class="w"> </span>/dev/device
</pre></div>
</div>
<p>For multi-fsblock atomic writes with bigalloc:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an ext4 filesystem with bigalloc and 64KB cluster size</span>
mkfs.ext4<span class="w"> </span>-F<span class="w"> </span>-O<span class="w"> </span>bigalloc<span class="w"> </span>-b<span class="w"> </span><span class="m">4096</span><span class="w"> </span>-C<span class="w"> </span><span class="m">65536</span><span class="w"> </span>/dev/device
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">-b</span></code> specifies the block size, <code class="docutils literal notranslate"><span class="pre">-C</span></code> specifies the cluster size in bytes,
and <code class="docutils literal notranslate"><span class="pre">-O</span> <span class="pre">bigalloc</span></code> enables the bigalloc feature.</p>
</section>
<section id="application-interface">
<h2>Application Interface<a class="headerlink" href="#application-interface" title="Link to this heading">¶</a></h2>
<p>Applications can use the <code class="docutils literal notranslate"><span class="pre">pwritev2()</span></code> system call with the <code class="docutils literal notranslate"><span class="pre">RWF_ATOMIC</span></code> flag
to perform atomic writes:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pwritev2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">iov</span><span class="p">,</span><span class="w"> </span><span class="n">iovcnt</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">RWF_ATOMIC</span><span class="p">);</span>
</pre></div>
</div>
<p>The write must be aligned to the filesystem’s block size and not exceed the
filesystem’s maximum atomic write unit size.
See <code class="docutils literal notranslate"><span class="pre">generic_atomic_write_valid()</span></code> for more details.</p>
<p><code class="docutils literal notranslate"><span class="pre">statx()</span></code> system call with <code class="docutils literal notranslate"><span class="pre">STATX_WRITE_ATOMIC</span></code> flag can provides following
details:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stx_atomic_write_unit_min</span></code>: Minimum size of an atomic write request.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stx_atomic_write_unit_max</span></code>: Maximum size of an atomic write request.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stx_atomic_write_segments_max</span></code>: Upper limit for segments. The number of
separate memory buffers that can be gathered into a write operation
(e.g., the iovcnt parameter for IOV_ITER). Currently, this is always set to one.</p></li>
</ul>
</div></blockquote>
<p>The STATX_ATTR_WRITE_ATOMIC flag in <code class="docutils literal notranslate"><span class="pre">statx-&gt;attributes</span></code> is set if atomic
writes are supported.</p>
</section>
</section>
<section id="hardware-support">
<span id="atomic-write-bdev-support"></span><h1>Hardware Support<a class="headerlink" href="#hardware-support" title="Link to this heading">¶</a></h1>
<p>The underlying storage device must support atomic write operations.
Modern NVMe and SCSI devices often provide this capability.
The Linux kernel exposes this information through sysfs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/block/&lt;device&gt;/queue/atomic_write_unit_min</span></code> - Minimum atomic write size</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/block/&lt;device&gt;/queue/atomic_write_unit_max</span></code> - Maximum atomic write size</p></li>
</ul>
<p>Nonzero values for these attributes indicate that the device supports
atomic writes.</p>
</section>
<section id="see-also">
<h1>See Also<a class="headerlink" href="#see-also" title="Link to this heading">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="bigalloc.html"><span class="doc">Bigalloc</span></a> - Documentation on the bigalloc feature</p></li>
<li><p><a class="reference internal" href="allocators.html"><span class="doc">Block and Inode Allocation Policy</span></a> - Documentation on block allocation in ext4</p></li>
<li><p>Support for atomic block writes in 6.13:
<a class="reference external" href="https://lwn.net/Articles/1009298/">https://lwn.net/Articles/1009298/</a></p></li>
</ul>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/filesystems/ext4/atomic_writes.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>