<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Network Filesystem Services Library &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="v9fs: Plan 9 Resource Sharing for Linux" href="9p.html" />
    <link rel="prev" title="fs-verity: read-only file-based authenticity protection" href="fsverity.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvme/index.html">NVMe Subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/netfs_library.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="network-filesystem-services-library">
<h1>Network Filesystem Services Library<a class="headerlink" href="#network-filesystem-services-library" title="Link to this heading">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>The network filesystem services library, netfslib, is a set of functions
designed to aid a network filesystem in implementing VM/VFS API operations.  It
takes over the normal buffered read, readahead, write and writeback and also
handles unbuffered and direct I/O.</p>
<p>The library provides support for (re-)negotiation of I/O sizes and retrying
failed I/O as well as local caching and will, in the future, provide content
encryption.</p>
<p>It insulates the filesystem from VM interface changes as much as possible and
handles VM features such as large multipage folios.  The filesystem basically
just has to provide a way to perform read and write RPC calls.</p>
<p>The way I/O is organised inside netfslib consists of a number of objects:</p>
<blockquote>
<div><ul class="simple">
<li><p>A <em>request</em>.  A request is used to track the progress of the I/O overall and
to hold on to resources.  The collection of results is done at the request
level.  The I/O within a request is divided into a number of parallel
streams of subrequests.</p></li>
<li><p>A <em>stream</em>.  A non-overlapping series of subrequests.  The subrequests
within a stream do not have to be contiguous.</p></li>
<li><p>A <em>subrequest</em>.  This is the basic unit of I/O.  It represents a single RPC
call or a single cache I/O operation.  The library passes these to the
filesystem and the cache to perform.</p></li>
</ul>
</div></blockquote>
<section id="requests-and-streams">
<h3>Requests and Streams<a class="headerlink" href="#requests-and-streams" title="Link to this heading">¶</a></h3>
<p>When actually performing I/O (as opposed to just copying into the pagecache),
netfslib will create one or more requests to track the progress of the I/O and
to hold resources.</p>
<p>A read operation will have a single stream and the subrequests within that
stream may be of mixed origins, for instance mixing RPC subrequests and cache
subrequests.</p>
<p>On the other hand, a write operation may have multiple streams, where each
stream targets a different destination.  For instance, there may be one stream
writing to the local cache and one to the server.  Currently, only two streams
are allowed, but this could be increased if parallel writes to multiple servers
is desired.</p>
<p>The subrequests within a write stream do not need to match alignment or size
with the subrequests in another write stream and netfslib performs the tiling
of subrequests in each stream over the source buffer independently.  Further,
each stream may contain holes that don’t correspond to holes in the other
stream.</p>
<p>In addition, the subrequests do not need to correspond to the boundaries of the
folios or vectors in the source/destination buffer.  The library handles the
collection of results and the wrangling of folio flags and references.</p>
</section>
<section id="subrequests">
<h3>Subrequests<a class="headerlink" href="#subrequests" title="Link to this heading">¶</a></h3>
<p>Subrequests are at the heart of the interaction between netfslib and the
filesystem using it.  Each subrequest is expected to correspond to a single
read or write RPC or cache operation.  The library will stitch together the
results from a set of subrequests to provide a higher level operation.</p>
<p>Netfslib has two interactions with the filesystem or the cache when setting up
a subrequest.  First, there’s an optional preparatory step that allows the
filesystem to negotiate the limits on the subrequest, both in terms of maximum
number of bytes and maximum number of vectors (e.g. for RDMA).  This may
involve negotiating with the server (e.g. cifs needing to acquire credits).</p>
<p>And, secondly, there’s the issuing step in which the subrequest is handed off
to the filesystem to perform.</p>
<p>Note that these two steps are done slightly differently between read and write:</p>
<blockquote>
<div><ul class="simple">
<li><p>For reads, the VM/VFS tells us how much is being requested up front, so the
library can preset maximum values that the cache and then the filesystem can
then reduce.  The cache also gets consulted first on whether it wants to do
a read before the filesystem is consulted.</p></li>
<li><p>For writeback, it is unknown how much there will be to write until the
pagecache is walked, so no limit is set by the library.</p></li>
</ul>
</div></blockquote>
<p>Once a subrequest is completed, the filesystem or cache informs the library of
the completion and then collection is invoked.  Depending on whether the
request is synchronous or asynchronous, the collection of results will be done
in either the application thread or in a work queue.</p>
</section>
<section id="result-collection-and-retry">
<h3>Result Collection and Retry<a class="headerlink" href="#result-collection-and-retry" title="Link to this heading">¶</a></h3>
<p>As subrequests complete, the results are collected and collated by the library
and folio unlocking is performed progressively (if appropriate).  Once the
request is complete, async completion will be invoked (again, if appropriate).
It is possible for the filesystem to provide interim progress reports to the
library to cause folio unlocking to happen earlier if possible.</p>
<p>If any subrequests fail, netfslib can retry them.  It will wait until all
subrequests are completed, offer the filesystem the opportunity to fiddle with
the resources/state held by the request and poke at the subrequests before
re-preparing and re-issuing the subrequests.</p>
<p>This allows the tiling of contiguous sets of failed subrequest within a stream
to be changed, adding more subrequests or ditching excess as necessary (for
instance, if the network sizes change or the server decides it wants smaller
chunks).</p>
<p>Further, if one or more contiguous cache-read subrequests fail, the library
will pass them to the filesystem to perform instead, renegotiating and retiling
them as necessary to fit with the filesystem’s parameters rather than those of
the cache.</p>
</section>
<section id="local-caching">
<h3>Local Caching<a class="headerlink" href="#local-caching" title="Link to this heading">¶</a></h3>
<p>One of the services netfslib provides, via <code class="docutils literal notranslate"><span class="pre">fscache</span></code>, is the option to cache
on local disk a copy of the data obtained from/written to a network filesystem.
The library will manage the storing, retrieval and some invalidation of data
automatically on behalf of the filesystem if a cookie is attached to the
<code class="docutils literal notranslate"><span class="pre">netfs_inode</span></code>.</p>
<p>Note that local caching used to use the PG_private_2 (aliased as PG_fscache) to
keep track of a page that was being written to the cache, but this is now
deprecated as PG_private_2 will be removed.</p>
<p>Instead, folios that are read from the server for which there was no data in
the cache will be marked as dirty and will have <code class="docutils literal notranslate"><span class="pre">folio-&gt;private</span></code> set to a
special value (<code class="docutils literal notranslate"><span class="pre">NETFS_FOLIO_COPY_TO_CACHE</span></code>) and left to writeback to write.
If the folio is modified before that happened, the special value will be
cleared and the write will become normally dirty.</p>
<p>When writeback occurs, folios that are so marked will only be written to the
cache and not to the server.  Writeback handles mixed cache-only writes and
server-and-cache writes by using two streams, sending one to the cache and one
to the server.  The server stream will have gaps in it corresponding to those
folios.</p>
</section>
<section id="content-encryption-fscrypt">
<h3>Content Encryption (fscrypt)<a class="headerlink" href="#content-encryption-fscrypt" title="Link to this heading">¶</a></h3>
<p>Though it does not do so yet, at some point netfslib will acquire the ability
to do client-side content encryption on behalf of the network filesystem (Ceph,
for example).  fscrypt can be used for this if appropriate (it may not be -
cifs, for example).</p>
<p>The data will be stored encrypted in the local cache using the same manner of
encryption as the data written to the server and the library will impose bounce
buffering and RMW cycles as necessary.</p>
</section>
</section>
<section id="per-inode-context">
<h2>Per-Inode Context<a class="headerlink" href="#per-inode-context" title="Link to this heading">¶</a></h2>
<p>The network filesystem helper library needs a place to store a bit of state for
its use on each netfs inode it is helping to manage.  To this end, a context
structure is defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_inode {
        struct inode inode;
        const struct netfs_request_ops *ops;
        struct fscache_cookie * cache;
        loff_t remote_i_size;
        unsigned long flags;
        ...
};
</pre></div>
</div>
<p>A network filesystem that wants to use netfslib must place one of these in its
inode wrapper struct instead of the VFS <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span></code>.  This can be done in
a way similar to the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_inode {
        struct netfs_inode netfs; /* Netfslib context and vfs inode */
        ...
};
</pre></div>
</div>
<p>This allows netfslib to find its state by using <code class="docutils literal notranslate"><span class="pre">container_of()</span></code> from the
inode pointer, thereby allowing the netfslib helper functions to be pointed to
directly by the VFS/VM operation tables.</p>
<p>The structure contains the following fields that are of interest to the
filesystem:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">inode</span></code></p>
<p>The VFS inode structure.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ops</span></code></p>
<p>The set of operations provided by the network filesystem to netfslib.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cache</span></code></p>
<p>Local caching cookie, or NULL if no caching is enabled.  This field does not
exist if fscache is disabled.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">remote_i_size</span></code></p>
<p>The size of the file on the server.  This differs from inode-&gt;i_size if
local modifications have been made but not yet written back.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code></p>
<p>A set of flags, some of which the filesystem might be interested in:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_ICTX_MODIFIED_ATTR</span></code></p>
<p>Set if netfslib modifies mtime/ctime.  The filesystem is free to ignore
this or clear it.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_ICTX_UNBUFFERED</span></code></p>
<p>Do unbuffered I/O upon the file.  Like direct I/O but without the
alignment limitations.  RMW will be performed if necessary.  The pagecache
will not be used unless mmap() is also used.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_ICTX_WRITETHROUGH</span></code></p>
<p>Do writethrough caching upon the file.  I/O will be set up and dispatched
as buffered writes are made to the page cache.  mmap() does the normal
writeback thing.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_ICTX_SINGLE_NO_UPLOAD</span></code></p>
<p>Set if the file has a monolithic content that must be read entirely in a
single go and must not be written back to the server, though it can be
cached (e.g. AFS directories).</p>
</li>
</ul>
</li>
</ul>
</div></blockquote>
<section id="inode-context-helper-functions">
<h3>Inode Context Helper Functions<a class="headerlink" href="#inode-context-helper-functions" title="Link to this heading">¶</a></h3>
<p>To help deal with the per-inode context, a number helper functions are
provided.  Firstly, a function to perform basic initialisation on a context and
set the operations table pointer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void netfs_inode_init(struct netfs_inode *ctx,
                      const struct netfs_request_ops *ops);
</pre></div>
</div>
<p>then a function to cast from the VFS inode structure to the netfs context:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_inode *netfs_inode(struct inode *inode);
</pre></div>
</div>
<p>and finally, a function to get the cache cookie pointer from the context
attached to an inode (or NULL if fscache is disabled):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_cookie *netfs_i_cookie(struct netfs_inode *ctx);
</pre></div>
</div>
</section>
<section id="inode-locking">
<h3>Inode Locking<a class="headerlink" href="#inode-locking" title="Link to this heading">¶</a></h3>
<p>A number of functions are provided to manage the locking of i_rwsem for I/O and
to effectively extend it to provide more separate classes of exclusion:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int netfs_start_io_read(struct inode *inode);
void netfs_end_io_read(struct inode *inode);
int netfs_start_io_write(struct inode *inode);
void netfs_end_io_write(struct inode *inode);
int netfs_start_io_direct(struct inode *inode);
void netfs_end_io_direct(struct inode *inode);
</pre></div>
</div>
<p>The exclusion breaks down into four separate classes:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Buffered reads and writes.</p>
<p>Buffered reads can run concurrently each other and with buffered writes,
but buffered writes cannot run concurrently with each other.</p>
</li>
<li><p>Direct reads and writes.</p>
<p>Direct (and unbuffered) reads and writes can run concurrently since they do
not share local buffering (i.e. the pagecache) and, in a network
filesystem, are expected to have exclusion managed on the server (though
this may not be the case for, say, Ceph).</p>
</li>
<li><p>Other major inode modifying operations (e.g. truncate, fallocate).</p>
<p>These should just access i_rwsem directly.</p>
</li>
<li><p>mmap().</p>
<p>mmap’d accesses might operate concurrently with any of the other classes.
They might form the buffer for an intra-file loopback DIO read/write.  They
might be permitted on unbuffered files.</p>
</li>
</ol>
</div></blockquote>
</section>
<section id="inode-writeback">
<h3>Inode Writeback<a class="headerlink" href="#inode-writeback" title="Link to this heading">¶</a></h3>
<p>Netfslib will pin resources on an inode for future writeback (such as pinning
use of an fscache cookie) when an inode is dirtied.  However, this pinning
needs careful management.  To manage the pinning, the following sequence
occurs:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>An inode state flag <code class="docutils literal notranslate"><span class="pre">I_PINNING_NETFS_WB</span></code> is set by netfslib when the
pinning begins (when a folio is dirtied, for example) if the cache is
active to stop the cache structures from being discarded and the cache
space from being culled.  This also prevents re-getting of cache resources
if the flag is already set.</p></li>
<li><p>This flag then cleared inside the inode lock during inode writeback in the
VM - and the fact that it was set is transferred to <code class="docutils literal notranslate"><span class="pre">-&gt;unpinned_netfs_wb</span></code>
in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">-&gt;unpinned_netfs_wb</span></code> is now set, the write_inode procedure is forced.</p></li>
<li><p>The filesystem’s <code class="docutils literal notranslate"><span class="pre">-&gt;write_inode()</span></code> function is invoked to do the cleanup.</p></li>
<li><p>The filesystem invokes netfs to do its cleanup.</p></li>
</ol>
</div></blockquote>
<p>To do the cleanup, netfslib provides a function to do the resource unpinning:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int netfs_unpin_writeback(struct inode *inode, struct writeback_control *wbc);
</pre></div>
</div>
<p>If the filesystem doesn’t need to do anything else, this may be set as a its
<code class="docutils literal notranslate"><span class="pre">.write_inode</span></code> method.</p>
<p>Further, if an inode is deleted, the filesystem’s write_inode method may not
get called, so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void netfs_clear_inode_writeback(struct inode *inode, const void *aux);
</pre></div>
</div>
<p>must be called from <code class="docutils literal notranslate"><span class="pre">-&gt;evict_inode()</span></code> <em>before</em> <code class="docutils literal notranslate"><span class="pre">clear_inode()</span></code> is called.</p>
</section>
</section>
<section id="high-level-vfs-api">
<h2>High-Level VFS API<a class="headerlink" href="#high-level-vfs-api" title="Link to this heading">¶</a></h2>
<p>Netfslib provides a number of sets of API calls for the filesystem to delegate
VFS operations to.  Netfslib, in turn, will call out to the filesystem and the
cache to negotiate I/O sizes, issue RPCs and provide places for it to intervene
at various times.</p>
<section id="unlocked-read-write-iter">
<h3>Unlocked Read/Write Iter<a class="headerlink" href="#unlocked-read-write-iter" title="Link to this heading">¶</a></h3>
<p>The first API set is for the delegation of operations to netfslib when the
filesystem is called through the standard VFS read/write_iter methods:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssize_t netfs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter);
ssize_t netfs_file_write_iter(struct kiocb *iocb, struct iov_iter *from);
ssize_t netfs_buffered_read_iter(struct kiocb *iocb, struct iov_iter *iter);
ssize_t netfs_unbuffered_read_iter(struct kiocb *iocb, struct iov_iter *iter);
ssize_t netfs_unbuffered_write_iter(struct kiocb *iocb, struct iov_iter *from);
</pre></div>
</div>
<p>They can be assigned directly to <code class="docutils literal notranslate"><span class="pre">.read_iter</span></code> and <code class="docutils literal notranslate"><span class="pre">.write_iter</span></code>.  They
perform the inode locking themselves and the first two will switch between
buffered I/O and DIO as appropriate.</p>
</section>
<section id="pre-locked-read-write-iter">
<h3>Pre-Locked Read/Write Iter<a class="headerlink" href="#pre-locked-read-write-iter" title="Link to this heading">¶</a></h3>
<p>The second API set is for the delegation of operations to netfslib when the
filesystem is called through the standard VFS methods, but needs to do some
other stuff before or after calling netfslib whilst still inside locked section
(e.g. Ceph negotiating caps).  The unbuffered read function is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssize_t netfs_unbuffered_read_iter_locked(struct kiocb *iocb, struct iov_iter *iter);
</pre></div>
</div>
<p>This must not be assigned directly to <code class="docutils literal notranslate"><span class="pre">.read_iter</span></code> and the filesystem is
responsible for performing the inode locking before calling it.  In the case of
buffered read, the filesystem should use <code class="docutils literal notranslate"><span class="pre">filemap_read()</span></code>.</p>
<p>There are three functions for writes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssize_t netfs_buffered_write_iter_locked(struct kiocb *iocb, struct iov_iter *from,
                                         struct netfs_group *netfs_group);
ssize_t netfs_perform_write(struct kiocb *iocb, struct iov_iter *iter,
                            struct netfs_group *netfs_group);
ssize_t netfs_unbuffered_write_iter_locked(struct kiocb *iocb, struct iov_iter *iter,
                                           struct netfs_group *netfs_group);
</pre></div>
</div>
<p>These must not be assigned directly to <code class="docutils literal notranslate"><span class="pre">.write_iter</span></code> and the filesystem is
responsible for performing the inode locking before calling them.</p>
<p>The first two functions are for buffered writes; the first just adds some
standard write checks and jumps to the second, but if the filesystem wants to
do the checks itself, it can use the second directly.  The third function is
for unbuffered or DIO writes.</p>
<p>On all three write functions, there is a writeback group pointer (which should
be NULL if the filesystem doesn’t use this).  Writeback groups are set on
folios when they’re modified.  If a folio to-be-modified is already marked with
a different group, it is flushed first.  The writeback API allows writing back
of a specific group.</p>
</section>
<section id="memory-mapped-i-o-api">
<h3>Memory-Mapped I/O API<a class="headerlink" href="#memory-mapped-i-o-api" title="Link to this heading">¶</a></h3>
<p>An API for support of mmap()’d I/O is provided:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vm_fault_t netfs_page_mkwrite(struct vm_fault *vmf, struct netfs_group *netfs_group);
</pre></div>
</div>
<p>This allows the filesystem to delegate <code class="docutils literal notranslate"><span class="pre">.page_mkwrite</span></code> to netfslib.  The
filesystem should not take the inode lock before calling it, but, as with the
locked write functions above, this does take a writeback group pointer.  If the
page to be made writable is in a different group, it will be flushed first.</p>
</section>
<section id="monolithic-files-api">
<h3>Monolithic Files API<a class="headerlink" href="#monolithic-files-api" title="Link to this heading">¶</a></h3>
<p>There is also a special API set for files for which the content must be read in
a single RPC (and not written back) and is maintained as a monolithic blob
(e.g. an AFS directory), though it can be stored and updated in the local cache:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssize_t netfs_read_single(struct inode *inode, struct file *file, struct iov_iter *iter);
void netfs_single_mark_inode_dirty(struct inode *inode);
int netfs_writeback_single(struct address_space *mapping,
                           struct writeback_control *wbc,
                           struct iov_iter *iter);
</pre></div>
</div>
<p>The first function reads from a file into the given buffer, reading from the
cache in preference if the data is cached there; the second function allows the
inode to be marked dirty, causing a later writeback; and the third function can
be called from the writeback code to write the data to the cache, if there is
one.</p>
<p>The inode should be marked <code class="docutils literal notranslate"><span class="pre">NETFS_ICTX_SINGLE_NO_UPLOAD</span></code> if this API is to be
used.  The writeback function requires the buffer to be of ITER_FOLIOQ type.</p>
</section>
</section>
<section id="high-level-vm-api">
<h2>High-Level VM API<a class="headerlink" href="#high-level-vm-api" title="Link to this heading">¶</a></h2>
<p>Netfslib also provides a number of sets of API calls for the filesystem to
delegate VM operations to.  Again, netfslib, in turn, will call out to the
filesystem and the cache to negotiate I/O sizes, issue RPCs and provide places
for it to intervene at various times:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void netfs_readahead(struct readahead_control *);
int netfs_read_folio(struct file *, struct folio *);
int netfs_writepages(struct address_space *mapping,
                     struct writeback_control *wbc);
bool netfs_dirty_folio(struct address_space *mapping, struct folio *folio);
void netfs_invalidate_folio(struct folio *folio, size_t offset, size_t length);
bool netfs_release_folio(struct folio *folio, gfp_t gfp);
</pre></div>
</div>
<p>These are <code class="docutils literal notranslate"><span class="pre">address_space_operations</span></code> methods and can be set directly in the
operations table.</p>
<section id="deprecated-pg-private-2-api">
<h3>Deprecated PG_private_2 API<a class="headerlink" href="#deprecated-pg-private-2-api" title="Link to this heading">¶</a></h3>
<p>There is also a deprecated function for filesystems that still use the
<code class="docutils literal notranslate"><span class="pre">-&gt;write_begin</span></code> method:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int netfs_write_begin(struct netfs_inode *inode, struct file *file,
                      struct address_space *mapping, loff_t pos, unsigned int len,
                      struct folio **_folio, void **_fsdata);
</pre></div>
</div>
<p>It uses the deprecated PG_private_2 flag and so should not be used.</p>
</section>
</section>
<section id="i-o-request-api">
<h2>I/O Request API<a class="headerlink" href="#i-o-request-api" title="Link to this heading">¶</a></h2>
<p>The I/O request API comprises a number of structures and a number of functions
that the filesystem may need to use.</p>
<section id="request-structure">
<h3>Request Structure<a class="headerlink" href="#request-structure" title="Link to this heading">¶</a></h3>
<p>The request structure manages the request as a whole, holding some resources
and state on behalf of the filesystem and tracking the collection of results:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_io_request {
        enum netfs_io_origin    origin;
        struct inode            *inode;
        struct address_space    *mapping;
        struct netfs_group      *group;
        struct netfs_io_stream  io_streams[];
        void                    *netfs_priv;
        void                    *netfs_priv2;
        unsigned long long      start;
        unsigned long long      len;
        unsigned long long      i_size;
        unsigned int            debug_id;
        unsigned long           flags;
        ...
};
</pre></div>
</div>
<p>Many of the fields are for internal use, but the fields shown here are of
interest to the filesystem:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">origin</span></code></p>
<p>The origin of the request (readahead, read_folio, DIO read, writeback, ...).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">inode</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mapping</span></code></p>
<p>The inode and the address space of the file being read from.  The mapping
may or may not point to inode-&gt;i_data.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">group</span></code></p>
<p>The writeback group this request is dealing with or NULL.  This holds a ref
on the group.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">io_streams</span></code></p>
<p>The parallel streams of subrequests available to the request.  Currently two
are available, but this may be made extensible in future.  <code class="docutils literal notranslate"><span class="pre">NR_IO_STREAMS</span></code>
indicates the size of the array.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">netfs_priv</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">netfs_priv2</span></code></p>
<p>The network filesystem’s private data.  The value for this can be passed in
to the helper functions or set during the request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
<p>The file position of the start of the read request and the length.  These
may be altered by the -&gt;expand_readahead() op.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">i_size</span></code></p>
<p>The size of the file at the start of the request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug_id</span></code></p>
<p>A number allocated to this operation that can be displayed in trace lines
for reference.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code></p>
<p>Flags for managing and controlling the operation of the request.  Some of
these may be of interest to the filesystem:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_RREQ_RETRYING</span></code></p>
<p>Netfslib sets this when generating retries.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_RREQ_PAUSE</span></code></p>
<p>The filesystem can set this to request to pause the library’s subrequest
issuing loop - but care needs to be taken as netfslib may also set it.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_RREQ_NONBLOCK</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_RREQ_BLOCKED</span></code></p>
<p>Netfslib sets the first to indicate that non-blocking mode was set by the
caller and the filesystem can set the second to indicate that it would
have had to block.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_RREQ_USE_PGPRIV2</span></code></p>
<p>The filesystem can set this if it wants to use PG_private_2 to track
whether a folio is being written to the cache.  This is deprecated as
PG_private_2 is going to go away.</p>
</li>
</ul>
</li>
</ul>
</div></blockquote>
<p>If the filesystem wants more private data than is afforded by this structure,
then it should wrap it and provide its own allocator.</p>
</section>
<section id="stream-structure">
<h3>Stream Structure<a class="headerlink" href="#stream-structure" title="Link to this heading">¶</a></h3>
<p>A request is comprised of one or more parallel streams and each stream may be
aimed at a different target.</p>
<p>For read requests, only stream 0 is used.  This can contain a mixture of
subrequests aimed at different sources.  For write requests, stream 0 is used
for the server and stream 1 is used for the cache.  For buffered writeback,
stream 0 is not enabled unless a normal dirty folio is encountered, at which
point -&gt;begin_writeback() will be invoked and the filesystem can mark the
stream available.</p>
<p>The stream struct looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_io_stream {
        unsigned char           stream_nr;
        bool                    avail;
        size_t                  sreq_max_len;
        unsigned int            sreq_max_segs;
        unsigned int            submit_extendable_to;
        ...
};
</pre></div>
</div>
<p>A number of members are available for access/use by the filesystem:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">stream_nr</span></code></p>
<p>The number of the stream within the request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">avail</span></code></p>
<p>True if the stream is available for use.  The filesystem should set this on
stream zero if in -&gt;begin_writeback().</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sreq_max_len</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sreq_max_segs</span></code></p>
<p>These are set by the filesystem or the cache in -&gt;prepare_read() or
-&gt;prepare_write() for each subrequest to indicate the maximum number of
bytes and, optionally, the maximum number of segments (if not 0) that that
subrequest can support.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">submit_extendable_to</span></code></p>
<p>The size that a subrequest can be rounded up to beyond the EOF, given the
available buffer.  This allows the cache to work out if it can do a DIO read
or write that straddles the EOF marker.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="subrequest-structure">
<h3>Subrequest Structure<a class="headerlink" href="#subrequest-structure" title="Link to this heading">¶</a></h3>
<p>Individual units of I/O are managed by the subrequest structure.  These
represent slices of the overall request and run independently:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_io_subrequest {
        struct netfs_io_request *rreq;
        struct iov_iter         io_iter;
        unsigned long long      start;
        size_t                  len;
        size_t                  transferred;
        unsigned long           flags;
        short                   error;
        unsigned short          debug_index;
        unsigned char           stream_nr;
        ...
};
</pre></div>
</div>
<p>Each subrequest is expected to access a single source, though the library will
handle falling back from one source type to another.  The members are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">rreq</span></code></p>
<p>A pointer to the read request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">io_iter</span></code></p>
<p>An I/O iterator representing a slice of the buffer to be read into or
written from.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
<p>The file position of the start of this slice of the read request and the
length.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">transferred</span></code></p>
<p>The amount of data transferred so far for this subrequest.  This should be
added to with the length of the transfer made by this issuance of the
subrequest.  If this is less than <code class="docutils literal notranslate"><span class="pre">len</span></code> then the subrequest may be
reissued to continue.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">flags</span></code></p>
<p>Flags for managing the subrequest.  There are a number of interest to the
filesystem or cache:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_MADE_PROGRESS</span></code></p>
<p>Set by the filesystem to indicates that at least one byte of data was read
or written.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_HIT_EOF</span></code></p>
<p>The filesystem should set this if a read hit the EOF on the file (in which
case <code class="docutils literal notranslate"><span class="pre">transferred</span></code> should stop at the EOF).  Netfslib may expand the
subrequest out to the size of the folio containing the EOF on the off
chance that a third party change happened or a DIO read may have asked for
more than is available.  The library will clear any excess pagecache.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_CLEAR_TAIL</span></code></p>
<p>The filesystem can set this to indicate that the remainder of the slice,
from transferred to len, should be cleared.  Do not set if HIT_EOF is set.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_NEED_RETRY</span></code></p>
<p>The filesystem can set this to tell netfslib to retry the subrequest.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_BOUNDARY</span></code></p>
<p>This can be set by the filesystem on a subrequest to indicate that it ends
at a boundary with the filesystem structure (e.g. at the end of a Ceph
object).  It tells netfslib not to retile subrequests across it.</p>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code></p>
<p>This is for the filesystem to store result of the subrequest.  It should be
set to 0 if successful and a negative error code otherwise.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug_index</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stream_nr</span></code></p>
<p>A number allocated to this slice that can be displayed in trace lines for
reference and the number of the request stream that it belongs to.</p>
</li>
</ul>
</div></blockquote>
<p>If necessary, the filesystem can get and put extra refs on the subrequest it is
given:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void netfs_get_subrequest(struct netfs_io_subrequest *subreq,
                          enum netfs_sreq_ref_trace what);
void netfs_put_subrequest(struct netfs_io_subrequest *subreq,
                          enum netfs_sreq_ref_trace what);
</pre></div>
</div>
<p>using netfs trace codes to indicate the reason.  Care must be taken, however,
as once control of the subrequest is returned to netfslib, the same subrequest
can be reissued/retried.</p>
</section>
<section id="filesystem-methods">
<h3>Filesystem Methods<a class="headerlink" href="#filesystem-methods" title="Link to this heading">¶</a></h3>
<p>The filesystem sets a table of operations in <code class="docutils literal notranslate"><span class="pre">netfs_inode</span></code> for netfslib to
use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_request_ops {
        mempool_t *request_pool;
        mempool_t *subrequest_pool;
        int (*init_request)(struct netfs_io_request *rreq, struct file *file);
        void (*free_request)(struct netfs_io_request *rreq);
        void (*free_subrequest)(struct netfs_io_subrequest *rreq);
        void (*expand_readahead)(struct netfs_io_request *rreq);
        int (*prepare_read)(struct netfs_io_subrequest *subreq);
        void (*issue_read)(struct netfs_io_subrequest *subreq);
        void (*done)(struct netfs_io_request *rreq);
        void (*update_i_size)(struct inode *inode, loff_t i_size);
        void (*post_modify)(struct inode *inode);
        void (*begin_writeback)(struct netfs_io_request *wreq);
        void (*prepare_write)(struct netfs_io_subrequest *subreq);
        void (*issue_write)(struct netfs_io_subrequest *subreq);
        void (*retry_request)(struct netfs_io_request *wreq,
                              struct netfs_io_stream *stream);
        void (*invalidate_cache)(struct netfs_io_request *wreq);
};
</pre></div>
</div>
<p>The table starts with a pair of optional pointers to memory pools from which
requests and subrequests can be allocated.  If these are not given, netfslib
has default pools that it will use instead.  If the filesystem wraps the netfs
structs in its own larger structs, then it will need to use its own pools.
Netfslib will allocate directly from the pools.</p>
<p>The methods defined in the table are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">init_request()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">free_request()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">free_subrequest()</span></code></p>
<p>[Optional] A filesystem may implement these to initialise or clean up any
resources that it attaches to the request or subrequest.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expand_readahead()</span></code></p>
<p>[Optional] This is called to allow the filesystem to expand the size of a
readahead request.  The filesystem gets to expand the request in both
directions, though it must retain the initial region as that may represent
an allocation already made.  If local caching is enabled, it gets to expand
the request first.</p>
<p>Expansion is communicated by changing -&gt;start and -&gt;len in the request
structure.  Note that if any change is made, -&gt;len must be increased by at
least as much as -&gt;start is reduced.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">prepare_read()</span></code></p>
<p>[Optional] This is called to allow the filesystem to limit the size of a
subrequest.  It may also limit the number of individual regions in iterator,
such as required by RDMA.  This information should be set on stream zero in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rreq-&gt;io_streams[0].sreq_max_len
rreq-&gt;io_streams[0].sreq_max_segs
</pre></div>
</div>
<p>The filesystem can use this, for example, to chop up a request that has to
be split across multiple servers or to put multiple reads in flight.</p>
<p>Zero should be returned on success and an error code otherwise.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">issue_read()</span></code></p>
<p>[Required] Netfslib calls this to dispatch a subrequest to the server for
reading.  In the subrequest, -&gt;start, -&gt;len and -&gt;transferred indicate what
data should be read from the server and -&gt;io_iter indicates the buffer to be
used.</p>
<p>There is no return value; the <code class="docutils literal notranslate"><span class="pre">netfs_read_subreq_terminated()</span></code> function
should be called to indicate that the subrequest completed either way.
-&gt;error, -&gt;transferred and -&gt;flags should be updated before completing.  The
termination can be done asynchronously.</p>
<p>Note: the filesystem must not deal with setting folios uptodate, unlocking
them or dropping their refs - the library deals with this as it may have to
stitch together the results of multiple subrequests that variously overlap
the set of folios.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">done()</span></code></p>
<p>[Optional] This is called after the folios in a read request have all been
unlocked (and marked uptodate if applicable).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">update_i_size()</span></code></p>
<p>[Optional] This is invoked by netfslib at various points during the write
paths to ask the filesystem to update its idea of the file size.  If not
given, netfslib will set i_size and i_blocks and update the local cache
cookie.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">post_modify()</span></code></p>
<p>[Optional] This is called after netfslib writes to the pagecache or when it
allows an mmap’d page to be marked as writable.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">begin_writeback()</span></code></p>
<p>[Optional] Netfslib calls this when processing a writeback request if it
finds a dirty page that isn’t simply marked NETFS_FOLIO_COPY_TO_CACHE,
indicating it must be written to the server.  This allows the filesystem to
only set up writeback resources when it knows it’s going to have to perform
a write.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">prepare_write()</span></code></p>
<p>[Optional] This is called to allow the filesystem to limit the size of a
subrequest.  It may also limit the number of individual regions in iterator,
such as required by RDMA.  This information should be set on stream to which
the subrequest belongs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rreq-&gt;io_streams[subreq-&gt;stream_nr].sreq_max_len
rreq-&gt;io_streams[subreq-&gt;stream_nr].sreq_max_segs
</pre></div>
</div>
<p>The filesystem can use this, for example, to chop up a request that has to
be split across multiple servers or to put multiple writes in flight.</p>
<p>This is not permitted to return an error.  Instead, in the event of failure,
<code class="docutils literal notranslate"><span class="pre">netfs_prepare_write_failed()</span></code> must be called.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">issue_write()</span></code></p>
<p>[Required] This is used to dispatch a subrequest to the server for writing.
In the subrequest, -&gt;start, -&gt;len and -&gt;transferred indicate what data
should be written to the server and -&gt;io_iter indicates the buffer to be
used.</p>
<p>There is no return value; the <code class="docutils literal notranslate"><span class="pre">netfs_write_subreq_terminated()</span></code> function
should be called to indicate that the subrequest completed either way.
-&gt;error, -&gt;transferred and -&gt;flags should be updated before completing.  The
termination can be done asynchronously.</p>
<p>Note: the filesystem must not deal with removing the dirty or writeback
marks on folios involved in the operation and should not take refs or pins
on them, but should leave retention to netfslib.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">retry_request()</span></code></p>
<p>[Optional] Netfslib calls this at the beginning of a retry cycle.  This
allows the filesystem to examine the state of the request, the subrequests
in the indicated stream and of its own data and make adjustments or
renegotiate resources.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">invalidate_cache()</span></code></p>
<p>[Optional] This is called by netfslib to invalidate data stored in the local
cache in the event that writing to the local cache fails, providing updated
coherency data that netfs can’t provide.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="terminating-a-subrequest">
<h3>Terminating a subrequest<a class="headerlink" href="#terminating-a-subrequest" title="Link to this heading">¶</a></h3>
<p>When a subrequest completes, there are a number of functions that the cache or
subrequest can call to inform netfslib of the status change.  One function is
provided to terminate a write subrequest at the preparation stage and acts
synchronously:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">netfs_prepare_write_failed(struct</span> <span class="pre">netfs_io_subrequest</span> <span class="pre">*subreq);</span></code></p>
<p>Indicate that the -&gt;prepare_write() call failed.  The <code class="docutils literal notranslate"><span class="pre">error</span></code> field should
have been updated.</p>
</li>
</ul>
</div></blockquote>
<p>Note that -&gt;prepare_read() can return an error as a read can simply be aborted.
Dealing with writeback failure is trickier.</p>
<p>The other functions are used for subrequests that got as far as being issued:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">netfs_read_subreq_terminated(struct</span> <span class="pre">netfs_io_subrequest</span> <span class="pre">*subreq);</span></code></p>
<p>Tell netfslib that a read subrequest has terminated.  The <code class="docutils literal notranslate"><span class="pre">error</span></code>,
<code class="docutils literal notranslate"><span class="pre">flags</span></code> and <code class="docutils literal notranslate"><span class="pre">transferred</span></code> fields should have been updated.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">netfs_write_subrequest_terminated(void</span> <span class="pre">*_op,</span> <span class="pre">ssize_t</span> <span class="pre">transferred_or_error);</span></code></p>
<p>Tell netfslib that a write subrequest has terminated.  Either the amount of
data processed or the negative error code can be passed in.  This is
can be used as a kiocb completion function.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">netfs_read_subreq_progress(struct</span> <span class="pre">netfs_io_subrequest</span> <span class="pre">*subreq);</span></code></p>
<p>This is provided to optionally update netfslib on the incremental progress
of a read, allowing some folios to be unlocked early and does not actually
terminate the subrequest.  The <code class="docutils literal notranslate"><span class="pre">transferred</span></code> field should have been
updated.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="local-cache-api">
<h3>Local Cache API<a class="headerlink" href="#local-cache-api" title="Link to this heading">¶</a></h3>
<p>Netfslib provides a separate API for a local cache to implement, though it
provides some somewhat similar routines to the filesystem request API.</p>
<p>Firstly, the netfs_io_request object contains a place for the cache to hang its
state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_cache_resources {
        const struct netfs_cache_ops    *ops;
        void                            *cache_priv;
        void                            *cache_priv2;
        unsigned int                    debug_id;
        unsigned int                    inval_counter;
};
</pre></div>
</div>
<p>This contains an operations table pointer and two private pointers plus the
debug ID of the fscache cookie for tracing purposes and an invalidation counter
that is cranked by calls to <code class="docutils literal notranslate"><span class="pre">fscache_invalidate()</span></code> allowing cache subrequests
to be invalidated after completion.</p>
<p>The cache operation table looks like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_cache_ops {
        void (*end_operation)(struct netfs_cache_resources *cres);
        void (*expand_readahead)(struct netfs_cache_resources *cres,
                                 loff_t *_start, size_t *_len, loff_t i_size);
        enum netfs_io_source (*prepare_read)(struct netfs_io_subrequest *subreq,
                                             loff_t i_size);
        int (*read)(struct netfs_cache_resources *cres,
                    loff_t start_pos,
                    struct iov_iter *iter,
                    bool seek_data,
                    netfs_io_terminated_t term_func,
                    void *term_func_priv);
        void (*prepare_write_subreq)(struct netfs_io_subrequest *subreq);
        void (*issue_write)(struct netfs_io_subrequest *subreq);
};
</pre></div>
</div>
<p>With a termination handler function pointer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef void (*netfs_io_terminated_t)(void *priv,
                                      ssize_t transferred_or_error,
                                      bool was_async);
</pre></div>
</div>
<p>The methods defined in the table are:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">end_operation()</span></code></p>
<p>[Required] Called to clean up the resources at the end of the read request.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expand_readahead()</span></code></p>
<p>[Optional] Called at the beginning of a readahead operation to allow the
cache to expand a request in either direction.  This allows the cache to
size the request appropriately for the cache granularity.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">prepare_read()</span></code></p>
<p>[Required] Called to configure the next slice of a request.  -&gt;start and
-&gt;len in the subrequest indicate where and how big the next slice can be;
the cache gets to reduce the length to match its granularity requirements.</p>
<p>The function is passed pointers to the start and length in its parameters,
plus the size of the file for reference, and adjusts the start and length
appropriately.  It should return one of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_FILL_WITH_ZEROES</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_DOWNLOAD_FROM_SERVER</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_READ_FROM_CACHE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NETFS_INVALID_READ</span></code></p></li>
</ul>
<p>to indicate whether the slice should just be cleared or whether it should be
downloaded from the server or read from the cache - or whether slicing
should be given up at the current point.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">read()</span></code></p>
<p>[Required] Called to read from the cache.  The start file offset is given
along with an iterator to read to, which gives the length also.  It can be
given a hint requesting that it seek forward from that start position for
data.</p>
<p>Also provided is a pointer to a termination handler function and private
data to pass to that function.  The termination function should be called
with the number of bytes transferred or an error code, plus a flag
indicating whether the termination is definitely happening in the caller’s
context.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">prepare_write_subreq()</span></code></p>
<p>[Required] This is called to allow the cache to limit the size of a
subrequest.  It may also limit the number of individual regions in iterator,
such as required by DIO/DMA.  This information should be set on stream to
which the subrequest belongs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rreq-&gt;io_streams[subreq-&gt;stream_nr].sreq_max_len
rreq-&gt;io_streams[subreq-&gt;stream_nr].sreq_max_segs
</pre></div>
</div>
<p>The filesystem can use this, for example, to chop up a request that has to
be split across multiple servers or to put multiple writes in flight.</p>
<p>This is not permitted to return an error.  In the event of failure,
<code class="docutils literal notranslate"><span class="pre">netfs_prepare_write_failed()</span></code> must be called.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">issue_write()</span></code></p>
<p>[Required] This is used to dispatch a subrequest to the cache for writing.
In the subrequest, -&gt;start, -&gt;len and -&gt;transferred indicate what data
should be written to the cache and -&gt;io_iter indicates the buffer to be
used.</p>
<p>There is no return value; the <code class="docutils literal notranslate"><span class="pre">netfs_write_subreq_terminated()</span></code> function
should be called to indicate that the subrequest completed either way.
-&gt;error, -&gt;transferred and -&gt;flags should be updated before completing.  The
termination can be done asynchronously.</p>
</li>
</ul>
</div></blockquote>
</section>
</section>
<section id="api-function-reference">
<h2>API Function Reference<a class="headerlink" href="#api-function-reference" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_start_private_2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_start_private_2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_start_private_2" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_start_private_2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Start an fscache write on a folio. [DEPRECATED]</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function before writing a folio to a local cache.  Starting a
second write before the first one finishes is not allowed.</p>
<p>Note that this should no longer be used.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_inode">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_inode" title="netfs_inode"><span class="n"><span class="pre">netfs_inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">netfs_inode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_inode" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_inode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the netfs inode context from the inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the netfs lib inode context from the network filesystem’s inode.  The
context struct is expected to directly follow on from the VFS inode struct.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_inode_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">netfs_inode_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_inode" title="netfs_inode"><span class="n"><span class="pre">netfs_inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">netfs_request_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">use_zero_point</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_inode_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialise a netfslib inode context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_inode</span> <span class="pre">*ctx</span></code></dt><dd><p>The netfs inode to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">netfs_request_ops</span> <span class="pre">*ops</span></code></dt><dd><p>The netfs’s operations list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_zero_point</span></code></dt><dd><p>True to use the zero_point read optimisation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise the netfs library context struct.  This is expected to follow on
directly from the VFS inode struct.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_resize_file">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">netfs_resize_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_inode" title="netfs_inode"><span class="n"><span class="pre">netfs_inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_i_size</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">changed_on_server</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_resize_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>Note that a file got resized</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_inode</span> <span class="pre">*ctx</span></code></dt><dd><p>The netfs inode being resized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">new_i_size</span></code></dt><dd><p>The new file size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">changed_on_server</span></code></dt><dd><p>The change was applied to the server</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the netfs lib that a file got resized so that it can adjust its state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_i_cookie">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fscache_cookie</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">netfs_i_cookie</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_inode" title="netfs_inode"><span class="n"><span class="pre">netfs_inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_i_cookie" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the cache cookie from the inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_inode</span> <span class="pre">*ctx</span></code></dt><dd><p>The netfs inode to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the caching cookie (if enabled) from the network filesystem’s inode.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_wait_for_outstanding_io">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">netfs_wait_for_outstanding_io</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_wait_for_outstanding_io" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_wait_for_outstanding_io" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait for outstanding I/O to complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The netfs inode to wait on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for outstanding I/O requests of any type to complete.  This is intended
to be called from inode eviction routines.  This makes sure that any
resources held by those requests are cleaned up before we let the inode get
cleaned up.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_readahead">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">netfs_readahead</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../core-api/mm-api.html#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ractl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_readahead" title="Link to this definition">¶</a><br /></dt>
<dd><p>Helper to manage a read request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>The description of the readahead request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fulfil a readahead request by drawing data from the cache if possible, or
the netfs if not.  Space beyond the EOF is zero-filled.  Multiple I/O
requests from different sources will get munged together.  If necessary, the
readahead window can be expanded in either direction to a more convenient
alighment for RPC efficiency or to make storage in the cache feasible.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_read_folio">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">netfs_read_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_read_folio" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_read_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_read_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Helper to manage a read_folio request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>The file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fulfil a read_folio request by drawing data from the cache if
possible, or the netfs if not.  Space beyond the EOF is zero-filled.
Multiple I/O requests from different sources will get munged together.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_write_begin">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">netfs_write_begin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_inode" title="netfs_inode"><span class="n"><span class="pre">netfs_inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.netfs_write_begin" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">pos</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">_folio</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">_fsdata</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_write_begin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Helper to prepare for writing [DEPRECATED]</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_inode</span> <span class="pre">*ctx</span></code></dt><dd><p>The netfs context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>The file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The mapping to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt><dd><p>File position at which the write will begin</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>The length of the write (may extend beyond the end of the folio chosen)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">**_folio</span></code></dt><dd><p>Where to put the resultant folio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**_fsdata</span></code></dt><dd><p>Place for the netfs to store a cookie</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pre-read data for a write-begin request by drawing data from the cache if
possible, or the netfs if not.  Space beyond the EOF is zero-filled.
Multiple I/O requests from different sources will get munged together.</p>
<p>The calling netfs must provide a table of operations, only one of which,
issue_read, is mandatory.</p>
<p>The check_write_begin() operation can be provided to check for and flush
conflicting writes once the folio is grabbed and locked.  It is passed a
pointer to the fsdata cookie that gets returned to the VM to be passed to
write_end.  It is permitted to sleep.  It should return 0 if the request
should go ahead or it may return an error.  It may also unlock and put the
folio, provided it sets <code class="docutils literal notranslate"><span class="pre">*foliop</span></code> to NULL, in which case a return of 0
will cause the folio to be re-got and the process to be retried.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
<p>Note that this should be considered deprecated and netfs_perform_write()
used instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_buffered_read_iter">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">netfs_buffered_read_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_buffered_read_iter" title="Link to this definition">¶</a><br /></dt>
<dd><p>Filesystem buffered I/O read routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>kernel I/O control block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>destination for the data read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the -&gt;read_iter() routine for all filesystems that can use the page
cache directly.</p>
<p>The IOCB_NOWAIT flag in iocb-&gt;ki_flags indicates that -EAGAIN shall be
returned when no data can be read without waiting for I/O requests to
complete; it doesn’t prevent readahead.</p>
<p>The IOCB_NOIO flag in iocb-&gt;ki_flags indicates that no new I/O requests
shall be made for the read or for readahead.  When no data can be read,
-EAGAIN shall be returned.  When readahead would be triggered, a partial,
possibly empty read shall be returned.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>number of bytes copied, even for partial reads</p></li>
<li><p>negative error code (or 0 if IOCB_NOIO) if nothing was read</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.netfs_file_read_iter">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">netfs_file_read_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_file_read_iter" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic filesystem read routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>kernel I/O control block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>destination for the data read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the -&gt;read_iter() routine for all filesystems that can use the page
cache directly.</p>
<p>The IOCB_NOWAIT flag in iocb-&gt;ki_flags indicates that -EAGAIN shall be
returned when no data can be read without waiting for I/O requests to
complete; it doesn’t prevent readahead.</p>
<p>The IOCB_NOIO flag in iocb-&gt;ki_flags indicates that no new I/O requests
shall be made for the read or for readahead.  When no data can be read,
-EAGAIN shall be returned.  When readahead would be triggered, a partial,
possibly empty read shall be returned.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>number of bytes copied, even for partial reads</p></li>
<li><p>negative error code (or 0 if IOCB_NOIO) if nothing was read</p></li>
</ul>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/netfs_library.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>