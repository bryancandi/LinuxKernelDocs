<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>IOMMUFD &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux Media Infrastructure userspace API" href="media/index.html" />
    <link rel="prev" title="Obsolete GPIO Userspace APIs" href="gpio/obsolete.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Userspace API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#system-calls">System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#security-related-interfaces">Security-related interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#devices-and-i-o">Devices and I/O</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="accelerators/ocxl.html">OpenCAPI (Open Coherent Accelerator Processor Interface)</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-buf-heaps.html">Allocating dma-buf using heaps</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-buf-alloc-exchange.html">Exchanging pixel buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="fwctl/index.html">Firmware Control (FWCTL) Userspace API</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio/index.html">GPIO</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">IOMMUFD</a></li>
<li class="toctree-l3"><a class="reference internal" href="media/index.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l3"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="vduse.html">VDUSE - “vDPA Device in Userspace”</a></li>
<li class="toctree-l3"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/userspace-api/iommufd.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="iommufd">
<h1>IOMMUFD<a class="headerlink" href="#iommufd" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Jason Gunthorpe</p>
</dd>
<dt class="field-even">Author<span class="colon">:</span></dt>
<dd class="field-even"><p>Kevin Tian</p>
</dd>
</dl>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>IOMMUFD is the user API to control the IOMMU subsystem as it relates to managing
IO page tables from userspace using file descriptors. It intends to be general
and consumable by any driver that wants to expose DMA to userspace. These
drivers are eventually expected to deprecate any internal IOMMU logic
they may already/historically implement (e.g. vfio_iommu_type1.c).</p>
<p>At minimum iommufd provides universal support of managing I/O address spaces and
I/O page tables for all IOMMUs, with room in the design to add non-generic
features to cater to specific hardware functionality.</p>
<p>In this context the capital letter (IOMMUFD) refers to the subsystem while the
small letter (iommufd) refers to the file descriptors created via /dev/iommu for
use by userspace.</p>
</section>
<section id="key-concepts">
<h2>Key Concepts<a class="headerlink" href="#key-concepts" title="Link to this heading">¶</a></h2>
<section id="user-visible-objects">
<h3>User Visible Objects<a class="headerlink" href="#user-visible-objects" title="Link to this heading">¶</a></h3>
<p>Following IOMMUFD objects are exposed to userspace:</p>
<ul>
<li><p>IOMMUFD_OBJ_IOAS, representing an I/O address space (IOAS), allowing map/unmap
of user space memory into ranges of I/O Virtual Address (IOVA).</p>
<p>The IOAS is a functional replacement for the VFIO container, and like the VFIO
container it copies an IOVA map to a list of iommu_domains held within it.</p>
</li>
<li><p>IOMMUFD_OBJ_DEVICE, representing a device that is bound to iommufd by an
external driver.</p></li>
<li><p>IOMMUFD_OBJ_HWPT_PAGING, representing an actual hardware I/O page table
(i.e. a single struct iommu_domain) managed by the iommu driver. “PAGING”
primarly indicates this type of HWPT should be linked to an IOAS. It also
indicates that it is backed by an iommu_domain with __IOMMU_DOMAIN_PAGING
feature flag. This can be either an UNMANAGED stage-1 domain for a device
running in the user space, or a nesting parent stage-2 domain for mappings
from guest-level physical addresses to host-level physical addresses.</p>
<p>The IOAS has a list of HWPT_PAGINGs that share the same IOVA mapping and
it will synchronize its mapping with each member HWPT_PAGING.</p>
</li>
<li><p>IOMMUFD_OBJ_HWPT_NESTED, representing an actual hardware I/O page table
(i.e. a single struct iommu_domain) managed by user space (e.g. guest OS).
“NESTED” indicates that this type of HWPT should be linked to an HWPT_PAGING.
It also indicates that it is backed by an iommu_domain that has a type of
IOMMU_DOMAIN_NESTED. This must be a stage-1 domain for a device running in
the user space (e.g. in a guest VM enabling the IOMMU nested translation
feature.) As such, it must be created with a given nesting parent stage-2
domain to associate to. This nested stage-1 page table managed by the user
space usually has mappings from guest-level I/O virtual addresses to guest-
level physical addresses.</p></li>
<li><p>IOMMUFD_FAULT, representing a software queue for an HWPT reporting IO page
faults using the IOMMU HW’s PRI (Page Request Interface). This queue object
provides user space an FD to poll the page fault events and also to respond
to those events. A FAULT object must be created first to get a fault_id that
could be then used to allocate a fault-enabled HWPT via the IOMMU_HWPT_ALLOC
command by setting the IOMMU_HWPT_FAULT_ID_VALID bit in its flags field.</p></li>
<li><p>IOMMUFD_OBJ_VIOMMU, representing a slice of the physical IOMMU instance,
passed to or shared with a VM. It may be some HW-accelerated virtualization
features and some SW resources used by the VM. For examples:</p>
<ul class="simple">
<li><p>Security namespace for guest owned ID, e.g. guest-controlled cache tags</p></li>
<li><p>Non-device-affiliated event reporting, e.g. invalidation queue errors</p></li>
<li><p>Access to a sharable nesting parent pagetable across physical IOMMUs</p></li>
<li><p>Virtualization of various platforms IDs, e.g. RIDs and others</p></li>
<li><p>Delivery of paravirtualized invalidation</p></li>
<li><p>Direct assigned invalidation queues</p></li>
<li><p>Direct assigned interrupts</p></li>
</ul>
<p>Such a vIOMMU object generally has the access to a nesting parent pagetable
to support some HW-accelerated virtualization features. So, a vIOMMU object
must be created given a nesting parent HWPT_PAGING object, and then it would
encapsulate that HWPT_PAGING object. Therefore, a vIOMMU object can be used
to allocate an HWPT_NESTED object in place of the encapsulated HWPT_PAGING.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The name “vIOMMU” isn’t necessarily identical to a virtualized IOMMU in a
VM. A VM can have one giant virtualized IOMMU running on a machine having
multiple physical IOMMUs, in which case the VMM will dispatch the requests
or configurations from this single virtualized IOMMU instance to multiple
vIOMMU objects created for individual slices of different physical IOMMUs.
In other words, a vIOMMU object is always a representation of one physical
IOMMU, not necessarily of a virtualized IOMMU. For VMMs that want the full
virtualization features from physical IOMMUs, it is suggested to build the
same number of virtualized IOMMUs as the number of physical IOMMUs, so the
passed-through devices would be connected to their own virtualized IOMMUs
backed by corresponding vIOMMU objects, in which case a guest OS would do
the “dispatch” naturally instead of VMM trappings.</p>
</div>
</li>
<li><p>IOMMUFD_OBJ_VDEVICE, representing a virtual device for an IOMMUFD_OBJ_DEVICE
against an IOMMUFD_OBJ_VIOMMU. This virtual device holds the device’s virtual
information or attributes (related to the vIOMMU) in a VM. An immediate vDATA
example can be the virtual ID of the device on a vIOMMU, which is a unique ID
that VMM assigns to the device for a translation channel/port of the vIOMMU,
e.g. vSID of ARM SMMUv3, vDeviceID of AMD IOMMU, and vRID of Intel VT-d to a
Context Table. Potential use cases of some advanced security information can
be forwarded via this object too, such as security level or realm information
in a Confidential Compute Architecture. A VMM should create a vDEVICE object
to forward all the device information in a VM, when it connects a device to a
vIOMMU, which is a separate ioctl call from attaching the same device to an
HWPT_PAGING that the vIOMMU holds.</p></li>
<li><p>IOMMUFD_OBJ_VEVENTQ, representing a software queue for a vIOMMU to report its
events such as translation faults occurred to a nested stage-1 (excluding I/O
page faults that should go through IOMMUFD_OBJ_FAULT) and HW-specific events.
This queue object provides user space an FD to poll/read the vIOMMU events. A
vIOMMU object must be created first to get its viommu_id, which could be then
used to allocate a vEVENTQ. Each vIOMMU can support multiple types of vEVENTS,
but is confined to one vEVENTQ per vEVENTQ type.</p></li>
</ul>
<p>All user-visible objects are destroyed via the IOMMU_DESTROY uAPI.</p>
<p>The diagrams below show relationships between user-visible objects and kernel
datastructures (external to iommufd), with numbers referred to operations
creating the objects and links:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> _______________________________________________________________________
|                      iommufd (HWPT_PAGING only)                       |
|                                                                       |
|        [1]                  [3]                                [2]    |
|  ________________      _____________                        ________  |
| |                |    |             |                      |        | |
| |      IOAS      |&lt;---| HWPT_PAGING |&lt;---------------------| DEVICE | |
| |________________|    |_____________|                      |________| |
|         |                    |                                  |     |
|_________|____________________|__________________________________|_____|
          |                    |                                  |
          |              ______v_____                          ___v__
          | PFN storage |  (paging)  |                        |struct|
          |------------&gt;|iommu_domain|&lt;-----------------------|device|
                        |____________|                        |______|

 _______________________________________________________________________
|                      iommufd (with HWPT_NESTED)                       |
|                                                                       |
|        [1]                  [3]                [4]             [2]    |
|  ________________      _____________      _____________     ________  |
| |                |    |             |    |             |   |        | |
| |      IOAS      |&lt;---| HWPT_PAGING |&lt;---| HWPT_NESTED |&lt;--| DEVICE | |
| |________________|    |_____________|    |_____________|   |________| |
|         |                    |                  |               |     |
|_________|____________________|__________________|_______________|_____|
          |                    |                  |               |
          |              ______v_____       ______v_____       ___v__
          | PFN storage |  (paging)  |     |  (nested)  |     |struct|
          |------------&gt;|iommu_domain|&lt;----|iommu_domain|&lt;----|device|
                        |____________|     |____________|     |______|

 _______________________________________________________________________
|                      iommufd (with vIOMMU/vDEVICE)                    |
|                                                                       |
|                             [5]                [6]                    |
|                        _____________      _____________               |
|                       |             |    |             |              |
|      |----------------|    vIOMMU   |&lt;---|   vDEVICE   |&lt;----|        |
|      |                |             |    |_____________|     |        |
|      |                |             |                        |        |
|      |      [1]       |             |          [4]           | [2]    |
|      |     ______     |             |     _____________     _|______  |
|      |    |      |    |     [3]     |    |             |   |        | |
|      |    | IOAS |&lt;---|(HWPT_PAGING)|&lt;---| HWPT_NESTED |&lt;--| DEVICE | |
|      |    |______|    |_____________|    |_____________|   |________| |
|      |        |              |                  |               |     |
|______|________|______________|__________________|_______________|_____|
       |        |              |                  |               |
 ______v_____   |        ______v_____       ______v_____       ___v__
|   struct   |  |  PFN  |  (paging)  |     |  (nested)  |     |struct|
|iommu_device|  |------&gt;|iommu_domain|&lt;----|iommu_domain|&lt;----|device|
|____________|   storage|____________|     |____________|     |______|
</pre></div>
</div>
<ol class="arabic">
<li><p>IOMMUFD_OBJ_IOAS is created via the IOMMU_IOAS_ALLOC uAPI. An iommufd can
hold multiple IOAS objects. IOAS is the most generic object and does not
expose interfaces that are specific to single IOMMU drivers. All operations
on the IOAS must operate equally on each of the iommu_domains inside of it.</p></li>
<li><p>IOMMUFD_OBJ_DEVICE is created when an external driver calls the IOMMUFD kAPI
to bind a device to an iommufd. The driver is expected to implement a set of
ioctls to allow userspace to initiate the binding operation. Successful
completion of this operation establishes the desired DMA ownership over the
device. The driver must also set the driver_managed_dma flag and must not
touch the device until this operation succeeds.</p></li>
<li><p>IOMMUFD_OBJ_HWPT_PAGING can be created in two ways:</p>
<ul class="simple">
<li><p>IOMMUFD_OBJ_HWPT_PAGING is automatically created when an external driver
calls the IOMMUFD kAPI to attach a bound device to an IOAS. Similarly the
external driver uAPI allows userspace to initiate the attaching operation.
If a compatible member HWPT_PAGING object exists in the IOAS’s HWPT_PAGING
list, then it will be reused. Otherwise a new HWPT_PAGING that represents
an iommu_domain to userspace will be created, and then added to the list.
Successful completion of this operation sets up the linkages among IOAS,
device and iommu_domain. Once this completes the device could do DMA.</p></li>
<li><p>IOMMUFD_OBJ_HWPT_PAGING can be manually created via the IOMMU_HWPT_ALLOC
uAPI, provided an ioas_id via &#64;pt_id to associate the new HWPT_PAGING to
the corresponding IOAS object. The benefit of this manual allocation is to
allow allocation flags (defined in <a class="reference internal" href="#c.iommufd_hwpt_alloc_flags" title="iommufd_hwpt_alloc_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_hwpt_alloc_flags</span></code></a>), e.g. it
allocates a nesting parent HWPT_PAGING if the IOMMU_HWPT_ALLOC_NEST_PARENT
flag is set.</p></li>
</ul>
</li>
<li><p>IOMMUFD_OBJ_HWPT_NESTED can be only manually created via the IOMMU_HWPT_ALLOC
uAPI, provided an hwpt_id or a viommu_id of a vIOMMU object encapsulating a
nesting parent HWPT_PAGING via &#64;pt_id to associate the new HWPT_NESTED object
to the corresponding HWPT_PAGING object. The associating HWPT_PAGING object
must be a nesting parent manually allocated via the same uAPI previously with
an IOMMU_HWPT_ALLOC_NEST_PARENT flag, otherwise the allocation will fail. The
allocation will be further validated by the IOMMU driver to ensure that the
nesting parent domain and the nested domain being allocated are compatible.
Successful completion of this operation sets up linkages among IOAS, device,
and iommu_domains. Once this completes the device could do DMA via a 2-stage
translation, a.k.a nested translation. Note that multiple HWPT_NESTED objects
can be allocated by (and then associated to) the same nesting parent.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Either a manual IOMMUFD_OBJ_HWPT_PAGING or an IOMMUFD_OBJ_HWPT_NESTED is
created via the same IOMMU_HWPT_ALLOC uAPI. The difference is at the type
of the object passed in via the &#64;pt_id field of struct iommufd_hwpt_alloc.</p>
</div>
</li>
<li><p>IOMMUFD_OBJ_VIOMMU can be only manually created via the IOMMU_VIOMMU_ALLOC
uAPI, provided a dev_id (for the device’s physical IOMMU to back the vIOMMU)
and an hwpt_id (to associate the vIOMMU to a nesting parent HWPT_PAGING). The
iommufd core will link the vIOMMU object to the struct iommu_device that the
<a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> is behind. And an IOMMU driver can implement a viommu_alloc op
to allocate its own vIOMMU data structure embedding the core-level structure
iommufd_viommu and some driver-specific data. If necessary, the driver can
also configure its HW virtualization feature for that vIOMMU (and thus for
the VM). Successful completion of this operation sets up the linkages between
the vIOMMU object and the HWPT_PAGING, then this vIOMMU object can be used
as a nesting parent object to allocate an HWPT_NESTED object described above.</p></li>
<li><p>IOMMUFD_OBJ_VDEVICE can be only manually created via the IOMMU_VDEVICE_ALLOC
uAPI, provided a viommu_id for an iommufd_viommu object and a dev_id for an
iommufd_device object. The vDEVICE object will be the binding between these
two parent objects. Another &#64;virt_id will be also set via the uAPI providing
the iommufd core an index to store the vDEVICE object to a vDEVICE array per
vIOMMU. If necessary, the IOMMU driver may choose to implement a vdevce_alloc
op to init its HW for virtualization feature related to a vDEVICE. Successful
completion of this operation sets up the linkages between vIOMMU and device.</p></li>
</ol>
<p>A device can only bind to an iommufd due to DMA ownership claim and attach to at
most one IOAS object (no support of PASID yet).</p>
</section>
<section id="kernel-datastructure">
<h3>Kernel Datastructure<a class="headerlink" href="#kernel-datastructure" title="Link to this heading">¶</a></h3>
<p>User visible objects are backed by following datastructures:</p>
<ul class="simple">
<li><p>iommufd_ioas for IOMMUFD_OBJ_IOAS.</p></li>
<li><p>iommufd_device for IOMMUFD_OBJ_DEVICE.</p></li>
<li><p>iommufd_hwpt_paging for IOMMUFD_OBJ_HWPT_PAGING.</p></li>
<li><p>iommufd_hwpt_nested for IOMMUFD_OBJ_HWPT_NESTED.</p></li>
<li><p>iommufd_fault for IOMMUFD_OBJ_FAULT.</p></li>
<li><p>iommufd_viommu for IOMMUFD_OBJ_VIOMMU.</p></li>
<li><p>iommufd_vdevice for IOMMUFD_OBJ_VDEVICE.</p></li>
<li><p>iommufd_veventq for IOMMUFD_OBJ_VEVENTQ.</p></li>
</ul>
<p>Several terminologies when looking at these datastructures:</p>
<ul class="simple">
<li><p>Automatic domain - refers to an iommu domain created automatically when
attaching a device to an IOAS object. This is compatible to the semantics of
VFIO type1.</p></li>
<li><p>Manual domain - refers to an iommu domain designated by the user as the
target pagetable to be attached to by a device. Though currently there are
no uAPIs to directly create such domain, the datastructure and algorithms
are ready for handling that use case.</p></li>
<li><p>In-kernel user - refers to something like a VFIO mdev that is using the
IOMMUFD access interface to access the IOAS. This starts by creating an
iommufd_access object that is similar to the domain binding a physical device
would do. The access object will then allow converting IOVA ranges into struct
page * lists, or doing direct read/write to an IOVA.</p></li>
</ul>
<p>iommufd_ioas serves as the metadata datastructure to manage how IOVA ranges are
mapped to memory pages, composed of:</p>
<ul class="simple">
<li><p>struct io_pagetable holding the IOVA map</p></li>
<li><p>struct iopt_area’s representing populated portions of IOVA</p></li>
<li><p>struct iopt_pages representing the storage of PFNs</p></li>
<li><p>struct iommu_domain representing the IO page table in the IOMMU</p></li>
<li><p>struct iopt_pages_access representing in-kernel users of PFNs</p></li>
<li><p><a class="reference internal" href="../core-api/xarray.html#c.xarray" title="xarray"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xarray</span></code></a> pinned_pfns holding a list of pages pinned by in-kernel users</p></li>
</ul>
<p>Each iopt_pages represents a logical linear array of full PFNs. The PFNs are
ultimately derived from userspace VAs via an mm_struct. Once they have been
pinned the PFNs are stored in IOPTEs of an iommu_domain or inside the pinned_pfns
xarray if they have been pinned through an iommufd_access.</p>
<p>PFN have to be copied between all combinations of storage locations, depending
on what domains are present and what kinds of in-kernel “software access” users
exist. The mechanism ensures that a page is pinned only once.</p>
<p>An io_pagetable is composed of iopt_areas pointing at iopt_pages, along with a
list of iommu_domains that mirror the IOVA to PFN map.</p>
<p>Multiple io_pagetable-s, through their iopt_area-s, can share a single
iopt_pages which avoids multi-pinning and double accounting of page
consumption.</p>
<p>iommufd_ioas is shareable between subsystems, e.g. VFIO and VDPA, as long as
devices managed by different subsystems are bound to a same iommufd.</p>
</section>
</section>
<section id="iommufd-user-api">
<h2>IOMMUFD User API<a class="headerlink" href="#iommufd-user-api" title="Link to this heading">¶</a></h2>
<p id="general-ioctl-format"><strong>General ioctl format</strong></p>
<p>The ioctl interface follows a general format to allow for extensibility. Each
ioctl is passed in a structure pointer as the argument providing the size of
the structure in the first u32. The kernel checks that any structure space
beyond what it understands is 0. This allows userspace to use the backward
compatible portion while consistently using the newer, larger, structures.</p>
<p>ioctls use a standard meaning for common errnos:</p>
<blockquote>
<div><ul class="simple">
<li><p>ENOTTY: The IOCTL number itself is not supported at all</p></li>
<li><p>E2BIG: The IOCTL number is supported, but the provided structure has
non-zero in a part the kernel does not understand.</p></li>
<li><p>EOPNOTSUPP: The IOCTL number is supported, and the structure is
understood, however a known field has a value the kernel does not
understand or support.</p></li>
<li><p>EINVAL: Everything about the IOCTL was understood, but a field is not
correct.</p></li>
<li><p>ENOENT: An ID or IOVA provided does not exist.</p></li>
<li><p>ENOMEM: Out of memory.</p></li>
<li><p>EOVERFLOW: Mathematics overflowed.</p></li>
</ul>
</div></blockquote>
<p>As well as additional errnos, within specific ioctls.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_destroy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_destroy</span></span></span><a class="headerlink" href="#c.iommu_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_DESTROY)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_destroy {
    __u32 size;
    __u32 id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_destroy" title="iommu_destroy"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_destroy</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>iommufd object ID to destroy. Can be any destroyable object type.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Destroy any object held within iommufd.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_ioas_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_ioas_alloc</span></span></span><a class="headerlink" href="#c.iommu_ioas_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_IOAS_ALLOC)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_ioas_alloc {
    __u32 size;
    __u32 flags;
    __u32 out_ioas_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_ioas_alloc" title="iommu_ioas_alloc"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_ioas_alloc</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_ioas_id</span></code></dt><dd><p>Output IOAS ID for the allocated object</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Allocate an IO Address Space (IOAS) which holds an IO Virtual Address (IOVA)
to memory mapping.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_iova_range">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_iova_range</span></span></span><a class="headerlink" href="#c.iommu_iova_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_IOVA_RANGE)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_iova_range {
    __aligned_u64 start;
    __aligned_u64 last;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>First IOVA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code></dt><dd><p>Inclusive last IOVA</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>An interval in IOVA space.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_ioas_iova_ranges">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_ioas_iova_ranges</span></span></span><a class="headerlink" href="#c.iommu_ioas_iova_ranges" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_IOAS_IOVA_RANGES)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_ioas_iova_ranges {
    __u32 size;
    __u32 ioas_id;
    __u32 num_iovas;
    __u32 __reserved;
    __aligned_u64 allowed_iovas;
    __aligned_u64 out_iova_alignment;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_ioas_iova_ranges" title="iommu_ioas_iova_ranges"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_ioas_iova_ranges</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioas_id</span></code></dt><dd><p>IOAS ID to read ranges from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_iovas</span></code></dt><dd><p>Input/Output total number of ranges in the IOAS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allowed_iovas</span></code></dt><dd><p>Pointer to the output array of <a class="reference internal" href="#c.iommu_iova_range" title="iommu_iova_range"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_iova_range</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_iova_alignment</span></code></dt><dd><p>Minimum alignment required for mapping IOVA</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Query an IOAS for ranges of allowed IOVAs. Mapping IOVA outside these ranges
is not allowed. num_iovas will be set to the total number of iovas and
the allowed_iovas[] will be filled in as space permits.</p>
<p>The allowed ranges are dependent on the HW path the DMA operation takes, and
can change during the lifetime of the IOAS. A fresh empty IOAS will have a
full range, and each attached device will narrow the ranges based on that
device’s HW restrictions. Detaching a device can widen the ranges. Userspace
should query ranges after every attach/detach to know what IOVAs are valid
for mapping.</p>
<p>On input num_iovas is the length of the allowed_iovas array. On output it is
the total number of iovas filled in. The ioctl will return -EMSGSIZE and set
num_iovas to the required value if num_iovas is too small. In this case the
caller should allocate a larger output array and re-issue the ioctl.</p>
<p>out_iova_alignment returns the minimum IOVA alignment that can be given
to IOMMU_IOAS_MAP/COPY. IOVA’s must satisfy:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>starting_iova % out_iova_alignment == 0
(starting_iova + length) % out_iova_alignment == 0
</pre></div>
</div>
<p>out_iova_alignment can be 1 indicating any IOVA is allowed. It cannot
be higher than the system PAGE_SIZE.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_ioas_allow_iovas">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_ioas_allow_iovas</span></span></span><a class="headerlink" href="#c.iommu_ioas_allow_iovas" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_IOAS_ALLOW_IOVAS)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_ioas_allow_iovas {
    __u32 size;
    __u32 ioas_id;
    __u32 num_iovas;
    __u32 __reserved;
    __aligned_u64 allowed_iovas;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_ioas_allow_iovas" title="iommu_ioas_allow_iovas"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_ioas_allow_iovas</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioas_id</span></code></dt><dd><p>IOAS ID to allow IOVAs from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_iovas</span></code></dt><dd><p>Input/Output total number of ranges in the IOAS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allowed_iovas</span></code></dt><dd><p>Pointer to array of <a class="reference internal" href="#c.iommu_iova_range" title="iommu_iova_range"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_iova_range</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Ensure a range of IOVAs are always available for allocation. If this call
succeeds then IOMMU_IOAS_IOVA_RANGES will never return a list of IOVA ranges
that are narrower than the ranges provided here. This call will fail if
IOMMU_IOAS_IOVA_RANGES is currently narrower than the given ranges.</p>
<p>When an IOAS is first created the IOVA_RANGES will be maximally sized, and as
devices are attached the IOVA will narrow based on the device restrictions.
When an allowed range is specified any narrowing will be refused, ie device
attachment can fail if the device requires limiting within the allowed range.</p>
<p>Automatic IOVA allocation is also impacted by this call. MAP will only
allocate within the allowed IOVAs if they are present.</p>
<p>This call replaces the entire allowed list with the given list.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommufd_ioas_map_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_ioas_map_flags</span></span></span><a class="headerlink" href="#c.iommufd_ioas_map_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flags for map and copy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_IOAS_MAP_FIXED_IOVA</span></code></dt><dd><p>If clear the kernel will compute an appropriate
IOVA to place the mapping at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_IOAS_MAP_WRITEABLE</span></code></dt><dd><p>DMA is allowed to write to this mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_IOAS_MAP_READABLE</span></code></dt><dd><p>DMA is allowed to read from this mapping</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_ioas_map">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_ioas_map</span></span></span><a class="headerlink" href="#c.iommu_ioas_map" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_IOAS_MAP)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_ioas_map {
    __u32 size;
    __u32 flags;
    __u32 ioas_id;
    __u32 __reserved;
    __aligned_u64 user_va;
    __aligned_u64 length;
    __aligned_u64 iova;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_ioas_map" title="iommu_ioas_map"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_ioas_map</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommufd_ioas_map_flags" title="iommufd_ioas_map_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_ioas_map_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioas_id</span></code></dt><dd><p>IOAS ID to change the mapping of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user_va</span></code></dt><dd><p>Userspace pointer to start mapping from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Number of bytes to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iova</span></code></dt><dd><p>IOVA the mapping was placed at. If IOMMU_IOAS_MAP_FIXED_IOVA is set
then this must be provided as input.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Set an IOVA mapping from a user pointer. If FIXED_IOVA is specified then the
mapping will be established at iova, otherwise a suitable location based on
the reserved and allowed lists will be automatically selected and returned in
iova.</p>
<p>If IOMMU_IOAS_MAP_FIXED_IOVA is specified then the iova range must currently
be unused, existing IOVA cannot be replaced.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_ioas_map_file">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_ioas_map_file</span></span></span><a class="headerlink" href="#c.iommu_ioas_map_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_IOAS_MAP_FILE)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_ioas_map_file {
    __u32 size;
    __u32 flags;
    __u32 ioas_id;
    __s32 fd;
    __aligned_u64 start;
    __aligned_u64 length;
    __aligned_u64 iova;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_ioas_map_file" title="iommu_ioas_map_file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_ioas_map_file</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>same as for iommu_ioas_map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioas_id</span></code></dt><dd><p>same as for iommu_ioas_map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fd</span></code></dt><dd><p>the memfd to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>byte offset from start of file to map from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>same as for iommu_ioas_map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iova</span></code></dt><dd><p>same as for iommu_ioas_map</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Set an IOVA mapping from a memfd file.  All other arguments and semantics
match those of IOMMU_IOAS_MAP.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_ioas_copy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_ioas_copy</span></span></span><a class="headerlink" href="#c.iommu_ioas_copy" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_IOAS_COPY)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_ioas_copy {
    __u32 size;
    __u32 flags;
    __u32 dst_ioas_id;
    __u32 src_ioas_id;
    __aligned_u64 length;
    __aligned_u64 dst_iova;
    __aligned_u64 src_iova;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_ioas_copy" title="iommu_ioas_copy"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_ioas_copy</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommufd_ioas_map_flags" title="iommufd_ioas_map_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_ioas_map_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst_ioas_id</span></code></dt><dd><p>IOAS ID to change the mapping of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_ioas_id</span></code></dt><dd><p>IOAS ID to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Number of bytes to copy and map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst_iova</span></code></dt><dd><p>IOVA the mapping was placed at. If IOMMU_IOAS_MAP_FIXED_IOVA is
set then this must be provided as input.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_iova</span></code></dt><dd><p>IOVA to start the copy</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Copy an already existing mapping from src_ioas_id and establish it in
dst_ioas_id. The src iova/length must exactly match a range used with
IOMMU_IOAS_MAP.</p>
<p>This may be used to efficiently clone a subset of an IOAS to another, or as a
kind of ‘cache’ to speed up mapping. Copy has an efficiency advantage over
establishing equivalent new mappings, as internal resources are shared, and
the kernel will pin the user memory only once.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_ioas_unmap">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_ioas_unmap</span></span></span><a class="headerlink" href="#c.iommu_ioas_unmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_IOAS_UNMAP)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_ioas_unmap {
    __u32 size;
    __u32 ioas_id;
    __aligned_u64 iova;
    __aligned_u64 length;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_ioas_unmap" title="iommu_ioas_unmap"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_ioas_unmap</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioas_id</span></code></dt><dd><p>IOAS ID to change the mapping of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iova</span></code></dt><dd><p>IOVA to start the unmapping at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Number of bytes to unmap, and return back the bytes unmapped</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Unmap an IOVA range. The iova/length must be a superset of a previously
mapped range used with IOMMU_IOAS_MAP or IOMMU_IOAS_COPY. Splitting or
truncating ranges is not allowed. The values 0 to U64_MAX will unmap
everything.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommufd_option">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_option</span></span></span><a class="headerlink" href="#c.iommufd_option" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_OPTION_RLIMIT_MODE) and ioctl(IOMMU_OPTION_HUGE_PAGES)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_OPTION_RLIMIT_MODE</span></code></dt><dd><p>Change how RLIMIT_MEMLOCK accounting works. The caller must have privilege
to invoke this. Value 0 (default) is user based accounting, 1 uses process
based accounting. Global option, object_id must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_OPTION_HUGE_PAGES</span></code></dt><dd><p>Value 1 (default) allows contiguous pages to be combined when generating
iommu mappings. Value 0 disables combining, everything is mapped to
PAGE_SIZE. This can be useful for benchmarking.  This is a per-IOAS
option, the object_id must be the IOAS ID.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommufd_option_ops">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_option_ops</span></span></span><a class="headerlink" href="#c.iommufd_option_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_OPTION_OP_SET) and ioctl(IOMMU_OPTION_OP_GET)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_OPTION_OP_SET</span></code></dt><dd><p>Set the option’s value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_OPTION_OP_GET</span></code></dt><dd><p>Get the option’s value</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_option">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_option</span></span></span><a class="headerlink" href="#c.iommu_option" title="Link to this definition">¶</a><br /></dt>
<dd><p>iommu option multiplexer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_option {
    __u32 size;
    __u32 option_id;
    __u16 op;
    __u16 __reserved;
    __u32 object_id;
    __aligned_u64 val64;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_option" title="iommu_option"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_option</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">option_id</span></code></dt><dd><p>One of <a class="reference internal" href="#c.iommufd_option" title="iommufd_option"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_option</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p>One of <a class="reference internal" href="#c.iommufd_option_ops" title="iommufd_option_ops"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_option_ops</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">object_id</span></code></dt><dd><p>ID of the object if required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val64</span></code></dt><dd><p>Option value to set or value returned on get</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Change a simple option value. This multiplexor allows controlling options
on objects. IOMMU_OPTION_OP_SET will load an option and IOMMU_OPTION_OP_GET
will return the current value.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommufd_vfio_ioas_op">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_vfio_ioas_op</span></span></span><a class="headerlink" href="#c.iommufd_vfio_ioas_op" title="Link to this definition">¶</a><br /></dt>
<dd><p>IOMMU_VFIO_IOAS_* ioctls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VFIO_IOAS_GET</span></code></dt><dd><p>Get the current compatibility IOAS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VFIO_IOAS_SET</span></code></dt><dd><p>Change the current compatibility IOAS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VFIO_IOAS_CLEAR</span></code></dt><dd><p>Disable VFIO compatibility</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_vfio_ioas">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_vfio_ioas</span></span></span><a class="headerlink" href="#c.iommu_vfio_ioas" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_VFIO_IOAS)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_vfio_ioas {
    __u32 size;
    __u32 ioas_id;
    __u16 op;
    __u16 __reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_vfio_ioas" title="iommu_vfio_ioas"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_vfio_ioas</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioas_id</span></code></dt><dd><p>For IOMMU_VFIO_IOAS_SET the input IOAS ID to set
For IOMMU_VFIO_IOAS_GET will output the IOAS ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p>One of <a class="reference internal" href="#c.iommufd_vfio_ioas_op" title="iommufd_vfio_ioas_op"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_vfio_ioas_op</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The VFIO compatibility support uses a single ioas because VFIO APIs do not
support the ID field. Set or Get the IOAS that VFIO compatibility will use.
When VFIO_GROUP_SET_CONTAINER is used on an iommufd it will get the
compatibility ioas, either by taking what is already set, or auto creating
one. From then on VFIO will continue to use that ioas and is not effected by
this ioctl. SET or CLEAR does not destroy any auto-created IOAS.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommufd_hwpt_alloc_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_hwpt_alloc_flags</span></span></span><a class="headerlink" href="#c.iommufd_hwpt_alloc_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flags for HWPT allocation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_ALLOC_NEST_PARENT</span></code></dt><dd><p>If set, allocate a HWPT that can serve as
the parent HWPT in a nesting configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_ALLOC_DIRTY_TRACKING</span></code></dt><dd><p>Dirty tracking support for device IOMMU is
enforced on device attachment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_FAULT_ID_VALID</span></code></dt><dd><p>The fault_id field of hwpt allocation data is
valid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_ALLOC_PASID</span></code></dt><dd><p>Requests a domain that can be used with PASID. The
domain can be attached to any PASID on the device.
Any domain attached to the non-PASID part of the
device must also be flagged, otherwise attaching a
PASID will blocked.
For the user that wants to attach PASID, ioas is
not recommended for both the non-PASID part
and PASID part of the device.
If IOMMU does not support PASID it will return
error (-EOPNOTSUPP).</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_hwpt_vtd_s1_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_vtd_s1_flags</span></span></span><a class="headerlink" href="#c.iommu_hwpt_vtd_s1_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Intel VT-d stage-1 page table entry attributes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VTD_S1_SRE</span></code></dt><dd><p>Supervisor request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VTD_S1_EAFE</span></code></dt><dd><p>Extended access enable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VTD_S1_WPE</span></code></dt><dd><p>Write protect enable</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_vtd_s1">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_vtd_s1</span></span></span><a class="headerlink" href="#c.iommu_hwpt_vtd_s1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Intel VT-d stage-1 page table info (IOMMU_HWPT_DATA_VTD_S1)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_vtd_s1 {
    __aligned_u64 flags;
    __aligned_u64 pgtbl_addr;
    __u32 addr_width;
    __u32 __reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommu_hwpt_vtd_s1_flags" title="iommu_hwpt_vtd_s1_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_hwpt_vtd_s1_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgtbl_addr</span></code></dt><dd><p>The base address of the stage-1 page table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_width</span></code></dt><dd><p>The address width of the stage-1 page table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_arm_smmuv3">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_arm_smmuv3</span></span></span><a class="headerlink" href="#c.iommu_hwpt_arm_smmuv3" title="Link to this definition">¶</a><br /></dt>
<dd><p>ARM SMMUv3 nested STE (IOMMU_HWPT_DATA_ARM_SMMUV3)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_arm_smmuv3 {
    __aligned_le64 ste[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ste</span></code></dt><dd><p>The first two double words of the user space Stream Table Entry for
the translation. Must be little-endian.
Allowed fields: (Refer to “5.2 Stream Table Entry” in SMMUv3 HW Spec)
- word-0: V, Cfg, S1Fmt, S1ContextPtr, S1CDMax
- word-1: EATS, S1DSS, S1CIR, S1COR, S1CSH, S1STALLD</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>-EIO will be returned if <strong>ste</strong> is not legal or contains any non-allowed field.
Cfg can be used to select a S1, Bypass or Abort configuration. A Bypass
nested domain will translate the same as the nesting parent. The S1 will
install a Context Descriptor Table pointing at userspace memory translated
by the nesting parent.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_hwpt_data_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_data_type</span></span></span><a class="headerlink" href="#c.iommu_hwpt_data_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>IOMMU HWPT Data Type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_DATA_NONE</span></code></dt><dd><p>no data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_DATA_VTD_S1</span></code></dt><dd><p>Intel VT-d stage-1 page table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_DATA_ARM_SMMUV3</span></code></dt><dd><p>ARM SMMUv3 Context Descriptor Table</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_alloc</span></span></span><a class="headerlink" href="#c.iommu_hwpt_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_HWPT_ALLOC)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_alloc {
    __u32 size;
    __u32 flags;
    __u32 dev_id;
    __u32 pt_id;
    __u32 out_hwpt_id;
    __u32 __reserved;
    __u32 data_type;
    __u32 data_len;
    __aligned_u64 data_uptr;
    __u32 fault_id;
    __u32 __reserved2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_hwpt_alloc" title="iommu_hwpt_alloc"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_hwpt_alloc</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommufd_hwpt_alloc_flags" title="iommufd_hwpt_alloc_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_hwpt_alloc_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>The device to allocate this HWPT for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_id</span></code></dt><dd><p>The IOAS or HWPT or vIOMMU to connect this HWPT to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_hwpt_id</span></code></dt><dd><p>The ID of the new HWPT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_type</span></code></dt><dd><p>One of <a class="reference internal" href="#c.iommu_hwpt_data_type" title="iommu_hwpt_data_type"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_hwpt_data_type</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_len</span></code></dt><dd><p>Length of the type specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_uptr</span></code></dt><dd><p>User pointer to the type specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fault_id</span></code></dt><dd><p>The ID of IOMMUFD_FAULT object. Valid only if flags field of
IOMMU_HWPT_FAULT_ID_VALID is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved2</span></code></dt><dd><p>Padding to 64-bit alignment. Must be 0.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Explicitly allocate a hardware page table object. This is the same object
type that is returned by <a class="reference internal" href="#c.iommufd_device_attach" title="iommufd_device_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_device_attach()</span></code></a> and represents the
underlying iommu driver’s iommu_domain kernel object.</p>
<p>A kernel-managed HWPT will be created with the mappings from the given
IOAS via the <strong>pt_id</strong>. The <strong>data_type</strong> for this allocation must be set to
IOMMU_HWPT_DATA_NONE. The HWPT can be allocated as a parent HWPT for a
nesting configuration by passing IOMMU_HWPT_ALLOC_NEST_PARENT via <strong>flags</strong>.</p>
<p>A user-managed nested HWPT will be created from a given vIOMMU (wrapping a
parent HWPT) or a parent HWPT via <strong>pt_id</strong>, in which the parent HWPT must be
allocated previously via the same ioctl from a given IOAS (<strong>pt_id</strong>). In this
case, the <strong>data_type</strong> must be set to a pre-defined type corresponding to an
I/O page table type supported by the underlying IOMMU hardware. The device
via <strong>dev_id</strong> and the vIOMMU via <strong>pt_id</strong> must be associated to the same IOMMU
instance.</p>
<p>If the <strong>data_type</strong> is set to IOMMU_HWPT_DATA_NONE, <strong>data_len</strong> and
<strong>data_uptr</strong> should be zero. Otherwise, both <strong>data_len</strong> and <strong>data_uptr</strong>
must be given.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_hw_info_vtd_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hw_info_vtd_flags</span></span></span><a class="headerlink" href="#c.iommu_hw_info_vtd_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flags for VT-d hw_info</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HW_INFO_VTD_ERRATA_772415_SPR17</span></code></dt><dd><p>If set, disallow read-only mappings
on a nested_parent domain.
<a class="reference external" href="https://www.intel.com/content/www/us/en/content-details/772415/content-details.html">https://www.intel.com/content/www/us/en/content-details/772415/content-details.html</a></p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hw_info_vtd">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hw_info_vtd</span></span></span><a class="headerlink" href="#c.iommu_hw_info_vtd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Intel VT-d hardware information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hw_info_vtd {
    __u32 flags;
    __u32 __reserved;
    __aligned_u64 cap_reg;
    __aligned_u64 ecap_reg;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommu_hw_info_vtd_flags" title="iommu_hw_info_vtd_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_hw_info_vtd_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cap_reg</span></code></dt><dd><p>Value of Intel VT-d capability register defined in VT-d spec
section 11.4.2 Capability Register.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ecap_reg</span></code></dt><dd><p>Value of Intel VT-d capability register defined in VT-d spec
section 11.4.3 Extended Capability Register.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>User needs to understand the Intel VT-d specification to decode the
register value.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hw_info_arm_smmuv3">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hw_info_arm_smmuv3</span></span></span><a class="headerlink" href="#c.iommu_hw_info_arm_smmuv3" title="Link to this definition">¶</a><br /></dt>
<dd><p>ARM SMMUv3 hardware information (IOMMU_HW_INFO_TYPE_ARM_SMMUV3)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hw_info_arm_smmuv3 {
    __u32 flags;
    __u32 __reserved;
    __u32 idr[6];
    __u32 iidr;
    __u32 aidr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Must be set to 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt><dd><p>Implemented features for ARM SMMU Non-secure programming interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iidr</span></code></dt><dd><p>Information about the implementation and implementer of ARM SMMU,
and architecture version supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aidr</span></code></dt><dd><p>ARM SMMU architecture version</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>For the details of <strong>idr</strong>, <strong>iidr</strong> and <strong>aidr</strong>, please refer to the chapters
from 6.3.1 to 6.3.6 in the SMMUv3 Spec.</p>
<p>This reports the raw HW capability, and not all bits are meaningful to be
read by userspace. Only the following fields should be used:</p>
<p>idr[0]: ST_LEVEL, TERM_MODEL, STALL_MODEL, TTENDIAN , CD2L, ASID16, TTF
idr[1]: SIDSIZE, SSIDSIZE
idr[3]: BBML, RIL
idr[5]: VAX, GRAN64K, GRAN16K, GRAN4K</p>
<ul class="simple">
<li><p>S1P should be assumed to be true if a NESTED HWPT can be created</p></li>
<li><p>VFIO/iommufd only support platforms with COHACC, it should be assumed to be
true.</p></li>
<li><p>ATS is a per-device property. If the VMM describes any devices as ATS
capable in ACPI/DT it should set the corresponding idr.</p></li>
</ul>
<p>This list may expand in future (eg E0PD, AIE, PBHA, D128, DS etc). It is
important that VMMs do not read bits outside the list to allow for
compatibility with future kernels. Several features in the SMMUv3
architecture are not currently supported by the kernel for nesting: HTTU,
BTM, MPAM and others.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_hw_info_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hw_info_type</span></span></span><a class="headerlink" href="#c.iommu_hw_info_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>IOMMU Hardware Info Types</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HW_INFO_TYPE_NONE</span></code></dt><dd><p>Used by the drivers that do not report hardware
info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HW_INFO_TYPE_INTEL_VTD</span></code></dt><dd><p>Intel VT-d iommu info type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HW_INFO_TYPE_ARM_SMMUV3</span></code></dt><dd><p>ARM SMMUv3 iommu info type</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommufd_hw_capabilities">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_hw_capabilities</span></span></span><a class="headerlink" href="#c.iommufd_hw_capabilities" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HW_CAP_DIRTY_TRACKING</span></code></dt><dd><p>IOMMU hardware support for dirty tracking
If available, it means the following APIs
are supported:</p>
<blockquote>
<div><p>IOMMU_HWPT_GET_DIRTY_BITMAP
IOMMU_HWPT_SET_DIRTY_TRACKING</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HW_CAP_PCI_PASID_EXEC</span></code></dt><dd><p>Execute Permission Supported, user ignores it
when the <a class="reference internal" href="#c.iommu_hw_info" title="iommu_hw_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">iommu_hw_info</span></code></a>::out_max_pasid_log2 is zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HW_CAP_PCI_PASID_PRIV</span></code></dt><dd><p>Privileged Mode Supported, user ignores it
when the <a class="reference internal" href="#c.iommu_hw_info" title="iommu_hw_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">iommu_hw_info</span></code></a>::out_max_pasid_log2 is zero.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hw_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hw_info</span></span></span><a class="headerlink" href="#c.iommu_hw_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_GET_HW_INFO)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hw_info {
    __u32 size;
    __u32 flags;
    __u32 dev_id;
    __u32 data_len;
    __aligned_u64 data_uptr;
    __u32 out_data_type;
    __u8 out_max_pasid_log2;
    __u8 __reserved[3];
    __aligned_u64 out_capabilities;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_hw_info" title="iommu_hw_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_hw_info</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>The device bound to the iommufd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_len</span></code></dt><dd><p>Input the length of a user buffer in bytes. Output the length of
data that kernel supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_uptr</span></code></dt><dd><p>User pointer to a user-space buffer used by the kernel to fill
the iommu type specific hardware information data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_data_type</span></code></dt><dd><p>Output the iommu hardware info type as defined in the <a class="reference internal" href="#c.iommu_hw_info_type" title="iommu_hw_info_type"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span>
<span class="pre">iommu_hw_info_type</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_max_pasid_log2</span></code></dt><dd><p>Output the width of PASIDs. 0 means no PASID support.
PCI devices turn to out_capabilities to check if the
specific capabilities is supported or not.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_capabilities</span></code></dt><dd><p>Output the generic iommu capability info type as defined
in the enum iommu_hw_capabilities.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Query an iommu type specific hardware information data from an iommu behind
a given device that has been bound to iommufd. This hardware info data will
be used to sync capabilities between the virtual iommu and the physical
iommu, e.g. a nested translation setup needs to check the hardware info, so
a guest stage-1 page table can be compatible with the physical iommu.</p>
<p>To capture an iommu type specific hardware information data, <strong>data_uptr</strong> and
its length <strong>data_len</strong> must be provided. Trailing bytes will be zeroed if the
user buffer is larger than the data that kernel has. Otherwise, kernel only
fills the buffer using the given length in <strong>data_len</strong>. If the ioctl succeeds,
<strong>data_len</strong> will be updated to the length that kernel actually supports,
<strong>out_data_type</strong> will be filled to decode the data filled in the buffer
pointed by <strong>data_uptr</strong>. Input <strong>data_len</strong> == zero is allowed.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_set_dirty_tracking">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_set_dirty_tracking</span></span></span><a class="headerlink" href="#c.iommu_hwpt_set_dirty_tracking" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_HWPT_SET_DIRTY_TRACKING)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_set_dirty_tracking {
    __u32 size;
    __u32 flags;
    __u32 hwpt_id;
    __u32 __reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_hwpt_set_dirty_tracking" title="iommu_hwpt_set_dirty_tracking"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_hwpt_set_dirty_tracking</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of enum iommufd_hwpt_set_dirty_tracking_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwpt_id</span></code></dt><dd><p>HW pagetable ID that represents the IOMMU domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Toggle dirty tracking on an HW pagetable.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommufd_hwpt_get_dirty_bitmap_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_hwpt_get_dirty_bitmap_flags</span></span></span><a class="headerlink" href="#c.iommufd_hwpt_get_dirty_bitmap_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flags for getting dirty bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_GET_DIRTY_BITMAP_NO_CLEAR</span></code></dt><dd><p>Just read the PTEs without clearing
any dirty bits metadata. This flag
can be passed in the expectation
where the next operation is an unmap
of the same IOVA range.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_get_dirty_bitmap">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_get_dirty_bitmap</span></span></span><a class="headerlink" href="#c.iommu_hwpt_get_dirty_bitmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_HWPT_GET_DIRTY_BITMAP)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_get_dirty_bitmap {
    __u32 size;
    __u32 hwpt_id;
    __u32 flags;
    __u32 __reserved;
    __aligned_u64 iova;
    __aligned_u64 length;
    __aligned_u64 page_size;
    __aligned_u64 data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_hwpt_get_dirty_bitmap" title="iommu_hwpt_get_dirty_bitmap"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_hwpt_get_dirty_bitmap</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwpt_id</span></code></dt><dd><p>HW pagetable ID that represents the IOMMU domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommufd_hwpt_get_dirty_bitmap_flags" title="iommufd_hwpt_get_dirty_bitmap_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_hwpt_get_dirty_bitmap_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iova</span></code></dt><dd><p>base IOVA of the bitmap first bit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>IOVA range size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_size</span></code></dt><dd><p>page size granularity of each bit in the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>bitmap where to set the dirty bits. The bitmap bits each
represent a page_size which you deviate from an arbitrary iova.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Checking a given IOVA is dirty:</p>
<blockquote>
<div><p>data[(iova / page_size) / 64] &amp; (1ULL &lt;&lt; ((iova / page_size) % 64))</p>
</div></blockquote>
<p>Walk the IOMMU pagetables for a given IOVA range to return a bitmap
with the dirty IOVAs. In doing so it will also by default clear any
dirty bit metadata set in the IOPTE.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_hwpt_invalidate_data_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_invalidate_data_type</span></span></span><a class="headerlink" href="#c.iommu_hwpt_invalidate_data_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>IOMMU HWPT Cache Invalidation Data Type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_HWPT_INVALIDATE_DATA_VTD_S1</span></code></dt><dd><p>Invalidation data for VTD_S1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VIOMMU_INVALIDATE_DATA_ARM_SMMUV3</span></code></dt><dd><p>Invalidation data for ARM SMMUv3</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_hwpt_vtd_s1_invalidate_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_vtd_s1_invalidate_flags</span></span></span><a class="headerlink" href="#c.iommu_hwpt_vtd_s1_invalidate_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flags for Intel VT-d stage-1 cache invalidation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VTD_INV_FLAGS_LEAF</span></code></dt><dd><p>Indicates whether the invalidation applies
to all-levels page structure cache or just
the leaf PTE cache.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_vtd_s1_invalidate">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_vtd_s1_invalidate</span></span></span><a class="headerlink" href="#c.iommu_hwpt_vtd_s1_invalidate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Intel VT-d cache invalidation (IOMMU_HWPT_INVALIDATE_DATA_VTD_S1)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_vtd_s1_invalidate {
    __aligned_u64 addr;
    __aligned_u64 npages;
    __u32 flags;
    __u32 __reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>The start address of the range to be invalidated. It needs to
be 4KB aligned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">npages</span></code></dt><dd><p>Number of contiguous 4K pages to be invalidated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommu_hwpt_vtd_s1_invalidate_flags" title="iommu_hwpt_vtd_s1_invalidate_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_hwpt_vtd_s1_invalidate_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The Intel VT-d specific invalidation data for user-managed stage-1 cache
invalidation in nested translation. Userspace uses this structure to
tell the impacted cache scope after modifying the stage-1 page table.</p>
<p>Invalidating all the caches related to the page table by setting <strong>addr</strong>
to be 0 and <strong>npages</strong> to be U64_MAX.</p>
<p>The device TLB will be invalidated automatically if ATS is enabled.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_viommu_arm_smmuv3_invalidate">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_viommu_arm_smmuv3_invalidate</span></span></span><a class="headerlink" href="#c.iommu_viommu_arm_smmuv3_invalidate" title="Link to this definition">¶</a><br /></dt>
<dd><p>ARM SMMUv3 cache invalidation (IOMMU_VIOMMU_INVALIDATE_DATA_ARM_SMMUV3)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_viommu_arm_smmuv3_invalidate {
    __aligned_le64 cmd[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>128-bit cache invalidation command that runs in SMMU CMDQ.
Must be little-endian.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Supported command list only when passing in a vIOMMU via <strong>hwpt_id</strong>:</dt><dd><p>CMDQ_OP_TLBI_NSNH_ALL
CMDQ_OP_TLBI_NH_VA
CMDQ_OP_TLBI_NH_VAA
CMDQ_OP_TLBI_NH_ALL
CMDQ_OP_TLBI_NH_ASID
CMDQ_OP_ATC_INV
CMDQ_OP_CFGI_CD
CMDQ_OP_CFGI_CD_ALL</p>
</dd>
</dl>
<p>-EIO will be returned if the command is not supported.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_invalidate">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_invalidate</span></span></span><a class="headerlink" href="#c.iommu_hwpt_invalidate" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_HWPT_INVALIDATE)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_invalidate {
    __u32 size;
    __u32 hwpt_id;
    __aligned_u64 data_uptr;
    __u32 data_type;
    __u32 entry_len;
    __u32 entry_num;
    __u32 __reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_hwpt_invalidate" title="iommu_hwpt_invalidate"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_hwpt_invalidate</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwpt_id</span></code></dt><dd><p>ID of a nested HWPT or a vIOMMU, for cache invalidation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_uptr</span></code></dt><dd><p>User pointer to an array of driver-specific cache invalidation
data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_type</span></code></dt><dd><p>One of <a class="reference internal" href="#c.iommu_hwpt_invalidate_data_type" title="iommu_hwpt_invalidate_data_type"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_hwpt_invalidate_data_type</span></code></a>, defining the data
type of all the entries in the invalidation request array. It
should be a type supported by the hwpt pointed by <strong>hwpt_id</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry_len</span></code></dt><dd><p>Length (in bytes) of a request entry in the request array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry_num</span></code></dt><dd><p>Input the number of cache invalidation requests in the array.
Output the number of requests successfully handled by kernel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Invalidate iommu cache for user-managed page table or vIOMMU. Modifications
on a user-managed page table should be followed by this operation, if a HWPT
is passed in via <strong>hwpt_id</strong>. Other caches, such as device cache or descriptor
cache can be flushed if a vIOMMU is passed in via the <strong>hwpt_id</strong> field.</p>
<p>Each ioctl can support one or more cache invalidation requests in the array
that has a total size of <strong>entry_len</strong> * <strong>entry_num</strong>.</p>
<p>An empty invalidation request array by setting <strong>entry_num**==0 is allowed, and
**entry_len</strong> and <strong>data_uptr</strong> would be ignored in this case. This can be used to
check if the given <strong>data_type</strong> is supported or not by kernel.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_hwpt_pgfault_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_pgfault_flags</span></span></span><a class="headerlink" href="#c.iommu_hwpt_pgfault_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>flags for <a class="reference internal" href="#c.iommu_hwpt_pgfault" title="iommu_hwpt_pgfault"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_hwpt_pgfault</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_PGFAULT_FLAGS_PASID_VALID</span></code></dt><dd><p>The pasid field of the fault data is
valid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_PGFAULT_FLAGS_LAST_PAGE</span></code></dt><dd><p>It’s the last fault of a fault group.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_hwpt_pgfault_perm">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_pgfault_perm</span></span></span><a class="headerlink" href="#c.iommu_hwpt_pgfault_perm" title="Link to this definition">¶</a><br /></dt>
<dd><p>perm bits for <a class="reference internal" href="#c.iommu_hwpt_pgfault" title="iommu_hwpt_pgfault"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_hwpt_pgfault</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_PGFAULT_PERM_READ</span></code></dt><dd><p>request for read permission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_PGFAULT_PERM_WRITE</span></code></dt><dd><p>request for write permission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_PGFAULT_PERM_EXEC</span></code></dt><dd><p>(PCIE 10.4.1) request with a PASID that has the
Execute Requested bit set in PASID TLP Prefix.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_PGFAULT_PERM_PRIV</span></code></dt><dd><p>(PCIE 10.4.1) request with a PASID that has the
Privileged Mode Requested bit set in PASID TLP
Prefix.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_pgfault">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_pgfault</span></span></span><a class="headerlink" href="#c.iommu_hwpt_pgfault" title="Link to this definition">¶</a><br /></dt>
<dd><p>iommu page fault data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_pgfault {
    __u32 flags;
    __u32 dev_id;
    __u32 pasid;
    __u32 grpid;
    __u32 perm;
    __u32 __reserved;
    __aligned_u64 addr;
    __u32 length;
    __u32 cookie;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommu_hwpt_pgfault_flags" title="iommu_hwpt_pgfault_flags"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_hwpt_pgfault_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>id of the originated device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pasid</span></code></dt><dd><p>Process Address Space ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grpid</span></code></dt><dd><p>Page Request Group Index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">perm</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommu_hwpt_pgfault_perm" title="iommu_hwpt_pgfault_perm"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_hwpt_pgfault_perm</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>Fault address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>a hint of how much data the requestor is expecting to fetch. For
example, if the PRI initiator knows it is going to do a 10MB
transfer, it could fill in 10MB and the OS could pre-fault in
10MB of IOVA. It’s default to 0 if there’s no such hint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cookie</span></code></dt><dd><p>kernel-managed cookie identifying a group of fault messages. The
cookie number encoded in the last page fault of the group should
be echoed back in the response message.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommufd_page_response_code">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_page_response_code</span></span></span><a class="headerlink" href="#c.iommufd_page_response_code" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return status of fault handlers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMUFD_PAGE_RESP_SUCCESS</span></code></dt><dd><p>Fault has been handled and the page tables
populated, retry the access. This is the
“Success” defined in PCI 10.4.2.1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMUFD_PAGE_RESP_INVALID</span></code></dt><dd><p>Could not handle this fault, don’t retry the
access. This is the “Invalid Request” in PCI
10.4.2.1.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_hwpt_page_response">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_hwpt_page_response</span></span></span><a class="headerlink" href="#c.iommu_hwpt_page_response" title="Link to this definition">¶</a><br /></dt>
<dd><p>IOMMU page fault response</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_hwpt_page_response {
    __u32 cookie;
    __u32 code;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cookie</span></code></dt><dd><p>The kernel-managed cookie reported in the fault message.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code</span></code></dt><dd><p>One of response code in <a class="reference internal" href="#c.iommufd_page_response_code" title="iommufd_page_response_code"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommufd_page_response_code</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_fault_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_fault_alloc</span></span></span><a class="headerlink" href="#c.iommu_fault_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_FAULT_QUEUE_ALLOC)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_fault_alloc {
    __u32 size;
    __u32 flags;
    __u32 out_fault_id;
    __u32 out_fault_fd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_fault_alloc" title="iommu_fault_alloc"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_fault_alloc</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_fault_id</span></code></dt><dd><p>The ID of the new FAULT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_fault_fd</span></code></dt><dd><p>The fd of the new FAULT</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Explicitly allocate a fault handling object.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_viommu_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_viommu_type</span></span></span><a class="headerlink" href="#c.iommu_viommu_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Virtual IOMMU Type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VIOMMU_TYPE_DEFAULT</span></code></dt><dd><p>Reserved for future use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VIOMMU_TYPE_ARM_SMMUV3</span></code></dt><dd><p>ARM SMMUv3 driver specific type</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_viommu_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_viommu_alloc</span></span></span><a class="headerlink" href="#c.iommu_viommu_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_VIOMMU_ALLOC)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_viommu_alloc {
    __u32 size;
    __u32 flags;
    __u32 type;
    __u32 dev_id;
    __u32 hwpt_id;
    __u32 out_viommu_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_viommu_alloc" title="iommu_viommu_alloc"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_viommu_alloc</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of the virtual IOMMU. Must be defined in <a class="reference internal" href="#c.iommu_viommu_type" title="iommu_viommu_type"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_viommu_type</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>The device’s physical IOMMU will be used to back the virtual IOMMU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwpt_id</span></code></dt><dd><p>ID of a nesting parent HWPT to associate to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_viommu_id</span></code></dt><dd><p>Output virtual IOMMU ID for the allocated object</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Allocate a virtual IOMMU object, representing the underlying physical IOMMU’s
virtualization support that is a security-isolated slice of the real IOMMU HW
that is unique to a specific VM. Operations global to the IOMMU are connected
to the vIOMMU, such as:
- Security namespace for guest owned ID, e.g. guest-controlled cache tags
- Non-device-affiliated event reporting, e.g. invalidation queue errors
- Access to a sharable nesting parent pagetable across physical IOMMUs
- Virtualization of various platforms IDs, e.g. RIDs and others
- Delivery of paravirtualized invalidation
- Direct assigned invalidation queues
- Direct assigned interrupts</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_vdevice_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_vdevice_alloc</span></span></span><a class="headerlink" href="#c.iommu_vdevice_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_VDEVICE_ALLOC)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_vdevice_alloc {
    __u32 size;
    __u32 viommu_id;
    __u32 dev_id;
    __u32 out_vdevice_id;
    __aligned_u64 virt_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_vdevice_alloc" title="iommu_vdevice_alloc"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_vdevice_alloc</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">viommu_id</span></code></dt><dd><p>vIOMMU ID to associate with the virtual device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>The physical device to allocate a virtual instance on the vIOMMU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_vdevice_id</span></code></dt><dd><p>Object handle for the vDevice. Pass to IOMMU_DESTORY</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">virt_id</span></code></dt><dd><p>Virtual device ID per vIOMMU, e.g. vSID of ARM SMMUv3, vDeviceID
of AMD IOMMU, and vRID of a nested Intel VT-d to a Context Table</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Allocate a virtual device instance (for a physical device) against a vIOMMU.
This instance holds the device’s information (related to its vIOMMU) in a VM.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_ioas_change_process">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_ioas_change_process</span></span></span><a class="headerlink" href="#c.iommu_ioas_change_process" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(VFIO_IOAS_CHANGE_PROCESS)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_ioas_change_process {
    __u32 size;
    __u32 __reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_ioas_change_process" title="iommu_ioas_change_process"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_ioas_change_process</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This transfers pinned memory counts for every memory map in every IOAS
in the context to the current process.  This only supports maps created
with IOMMU_IOAS_MAP_FILE, and returns EINVAL if other maps are present.
If the ioctl returns a failure status, then nothing is changed.</p>
<p>This API is useful for transferring operation of a device from one process
to another, such as during userland live update.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_veventq_flag">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_veventq_flag</span></span></span><a class="headerlink" href="#c.iommu_veventq_flag" title="Link to this definition">¶</a><br /></dt>
<dd><p>flag for <a class="reference internal" href="#c.iommufd_vevent_header" title="iommufd_vevent_header"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_vevent_header</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VEVENTQ_FLAG_LOST_EVENTS</span></code></dt><dd><p>vEVENTQ has lost vEVENTs</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommufd_vevent_header">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_vevent_header</span></span></span><a class="headerlink" href="#c.iommufd_vevent_header" title="Link to this definition">¶</a><br /></dt>
<dd><p>Virtual Event Header for a vEVENTQ Status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommufd_vevent_header {
    __u32 flags;
    __u32 sequence;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Combination of <a class="reference internal" href="#c.iommu_veventq_flag" title="iommu_veventq_flag"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_veventq_flag</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sequence</span></code></dt><dd><p>The sequence index of a vEVENT in the vEVENTQ, with a range of
[0, INT_MAX] where the following index of INT_MAX is 0</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Each iommufd_vevent_header reports a sequence index of the following vEVENT:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>header0 {sequence=0}</p></td>
<td><p>data0</p></td>
<td><p>header1 {sequence=1}</p></td>
<td><p>data1</p></td>
<td><p>...</p></td>
<td><p>dataN</p></td>
</tr>
</tbody>
</table>
<p>And this sequence index is expected to be monotonic to the sequence index of
the previous vEVENT. If two adjacent sequence indexes has a delta larger than
1, it means that delta - 1 number of vEVENTs has lost, e.g. two lost vEVENTs:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>...</p></td>
<td><p>header3 {sequence=3}</p></td>
<td><p>data3</p></td>
<td><p>header6 {sequence=6}</p></td>
<td><p>data6</p></td>
<td><p>...</p></td>
</tr>
</tbody>
</table>
<p>If a vEVENT lost at the tail of the vEVENTQ and there is no following vEVENT
providing the next sequence index, an IOMMU_VEVENTQ_FLAG_LOST_EVENTS header
would be added to the tail, and no data would follow this header:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td></td>
<td><p>header3 {sequence=3}</p></td>
<td><p>data3</p></td>
<td><p>header4 {flags=LOST_EVENTS, sequence=4}</p></td>
</tr>
</tbody>
</table>
<dl class="c enum">
<dt class="sig sig-object c" id="c.iommu_veventq_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_veventq_type</span></span></span><a class="headerlink" href="#c.iommu_veventq_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Virtual Event Queue Type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VEVENTQ_TYPE_DEFAULT</span></code></dt><dd><p>Reserved for future use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IOMMU_VEVENTQ_TYPE_ARM_SMMUV3</span></code></dt><dd><p>ARM SMMUv3 Virtual Event Queue</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_vevent_arm_smmuv3">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_vevent_arm_smmuv3</span></span></span><a class="headerlink" href="#c.iommu_vevent_arm_smmuv3" title="Link to this definition">¶</a><br /></dt>
<dd><p>ARM SMMUv3 Virtual Event (IOMMU_VEVENTQ_TYPE_ARM_SMMUV3)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_vevent_arm_smmuv3 {
    __aligned_le64 evt[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">evt</span></code></dt><dd><p>256-bit ARM SMMUv3 Event record, little-endian.
Reported event records: (Refer to “7.3 Event records” in SMMUv3 HW Spec)
- 0x04 C_BAD_STE
- 0x06 F_STREAM_DISABLED
- 0x08 C_BAD_SUBSTREAMID
- 0x0a C_BAD_CD
- 0x10 F_TRANSLATION
- 0x11 F_ADDR_SIZE
- 0x12 F_ACCESS
- 0x13 F_PERMISSION</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>StreamID field reports a virtual device ID. To receive a virtual event for a
device, a vDEVICE must be allocated via IOMMU_VDEVICE_ALLOC.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.iommu_veventq_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommu_veventq_alloc</span></span></span><a class="headerlink" href="#c.iommu_veventq_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>ioctl(IOMMU_VEVENTQ_ALLOC)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct iommu_veventq_alloc {
    __u32 size;
    __u32 flags;
    __u32 viommu_id;
    __u32 type;
    __u32 veventq_depth;
    __u32 out_veventq_id;
    __u32 out_veventq_fd;
    __u32 __reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.iommu_veventq_alloc" title="iommu_veventq_alloc"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_veventq_alloc</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">viommu_id</span></code></dt><dd><p>virtual IOMMU ID to associate the vEVENTQ with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of the vEVENTQ. Must be defined in <a class="reference internal" href="#c.iommu_veventq_type" title="iommu_veventq_type"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iommu_veventq_type</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">veventq_depth</span></code></dt><dd><p>Maximum number of events in the vEVENTQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_veventq_id</span></code></dt><dd><p>The ID of the new vEVENTQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_veventq_fd</span></code></dt><dd><p>The fd of the new vEVENTQ. User space must close the
successfully returned fd after using it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reserved</span></code></dt><dd><p>Must be 0</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Explicitly allocate a virtual event queue interface for a vIOMMU. A vIOMMU
can have multiple FDs for different types, but is confined to one per <strong>type</strong>.
User space should open the <strong>out_veventq_fd</strong> to read vEVENTs out of a vEVENTQ,
if there are vEVENTs available. A vEVENTQ will lose events due to overflow,
if the number of the vEVENTs hits <strong>veventq_depth</strong>.</p>
<p>Each vEVENT in a vEVENTQ encloses a <a class="reference internal" href="#c.iommufd_vevent_header" title="iommufd_vevent_header"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_vevent_header</span></code></a> followed by
a type-specific data structure, in a normal case:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td></td>
<td><p>header0</p></td>
<td><p>data0</p></td>
<td><p>header1</p></td>
<td><p>data1</p></td>
<td><p>...</p></td>
<td><p>headerN</p></td>
<td><p>dataN</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>unless a tailing IOMMU_VEVENTQ_FLAG_LOST_EVENTS header is logged (refer to
<a class="reference internal" href="#c.iommufd_vevent_header" title="iommufd_vevent_header"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_vevent_header</span></code></a>).</p>
</section>
<section id="iommufd-kernel-api">
<h2>IOMMUFD Kernel API<a class="headerlink" href="#iommufd-kernel-api" title="Link to this heading">¶</a></h2>
<p>The IOMMUFD kAPI is device-centric with group-related tricks managed behind the
scene. This allows the external drivers calling such kAPI to implement a simple
device-centric uAPI for connecting its device to an iommufd, instead of
explicitly imposing the group semantics in its uAPI as VFIO does.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_device_bind">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_device_bind</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ictx</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_device_bind" title="Link to this definition">¶</a><br /></dt>
<dd><p>Bind a physical device to an iommu fd</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_ctx</span> <span class="pre">*ictx</span></code></dt><dd><p>iommufd file descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to a physical device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Output ID number to return to userspace for this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A successful bind establishes an ownership over the device and returns
struct iommufd_device pointer, otherwise returns error pointer.</p>
<p>A driver using this API must set driver_managed_dma and must not touch
the device until this routine succeeds and establishes ownership.</p>
<p>Binding a PCI device places the entire RID under iommufd control.</p>
<p>The caller must undo this with <a class="reference internal" href="#c.iommufd_device_unbind" title="iommufd_device_unbind"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_device_unbind()</span></code></a></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_ctx_has_group">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_ctx_has_group</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ictx</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommu_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">group</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_ctx_has_group" title="Link to this definition">¶</a><br /></dt>
<dd><p>True if any device within the group is bound to the ictx</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_ctx</span> <span class="pre">*ictx</span></code></dt><dd><p>iommufd file descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommu_group</span> <span class="pre">*group</span></code></dt><dd><p>Pointer to a physical iommu_group struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>True if any device within the group has been bound to this ictx, ex. via
<a class="reference internal" href="#c.iommufd_device_bind" title="iommufd_device_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_device_bind()</span></code></a>, therefore implying ictx ownership of the group.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_device_unbind">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_device_unbind</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_device_unbind" title="Link to this definition">¶</a><br /></dt>
<dd><p>Undo <a class="reference internal" href="#c.iommufd_device_bind" title="iommufd_device_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_device_bind()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_device</span> <span class="pre">*idev</span></code></dt><dd><p>Device returned by <a class="reference internal" href="#c.iommufd_device_bind" title="iommufd_device_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_device_bind()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release the device from iommufd control. The DMA ownership will return back
to unowned with DMA controlled by the DMA API. This invalidates the
iommufd_device pointer, other APIs that consume it must not be called
concurrently.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_device_attach">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_device_attach</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idev</span></span>, <span class="n"><span class="pre">ioasid_t</span></span><span class="w"> </span><span class="n"><span class="pre">pasid</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pt_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_device_attach" title="Link to this definition">¶</a><br /></dt>
<dd><p>Connect a device/pasid to an iommu_domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_device</span> <span class="pre">*idev</span></code></dt><dd><p>device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioasid_t</span> <span class="pre">pasid</span></code></dt><dd><p>pasid to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*pt_id</span></code></dt><dd><p>Input a IOMMUFD_OBJ_IOAS, or IOMMUFD_OBJ_HWPT_PAGING
Output the IOMMUFD_OBJ_HWPT_PAGING ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This connects the device/pasid to an iommu_domain, either automatically
or manually selected. Once this completes the device could do DMA with
<strong>pasid</strong>. <strong>pasid</strong> is IOMMU_NO_PASID if this attach is for no pasid usage.</p>
<p>The caller should return the resulting pt_id back to userspace.
This function is undone by calling <a class="reference internal" href="#c.iommufd_device_detach" title="iommufd_device_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_device_detach()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_device_replace">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_device_replace</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idev</span></span>, <span class="n"><span class="pre">ioasid_t</span></span><span class="w"> </span><span class="n"><span class="pre">pasid</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pt_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_device_replace" title="Link to this definition">¶</a><br /></dt>
<dd><p>Change the device/pasid’s iommu_domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_device</span> <span class="pre">*idev</span></code></dt><dd><p>device to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioasid_t</span> <span class="pre">pasid</span></code></dt><dd><p>pasid to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*pt_id</span></code></dt><dd><p>Input a IOMMUFD_OBJ_IOAS, or IOMMUFD_OBJ_HWPT_PAGING
Output the IOMMUFD_OBJ_HWPT_PAGING ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>iommufd_device_detach();
iommufd_device_attach();
</pre></div>
</div>
<p>If it fails then no change is made to the attachment. The iommu driver may
implement this so there is no disruption in translation. This can only be
called if <a class="reference internal" href="#c.iommufd_device_attach" title="iommufd_device_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_device_attach()</span></code></a> has already succeeded. <strong>pasid</strong> is
IOMMU_NO_PASID for no pasid usage.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_device_detach">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_device_detach</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idev</span></span>, <span class="n"><span class="pre">ioasid_t</span></span><span class="w"> </span><span class="n"><span class="pre">pasid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_device_detach" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disconnect a device/device to an iommu_domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_device</span> <span class="pre">*idev</span></code></dt><dd><p>device to detach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioasid_t</span> <span class="pre">pasid</span></code></dt><dd><p>pasid to detach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo <a class="reference internal" href="#c.iommufd_device_attach" title="iommufd_device_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_device_attach()</span></code></a>. This disconnects the idev from the previously
attached pt_id. The device returns back to a blocked DMA translation.
<strong>pasid</strong> is IOMMU_NO_PASID for no pasid usage.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_access_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_access</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_access_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ictx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_access_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_access_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create an iommufd_access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_ctx</span> <span class="pre">*ictx</span></code></dt><dd><p>iommufd file descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iommufd_access_ops</span> <span class="pre">*ops</span></code></dt><dd><p>Driver’s ops to associate with the access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Opaque data to pass into ops functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id</span></code></dt><dd><p>Output ID number to return to userspace for this access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An iommufd_access allows a driver to read/write to the IOAS without using
DMA. The underlying CPU memory can be accessed using the
<a class="reference internal" href="#c.iommufd_access_pin_pages" title="iommufd_access_pin_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_access_pin_pages()</span></code></a> or <a class="reference internal" href="#c.iommufd_access_rw" title="iommufd_access_rw"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_access_rw()</span></code></a> functions.</p>
<p>The provided ops are required to use <a class="reference internal" href="#c.iommufd_access_pin_pages" title="iommufd_access_pin_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_access_pin_pages()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_access_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_access_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_access</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">access</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_access_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Destroy an iommufd_access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_access</span> <span class="pre">*access</span></code></dt><dd><p>The access to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must stop using the access before destroying it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_access_unpin_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_access_unpin_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_access</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">access</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">iova</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_access_unpin_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Undo iommufd_access_pin_pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_access</span> <span class="pre">*access</span></code></dt><dd><p>IOAS access to act on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">iova</span></code></dt><dd><p>Starting IOVA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">length</span></code></dt><dd><p>Number of bytes to access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the struct page’s. The caller must stop accessing them before calling
this. The iova/length must exactly match the one provided to access_pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_access_pin_pages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_access_pin_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_access</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">access</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">iova</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_access_pin_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a list of pages under the iova</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_access</span> <span class="pre">*access</span></code></dt><dd><p>IOAS access to act on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">iova</span></code></dt><dd><p>Starting IOVA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">length</span></code></dt><dd><p>Number of bytes to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**out_pages</span></code></dt><dd><p>Output page list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>IOPMMUFD_ACCESS_RW_* flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads <strong>length</strong> bytes starting at iova and returns the struct page * pointers.
These can be kmap’d by the caller for CPU access.</p>
<p>The caller must perform <a class="reference internal" href="#c.iommufd_access_unpin_pages" title="iommufd_access_unpin_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_access_unpin_pages()</span></code></a> when done to balance
this.</p>
<p>This API always requires a page aligned iova. This happens naturally if the
ioas alignment is &gt;= PAGE_SIZE and the iova is PAGE_SIZE aligned. However
smaller alignments have corner cases where this API can fail on otherwise
aligned iova.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_access_rw">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_access_rw</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_access</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">access</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">iova</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_access_rw" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read or write data under the iova</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_access</span> <span class="pre">*access</span></code></dt><dd><p>IOAS access to act on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">iova</span></code></dt><dd><p>Starting IOVA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Kernel buffer to copy to/from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>Number of bytes to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>IOMMUFD_ACCESS_RW_* flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy kernel to/from data into the range given by IOVA/length. If flags
indicates IOMMUFD_ACCESS_RW_KTHREAD then a large copy can be optimized
by changing it into copy_to/from_user().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_ctx_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_ctx_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ictx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_ctx_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a context reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_ctx</span> <span class="pre">*ictx</span></code></dt><dd><p>Context to get</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must already hold a valid reference to ictx.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_ctx_from_file">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_ctx_from_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.iommufd_ctx_from_file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_ctx_from_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>Acquires a reference to the iommufd context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>File to obtain the reference from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the iommufd_ctx, otherwise ERR_PTR. The <a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>
remains owned by the caller and the caller must still do fput. On success
the caller is responsible to call <a class="reference internal" href="#c.iommufd_ctx_put" title="iommufd_ctx_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_ctx_put()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_ctx_from_fd">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_ctx_from_fd</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">fd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_ctx_from_fd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Acquires a reference to the iommufd context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>File descriptor to obtain the reference from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the iommufd_ctx, otherwise ERR_PTR. On success
the caller is responsible to call <a class="reference internal" href="#c.iommufd_ctx_put" title="iommufd_ctx_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">iommufd_ctx_put()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.iommufd_ctx_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">iommufd_ctx_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iommufd_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ictx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.iommufd_ctx_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>Put back a reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iommufd_ctx</span> <span class="pre">*ictx</span></code></dt><dd><p>Context to put back</p>
</dd>
</dl>
</div>
<section id="vfio-and-iommufd">
<h3>VFIO and IOMMUFD<a class="headerlink" href="#vfio-and-iommufd" title="Link to this heading">¶</a></h3>
<p>Connecting a VFIO device to iommufd can be done in two ways.</p>
<p>First is a VFIO compatible way by directly implementing the /dev/vfio/vfio
container IOCTLs by mapping them into io_pagetable operations. Doing so allows
the use of iommufd in legacy VFIO applications by symlinking /dev/vfio/vfio to
/dev/iommufd or extending VFIO to SET_CONTAINER using an iommufd instead of a
container fd.</p>
<p>The second approach directly extends VFIO to support a new set of device-centric
user API based on aforementioned IOMMUFD kernel API. It requires userspace
change but better matches the IOMMUFD API semantics and easier to support new
iommufd features when comparing it to the first approach.</p>
<p>Currently both approaches are still work-in-progress.</p>
<p>There are still a few gaps to be resolved to catch up with VFIO type1, as
documented in iommufd_vfio_check_extension().</p>
</section>
</section>
<section id="future-todos">
<h2>Future TODOs<a class="headerlink" href="#future-todos" title="Link to this heading">¶</a></h2>
<p>Currently IOMMUFD supports only kernel-managed I/O page table, similar to VFIO
type1. New features on the radar include:</p>
<blockquote>
<div><ul class="simple">
<li><p>Binding iommu_domain’s to PASID/SSID</p></li>
<li><p>Userspace page tables, for ARM, x86 and S390</p></li>
<li><p>Kernel bypass’d invalidation of user page tables</p></li>
<li><p>Re-use of the KVM page table in the IOMMU</p></li>
<li><p>Dirty page tracking in the IOMMU</p></li>
<li><p>Runtime Increase/Decrease of IOPTE size</p></li>
<li><p>PRI support with faults resolved in userspace</p></li>
</ul>
</div></blockquote>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/userspace-api/iommufd.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>