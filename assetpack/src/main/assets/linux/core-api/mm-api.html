<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Memory Management APIs &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Cgroup Kernel APIs" href="cgroup.html" />
    <link rel="prev" title="DMA and swiotlb" href="swiotlb.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#memory-management">Memory management</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="memory-allocation.html">Memory Allocation Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="unaligned-memory-access.html">Unaligned Memory Accesses</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-api.html">Dynamic DMA mapping using the generic device</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-api-howto.html">Dynamic DMA mapping Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-attributes.html">DMA attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-isa-lpc.html">DMA with ISA and LPC devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="swiotlb.html">DMA and swiotlb</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Memory Management APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="cgroup.html">Cgroup Kernel APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="genalloc.html">The genalloc/genpool subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="pin_user_pages.html">pin_user_pages() and related calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="boot-time-mm.html">Boot time memory management</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfp_mask-from-fs-io.html">GFP masks used from FS/IO context</a></li>
<li class="toctree-l3"><a class="reference internal" href="kho/index.html">Kexec Handover Subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/mm-api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../translations/zh_CN/core-api/mm-api.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="memory-management-apis">
<h1>Memory Management APIs<a class="headerlink" href="#memory-management-apis" title="Link to this heading">¶</a></h1>
<section id="user-space-memory-access">
<h2>User Space Memory Access<a class="headerlink" href="#user-space-memory-access" title="Link to this heading">¶</a></h2>
<dl class="c macro">
<dt class="sig sig-object c" id="c.get_user">
<span class="sig-name descname"><span class="n"><span class="pre">get_user</span></span></span><a class="headerlink" href="#c.get_user" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">get_user</span> <span class="pre">(x,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Get a simple variable from user space.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>Variable to store result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Source address, in user space.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p><strong>Return</strong></p>
<p>zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.__get_user">
<span class="sig-name descname"><span class="n"><span class="pre">__get_user</span></span></span><a class="headerlink" href="#c.__get_user" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">__get_user</span> <span class="pre">(x,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Get a simple variable from user space, with less checking.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>Variable to store result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Source address, in user space.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p>Caller must check the pointer with access_ok() before calling this
function.</p>
<p><strong>Return</strong></p>
<p>zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.put_user">
<span class="sig-name descname"><span class="n"><span class="pre">put_user</span></span></span><a class="headerlink" href="#c.put_user" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">put_user</span> <span class="pre">(x,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Write a simple value into user space.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>Value to copy to user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Destination address, in user space.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p><strong>Return</strong></p>
<p>zero on success, or -EFAULT on error.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.__put_user">
<span class="sig-name descname"><span class="n"><span class="pre">__put_user</span></span></span><a class="headerlink" href="#c.__put_user" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">__put_user</span> <span class="pre">(x,</span> <span class="pre">ptr)</span></code></p>
<blockquote>
<div><p>Write a simple value into user space, with less checking.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>Value to copy to user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>Destination address, in user space.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p>Caller must check the pointer with access_ok() before calling this
function.</p>
<p><strong>Return</strong></p>
<p>zero on success, or -EFAULT on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clear_user">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_user</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_user" title="Link to this definition">¶</a><br /></dt>
<dd><p>Zero a block of memory in user space.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*to</span></code></dt><dd><p>Destination address, in user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>Number of bytes to zero.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.</p>
<p><strong>Return</strong></p>
<p>number of bytes that could not be cleared.
On success, this will be zero.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__clear_user">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__clear_user</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__clear_user" title="Link to this definition">¶</a><br /></dt>
<dd><p>Zero a block of memory in user space, with less checking.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*to</span></code></dt><dd><p>Destination address, in user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>Number of bytes to zero.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.  Caller must check
the specified block with access_ok() before calling this function.</p>
<p><strong>Return</strong></p>
<p>number of bytes that could not be cleared.
On success, this will be zero.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_user_pages_fast">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_user_pages_fast</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">gup_flags</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_user_pages_fast" title="Link to this definition">¶</a><br /></dt>
<dd><p>pin user pages in memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>starting user address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>number of pages from start to pin</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gup_flags</span></code></dt><dd><p>flags modifying pin behaviour</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>array that receives pointers to the pages pinned.
Should be at least nr_pages long.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to pin user pages in memory without taking mm-&gt;mmap_lock.
If not successful, it will fall back to taking the lock and
calling get_user_pages().</p>
<p>Returns number of pages pinned. This may be fewer than the number requested.
If nr_pages is 0 or negative, returns 0. If no pages were pinned, returns
-errno.</p>
</div>
</section>
<section id="memory-allocation-controls">
<span id="mm-api-gfp-flags"></span><h2>Memory Allocation Controls<a class="headerlink" href="#memory-allocation-controls" title="Link to this heading">¶</a></h2>
<section id="page-mobility-and-placement-hints">
<h3>Page mobility and placement hints<a class="headerlink" href="#page-mobility-and-placement-hints" title="Link to this heading">¶</a></h3>
<p>These flags provide hints about how mobile the page is. Pages with similar
mobility are placed within the same pageblocks to minimise problems due
to external fragmentation.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_MOVABLE</span></code> (also a zone modifier) indicates that the page can be
moved by page migration during memory compaction or can be reclaimed.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_RECLAIMABLE</span></code> is used for slab allocations that specify
SLAB_RECLAIM_ACCOUNT and whose pages can be freed via shrinkers.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_WRITE</span></code> indicates the caller intends to dirty the page. Where possible,
these pages will be spread between local zones to avoid all the dirty
pages being in one zone (fair zone allocation policy).</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_HARDWALL</span></code> enforces the cpuset memory allocation policy.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_THISNODE</span></code> forces the allocation to be satisfied from the requested
node with no fallbacks or placement policy enforcements.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_ACCOUNT</span></code> causes the allocation to be accounted to kmemcg.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_NO_OBJ_EXT</span></code> causes slab allocation to have no object extension.</p>
</section>
<section id="watermark-modifiers-controls-access-to-emergency-reserves">
<h3>Watermark modifiers -- controls access to emergency reserves<a class="headerlink" href="#watermark-modifiers-controls-access-to-emergency-reserves" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_HIGH</span></code> indicates that the caller is high-priority and that granting
the request is necessary before the system can make forward progress.
For example creating an IO context to clean pages and requests
from atomic context.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_MEMALLOC</span></code> allows access to all memory. This should only be used when
the caller guarantees the allocation will allow more memory to be freed
very shortly e.g. process exiting or swapping. Users either should
be the MM or co-ordinating closely with the VM (e.g. swap over NFS).
Users of this flag have to be extremely careful to not deplete the reserve
completely and implement a throttling mechanism which controls the
consumption of the reserve based on the amount of freed memory.
Usage of a pre-allocated pool (e.g. mempool) should be always considered
before using this flag.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_NOMEMALLOC</span></code> is used to explicitly forbid access to emergency reserves.
This takes precedence over the <code class="docutils literal notranslate"><span class="pre">__GFP_MEMALLOC</span></code> flag if both are set.</p>
</section>
<section id="reclaim-modifiers">
<h3>Reclaim modifiers<a class="headerlink" href="#reclaim-modifiers" title="Link to this heading">¶</a></h3>
<p>Please note that all the following flags are only applicable to sleepable
allocations (e.g. <code class="docutils literal notranslate"><span class="pre">GFP_NOWAIT</span></code> and <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code> will ignore them).</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_IO</span></code> can start physical IO.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_FS</span></code> can call down to the low-level FS. Clearing the flag avoids the
allocator recursing into the filesystem which might already be holding
locks.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> indicates that the caller may enter direct reclaim.
This flag can be cleared to avoid unnecessary delays when a fallback
option is available.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_KSWAPD_RECLAIM</span></code> indicates that the caller wants to wake kswapd when
the low watermark is reached and have it reclaim pages until the high
watermark is reached. A caller may wish to clear this flag when fallback
options are available and the reclaim is likely to disrupt the system. The
canonical example is THP allocation where a fallback is cheap but
reclaim/compaction may cause indirect stalls.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_RECLAIM</span></code> is shorthand to allow/forbid both direct and kswapd reclaim.</p>
<p>The default allocator behavior depends on the request size. We have a concept
of so-called costly allocations (with order &gt; <code class="docutils literal notranslate"><span class="pre">PAGE_ALLOC_COSTLY_ORDER</span></code>).
!costly allocations are too essential to fail so they are implicitly
non-failing by default (with some exceptions like OOM victims might fail so
the caller still has to check for failures) while costly requests try to be
not disruptive and back off even without invoking the OOM killer.
The following three modifiers might be used to override some of these
implicit rules. Please note that all of them must be used along with
<code class="docutils literal notranslate"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> flag.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_NORETRY</span></code>: The VM implementation will try only very lightweight
memory direct reclaim to get some memory under memory pressure (thus
it can sleep). It will avoid disruptive actions like OOM killer. The
caller must handle the failure which is quite likely to happen under
heavy memory pressure. The flag is suitable when failure can easily be
handled at small cost, such as reduced throughput.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_RETRY_MAYFAIL</span></code>: The VM implementation will retry memory reclaim
procedures that have previously failed if there is some indication
that progress has been made elsewhere.  It can wait for other
tasks to attempt high-level approaches to freeing memory such as
compaction (which removes fragmentation) and page-out.
There is still a definite limit to the number of retries, but it is
a larger limit than with <code class="docutils literal notranslate"><span class="pre">__GFP_NORETRY</span></code>.
Allocations with this flag may fail, but only when there is
genuinely little unused memory. While these allocations do not
directly trigger the OOM killer, their failure indicates that
the system is likely to need to use the OOM killer soon.  The
caller must handle failure, but can reasonably do so by failing
a higher-level request, or completing it only in a much less
efficient manner.
If the allocation does fail, and the caller is in a position to
free some non-essential memory, doing so could benefit the system
as a whole.</p>
<p><code class="docutils literal notranslate"><span class="pre">__GFP_NOFAIL</span></code>: The VM implementation _must_ retry infinitely: the caller
cannot handle allocation failures. The allocation could block
indefinitely but will never return with failure. Testing for
failure is pointless.
It _must_ be blockable and used together with __GFP_DIRECT_RECLAIM.
It should _never_ be used in non-sleepable contexts.
New users should be evaluated carefully (and the flag should be
used only when there is no reasonable failure policy) but it is
definitely preferable to use the flag rather than opencode endless
loop around allocator.
Allocating pages from the buddy with __GFP_NOFAIL and order &gt; 1 is
not supported. Please consider using kvmalloc() instead.</p>
</section>
<section id="useful-gfp-flag-combinations">
<h3>Useful GFP flag combinations<a class="headerlink" href="#useful-gfp-flag-combinations" title="Link to this heading">¶</a></h3>
<p>Useful GFP flag combinations that are commonly used. It is recommended
that subsystems start with one of these combinations and then set/clear
<code class="docutils literal notranslate"><span class="pre">__GFP_FOO</span></code> flags as necessary.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code> users can not sleep and need the allocation to succeed. A lower
watermark is applied to allow access to “atomic reserves”.
The current implementation doesn’t support NMI and few other strict
non-preemptive contexts (e.g. raw_spin_lock). The same applies to <code class="docutils literal notranslate"><span class="pre">GFP_NOWAIT</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code> is typical for kernel-internal allocations. The caller requires
<code class="docutils literal notranslate"><span class="pre">ZONE_NORMAL</span></code> or a lower zone for direct access but can direct reclaim.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_KERNEL_ACCOUNT</span></code> is the same as GFP_KERNEL, except the allocation is
accounted to kmemcg.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_NOWAIT</span></code> is for kernel allocations that should not stall for direct
reclaim, start physical IO or use any filesystem callback.  It is very
likely to fail to allocate memory, even for very small allocations.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_NOIO</span></code> will use direct reclaim to discard clean pages or slab pages
that do not require the starting of any physical IO.
Please try to avoid using this flag directly and instead use
memalloc_noio_{save,restore} to mark the whole scope which cannot
perform any IO with a short explanation why. All allocation requests
will inherit GFP_NOIO implicitly.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_NOFS</span></code> will use direct reclaim but will not use any filesystem interfaces.
Please try to avoid using this flag directly and instead use
memalloc_nofs_{save,restore} to mark the whole scope which cannot/shouldn’t
recurse into the FS layer with a short explanation why. All allocation
requests will inherit GFP_NOFS implicitly.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_USER</span></code> is for userspace allocations that also need to be directly
accessibly by the kernel or hardware. It is typically used by hardware
for buffers that are mapped to userspace (e.g. graphics) that hardware
still must DMA to. cpuset limits are enforced for these allocations.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_DMA</span></code> exists for historical reasons and should be avoided where possible.
The flags indicates that the caller requires that the lowest zone be
used (<code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code> or 16M on x86-64). Ideally, this would be removed but
it would require careful auditing as some users really require it and
others use the flag to avoid lowmem reserves in <code class="docutils literal notranslate"><span class="pre">ZONE_DMA</span></code> and treat the
lowest zone as a type of emergency reserve.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_DMA32</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">GFP_DMA</span></code> except that the caller requires a 32-bit
address. Note that kmalloc(..., GFP_DMA32) does not return DMA32 memory
because the DMA32 kmalloc cache array is not implemented.
(Reason: there is no such user in kernel).</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_HIGHUSER</span></code> is for userspace allocations that may be mapped to userspace,
do not need to be directly accessible by the kernel but that cannot
move once in use. An example may be a hardware allocation that maps
data directly into userspace but has no addressing limitations.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_HIGHUSER_MOVABLE</span></code> is for userspace allocations that the kernel does not
need direct access to but can use <a class="reference internal" href="../mm/highmem.html#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> when access is required. They
are expected to be movable via page reclaim or page migration. Typically,
pages on the LRU would also be allocated with <code class="docutils literal notranslate"><span class="pre">GFP_HIGHUSER_MOVABLE</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">GFP_TRANSHUGE</span></code> and <code class="docutils literal notranslate"><span class="pre">GFP_TRANSHUGE_LIGHT</span></code> are used for THP allocations. They
are compound allocations that will generally fail quickly if memory is not
available and will not wake kswapd/kcompactd on failure. The _LIGHT
version does not attempt reclaim/compaction at all and is by default used
in page fault path, while the non-light is used by khugepaged.</p>
</section>
</section>
<section id="the-slab-cache">
<h2>The Slab Cache<a class="headerlink" href="#the-slab-cache" title="Link to this heading">¶</a></h2>
<dl class="c macro">
<dt class="sig sig-object c" id="c.SLAB_HWCACHE_ALIGN">
<span class="sig-name descname"><span class="n"><span class="pre">SLAB_HWCACHE_ALIGN</span></span></span><a class="headerlink" href="#c.SLAB_HWCACHE_ALIGN" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">SLAB_HWCACHE_ALIGN</span></code></p>
<blockquote>
<div><blockquote>
<div><p>Align objects on cache line boundaries.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>Sufficiently large objects are aligned on cache line boundary. For object
size smaller than a half of cache line size, the alignment is on the half of
cache line size. In general, if object size is smaller than 1/2^n of cache
line size, the alignment is adjusted to 1/2^n.</p>
<p>If explicit alignment is also requested by the respective
<a class="reference internal" href="#c.kmem_cache_args" title="kmem_cache_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache_args</span></code></a> field, the greater of both is alignments is applied.</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.SLAB_TYPESAFE_BY_RCU">
<span class="sig-name descname"><span class="n"><span class="pre">SLAB_TYPESAFE_BY_RCU</span></span></span><a class="headerlink" href="#c.SLAB_TYPESAFE_BY_RCU" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">SLAB_TYPESAFE_BY_RCU</span></code></p>
<blockquote>
<div><blockquote>
<div><p><strong>WARNING</strong> READ THIS!</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>This delays freeing the SLAB page by a grace period, it does _NOT_
delay object freeing. This means that if you do <a class="reference internal" href="#c.kmem_cache_free" title="kmem_cache_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_free()</span></code></a>
that memory location is free to be reused at any time. Thus it may
be possible to see another object there in the same RCU grace period.</p>
<p>This feature only ensures the memory location backing the object
stays valid, the trick to using this is relying on an independent
object validation pass. Something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>begin:
 rcu_read_lock();
 obj = lockless_lookup(key);
 if (obj) {
   if (!try_get_ref(obj)) // might fail for free objects
     rcu_read_unlock();
     goto begin;

   if (obj-&gt;key != key) { // not the object we expected
     put_ref(obj);
     rcu_read_unlock();
     goto begin;
   }
 }
rcu_read_unlock();
</pre></div>
</div>
<p>This is useful if we need to approach a kernel structure obliquely,
from its address obtained without the usual locking. We can lock
the structure to stabilize it and check it’s still at the given address,
only if we can be sure that the memory has not been meanwhile reused
for some other kind of object (which our subsystem’s lock might corrupt).</p>
<p>rcu_read_lock before reading the address, then rcu_read_unlock after
taking the spinlock within the structure expected at that address.</p>
<p>Note that object identity check has to be done <em>after</em> acquiring a
reference, therefore user has to ensure proper ordering for loads.
Similarly, when initializing objects allocated with SLAB_TYPESAFE_BY_RCU,
the newly allocated object has to be fully initialized <em>before</em> its
refcount gets initialized and proper ordering for stores is required.
refcount_{add|inc}_not_zero_acquire() and <a class="reference internal" href="../driver-api/basics.html#c.refcount_set_release" title="refcount_set_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_set_release()</span></code></a> are
designed with the proper fences required for reference counting objects
allocated with SLAB_TYPESAFE_BY_RCU.</p>
<p>Note that it is not possible to acquire a lock within a structure
allocated with SLAB_TYPESAFE_BY_RCU without first acquiring a reference
as described above.  The reason is that SLAB_TYPESAFE_BY_RCU pages
are not zeroed before being given to the slab, which means that any
locks must be initialized after each and every kmem_struct_alloc().
Alternatively, make the ctor passed to <a class="reference internal" href="#c.kmem_cache_create" title="kmem_cache_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_create()</span></code></a> initialize
the locks at page-allocation time, as is done in __i915_request_ctor(),
sighand_ctor(), and anon_vma_ctor().  Such a ctor permits readers
to safely acquire those ctor-initialized locks under <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>
protection.</p>
<p>Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.SLAB_ACCOUNT">
<span class="sig-name descname"><span class="n"><span class="pre">SLAB_ACCOUNT</span></span></span><a class="headerlink" href="#c.SLAB_ACCOUNT" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">SLAB_ACCOUNT</span></code></p>
<blockquote>
<div><blockquote>
<div><p>Account allocations to memcg.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>All object allocations from this cache will be memcg accounted, regardless of
__GFP_ACCOUNT being or not being passed to individual allocations.</p>
</div></blockquote>
<dl class="c macro">
<dt class="sig sig-object c" id="c.SLAB_RECLAIM_ACCOUNT">
<span class="sig-name descname"><span class="n"><span class="pre">SLAB_RECLAIM_ACCOUNT</span></span></span><a class="headerlink" href="#c.SLAB_RECLAIM_ACCOUNT" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">SLAB_RECLAIM_ACCOUNT</span></code></p>
<blockquote>
<div><blockquote>
<div><p>Objects are reclaimable.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>Use this flag for caches that have an associated shrinker. As a result, slab
pages are allocated with __GFP_RECLAIMABLE, which affects grouping pages by
mobility, and are accounted in SReclaimable counter in /proc/meminfo</p>
</div></blockquote>
<dl class="c struct">
<dt class="sig sig-object c" id="c.kmem_cache_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_args</span></span></span><a class="headerlink" href="#c.kmem_cache_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Less common arguments for <a class="reference internal" href="#c.kmem_cache_create" title="kmem_cache_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_create()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kmem_cache_args {
    unsigned int align;
    unsigned int useroffset;
    unsigned int usersize;
    unsigned int freeptr_offset;
    bool use_freeptr_offset;
    void (*ctor)(void *);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">align</span></code></dt><dd><p>The required alignment for the objects.</p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> means no specific alignment is requested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">useroffset</span></code></dt><dd><p>Usercopy region offset.</p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> is a valid offset, when <strong>usersize</strong> is non-<code class="docutils literal notranslate"><span class="pre">0</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usersize</span></code></dt><dd><p>Usercopy region size.</p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> means no usercopy region is specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freeptr_offset</span></code></dt><dd><p>Custom offset for the free pointer
in <a class="reference internal" href="#c.SLAB_TYPESAFE_BY_RCU" title="SLAB_TYPESAFE_BY_RCU"><code class="xref c c-type docutils literal notranslate"><span class="pre">SLAB_TYPESAFE_BY_RCU</span></code></a> caches</p>
<p>By default <a class="reference internal" href="#c.SLAB_TYPESAFE_BY_RCU" title="SLAB_TYPESAFE_BY_RCU"><code class="xref c c-type docutils literal notranslate"><span class="pre">SLAB_TYPESAFE_BY_RCU</span></code></a> caches place the free pointer
outside of the object. This might cause the object to grow in size.
Cache creators that have a reason to avoid this can specify a custom
free pointer offset in their struct where the free pointer will be
placed.</p>
<p>Note that placing the free pointer inside the object requires the
caller to ensure that no fields are invalidated that are required to
guard against object recycling (See <a class="reference internal" href="#c.SLAB_TYPESAFE_BY_RCU" title="SLAB_TYPESAFE_BY_RCU"><code class="xref c c-type docutils literal notranslate"><span class="pre">SLAB_TYPESAFE_BY_RCU</span></code></a> for
details).</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">0</span></code> as a value for <strong>freeptr_offset</strong> is valid. If <strong>freeptr_offset</strong>
is specified, <code class="docutils literal notranslate"><span class="pre">use_freeptr_offset</span></code> must be set <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Note that <strong>ctor</strong> currently isn’t supported with custom free pointers
as a <strong>ctor</strong> requires an external free pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_freeptr_offset</span></code></dt><dd><p>Whether a <strong>freeptr_offset</strong> is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctor</span></code></dt><dd><p>A constructor for the objects.</p>
<p>The constructor is invoked for each object in a newly allocated slab
page. It is the cache user’s responsibility to free object in the
same state as after calling the constructor, or deal appropriately
with any differences between a freshly constructed and a reallocated
object.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> means no constructor.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Any uninitialized fields of the structure are interpreted as unused. The
exception is <strong>freeptr_offset</strong> where <code class="docutils literal notranslate"><span class="pre">0</span></code> is a valid value, so
<strong>use_freeptr_offset</strong> must be also set to <code class="docutils literal notranslate"><span class="pre">true</span></code> in order to interpret the field
as used. For <strong>useroffset</strong> <code class="docutils literal notranslate"><span class="pre">0</span></code> is also valid, but only with non-<code class="docutils literal notranslate"><span class="pre">0</span></code>
<strong>usersize</strong>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">NULL</span></code> args is passed to <a class="reference internal" href="#c.kmem_cache_create" title="kmem_cache_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_create()</span></code></a>, it is equivalent to all
fields unused.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_create_usercopy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_create_usercopy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">slab_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">useroffset</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">usersize</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctor</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_create_usercopy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a kmem cache with a region suitable for copying to userspace.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>A string which is used in /proc/slabinfo to identify this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>The size of objects to be created in this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">align</span></code></dt><dd><p>The required alignment for the objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slab_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>SLAB flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">useroffset</span></code></dt><dd><p>Usercopy region offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">usersize</span></code></dt><dd><p>Usercopy region size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*ctor)(void</span> <span class="pre">*)</span></code></dt><dd><p>A constructor for the objects, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a legacy wrapper, new code should use either KMEM_CACHE_USERCOPY()
if whitelisting a single field is sufficient, or <a class="reference internal" href="#c.kmem_cache_create" title="kmem_cache_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_create()</span></code></a> with
the necessary parameters passed via the args parameter (see
<a class="reference internal" href="#c.kmem_cache_args" title="kmem_cache_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache_args</span></code></a>)</p>
<p><strong>Return</strong></p>
<p>a pointer to the cache on success, NULL on failure.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kmem_cache_create">
<span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_create</span></span></span><a class="headerlink" href="#c.kmem_cache_create" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kmem_cache_create</span> <span class="pre">(__name,</span> <span class="pre">__object_size,</span> <span class="pre">__args,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>Create a kmem cache.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__name</span></code></dt><dd><p>A string which is used in /proc/slabinfo to identify this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__object_size</span></code></dt><dd><p>The size of objects to be created in this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__args</span></code></dt><dd><p>Optional arguments, see <a class="reference internal" href="#c.kmem_cache_args" title="kmem_cache_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache_args</span></code></a>. Passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
means defaults will be used for all the arguments.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is currently implemented as a macro using <code class="docutils literal notranslate"><span class="pre">_Generic()</span></code> to call
either the new variant of the function, or a legacy one.</p>
<p>The new variant has 4 parameters:
<code class="docutils literal notranslate"><span class="pre">kmem_cache_create(name,</span> <span class="pre">object_size,</span> <span class="pre">args,</span> <span class="pre">flags)</span></code></p>
<p>See <a class="reference internal" href="#c.__kmem_cache_create_args" title="__kmem_cache_create_args"><code class="xref c c-func docutils literal notranslate"><span class="pre">__kmem_cache_create_args()</span></code></a> which implements this.</p>
<p>The legacy variant has 5 parameters:
<code class="docutils literal notranslate"><span class="pre">kmem_cache_create(name,</span> <span class="pre">object_size,</span> <span class="pre">align,</span> <span class="pre">flags,</span> <span class="pre">ctor)</span></code></p>
<p>The align and ctor parameters map to the respective fields of
<a class="reference internal" href="#c.kmem_cache_args" title="kmem_cache_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache_args</span></code></a></p>
<p><strong>Context</strong></p>
<p>Cannot be called within a interrupt, but can be interrupted.</p>
<p><strong>Return</strong></p>
<p>a pointer to the cache on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ksize">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ksize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ksize" title="Link to this definition">¶</a><br /></dt>
<dd><p>Report actual allocation size of associated object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*objp</span></code></dt><dd><p>Pointer returned from a prior <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>-family allocation.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should not be used for writing beyond the originally requested
allocation size. Either use krealloc() or round up the allocation size
with <a class="reference internal" href="#c.kmalloc_size_roundup" title="kmalloc_size_roundup"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc_size_roundup()</span></code></a> prior to allocation. If this is used to
access beyond the originally requested allocation size, UBSAN_BOUNDS
and/or FORTIFY_SOURCE may trip, since they only know about the
originally allocated size via the __alloc_size attribute.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cachep</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*cachep</span></code></dt><dd><p>The cache to allocate from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an object from this cache.
See kmem_cache_zalloc() for a shortcut of adding __GFP_ZERO to flags.</p>
<p><strong>Return</strong></p>
<p>pointer to the new object or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_charge">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_charge</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objp</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfpflags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_charge" title="Link to this definition">¶</a><br /></dt>
<dd><p>memcg charge an already allocated slab memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*objp</span></code></dt><dd><p>address of the slab object to memcg charge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfpflags</span></code></dt><dd><p>describe the allocation context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmem_cache_charge allows charging a slab object to the current memcg,
primarily in cases where charging at allocation time might not be possible
because the target memcg is not known (i.e. softirq context)</p>
<p>The objp should be pointer returned by the slab allocator functions like
kmalloc (with __GFP_ACCOUNT in flags) or kmem_cache_alloc. The memcg charge
behavior can be controlled through gfpflags parameter, which affects how the
necessary internal metadata can be allocated. Including __GFP_NOFAIL denotes
that overcharging is requested instead of failure, but is not applied for the
internal metadata allocation.</p>
<p>There are several cases where it will return true even if the charging was
not done:
More specifically:</p>
<ol class="arabic simple">
<li><p>For !CONFIG_MEMCG or cgroup_disable=memory systems.</p></li>
<li><p>Already charged slab objects.</p></li>
<li><p>For slab objects from KMALLOC_NORMAL caches - allocated by <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>
without __GFP_ACCOUNT</p></li>
<li><p>Allocating internal metadata has failed</p></li>
</ol>
<p><strong>Return</strong></p>
<p>true if charge was successful otherwise false.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate kernel memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>how many bytes of memory are required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>describe the allocation context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc is the normal method of allocating memory
for objects smaller than page size in the kernel.</p>
<p>The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN
bytes. For <strong>size</strong> of power of two bytes, the alignment is also guaranteed
to be at least to the size. For other sizes, the alignment is guaranteed to
be at least the largest power-of-two divisor of <strong>size</strong>.</p>
<p>The <strong>flags</strong> argument may be one of the GFP flags defined at
include/linux/gfp_types.h and described at
<a class="reference internal" href="#mm-api-gfp-flags"><span class="std std-ref">Documentation/core-api/mm-api.rst</span></a></p>
<p>The recommended usage of the <strong>flags</strong> is described at
<a class="reference internal" href="memory-allocation.html#memory-allocation"><span class="std std-ref">Documentation/core-api/memory-allocation.rst</span></a></p>
<p>Below is a brief outline of the most useful GFP flags</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code></dt><dd><p>Allocate normal kernel ram. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_NOWAIT</span></code></dt><dd><p>Allocation will not sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code></dt><dd><p>Allocation will not sleep.  May use emergency pools.</p>
</dd>
</dl>
<p>Also it is possible to set different flags by OR’ing
in one or more of the following additional <strong>flags</strong>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_ZERO</span></code></dt><dd><p>Zero the allocated memory before returning. Also see <a class="reference internal" href="#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_HIGH</span></code></dt><dd><p>This allocation has high priority and may use emergency pools.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_NOFAIL</span></code></dt><dd><p>Indicate that this allocation is in no way allowed to fail
(think twice before using).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_NORETRY</span></code></dt><dd><p>If memory is not immediately available,
then give up at once.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_NOWARN</span></code></dt><dd><p>If allocation fails, don’t issue any warnings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__GFP_RETRY_MAYFAIL</span></code></dt><dd><p>Try really hard to succeed the allocation but fail
eventually.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmalloc_array">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmalloc_array</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate memory for an array.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>number of elements.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>element size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc).</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.krealloc_array">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">krealloc_array</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_n</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.krealloc_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>reallocate memory for an array.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>pointer to the memory chunk to reallocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_n</span></code></dt><dd><p>new number of elements to alloc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_size</span></code></dt><dd><p>new size of a single member of the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If __GFP_ZERO logic is requested, callers must ensure that, starting with the
initial memory allocation, every subsequent call to this API for the same
memory allocation is flagged with __GFP_ZERO. Otherwise, it is possible that
__GFP_ZERO is not fully honored by this API.</p>
<p>See krealloc_noprof() for further details.</p>
<p>In any case, the contents of the object pointed to are preserved up to the
lesser of the new and old sizes.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kcalloc">
<span class="sig-name descname"><span class="n"><span class="pre">kcalloc</span></span></span><a class="headerlink" href="#c.kcalloc" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kcalloc</span> <span class="pre">(n,</span> <span class="pre">size,</span> <span class="pre">flags)</span></code></p>
<blockquote>
<div><p>allocate memory for an array. The memory is set to zero.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>number of elements.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>element size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc).</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kzalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kzalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate memory. The memory is set to zero.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>how many bytes of memory are required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>the type of memory to allocate (see kmalloc).</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmalloc_size_roundup">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmalloc_size_roundup</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc_size_roundup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Report allocation bucket size for the given size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Number of bytes to round up from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the number of bytes that would be available in a <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>
allocation of <strong>size</strong> bytes. For example, a 126 byte request would be
rounded up to the next sized kmalloc bucket, 128 bytes. (This is strictly
for the general-purpose <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>-based allocations, and is not for the
pre-sized <a class="reference internal" href="#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_alloc()</span></code></a>-based allocations.)</p>
<p>Use this to <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> the full bucket size ahead of time instead of using
<a class="reference internal" href="#c.ksize" title="ksize"><code class="xref c c-func docutils literal notranslate"><span class="pre">ksize()</span></code></a> to query the size after an allocation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>Deallocate an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*s</span></code></dt><dd><p>The cache the allocation was from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*x</span></code></dt><dd><p>The previously allocated object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free an object which was previously allocated from this
cache.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">object</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree" title="Link to this definition">¶</a><br /></dt>
<dd><p>free previously allocated memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*object</span></code></dt><dd><p>pointer returned by <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_alloc()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>object</strong> is NULL, no operation is performed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kvfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kvfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kvfree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to allocated memory.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>kvfree frees memory allocated by any of vmalloc(), <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or kvmalloc().
It is slightly more efficient to use <a class="reference internal" href="#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> or <a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfree()</span></code></a> if you are certain
that you know which one to use.</p>
<p><strong>Context</strong></p>
<p>Either preemptible task context or not-NMI interrupt.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kvfree_sensitive">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kvfree_sensitive</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kvfree_sensitive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free a data object containing sensitive information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>address of the data object to be freed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of the data object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the special <a class="reference internal" href="kernel-api.html#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal notranslate"><span class="pre">memzero_explicit()</span></code></a> function to clear the content of a
kvmalloc’ed object containing sensitive data to make sure that the
compiler won’t optimize out the data clearing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__kmem_cache_create_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__kmem_cache_create_args</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">object_size</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kmem_cache_args" title="kmem_cache_args"><span class="n"><span class="pre">kmem_cache_args</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="n"><span class="pre">slab_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__kmem_cache_create_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a kmem cache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>A string which is used in /proc/slabinfo to identify this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">object_size</span></code></dt><dd><p>The size of objects to be created in this cache.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache_args</span> <span class="pre">*args</span></code></dt><dd><p>Additional arguments for the cache creation (see
<a class="reference internal" href="#c.kmem_cache_args" title="kmem_cache_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache_args</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slab_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>See the desriptions of individual flags. The common ones are listed
in the description below.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not to be called directly, use the <a class="reference internal" href="#c.kmem_cache_create" title="kmem_cache_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_create()</span></code></a> wrapper with the same
parameters.</p>
<p>Commonly used <strong>flags</strong>:</p>
<p><a class="reference internal" href="#c.SLAB_ACCOUNT" title="SLAB_ACCOUNT"><code class="xref c c-type docutils literal notranslate"><span class="pre">SLAB_ACCOUNT</span></code></a> - Account allocations to memcg.</p>
<p><a class="reference internal" href="#c.SLAB_HWCACHE_ALIGN" title="SLAB_HWCACHE_ALIGN"><code class="xref c c-type docutils literal notranslate"><span class="pre">SLAB_HWCACHE_ALIGN</span></code></a> - Align objects on cache line boundaries.</p>
<p><a class="reference internal" href="#c.SLAB_RECLAIM_ACCOUNT" title="SLAB_RECLAIM_ACCOUNT"><code class="xref c c-type docutils literal notranslate"><span class="pre">SLAB_RECLAIM_ACCOUNT</span></code></a> - Objects are reclaimable.</p>
<p><a class="reference internal" href="#c.SLAB_TYPESAFE_BY_RCU" title="SLAB_TYPESAFE_BY_RCU"><code class="xref c c-type docutils literal notranslate"><span class="pre">SLAB_TYPESAFE_BY_RCU</span></code></a> - Slab page (not individual objects) freeing delayed
by a grace period - see the full description before using.</p>
<p><strong>Context</strong></p>
<p>Cannot be called within a interrupt, but can be interrupted.</p>
<p><strong>Return</strong></p>
<p>a pointer to the cache on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_buckets_create">
<span class="n"><span class="pre">kmem_buckets</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmem_buckets_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">slab_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">useroffset</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">usersize</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctor</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_buckets_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a set of caches that handle dynamic sized allocations via kmem_buckets_alloc()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>A prefix string which is used in /proc/slabinfo to identify this
cache. The individual caches with have their sizes as the suffix.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slab_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>SLAB flags (see <a class="reference internal" href="#c.kmem_cache_create" title="kmem_cache_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_create()</span></code></a> for details).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">useroffset</span></code></dt><dd><p>Starting offset within an allocation that may be copied
to/from userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">usersize</span></code></dt><dd><p>How many bytes, starting at <strong>useroffset</strong>, may be copied
to/from userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*ctor)(void</span> <span class="pre">*)</span></code></dt><dd><p>A constructor for the objects, run when new allocations are made.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cannot be called within an interrupt, but can be interrupted.</p>
<p><strong>Return</strong></p>
<p>a pointer to the cache on success, NULL on failure. When
CONFIG_SLAB_BUCKETS is not enabled, ZERO_SIZE_PTR is returned, and
subsequent calls to kmem_buckets_alloc() will fall back to <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>.
(i.e. callers only need to check for NULL on failure.)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_cache_shrink">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_cache_shrink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cachep</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_shrink" title="Link to this definition">¶</a><br /></dt>
<dd><p>Shrink a cache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*cachep</span></code></dt><dd><p>The cache to shrink.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases as many slabs as possible for a cache.
To help debugging, a zero exit status indicates all slabs were released.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> if all slabs were released, non-zero otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmem_dump_obj">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmem_dump_obj</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">object</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_dump_obj" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print available slab provenance information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*object</span></code></dt><dd><p>slab object for which to find provenance information.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function uses <a class="reference internal" href="printk-basics.html#c.pr_cont" title="pr_cont"><code class="xref c c-func docutils literal notranslate"><span class="pre">pr_cont()</span></code></a>, so that the caller is expected to have
printed out whatever preamble is appropriate.  The provenance information
depends on the type of object and on how much debugging is enabled.
For a slab-cache object, the fact that it is a slab object is printed,
and, if available, the slab name, return address, and stack trace from
the allocation and last free path of that object.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the pointer is to a not-yet-freed object from
<a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_alloc()</span></code></a>, either <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> if the pointer
is to an already-freed object, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfree_sensitive">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree_sensitive</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_sensitive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear sensitive information in memory before freeing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>object to free memory of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The memory of the object <strong>p</strong> points to is zeroed before freed.
If <strong>p</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <a class="reference internal" href="#c.kfree_sensitive" title="kfree_sensitive"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_sensitive()</span></code></a> does nothing.</p>
<p><strong>Note</strong></p>
<p>this function zeroes the whole allocated buffer which can be a good
deal bigger than the requested buffer size passed to <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>. So be
careful when using this function in performance sensitive code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kvfree_rcu_barrier">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kvfree_rcu_barrier</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kvfree_rcu_barrier" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait until all in-flight kvfree_rcu() complete.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that a single argument of kvfree_rcu() call has a slow path that
triggers <a class="reference internal" href="kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> following by freeing a pointer. It is done
before the return from the function. Therefore for any single-argument
call that will result in a <a class="reference internal" href="#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> to a cache that is to be destroyed
during module exit, it is developer’s responsibility to ensure that all
such calls have returned before the call to kmem_cache_destroy().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfree_const">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree_const</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_const" title="Link to this definition">¶</a><br /></dt>
<dd><p>conditionally free memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*x</span></code></dt><dd><p>pointer to the memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function calls kfree only if <strong>x</strong> is not in .rodata section.</p>
</div>
</section>
<section id="virtually-contiguous-mappings">
<h2>Virtually Contiguous Mappings<a class="headerlink" href="#virtually-contiguous-mappings" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_unmap_aliases">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_unmap_aliases</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_aliases" title="Link to this definition">¶</a><br /></dt>
<dd><p>unmap outstanding lazy aliases in the vmap layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vmap/vmalloc layer lazily flushes kernel virtual mappings primarily
to amortize TLB flushing overheads. What this means is that any page you
have now, may, in a former life, have been mapped into kernel virtual
address by the vmap layer and so there might be some CPUs with TLB entries
still referencing that page (additional to the regular 1:1 kernel mapping).</p>
<p>vm_unmap_aliases flushes all such lazy mappings. After it returns, we can
be sure that none of the pages we have control over will have any aliases
from the vmap layer.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_unmap_ram">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_unmap_ram</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mem</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_ram" title="Link to this definition">¶</a><br /></dt>
<dd><p>unmap linear kernel address space set up by vm_map_ram</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*mem</span></code></dt><dd><p>the pointer returned by vm_map_ram</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the count passed to that vm_map_ram call (cannot unmap partial)</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_map_ram">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vm_map_ram</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_ram" title="Link to this definition">¶</a><br /></dt>
<dd><p>map pages linearly into kernel virtual address (vmalloc space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>an array of pointers to the pages to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>prefer to allocate data structures on this node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you use this function for less than VMAP_MAX_ALLOC pages, it could be
faster than vmap so it’s good.  But if you mix long-life and short-life
objects with <a class="reference internal" href="#c.vm_map_ram" title="vm_map_ram"><code class="xref c c-func docutils literal notranslate"><span class="pre">vm_map_ram()</span></code></a>, it could consume lots of address space through
fragmentation (especially on a 32bit machine).  You could see failures in
the end.  Please use this function for short-lived objects.</p>
<p><strong>Return</strong></p>
<p>a pointer to the address that has been mapped, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vfree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release memory allocated by vmalloc()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>Memory base address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the virtually continuous memory area starting at <strong>addr</strong>, as obtained
from one of the vmalloc() family of APIs.  This will usually also free the
physical memory underlying the virtual allocation, but that memory is
reference counted, so it will not be freed until the last user goes away.</p>
<p>If <strong>addr</strong> is NULL, no operation is performed.</p>
<p><strong>Context</strong></p>
<p>May sleep if called <em>not</em> from interrupt context.
Must not be called in NMI context (strictly speaking, it could be
if we have CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG, but making the calling
conventions for <a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfree()</span></code></a> arch-dependent would be a really bad idea).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vunmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vunmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vunmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>release virtual mapping obtained by <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>memory base address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the virtually contiguous memory area starting at <strong>addr</strong>,
which was created from the page array passed to <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a>.</p>
<p>Must not be called in interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>map an array of pages into virtually contiguous space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>array of page pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pages to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>vm_area-&gt;flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt><dd><p>page protection for the mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps <strong>count</strong> pages from <strong>pages</strong> into contiguous kernel virtual space.
If <strong>flags</strong> contains <code class="docutils literal notranslate"><span class="pre">VM_MAP_PUT_PAGES</span></code> the ownership of the pages array itself
(which must be kmalloc or vmalloc memory) and one reference per pages in it
are transferred from the caller to <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a>, and will be freed / dropped when
<a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfree()</span></code></a> is called on the return value.</p>
<p><strong>Return</strong></p>
<p>the address of the area or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmap_pfn">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmap_pfn</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pfns</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmap_pfn" title="Link to this definition">¶</a><br /></dt>
<dd><p>map an array of PFNs into virtually contiguous space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*pfns</span></code></dt><dd><p>array of PFNs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pages to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt><dd><p>page protection for the mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps <strong>count</strong> PFNs from <strong>pfns</strong> into contiguous kernel virtual space and returns
the start address of the mapping.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.remap_vmalloc_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">remap_vmalloc_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pgoff</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_vmalloc_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>map vmalloc pages to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vma to cover (map full range of vma)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>vmalloc memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt><dd><p>number of pages into addr before first page to map</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -Exxx on failure</p>
<p><strong>Description</strong></p>
<p>This function checks that addr is a valid vmalloc’ed area, and
that it is big enough to cover the vma. Will return failure if
that criteria isn’t met.</p>
<p>Similar to <a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">remap_pfn_range()</span></code></a> (see mm/memory.c)</p>
</div>
</section>
<section id="file-mapping-and-page-cache">
<h2>File Mapping and Page Cache<a class="headerlink" href="#file-mapping-and-page-cache" title="Link to this heading">¶</a></h2>
<section id="filemap">
<h3>Filemap<a class="headerlink" href="#filemap" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawrite_wbc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawrite_wbc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawrite_wbc" title="Link to this definition">¶</a><br /></dt>
<dd><p>start writeback on mapping dirty pages in range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>the writeback_control controlling the writeout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call writepages on the mapping using the provided wbc to control the
writeout.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawrite_range_kick">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawrite_range_kick</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawrite_range_kick" title="Link to this definition">¶</a><br /></dt>
<dd><p>start writeback on a range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>target address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>index to start writeback on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt><dd><p>last (inclusive) index for writeback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a non-integrity writeback helper, to start writing back folios
for the indicated range.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_flush">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_flush</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_flush" title="Link to this definition">¶</a><br /></dt>
<dd><p>mostly a non-blocking flush</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>target address_space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a mostly non-blocking flush.  Not suitable for data-integrity
purposes - I/O may not be started against all dirty pages.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_range_has_page">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_range_has_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_range_has_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if a page exists in range.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space within which to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find at least one page in the range supplied, usually used to check if
direct writing in this range will trigger a writeback.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if at least one page exists in the specified range,
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawait_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawait_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
in the given range and wait for all of them.  Check error status of
the address space and return it.</p>
<p>Since the error status of the address space is cleared by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<p><strong>Return</strong></p>
<p>error status of the address space.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawait_range_keep_errors">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawait_range_keep_errors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_range_keep_errors" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space in the
given range and wait for all of them.  Unlike <a class="reference internal" href="#c.filemap_fdatawait_range" title="filemap_fdatawait_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_fdatawait_range()</span></code></a>,
this function does not clear error status of the address space.</p>
<p>Use this function if callers don’t handle errors themselves.  Expected
call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
fsfreeze(8)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.file_fdatawait_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">file_fdatawait_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.file_fdatawait_range" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.file_fdatawait_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file pointing to address space structure to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the address space that file
refers to, in the given range and wait for all of them.  Check error
status of the address space vs. the file-&gt;f_wb_err cursor and return it.</p>
<p>Since the error status of the file is advanced by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<p><strong>Return</strong></p>
<p>error status of the address space vs. the file-&gt;f_wb_err cursor.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fdatawait_keep_errors">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fdatawait_keep_errors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_keep_errors" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for writeback without clearing errors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
and wait for all of them.  Unlike filemap_fdatawait(), this function
does not clear error status of the address space.</p>
<p>Use this function if callers don’t handle errors themselves.  Expected
call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
fsfreeze(8)</p>
<p><strong>Return</strong></p>
<p>error status of the address space.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_write_and_wait_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_write_and_wait_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_write_and_wait_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space for the pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<p><strong>Return</strong></p>
<p>error status of the address space.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.file_check_and_advance_wb_err">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">file_check_and_advance_wb_err</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.file_check_and_advance_wb_err" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.file_check_and_advance_wb_err" title="Link to this definition">¶</a><br /></dt>
<dd><p>report wb error (if any) that was previously and advance wb_err to current one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p><a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a> on which the error is being reported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When userland calls fsync (or something like nfsd does the equivalent), we
want to report any writeback errors that occurred since the last fsync (or
since the file was opened if there haven’t been any).</p>
<p>Grab the wb_err from the mapping. If it matches what we have in the file,
then just quickly return 0. The file is all caught up.</p>
<p>If it doesn’t match, then take the mapping value, set the “seen” flag in
it and try to swap it into place. If it works, or another task beat us
to it with the new value, then update the f_wb_err and return the error
portion. The error at this point must be reported via proper channels
(a’la fsync, or NFS COMMIT operation, etc.).</p>
<p>While we handle mapping-&gt;wb_err with atomic operations, the f_wb_err
value is protected by the f_lock since we must ensure that it reflects
the latest value swapped in for this file descriptor.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.file_write_and_wait_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">file_write_and_wait_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.file_write_and_wait_range" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.file_write_and_wait_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file pointing to address_space with pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<p>After writing out and waiting on the data, we check and advance the
f_wb_err cursor to the latest value, and return any errors detected there.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.replace_page_cache_folio">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">replace_page_cache_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.replace_page_cache_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>replace a pagecache folio with a new one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*old</span></code></dt><dd><p>folio to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*new</span></code></dt><dd><p>folio to replace with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function replaces a folio in the pagecache with a new one.  On
success it acquires the pagecache reference for the new folio and
drops it for the old folio.  Both the old and new folios must be
locked.  This function does not add the new folio to the LRU, the
caller must do that.</p>
<p>The remove + add is atomic.  This function cannot fail.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_unlock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_unlock" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_unlock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unlock a locked folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the folio and wakes up any thread sleeping on the page lock.</p>
<p><strong>Context</strong></p>
<p>May be called from interrupt or process context.  May not be
called from NMI context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_end_read">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_end_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_end_read" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">success</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_end_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>End read on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">success</span></code></dt><dd><p>True if all reads completed successfully.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When all reads against a folio have completed, filesystems should
call this function to let the pagecache know that no more reads
are outstanding.  This will unlock the folio and wake up any thread
sleeping on the lock.  The folio will also be marked uptodate if all
reads succeeded.</p>
<p><strong>Context</strong></p>
<p>May be called from interrupt or process context.  May not be
called from NMI context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_end_private_2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_end_private_2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_end_private_2" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_end_private_2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear PG_private_2 and wake any waiters.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear the PG_private_2 bit on a folio and wake up any sleepers waiting for
it.  The folio reference held for PG_private_2 being set is released.</p>
<p>This is, for example, used when a netfs folio is being written to a local
disk cache, thereby allowing writes to the cache for the same folio to be
serialised.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_private_2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_private_2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_private_2" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_private_2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait for PG_private_2 to be cleared on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for PG_private_2 to be cleared on a folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_private_2_killable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_private_2_killable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_private_2_killable" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_private_2_killable" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait for PG_private_2 to be cleared on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for PG_private_2 to be cleared on a folio or until a fatal signal is
received by the calling task.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0 if successful.</p></li>
<li><p>-EINTR if a fatal signal was encountered.</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_end_writeback">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_end_writeback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_end_writeback" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_end_writeback" title="Link to this definition">¶</a><br /></dt>
<dd><p>End writeback against a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The folio must actually be under writeback.</p>
<p><strong>Context</strong></p>
<p>May be called from process or interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__folio_lock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__folio_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__folio_lock" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__folio_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a lock on the folio, assuming we need to sleep to get it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to lock</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_next_miss">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_next_miss</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max_scan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_next_miss" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the next gap in the page cache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>Mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>Index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt><dd><p>Maximum range to search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the range [index, min(index + max_scan - 1, ULONG_MAX)] for the
gap with the lowest index.</p>
<p>This function may be called under the rcu_read_lock.  However, this will
not atomically search a snapshot of the cache at a single point in time.
For example, if a gap is created at index 5, then subsequently a gap is
created at index 10, page_cache_next_miss covering both indices may
return 10 if called under the rcu_read_lock.</p>
<p><strong>Return</strong></p>
<p>The index of the gap if found, otherwise an index outside the
range specified (in which case ‘return - index &gt;= max_scan’ will be true).
In the rare case of index wrap-around, 0 will be returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_prev_miss">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_prev_miss</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max_scan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_prev_miss" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the previous gap in the page cache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>Mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>Index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt><dd><p>Maximum range to search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the range [max(index - max_scan + 1, 0), index] for the
gap with the highest index.</p>
<p>This function may be called under the rcu_read_lock.  However, this will
not atomically search a snapshot of the cache at a single point in time.
For example, if a gap is created at index 10, then subsequently a gap is
created at index 5, <a class="reference internal" href="#c.page_cache_prev_miss" title="page_cache_prev_miss"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_prev_miss()</span></code></a> covering both indices may
return 5 if called under the rcu_read_lock.</p>
<p><strong>Return</strong></p>
<p>The index of the gap if found, otherwise an index outside the
range specified (in which case ‘index - return &gt;= max_scan’ will be true).
In the rare case of wrap-around, ULONG_MAX will be returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__filemap_get_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__filemap_get_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <a class="reference internal" href="#c.fgf_t" title="fgf_t"><span class="n"><span class="pre">fgf_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">fgp_flags</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__filemap_get_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find and get a reference to a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fgf_t</span> <span class="pre">fgp_flags</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">FGP</span></code> flags modify how the folio is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags to use if <code class="docutils literal notranslate"><span class="pre">FGP_CREAT</span></code> is specified.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>mapping</strong> &amp; <strong>index</strong>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">FGP_LOCK</span></code> or <code class="docutils literal notranslate"><span class="pre">FGP_CREAT</span></code> are specified then the function may sleep even
if the <code class="docutils literal notranslate"><span class="pre">GFP</span></code> flags specified for <code class="docutils literal notranslate"><span class="pre">FGP_CREAT</span></code> are atomic.</p>
<p>If this function returns a folio, it is returned with an increased refcount.</p>
<p><strong>Return</strong></p>
<p>The found folio or an <a class="reference internal" href="kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_get_folios">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_get_folios</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_batch</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fbatch</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_get_folios" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a batch of folios</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">*start</span></code></dt><dd><p>The starting page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>The final page index (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_batch</span> <span class="pre">*fbatch</span></code></dt><dd><p>The batch to fill.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for and return a batch of folios in the mapping starting at
index <strong>start</strong> and up to index <strong>end</strong> (inclusive).  The folios are returned
in <strong>fbatch</strong> with an elevated reference count.</p>
<p><strong>Return</strong></p>
<p>The number of folios which were found.
We also update <strong>start</strong> to index the next folio for the traversal.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_get_folios_contig">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_get_folios_contig</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_batch</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fbatch</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_get_folios_contig" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a batch of contiguous folios</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">*start</span></code></dt><dd><p>The starting page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>The final page index (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_batch</span> <span class="pre">*fbatch</span></code></dt><dd><p>The batch to fill</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.filemap_get_folios_contig" title="filemap_get_folios_contig"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_get_folios_contig()</span></code></a> works exactly like <a class="reference internal" href="#c.filemap_get_folios" title="filemap_get_folios"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_get_folios()</span></code></a>,
except the returned folios are guaranteed to be contiguous. This may
not return all contiguous folios if the batch gets filled up.</p>
<p><strong>Return</strong></p>
<p>The number of folios found.
Also update <strong>start</strong> to be positioned for traversal of the next folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_get_folios_tag">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_get_folios_tag</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="n"><span class="pre">xa_mark_t</span></span><span class="w"> </span><span class="n"><span class="pre">tag</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_batch</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fbatch</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_get_folios_tag" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a batch of folios matching <strong>tag</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">*start</span></code></dt><dd><p>The starting page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>The final page index (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xa_mark_t</span> <span class="pre">tag</span></code></dt><dd><p>The tag index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_batch</span> <span class="pre">*fbatch</span></code></dt><dd><p>The batch to fill</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The first folio may start before <strong>start</strong>; if it does, it will contain
<strong>start</strong>.  The final folio may extend beyond <strong>end</strong>; if it does, it will
contain <strong>end</strong>.  The folios have ascending indices.  There may be gaps
between the folios if there are indices which have no folio in the
page cache.  If folios are added to or removed from the page cache
while this is running, they may or may not be found by this call.
Only returns folios that are tagged with <strong>tag</strong>.</p>
<p><strong>Return</strong></p>
<p>The number of folios found.
Also update <strong>start</strong> to index the next folio for traversal.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_read">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span>, <span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="n"><span class="pre">already_read</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read data from the page cache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>The iocb to read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>Destination for the data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">already_read</span></code></dt><dd><p>Number of bytes already read by the caller.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data from the page cache.  If the data is not currently present,
uses the readahead and read_folio address_space operations to fetch it.</p>
<p><strong>Return</strong></p>
<p>Total number of bytes copied, including those already read by
the caller.  If an error happens before any bytes are copied, returns
a negative error number.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_file_read_iter">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_file_read_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_read_iter" title="Link to this definition">¶</a><br /></dt>
<dd><p>generic filesystem read routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>kernel I/O control block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>destination for the data read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the “read_iter()” routine for all filesystems
that can use the page cache directly.</p>
<p>The IOCB_NOWAIT flag in iocb-&gt;ki_flags indicates that -EAGAIN shall
be returned when no data can be read without waiting for I/O requests
to complete; it doesn’t prevent readahead.</p>
<p>The IOCB_NOIO flag in iocb-&gt;ki_flags indicates that no new I/O
requests shall be made for the read or for readahead.  When no data
can be read, -EAGAIN shall be returned.  When readahead would be
triggered, a partial, possibly empty read shall be returned.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>number of bytes copied, even for partial reads</p></li>
<li><p>negative error code (or 0 if IOCB_NOIO) if nothing was read</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_splice_read">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_splice_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">in</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ppos</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/splice.html#c.pipe_inode_info" title="pipe_inode_info"><span class="n"><span class="pre">pipe_inode_info</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pipe</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_splice_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>Splice data from a file’s pagecache into a pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*in</span></code></dt><dd><p>The file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>Pointer to the file position to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*pipe</span></code></dt><dd><p>The pipe to splice into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The amount to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>The SPLICE_F_* flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets folios from a file’s pagecache and splices them into the
pipe.  Readahead will be called as necessary to fill more folios.  This may
be used for blockdevs also.</p>
<p><strong>Return</strong></p>
<p>On success, the number of bytes read will be returned and <strong>*ppos</strong>
will be updated if appropriate; 0 will be returned if there is no more data
to be read; -EAGAIN will be returned if the pipe had no space, and some
other negative error code will be returned on error.  A short read may occur
if the pipe has insufficient space, we reach the end of the data or we hit a
hole.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_fault">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_fault</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_fault</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vmf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fault" title="Link to this definition">¶</a><br /></dt>
<dd><p>read in file data for page fault handling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*vmf</span></code></dt><dd><p>struct vm_fault containing details of the fault</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.filemap_fault" title="filemap_fault"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_fault()</span></code></a> is invoked via the vma operations vector for a
mapped memory region to read in file data during a page fault.</p>
<p>The goto’s are kind of ugly, but this streamlines the normal case of having
it in the page cache, and handles the special cases reasonably without
having a lot of duplicated code.</p>
<p>vma-&gt;vm_mm-&gt;mmap_lock must be held on entry.</p>
<p>If our return value has VM_FAULT_RETRY set, it’s because the mmap_lock
may be dropped before doing I/O or by lock_folio_maybe_drop_mmap().</p>
<p>If our return value does not have VM_FAULT_RETRY set, the mmap_lock
has not been released.</p>
<p>We never return with VM_FAULT_RETRY and a bit from VM_FAULT_ERROR set.</p>
<p><strong>Return</strong></p>
<p>bitwise-OR of <code class="docutils literal notranslate"><span class="pre">VM_FAULT_</span></code> codes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.read_cache_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">read_cache_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="n"><span class="pre">filler_t</span></span><span class="w"> </span><span class="n"><span class="pre">filler</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.read_cache_folio" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read into page cache, fill it if needed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to read from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The index to read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filler_t</span> <span class="pre">filler</span></code></dt><dd><p>Function to perform the read, or NULL to use aops-&gt;read_folio().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>Passed to filler function, may be NULL if not required.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read one page into the page cache.  If it succeeds, the folio returned
will contain <strong>index</strong>, but it may not be the first page of the folio.</p>
<p>If the filler function returns an error, it will be returned to the
caller.</p>
<p><strong>Context</strong></p>
<p>May sleep.  Expects mapping-&gt;invalidate_lock to be held.</p>
<p><strong>Return</strong></p>
<p>An uptodate folio on success, <a class="reference internal" href="kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mapping_read_folio_gfp">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mapping_read_folio_gfp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mapping_read_folio_gfp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read into page cache, using specified allocation flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space for the folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The index that the allocated folio will contain.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The page allocator flags to use if allocating.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as “read_cache_folio(mapping, index, NULL, NULL)”, but with
any new memory allocations done using the specified allocation flags.</p>
<p>The most likely error from this function is EIO, but ENOMEM is
possible and so is EINTR.  If -&gt;read_folio returns another error,
that will be returned to the caller.</p>
<p>The function expects mapping-&gt;invalidate_lock to be already held.</p>
<p><strong>Return</strong></p>
<p>Uptodate folio on success, <a class="reference internal" href="kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.read_cache_page_gfp">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">read_cache_page_gfp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page_gfp" title="Link to this definition">¶</a><br /></dt>
<dd><p>read into page cache, using specified page allocation flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the page’s address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the page allocator flags to use if allocating</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as “read_mapping_page(mapping, index, NULL)”, but with
any new page allocations done using the specified allocation flags.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<p>The function expects mapping-&gt;invalidate_lock to be already held.</p>
<p><strong>Return</strong></p>
<p>up to date page on success, <a class="reference internal" href="kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__generic_file_write_iter">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__generic_file_write_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__generic_file_write_iter" title="Link to this definition">¶</a><br /></dt>
<dd><p>write data to a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>IO state structure (file, offset, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*from</span></code></dt><dd><p>iov_iter with data to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does all the work needed for actually writing data to a
file. It does all basic checks, removes SUID from the file, updates
modification times and calls proper subroutines depending on whether we
do direct IO or a standard buffered write.</p>
<p>It expects i_rwsem to be grabbed unless we work on a block device or similar
object which does not need locking at all.</p>
<p>This function does <em>not</em> take care of syncing data in case of O_SYNC write.
A caller has to handle it. This is mainly due to the fact that we want to
avoid syncing under i_rwsem.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>number of bytes written, even for truncated writes</p></li>
<li><p>negative error code if no data has been written at all</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_file_write_iter">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_file_write_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kiocb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iocb</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_write_iter" title="Link to this definition">¶</a><br /></dt>
<dd><p>write data to a file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*iocb</span></code></dt><dd><p>IO state structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*from</span></code></dt><dd><p>iov_iter with data to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a wrapper around <a class="reference internal" href="#c.__generic_file_write_iter" title="__generic_file_write_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">__generic_file_write_iter()</span></code></a> to be used by most
filesystems. It takes care of syncing the file in case of O_SYNC file
and acquires i_rwsem as needed.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>negative error code if no data has been written at all of
<a class="reference internal" href="../filesystems/api-summary.html#c.vfs_fsync_range" title="vfs_fsync_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfs_fsync_range()</span></code></a> failed for a synchronous write</p></li>
<li><p>number of bytes written, even for truncated writes</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_release_folio">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_release_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.filemap_release_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_release_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release fs-specific metadata on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio which the kernel is trying to free.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags (and I/O mode).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The address_space is trying to release any data attached to a folio
(presumably at folio-&gt;private).</p>
<p>This will also be called if the private_2 flag is set on a page,
indicating that the folio has other metadata associated with it.</p>
<p>The <strong>gfp</strong> argument specifies whether I/O may be performed to release
this page (__GFP_IO), and whether the call may block
(__GFP_RECLAIM &amp; __GFP_FS).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the release was successful, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_invalidate_inode">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_invalidate_inode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.filemap_invalidate_inode" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">flush</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_invalidate_inode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Invalidate/forcibly write back a range of an inode’s pagecache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode to flush</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">flush</span></code></dt><dd><p>Set to write back rather than simply invalidate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>First byte to in range.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt><dd><p>Last byte in range (inclusive), or LLONG_MAX for everything from start
onwards.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invalidate all the folios on an inode that contribute to the specified
range, possibly writing them back first.  Whilst the operation is
undertaken, the invalidate lock is held to prevent new folios from being
installed.</p>
</div>
</section>
<section id="readahead">
<h3>Readahead<a class="headerlink" href="#readahead" title="Link to this heading">¶</a></h3>
<p>Readahead is used to read content into the page cache before it is
explicitly requested by the application.  Readahead only ever
attempts to read folios that are not yet in the page cache.  If a
folio is present but not up-to-date, readahead will not try to read
it. In that case a simple -&gt;read_folio() will be requested.</p>
<p>Readahead is triggered when an application read request (whether a
system call or a page fault) finds that the requested folio is not in
the page cache, or that it is in the page cache and has the
readahead flag set.  This flag indicates that the folio was read
as part of a previous readahead request and now that it has been
accessed, it is time for the next readahead.</p>
<p>Each readahead request is partly synchronous read, and partly async
readahead.  This is reflected in the <a class="reference internal" href="../filesystems/api-summary.html#c.file_ra_state" title="file_ra_state"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_ra_state</span></code></a> which
contains -&gt;size being the total number of pages, and -&gt;async_size
which is the number of pages in the async section.  The readahead
flag will be set on the first folio in this async section to trigger
a subsequent readahead.  Once a series of sequential reads has been
established, there should be no need for a synchronous component and
all readahead request will be fully asynchronous.</p>
<p>When either of the triggers causes a readahead, three numbers need
to be determined: the start of the region to read, the size of the
region, and the size of the async tail.</p>
<p>The start of the region is simply the first page address at or after
the accessed address, which is not currently populated in the page
cache.  This is found with a simple search in the page cache.</p>
<p>The size of the async tail is determined by subtracting the size that
was explicitly requested from the determined request size, unless
this would be less than zero - then zero is used.  NOTE THIS
CALCULATION IS WRONG WHEN THE START OF THE REGION IS NOT THE ACCESSED
PAGE.  ALSO THIS CALCULATION IS NOT USED CONSISTENTLY.</p>
<p>The size of the region is normally determined from the size of the
previous readahead which loaded the preceding pages.  This may be
discovered from the <a class="reference internal" href="../filesystems/api-summary.html#c.file_ra_state" title="file_ra_state"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_ra_state</span></code></a> for simple sequential reads,
or from examining the state of the page cache when multiple
sequential reads are interleaved.  Specifically: where the readahead
was triggered by the readahead flag, the size of the previous
readahead is assumed to be the number of pages from the triggering
page to the start of the new readahead.  In these cases, the size of
the previous readahead is scaled, often doubled, for the new
readahead, though see get_next_ra_size() for details.</p>
<p>If the size of the previous read cannot be determined, the number of
preceding pages in the page cache is used to estimate the size of
a previous read.  This estimate could easily be misled by random
reads being coincidentally adjacent, so it is ignored unless it is
larger than the current request, and it is not scaled up, unless it
is at the start of file.</p>
<p>In general readahead is accelerated at the start of the file, as
reads from there are often sequential.  There are other minor
adjustments to the readahead size in various special cases and these
are best discovered by reading the code.</p>
<p>The above calculation, based on the previous readahead size,
determines the size of the readahead, to which any requested read
size may be added.</p>
<p>Readahead requests are sent to the filesystem using the -&gt;readahead()
address space operation, for which <a class="reference internal" href="../filesystems/api-summary.html#c.mpage_readahead" title="mpage_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">mpage_readahead()</span></code></a> is a canonical
implementation.  -&gt;readahead() should normally initiate reads on all
folios, but may fail to read any or all folios without causing an I/O
error.  The page cache reading code will issue a -&gt;read_folio() request
for any folio which -&gt;readahead() did not read, and only an error
from this will be final.</p>
<p>-&gt;readahead() will generally call <a class="reference internal" href="#c.readahead_folio" title="readahead_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">readahead_folio()</span></code></a> repeatedly to get
each folio from those prepared for readahead.  It may fail to read a
folio by:</p>
<ul class="simple">
<li><p>not calling <a class="reference internal" href="#c.readahead_folio" title="readahead_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">readahead_folio()</span></code></a> sufficiently many times, effectively
ignoring some folios, as might be appropriate if the path to
storage is congested.</p></li>
<li><p>failing to actually submit a read request for a given folio,
possibly due to insufficient resources, or</p></li>
<li><p>getting an error during subsequent processing of a request.</p></li>
</ul>
<p>In the last two cases, the folio should be unlocked by the filesystem
to indicate that the read attempt has failed.  In the first case the
folio will be unlocked by the VFS.</p>
<p>Those folios not in the final <code class="docutils literal notranslate"><span class="pre">async_size</span></code> of the request should be
considered to be important and -&gt;readahead() should not fail them due
to congestion or temporary resource unavailability, but should wait
for necessary resources (e.g.  memory or indexing information) to
become available.  Folios in the final <code class="docutils literal notranslate"><span class="pre">async_size</span></code> may be
considered less urgent and failure to read them is more acceptable.
In this case it is best to use filemap_remove_folio() to remove the
folios from the page cache as is automatically done for folios that
were not fetched with <a class="reference internal" href="#c.readahead_folio" title="readahead_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">readahead_folio()</span></code></a>.  This will allow a
subsequent synchronous readahead request to try them again.  If they
are left in the page cache, then they will be read individually using
-&gt;read_folio() which may be less efficient.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_ra_unbounded">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_ra_unbounded</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ractl</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr_to_read</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">lookahead_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_ra_unbounded" title="Link to this definition">¶</a><br /></dt>
<dd><p>Start unchecked readahead.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>Readahead control.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr_to_read</span></code></dt><dd><p>The number of pages to read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">lookahead_size</span></code></dt><dd><p>Where to start the next readahead.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is for filesystems to call when they want to start
readahead beyond a file’s stated i_size.  This is almost certainly
not the function you want to call.  Use <a class="reference internal" href="#c.page_cache_async_readahead" title="page_cache_async_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_async_readahead()</span></code></a>
or <a class="reference internal" href="#c.page_cache_sync_readahead" title="page_cache_sync_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_sync_readahead()</span></code></a> instead.</p>
<p><strong>Context</strong></p>
<p>File is referenced by caller.  Mutexes may be held by caller.
May sleep, but will not reenter filesystem to reclaim memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_expand">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_expand</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ractl</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_start</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">new_len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_expand" title="Link to this definition">¶</a><br /></dt>
<dd><p>Expand a readahead request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>The request to be expanded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">new_start</span></code></dt><dd><p>The revised start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_len</span></code></dt><dd><p>The revised size of the request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to expand a readahead request outwards from the current size to the
specified size by inserting locked pages before and after the current window
to increase the size to the new window.  This may involve the insertion of
THPs, in which case the window may get expanded even beyond what was
requested.</p>
<p>The algorithm will stop if it encounters a conflicting page already in the
pagecache and leave a smaller expansion than requested.</p>
<p>The caller must check for this by examining the revised <strong>ractl</strong> object for a
different expansion than was requested.</p>
</div>
</section>
<section id="writeback">
<h3>Writeback<a class="headerlink" href="#writeback" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.balance_dirty_pages_ratelimited_flags">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">balance_dirty_pages_ratelimited_flags</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.balance_dirty_pages_ratelimited_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Balance dirty memory state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address_space which was dirtied.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>BDP flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes which are dirtying memory should call in here once for each page
which was newly dirtied.  The function will periodically check the system’s
dirty state and will initiate writeback if needed.</p>
<p>See <a class="reference internal" href="#c.balance_dirty_pages_ratelimited" title="balance_dirty_pages_ratelimited"><code class="xref c c-func docutils literal notranslate"><span class="pre">balance_dirty_pages_ratelimited()</span></code></a> for details.</p>
<p><strong>Return</strong></p>
<p>If <strong>flags</strong> contains BDP_ASYNC, it may return -EAGAIN to
indicate that memory is out of balance and the caller must wait
for I/O to complete.  Otherwise, it will return 0 to indicate
that either memory was already in balance, or it was able to sleep
until the amount of dirty memory returned to balance.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.balance_dirty_pages_ratelimited">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">balance_dirty_pages_ratelimited</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.balance_dirty_pages_ratelimited" title="Link to this definition">¶</a><br /></dt>
<dd><p>balance dirty memory state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address_space which was dirtied.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes which are dirtying memory should call in here once for each page
which was newly dirtied.  The function will periodically check the system’s
dirty state and will initiate writeback if needed.</p>
<p>Once we’re over the dirty memory limit we decrease the ratelimiting
by a lot, to prevent individual processes from overshooting the limit
by (ratelimit_pages) each.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.tag_pages_for_writeback">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tag_pages_for_writeback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.tag_pages_for_writeback" title="Link to this definition">¶</a><br /></dt>
<dd><p>tag pages to be written by writeback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt><dd><p>starting page index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>ending page index (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function scans the page range from <strong>start</strong> to <strong>end</strong> (inclusive) and tags
all pages that have DIRTY tag set with a special TOWRITE tag.  The caller
can then use the TOWRITE tag to identify pages eligible for writeback.
This mechanism is used to avoid livelocking of writeback by a process
steadily creating new dirty pages in the file (thus it is important for this
function to be quick so that it can tag pages faster than a dirtying process
can create them).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.writeback_iter">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.writeback_iter" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">writeback_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.writeback_iter" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">error</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.writeback_iter" title="Link to this definition">¶</a><br /></dt>
<dd><p>iterate folio of a mapping for writeback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>writeback context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>previously iterated folio (<code class="docutils literal notranslate"><span class="pre">NULL</span></code> to start)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*error</span></code></dt><dd><p>in-out pointer for writeback errors (see below)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the next folio for the writeback operation described by
<strong>wbc</strong> on <strong>mapping</strong> and  should be called in a while loop in the -&gt;writepages
implementation.</p>
<p>To start the writeback operation, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is passed in the <strong>folio</strong> argument, and
for every subsequent iteration the folio returned previously should be passed
back in.</p>
<p>If there was an error in the per-folio writeback inside the <a class="reference internal" href="#c.writeback_iter" title="writeback_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">writeback_iter()</span></code></a>
loop, <strong>error</strong> should be set to the error value.</p>
<p>Once the writeback described in <strong>wbc</strong> has finished, this function will return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> and if there was an error in any iteration restore it to <strong>error</strong>.</p>
<p><strong>Note</strong></p>
<p>callers should not manually break out of the loop using break or goto
but must keep calling <a class="reference internal" href="#c.writeback_iter" title="writeback_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">writeback_iter()</span></code></a> until it returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p><strong>Return</strong></p>
<p>the folio to write or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the loop is done.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.write_cache_pages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">write_cache_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span>, <span class="n"><span class="pre">writepage_t</span></span><span class="w"> </span><span class="n"><span class="pre">writepage</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.write_cache_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>walk the list of dirty pages of the given address space and write all of them.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space structure to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>subtract the number of written pages from <strong>*wbc-&gt;nr_to_write</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writepage_t</span> <span class="pre">writepage</span></code></dt><dd><p>function called for each page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data passed to writepage function</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise</p>
<p><strong>Note</strong></p>
<p>please use <a class="reference internal" href="#c.writeback_iter" title="writeback_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">writeback_iter()</span></code></a> instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_dirty_folio">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_dirty_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.filemap_dirty_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_dirty_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Mark a folio dirty for filesystems which do not use buffer_heads.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>Address space this folio belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to be marked as dirty.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filesystems which do not use buffer heads should call this function
from their dirty_folio address space operation.  It ignores the
contents of folio_get_private(), so if the filesystem marks individual
blocks as dirty, the filesystem should handle that itself.</p>
<p>This is also sometimes used by filesystems which use buffer_heads when
a single buffer is being dirtied: we want to set the folio dirty in
that case, but not all the buffers.  This is a “bottom-up” dirtying,
whereas <a class="reference internal" href="../filesystems/buffer.html#c.block_dirty_folio" title="block_dirty_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">block_dirty_folio()</span></code></a> is a “top-down” dirtying.</p>
<p>The caller must ensure this doesn’t race with truncation.  Most will
simply hold the folio lock, but e.g. zap_pte_range() calls with the
folio mapped and the pte lock held, which also locks out truncation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_redirty_for_writepage">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_redirty_for_writepage</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_redirty_for_writepage" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_redirty_for_writepage" title="Link to this definition">¶</a><br /></dt>
<dd><p>Decline to write a dirty folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>The writeback control.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a writepage implementation decides that it doesn’t want to write
<strong>folio</strong> for some reason, it should call this function, unlock <strong>folio</strong> and
return 0.</p>
<p><strong>Return</strong></p>
<p>True if we redirtied the folio.  False if someone else dirtied
it first.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mark_dirty">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mark_dirty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mark_dirty" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mark_dirty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Mark a folio as being modified.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The folio may not be truncated while this function is running.
Holding the folio lock is sufficient to prevent truncation, but some
callers cannot acquire a sleeping lock.  These callers instead hold
the page table lock for a page table which contains at least one page
in this folio.  Truncation will block on the page table lock as it
unmaps pages before removing the folio from its mapping.</p>
<p><strong>Return</strong></p>
<p>True if the folio was newly dirtied, false if it was already dirty.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_writeback">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_writeback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_writeback" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_writeback" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait for a folio to finish writeback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the folio is currently being written back to storage, wait for the
I/O to complete.</p>
<p><strong>Context</strong></p>
<p>Sleeps.  Must be called in process context and with
no spinlocks held.  Caller should hold a reference on the folio.
If the folio is not locked, writeback may start again after writeback
has finished.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_writeback_killable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_writeback_killable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_writeback_killable" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_writeback_killable" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait for a folio to finish writeback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the folio is currently being written back to storage, wait for the
I/O to complete or a fatal signal to arrive.</p>
<p><strong>Context</strong></p>
<p>Sleeps.  Must be called in process context and with
no spinlocks held.  Caller should hold a reference on the folio.
If the folio is not locked, writeback may start again after writeback
has finished.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINTR if we get a fatal signal while waiting.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_wait_stable">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_wait_stable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_wait_stable" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_stable" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for writeback to finish, if necessary.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to wait on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function determines if the given folio is related to a backing
device that requires folio contents to be held stable during writeback.
If so, then it will wait for any pending writeback to complete.</p>
<p><strong>Context</strong></p>
<p>Sleeps.  Must be called in process context and with
no spinlocks held.  Caller should hold a reference on the folio.
If the folio is not locked, writeback may start again after writeback
has finished.</p>
</div>
</section>
<section id="truncate">
<h3>Truncate<a class="headerlink" href="#truncate" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_invalidate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_invalidate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_invalidate" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_invalidate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Invalidate part or all of a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio which is affected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt><dd><p>start of the range to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of the range to invalidate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.folio_invalidate" title="folio_invalidate"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_invalidate()</span></code></a> is called when all or part of the folio has become
invalidated by a truncate operation.</p>
<p><a class="reference internal" href="#c.folio_invalidate" title="folio_invalidate"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_invalidate()</span></code></a> does not have to release all buffers, but it must
ensure that no dirty buffer is left outside <strong>offset</strong> and that no I/O
is underway against any of the blocks which are outside the truncation
point.  Because the caller is about to free (and possibly reuse) those
blocks on-disk.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_inode_pages_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_inode_pages_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>truncate range of pages specified by start &amp; end byte offsets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping to truncate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset from which to truncate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt><dd><p>offset to which to truncate (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncate the page cache, removing the pages that are between
specified offsets (and zeroing out partial pages
if lstart or lend + 1 is not page aligned).</p>
<p>Truncate takes two passes - the first pass is nonblocking.  It will not
block on page locks and it will not block on writeback.  The second pass
will wait.  This is to prevent as much IO as possible in the affected region.
The first pass will remove most pages, so the search cost of the second pass
is low.</p>
<p>We pass down the cache-hot hint to the page freeing code.  Even if the
mapping is large, it is probably the case that the final pages are the most
recently touched, and freeing happens in ascending file offset order.</p>
<p>Note that since -&gt;invalidate_folio() accepts range to invalidate
truncate_inode_pages_range is able to handle cases where lend + 1 is not
page aligned properly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_inode_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_inode_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>truncate <em>all</em> the pages from an offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping to truncate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset from which to truncate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialised by) inode-&gt;i_rwsem and
mapping-&gt;invalidate_lock.</p>
<p><strong>Note</strong></p>
<p>When this function returns, there can be a page in the process of
deletion (inside __filemap_remove_folio()) in the specified range.  Thus
mapping-&gt;nrpages can be non-zero when this function returns even after
truncation of the whole mapping.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_inode_pages_final">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_inode_pages_final</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_final" title="Link to this definition">¶</a><br /></dt>
<dd><p>truncate <em>all</em> pages before inode dies</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping to truncate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialized by) inode-&gt;i_rwsem.</p>
<p>Filesystems have to use this in the .evict_inode path to inform the
VM that this is the final truncate and the inode is going away.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.invalidate_mapping_pages">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invalidate_mapping_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_mapping_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Invalidate all clean, unlocked cache of one inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space which holds the cache to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt><dd><p>the offset ‘from’ which to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>the offset ‘to’ which to invalidate (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes pages that are clean, unmapped and unlocked,
as well as shadow entries. It will not block on IO activity.</p>
<p>If you want to remove all the pages of one inode, regardless of
their use and writeback state, use <a class="reference internal" href="#c.truncate_inode_pages" title="truncate_inode_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">truncate_inode_pages()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The number of indices that had their contents invalidated</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.invalidate_inode_pages2_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invalidate_inode_pages2_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove range of pages from an address_space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt><dd><p>the page offset ‘from’ which to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt><dd><p>the page offset ‘to’ which to invalidate (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p><strong>Return</strong></p>
<p>-EBUSY if any pages could not be invalidated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.invalidate_inode_pages2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invalidate_inode_pages2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove all pages from an address_space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p><strong>Return</strong></p>
<p>-EBUSY if any pages could not be invalidated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_pagecache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_pagecache</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.truncate_pagecache" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">newsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache" title="Link to this definition">¶</a><br /></dt>
<dd><p>unmap and remove pagecache that has been truncated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt><dd><p>new file size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>inode’s new i_size must already be written before truncate_pagecache
is called.</p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_setsize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_setsize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.truncate_setsize" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">newsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_setsize" title="Link to this definition">¶</a><br /></dt>
<dd><p>update inode and pagecache for a new file size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt><dd><p>new file size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>truncate_setsize updates i_size and performs pagecache truncation (if
necessary) to <strong>newsize</strong>. It will be typically be called from the filesystem’s
setattr function when ATTR_SIZE is passed in.</p>
<p>Must be called with a lock serializing truncates and writes (generally
i_rwsem but e.g. xfs uses a different lock) and before all filesystem
specific block truncation has been performed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pagecache_isize_extended">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pagecache_isize_extended</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pagecache_isize_extended" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">from</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">to</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pagecache_isize_extended" title="Link to this definition">¶</a><br /></dt>
<dd><p>update pagecache after extension of i_size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode for which i_size was extended</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt><dd><p>original inode size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt><dd><p>new inode size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle extension of inode size either caused by extending truncate or
by write starting after current i_size.  We mark the page straddling
current i_size RO so that page_mkwrite() is called on the first
write access to the page.  The filesystem will update its per-block
information before user writes to the page via mmap after the i_size
has been changed.</p>
<p>The function must be called after i_size is updated so that page fault
coming after we unlock the folio will already see the new i_size.
The function must be called while we still hold i_rwsem - this not only
makes sure i_size is stable but also that userspace cannot observe new
i_size value before we are prepared to store mmap writes at new inode size.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.truncate_pagecache_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">truncate_pagecache_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.truncate_pagecache_range" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lstart</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">lend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>unmap and remove pagecache that is hole-punched</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt><dd><p>offset of beginning of hole</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt><dd><p>offset of last byte of hole</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_set_wb_err">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_set_wb_err</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">err</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_set_wb_err" title="Link to this definition">¶</a><br /></dt>
<dd><p>set a writeback error on an address_space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping in which to set writeback error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">err</span></code></dt><dd><p>error to be set in mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When writeback fails in some way, we must record that error so that
userspace can be informed when fsync and the like are called.  We endeavor
to report errors on any file that was open at the time of the error.  Some
internal callers also need to know when writeback errors have occurred.</p>
<p>When a writeback error occurs, most filesystems will want to call
filemap_set_wb_err to record the error in the mapping so that it will be
automatically reported whenever fsync is called on the file.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_check_wb_err">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_check_wb_err</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">errseq_t</span></span><span class="w"> </span><span class="n"><span class="pre">since</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_check_wb_err" title="Link to this definition">¶</a><br /></dt>
<dd><p>has an error occurred since the mark was sampled?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping to check for writeback errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">errseq_t</span> <span class="pre">since</span></code></dt><dd><p>previously-sampled errseq_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grab the errseq_t value from the mapping, and see if it has changed “since”
the given value was sampled.</p>
<p>If it has then report the latest error set, otherwise return 0.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_sample_wb_err">
<span class="n"><span class="pre">errseq_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_sample_wb_err</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_sample_wb_err" title="Link to this definition">¶</a><br /></dt>
<dd><p>sample the current errseq_t to test for later errors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>mapping to be sampled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writeback errors are always reported relative to a particular sample point
in the past. This function provides those sample points.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.file_sample_sb_err">
<span class="n"><span class="pre">errseq_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">file_sample_sb_err</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.file_sample_sb_err" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.file_sample_sb_err" title="Link to this definition">¶</a><br /></dt>
<dd><p>sample the current errseq_t to test for later errors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file pointer to be sampled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grab the most current superblock-level errseq_t value for the given
<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mapping_set_error">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mapping_set_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">error</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mapping_set_error" title="Link to this definition">¶</a><br /></dt>
<dd><p>record a writeback error in the address_space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the mapping in which an error should be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt><dd><p>the error to set in the mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When writeback fails in some way, we must record that error so that
userspace can be informed when fsync and the like are called.  We endeavor
to report errors on any file that was open at the time of the error.  Some
internal callers also need to know when writeback errors have occurred.</p>
<p>When a writeback error occurs, most filesystems will want to call
mapping_set_error to record the error in the mapping so that it can be
reported when the application calls fsync(2).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mapping_set_large_folios">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mapping_set_large_folios</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mapping_set_large_folios" title="Link to this definition">¶</a><br /></dt>
<dd><p>Indicate the file supports large folios.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space of the file.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The filesystem should call this function in its inode constructor to
indicate that the VFS can use large folios to cache the contents of
the file.</p>
<p><strong>Context</strong></p>
<p>This should not be called while the inode is active as it
is non-atomic.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mapping_align_index">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mapping_align_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mapping_align_index" title="Link to this definition">¶</a><br /></dt>
<dd><p>Align index for this mapping.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The index of a folio must be naturally aligned.  If you are adding a
new folio to the page cache and need to know what index to give it,
call this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_flush_mapping">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_flush_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_flush_mapping" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_flush_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the file mapping this folio belongs to.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For folios which are in the page cache, return the mapping that this
page belongs to.  Anonymous folios return NULL, even if they’re in
the swap cache.  Other kinds of folio also return NULL.</p>
<p>This is ONLY used by architecture cache flushing code.  If you aren’t
writing cache flushing code, you want either <a class="reference internal" href="#c.folio_mapping" title="folio_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mapping()</span></code></a> or
folio_file_mapping().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_inode">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_inode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_inode" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_inode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the host inode for this folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For folios which are in the page cache, return the inode that this folio
belongs to.</p>
<p>Do not call this for folios which aren’t in the page cache.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_attach_private">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_attach_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_attach_private" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_attach_private" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attach private data to a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to attach data to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to attach to folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attaching private data to a folio increments the page’s reference count.
The data must be detached before the folio will be freed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_change_private">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_change_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_change_private" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_change_private" title="Link to this definition">¶</a><br /></dt>
<dd><p>Change private data on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to change the data on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to set on the folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change the private data attached to a folio and return the old
data.  The page must previously have had data attached and the data
must be detached before the folio will be freed.</p>
<p><strong>Return</strong></p>
<p>Data that was previously attached to the folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_detach_private">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_detach_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_detach_private" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_detach_private" title="Link to this definition">¶</a><br /></dt>
<dd><p>Detach private data from a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to detach data from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the data that was previously attached to the folio and decrements
the refcount on the page.</p>
<p><strong>Return</strong></p>
<p>Data that was attached to the folio.</p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.fgf_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fgf_t</span></span></span><a class="headerlink" href="#c.fgf_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flags for getting folios from the page cache.</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>Most users of the page cache will not need to use these flags;
there are convenience functions such as <a class="reference internal" href="#c.filemap_get_folio" title="filemap_get_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_get_folio()</span></code></a> and
<a class="reference internal" href="#c.filemap_lock_folio" title="filemap_lock_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_lock_folio()</span></code></a>.  For users which need more control over exactly
what is done with the folios, these flags to <a class="reference internal" href="#c.__filemap_get_folio" title="__filemap_get_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">__filemap_get_folio()</span></code></a>
are available.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_ACCESSED</span></code> - The folio will be marked accessed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_LOCK</span></code> - The folio is returned locked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_CREAT</span></code> - If no folio is present then a new folio is allocated,
added to the page cache and the VM’s LRU list.  The folio is
returned locked.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_FOR_MMAP</span></code> - The caller wants to do its own locking dance if the
folio is already in cache.  If the folio was allocated, unlock it
before returning so the caller can do the same dance.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_WRITE</span></code> - The folio will be written to by the caller.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_NOFS</span></code> - __GFP_FS will get cleared in gfp.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_NOWAIT</span></code> - Don’t block on the folio lock.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_STABLE</span></code> - Wait for the folio to be stable (finished writeback)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_DONTCACHE</span></code> - Uncached buffered IO</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FGP_WRITEBEGIN</span></code> - The flags to use in a filesystem write_begin()
implementation.</p></li>
</ul>
<dl class="c function">
<dt class="sig sig-object c" id="c.fgf_set_order">
<a class="reference internal" href="#c.fgf_t" title="fgf_t"><span class="n"><span class="pre">fgf_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fgf_set_order</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fgf_set_order" title="Link to this definition">¶</a><br /></dt>
<dd><p>Encode a length in the fgf_t flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The suggested size of the folio to create.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller of <a class="reference internal" href="#c.__filemap_get_folio" title="__filemap_get_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">__filemap_get_folio()</span></code></a> can use this to suggest a preferred
size for the folio that is created.  If there is already a folio at
the index, it will be returned, no matter what its size.  If a folio
is freshly created, it may be of a different size than requested
due to alignment constraints, memory pressure, or the presence of
other folios at nearby indices.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_get_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">filemap_get_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_get_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find and get a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>mapping</strong> &amp; <strong>index</strong>.  If a folio is
present, it is returned with an increased refcount.</p>
<p><strong>Return</strong></p>
<p>A folio or ERR_PTR(-ENOENT) if there is no folio in the cache for
this index.  Will not return a shadow, swap or DAX entry.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_lock_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">filemap_lock_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_lock_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find and lock a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>mapping</strong> &amp; <strong>index</strong>.  If a folio is
present, it is returned locked with an increased refcount.</p>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>A folio or ERR_PTR(-ENOENT) if there is no folio in the cache for
this index.  Will not return a shadow, swap or DAX entry.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_grab_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">filemap_grab_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_grab_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>grab a folio from the page cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>mapping</strong> &amp; <strong>index</strong>. If no folio is found,
a new folio is created. The folio is locked, marked as accessed, and
returned.</p>
<p><strong>Return</strong></p>
<p>A found or created folio. ERR_PTR(-ENOMEM) if no folio is found
and failed to create a folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_get_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_get_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>find and get a page reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt><dd><p>the page index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned with an increased refcount.</p>
<p>Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_lock_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_lock_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_lock_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>locate, pin and lock a pagecache page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address_space to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>mapping</strong> &amp; <strong>index</strong>.  If there is a
page cache page, it is returned locked and with an increased
refcount.</p>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>A struct page or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no page in the cache for this
index.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_or_create_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_or_create_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_or_create_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>locate or add a pagecache page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the page’s address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page’s index into the mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>page allocation mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned locked and with an increased
refcount.</p>
<p>If the page is not present, a new page is allocated using <strong>gfp_mask</strong>
and added to the page cache and the VM’s LRU list.  The page is
returned locked and with an increased refcount.</p>
<p>On memory exhaustion, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
<p><a class="reference internal" href="#c.find_or_create_page" title="find_or_create_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">find_or_create_page()</span></code></a> may sleep, even if <strong>gfp_flags</strong> specifies an
atomic allocation!</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.grab_cache_page_nowait">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">grab_cache_page_nowait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.grab_cache_page_nowait" title="Link to this definition">¶</a><br /></dt>
<dd><p>returns locked page at given index in given cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>target address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as grab_cache_page(), but do not wait if the page is unavailable.
This is intended for speculative data generators, where the data can
be regenerated if the page couldn’t be grabbed.  This routine should
be safe to call while holding the lock for another page.</p>
<p>Clear __GFP_FS when allocating the page to avoid recursion into the fs
and deadlock against the caller’s locked page.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_next_index">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_next_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_next_index" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_next_index" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the index of the next folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The current folio.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The index of the folio which follows this folio in the file.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_file_page">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_file_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_file_page" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_file_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>The page for a particular index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio which contains this index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The index we want to look up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sometimes after looking up a folio in the page cache, we need to
obtain the specific page for an index (eg a page fault).</p>
<p><strong>Return</strong></p>
<p>The page containing the file data for this index.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_contains">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_contains</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_contains" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_contains" title="Link to this definition">¶</a><br /></dt>
<dd><p>Does this folio contain this index?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index within the file.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>The caller should have the folio locked and ensure
e.g., shmem did not move this folio to the swap cache.</p>
<p><strong>Return</strong></p>
<p>true or false.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_pgoff">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_pgoff</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_pgoff" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_pgoff" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_pgoff" title="Link to this definition">¶</a><br /></dt>
<dd><p>Calculate the logical page offset of this page.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio containing this page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page which we need the offset of.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For file pages, this is the offset from the beginning of the file
in units of PAGE_SIZE.  For anonymous pages, this is the offset from
the beginning of the anon_vma in units of PAGE_SIZE.  This will
return nonsense for KSM pages.</p>
<p><strong>Context</strong></p>
<p>Caller must have a reference on the folio or otherwise
prevent it from being split or freed.</p>
<p><strong>Return</strong></p>
<p>The offset in units of PAGE_SIZE.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_pos">
<span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_pos</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_pos" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_pos" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the byte position of this folio in its file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_trylock">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_trylock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_trylock" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_trylock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempt to lock a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to attempt to lock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sometimes it is undesirable to wait for a folio to be unlocked (eg
when the locks are being taken in the wrong order, or if making
progress through a batch of folios is more important than processing
them in order).  Usually <a class="reference internal" href="#c.folio_lock" title="folio_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_lock()</span></code></a> is the correct function to call.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>Whether the lock was successfully acquired.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_lock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_lock" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lock this folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to lock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The folio lock protects against many things, probably more than it
should.  It is primarily held while a folio is being brought uptodate,
either from its backing file or from swap.  It is also held while a
folio is being truncated from its address_space, so holding the lock
is sufficient to keep folio-&gt;mapping stable.</p>
<p>The folio lock is also held while write() is modifying the page to
provide POSIX atomicity guarantees (as long as the write does not
cross a page boundary).  Other modifications to the data in the folio
do not hold the folio lock and can race with writes, eg DMA and stores
to mapped pages.</p>
<p><strong>Context</strong></p>
<p>May sleep.  If you need to acquire the locks of two or
more folios, they must be in order of ascending index, if they are
in the same address_space.  If they are in different address_spaces,
acquire the lock of the folio which belongs to the address_space which
has the lowest address in memory first.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lock_page">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lock_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.lock_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lock the folio containing this page.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page to lock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.folio_lock" title="folio_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_lock()</span></code></a> for a description of what the lock protects.
This is a legacy function and new code should probably use <a class="reference internal" href="#c.folio_lock" title="folio_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_lock()</span></code></a>
instead.</p>
<p><strong>Context</strong></p>
<p>May sleep.  Pages in the same folio share a lock, so do not
attempt to lock two pages which share a folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_lock_killable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_lock_killable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_lock_killable" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_lock_killable" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lock this folio, interruptible by a fatal signal.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to lock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempts to lock the folio, like <a class="reference internal" href="#c.folio_lock" title="folio_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_lock()</span></code></a>, except that the sleep
to acquire the lock is interruptible by a fatal signal.</p>
<p><strong>Context</strong></p>
<p>May sleep; see <a class="reference internal" href="#c.folio_lock" title="folio_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_lock()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 if the lock was acquired; -EINTR if a fatal signal was received.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.filemap_range_needs_writeback">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filemap_range_needs_writeback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start_byte</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end_byte</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_range_needs_writeback" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if range potentially needs writeback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address space within which to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt><dd><p>offset in bytes where the range starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt><dd><p>offset in bytes where the range ends (inclusive)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find at least one page in the range supplied, usually used to check if
direct writing in this range will trigger a writeback. Used by O_DIRECT
read/write with IOCB_NOWAIT, to see if the caller needs to do
<a class="reference internal" href="#c.filemap_write_and_wait_range" title="filemap_write_and_wait_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_write_and_wait_range()</span></code></a> before proceeding.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the caller should do <a class="reference internal" href="#c.filemap_write_and_wait_range" title="filemap_write_and_wait_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_write_and_wait_range()</span></code></a> before
doing O_DIRECT to a page in this range, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.readahead_control">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_control</span></span></span><a class="headerlink" href="#c.readahead_control" title="Link to this definition">¶</a><br /></dt>
<dd><p>Describes a readahead request.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct readahead_control {
    struct file *file;
    struct address_space *mapping;
    struct file_ra_state *ra;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>The file, used primarily by network filesystems for authentication.
May be NULL if invoked internally by the filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mapping</span></code></dt><dd><p>Readahead this filesystem object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ra</span></code></dt><dd><p>File readahead state.  May be NULL.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A readahead request is for consecutive pages.  Filesystems which
implement the -&gt;readahead method should call <a class="reference internal" href="#c.readahead_folio" title="readahead_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">readahead_folio()</span></code></a> or
__readahead_batch() in a loop and attempt to start reads into each
folio in the request.</p>
<p>Most of the fields in this struct are private and should be accessed
by the functions below.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_sync_readahead">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_sync_readahead</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file_ra_state" title="file_ra_state"><span class="n"><span class="pre">file_ra_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ra</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_cache_sync_readahead" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">req_count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_sync_readahead" title="Link to this definition">¶</a><br /></dt>
<dd><p>generic file readahead</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address_space which holds the pagecache and I/O vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*ra</span></code></dt><dd><p>file_ra_state which holds the readahead state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>Used by the filesystem for authentication.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>Index of first page to be read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_count</span></code></dt><dd><p>Total number of pages being read by the caller.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_sync_readahead" title="page_cache_sync_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_sync_readahead()</span></code></a> should be called when a cache miss happened:
it will submit the read.  The readahead logic may decide to piggyback more
pages onto the read request if access patterns suggest it will improve
performance.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cache_async_readahead">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cache_async_readahead</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file_ra_state" title="file_ra_state"><span class="n"><span class="pre">file_ra_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ra</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_cache_async_readahead" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_cache_async_readahead" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">req_count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_async_readahead" title="Link to this definition">¶</a><br /></dt>
<dd><p>file readahead for marked pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>address_space which holds the pagecache and I/O vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*ra</span></code></dt><dd><p>file_ra_state which holds the readahead state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>Used by the filesystem for authentication.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio which triggered the readahead call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_count</span></code></dt><dd><p>Total number of pages being read by the caller.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_async_readahead" title="page_cache_async_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cache_async_readahead()</span></code></a> should be called when a page is used which
is marked as PageReadahead; this is a marker to suggest that the application
has used up enough of the readahead window that we should start pulling in
more pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">readahead_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ractl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the next folio to read.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt><dd><p>The current readahead request.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>The folio is locked.  The caller should unlock the folio once
all I/O to that folio has completed.</p>
<p><strong>Return</strong></p>
<p>A pointer to the next folio, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if we are done.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_pos">
<span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_pos</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_pos" title="Link to this definition">¶</a><br /></dt>
<dd><p>The byte offset into the file of this readahead request.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_length">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_length</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_length" title="Link to this definition">¶</a><br /></dt>
<dd><p>The number of bytes in this readahead request.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_index">
<span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_index" title="Link to this definition">¶</a><br /></dt>
<dd><p>The index of the first page in this readahead request.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_count">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_count" title="Link to this definition">¶</a><br /></dt>
<dd><p>The number of pages in this readahead request.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.readahead_batch_length">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readahead_batch_length</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.readahead_control" title="readahead_control"><span class="n"><span class="pre">readahead_control</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.readahead_batch_length" title="Link to this definition">¶</a><br /></dt>
<dd><p>The number of bytes in the current batch.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*rac</span></code></dt><dd><p>The readahead request.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mkwrite_check_truncate">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mkwrite_check_truncate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mkwrite_check_truncate" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mkwrite_check_truncate" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mkwrite_check_truncate" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if folio was truncated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>the folio to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode to check the folio against</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of bytes in the folio up to EOF,
or -EFAULT if the folio was truncated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.i_blocks_per_folio">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">i_blocks_per_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.i_blocks_per_folio" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.i_blocks_per_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.i_blocks_per_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>How many blocks fit in this folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>The inode which contains the blocks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the block size is larger than the size of this folio, return zero.</p>
<p><strong>Context</strong></p>
<p>The caller should hold a refcount on the folio to prevent it
from being split.</p>
<p><strong>Return</strong></p>
<p>The number of filesystem blocks covered by this folio.</p>
</div>
</section>
</section>
<section id="memory-pools">
<h2>Memory pools<a class="headerlink" href="#memory-pools" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_exit</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_exit" title="Link to this definition">¶</a><br /></dt>
<dd><p>exit a mempool initialized with mempool_init()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was initialized with
mempool_init().</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all reserved elements in <strong>pool</strong> and <strong>pool</strong> itself.  This function
only sleeps if the free_fn() function sleeps.</p>
<p>May be called on a zeroed but uninitialized mempool (i.e. allocated with
<a class="reference internal" href="#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a>).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_destroy</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>deallocate a memory pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was allocated via
mempool_create().</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all reserved elements in <strong>pool</strong> and <strong>pool</strong> itself.  This function
only sleeps if the free_fn() function sleeps.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_resize">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_resize</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">new_min_nr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_resize" title="Link to this definition">¶</a><br /></dt>
<dd><p>resize an existing memory pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was allocated via
mempool_create().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new_min_nr</span></code></dt><dd><p>the new minimum number of elements guaranteed to be
allocated for this pool.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function shrinks/grows the pool. In the case of growing,
it cannot be guaranteed that the pool will be grown to the new
size immediately, but new <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_free()</span></code></a> calls will refill it.
This function may sleep.</p>
<p>Note, the caller must guarantee that no mempool_destroy is called
while this function is running. mempool_alloc() &amp; <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">mempool_free()</span></code></a>
might be called (eg. from IRQ contexts) while this function executes.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_alloc_preallocated">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mempool_alloc_preallocated</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_alloc_preallocated" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate an element from preallocated elements belonging to a specific memory pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was allocated via
mempool_create().</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar to mempool_alloc, but it only attempts allocating
an element from the preallocated elements. It does not sleep and immediately
returns if no preallocated elements are available.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated element or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no elements are
available.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mempool_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mempool_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">element</span></span>, <span class="n"><span class="pre">mempool_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>return an element to the pool.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*element</span></code></dt><dd><p>pool element pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mempool_t</span> <span class="pre">*pool</span></code></dt><dd><p>pointer to the memory pool which was allocated via
mempool_create().</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the free_fn() function sleeps.</p>
</div>
</section>
<section id="dma-pools">
<h2>DMA pools<a class="headerlink" href="#dma-pools" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_pool_create_node">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_pool_create_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">boundary</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_create_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>Creates a pool of consistent memory blocks, for dma.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of pool, for diagnostics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that will be doing the DMA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the blocks in this pool.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment requirement for blocks; must be a power of two</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">boundary</span></code></dt><dd><p>returned blocks won’t cross this power of two boundary</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>optional NUMA node to allocate structs ‘dma_pool’ and ‘dma_page’ on</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>not in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Given one of these pools, <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_alloc()</span></code></a>
may be used to allocate memory.  Such memory will all have “consistent”
DMA mappings, accessible by the device and its driver without using
cache flushing primitives.  The actual size of blocks allocated may be
larger than requested because of alignment.</p>
<p>If <strong>boundary</strong> is nonzero, objects returned from <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_alloc()</span></code></a> won’t
cross that size boundary.  This is useful for devices which have
addressing restrictions on individual DMA transfers, such as not crossing
boundaries of 4KBytes.</p>
<p><strong>Return</strong></p>
<p>a dma allocation pool with the requested characteristics, or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if one can’t be created.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_pool_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_pool_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroys a pool of dma memory blocks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*pool</span></code></dt><dd><p>dma pool that will be destroyed</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>!in_interrupt()</p>
<p><strong>Description</strong></p>
<p>Caller guarantees that no more memory from the pool is in use,
and that nothing will try to use the pool after this call.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_pool_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dma_pool_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">mem_flags</span></span>, <span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a block of consistent memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*pool</span></code></dt><dd><p>dma pool that will produce the block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt><dd><p>GFP_* bitmask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*handle</span></code></dt><dd><p>pointer to dma address of block</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the kernel virtual address of a currently unused block,
and reports its dma address through the handle.
If such a memory block can’t be allocated, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_pool_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_pool_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vaddr</span></span>, <span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">dma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>put block back into dma pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the dma pool holding the block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*vaddr</span></code></dt><dd><p>virtual address of block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma</span></code></dt><dd><p>dma address of block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller promises neither device nor driver will again touch this block
unless it is first re-allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dmam_pool_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dmam_pool_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">allocation</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Managed dma_pool_create()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of pool, for diagnostics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that will be doing the DMA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the blocks in this pool.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment requirement for blocks; must be a power of two</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">allocation</span></code></dt><dd><p>returned blocks won’t cross this boundary (or zero)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed dma_pool_create().  DMA pool created with this function is
automatically destroyed on driver detach.</p>
<p><strong>Return</strong></p>
<p>a managed dma allocation pool with the requested
characteristics, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if one can’t be created.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dmam_pool_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dmam_pool_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dma_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_destroy()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*pool</span></code></dt><dd><p>dma pool that will be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_pool_destroy()</span></code></a>.</p>
</div>
</section>
<section id="more-memory-management-functions">
<h2>More Memory Management Functions<a class="headerlink" href="#more-memory-management-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.zap_vma_ptes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zap_vma_ptes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zap_vma_ptes" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove ptes mapping the vma</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vm_area_struct holding ptes to be zapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>starting address of pages to zap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>number of bytes to zap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only unmaps ptes assigned to VM_PFNMAP vmas.</p>
<p>The entire address range must be fully contained within the vma.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_insert_pages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_insert_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert multiple pages into user vma, batching the pmd lock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target start user address of these pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>source kernel pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*num</span></code></dt><dd><p>in: number of pages to map. out: number of pages that were <em>not</em>
mapped. (0 means all pages were successfully mapped).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Preferred over <a class="reference internal" href="#c.vm_insert_page" title="vm_insert_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">vm_insert_page()</span></code></a> when inserting multiple pages.</p>
<p>In case of error, we may have mapped a subset of the provided
pages. It is the caller’s responsibility to account for this case.</p>
<p>The same restrictions apply as in <a class="reference internal" href="#c.vm_insert_page" title="vm_insert_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">vm_insert_page()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_insert_page">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_insert_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.vm_insert_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert single page into user vma</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target user address of this page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>source kernel page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allows drivers to insert individual pages they’ve allocated
into a user vma. The zeropage is supported in some VMAs,
see vm_mixed_zeropage_allowed().</p>
<p>The page has to be a nice clean _individual_ kernel allocation.
If you allocate a compound page, you need to have marked it as
such (__GFP_COMP), or manually just split the page up yourself
(see split_page()).</p>
<p>NOTE! Traditionally this was done with “<a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">remap_pfn_range()</span></code></a>” which
took an arbitrary page protection parameter. This doesn’t allow
that. Your vma protection will have to be set up correctly, which
means that if you want a shared writable mapping, you’d better
ask for a shared writable mapping!</p>
<p>The page does not need to be reserved.</p>
<p>Usually this function is called from f_op-&gt;mmap() handler
under mm-&gt;mmap_lock write-lock, so it can change vma-&gt;vm_flags.
Caller must set VM_MIXEDMAP on vma if it wants to call this
function from other places, for example from page-fault handler.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_map_pages">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_map_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>maps range of kernel pages starts with non zero offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>pointer to array of source kernel pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">num</span></code></dt><dd><p>number of pages in page array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps an object consisting of <strong>num</strong> pages, catering for the user’s
requested vm_pgoff</p>
<p>If we fail to insert any page into the vma, the function will return
immediately leaving any previously inserted pages present.  Callers
from the mmap handler may immediately return the error as their caller
will destroy the vma, removing any successfully inserted pages. Other
callers should make their own arrangements for calling unmap_region().</p>
<p><strong>Context</strong></p>
<p>Process context. Called by mmap handlers.</p>
<p><strong>Return</strong></p>
<p>0 on success and error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_map_pages_zero">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_map_pages_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_pages_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>map range of kernel pages starts with zero offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>pointer to array of source kernel pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">num</span></code></dt><dd><p>number of pages in page array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.vm_map_pages" title="vm_map_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">vm_map_pages()</span></code></a>, except that it explicitly sets the offset
to 0. This function is intended for the drivers that did not consider
vm_pgoff.</p>
<p><strong>Context</strong></p>
<p>Process context. Called by mmap handlers.</p>
<p><strong>Return</strong></p>
<p>0 on success and error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmf_insert_pfn_prot">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vmf_insert_pfn_prot</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgprot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmf_insert_pfn_prot" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert single pfn into user vma with specified pgprot</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target user address of this page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>source kernel pfn</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">pgprot</span></code></dt><dd><p>pgprot flags for the inserted page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is exactly like <a class="reference internal" href="#c.vmf_insert_pfn" title="vmf_insert_pfn"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmf_insert_pfn()</span></code></a>, except that it allows drivers
to override pgprot on a per-page basis.</p>
<p>This only makes sense for IO mappings, and it makes no sense for
COW mappings.  In general, using multiple vmas is preferable;
vmf_insert_pfn_prot should only be used if using multiple VMAs is
impractical.</p>
<p>pgprot typically only differs from <strong>vma-&gt;vm_page_prot</strong> when drivers set
caching- and encryption bits different than those of <strong>vma-&gt;vm_page_prot</strong>,
because the caching- or encryption mode may not be known at mmap() time.</p>
<p>This is ok as long as <strong>vma-&gt;vm_page_prot</strong> is not used by the core vm
to set caching and encryption bits for those vmas (except for COW pages).
This is ensured by core vm only modifying these page table entries using
functions that don’t touch caching- or encryption bits, using pte_modify()
if needed. (See for example mprotect()).</p>
<p>Also when new page-table entries are created, this is only done using the
fault() callback, and never using the value of vma-&gt;vm_page_prot,
except for page-table entries that point to anonymous pages as the result
of COW.</p>
<p><strong>Context</strong></p>
<p>Process context.  May allocate using <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>.</p>
<p><strong>Return</strong></p>
<p>vm_fault_t value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmf_insert_pfn">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vmf_insert_pfn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmf_insert_pfn" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert single pfn into user vma</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target user address of this page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>source kernel pfn</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to vm_insert_page, this allows drivers to insert individual pages
they’ve allocated into a user vma. Same comments apply.</p>
<p>This function should only be called from a vm_ops-&gt;fault handler, and
in that case the handler should return the result of this function.</p>
<p>vma cannot be a COW mapping.</p>
<p>As this is called only for pages that do not currently exist, we
do not need to flush old virtual caches or the TLB.</p>
<p><strong>Context</strong></p>
<p>Process context.  May allocate using <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>.</p>
<p><strong>Return</strong></p>
<p>vm_fault_t value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.remap_pfn_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">remap_pfn_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_pfn_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>remap kernel memory to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target page aligned user address to start at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>page frame number of kernel physical memory address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>size of mapping area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt><dd><p>page protection flags for this mapping</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>this is only safe if the mm semaphore is held when called.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vm_iomap_memory">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_iomap_memory</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="n"><span class="pre">phys_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_iomap_memory" title="Link to this definition">¶</a><br /></dt>
<dd><p>remap memory to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">start</span></code></dt><dd><p>start of the physical memory to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt><dd><p>size of area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified io_remap_pfn_range() for common driver use. The
driver just needs to give us the physical memory range to be mapped,
we’ll figure out the rest from the vma information.</p>
<p>NOTE! Some drivers might want to tweak vma-&gt;vm_page_prot first to get
whatever write-combining details or similar.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unmap_mapping_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unmap_mapping_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">even_cows</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_mapping_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unmap pages from processes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space containing pages to be unmapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt><dd><p>Index of first page to be unmapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">nr</span></code></dt><dd><p>Number of pages to be unmapped.  0 to unmap to end of file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">even_cows</span></code></dt><dd><p>Whether to unmap even private COWed pages.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap the pages in this address space from any userspace process which
has them mmaped.  Generally, you want to remove COWed pages as well when
a file is being truncated, but not when invalidating pages from the page
cache.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unmap_mapping_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unmap_mapping_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">holebegin</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">holelen</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">even_cows</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_mapping_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>unmap the portion of all mmaps in the specified address_space corresponding to the specified byte range in the underlying file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the address space containing mmaps to be unmapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holebegin</span></code></dt><dd><p>byte in first page to unmap, relative to the start of
the underlying file.  This will be rounded down to a PAGE_SIZE
boundary.  Note that this is different from <a class="reference internal" href="#c.truncate_pagecache" title="truncate_pagecache"><code class="xref c c-func docutils literal notranslate"><span class="pre">truncate_pagecache()</span></code></a>, which
must keep the partial page.  In contrast, we must get rid of
partial pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holelen</span></code></dt><dd><p>size of prospective hole in bytes.  This will be rounded
up to a PAGE_SIZE boundary.  A holelen of zero truncates to the
end of the file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">even_cows</span></code></dt><dd><p>1 when truncating a file, unmap even private COWed pages;
but 0 when invalidating pagecache, don’t throw away private data.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.follow_pfnmap_start">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">follow_pfnmap_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">follow_pfnmap_args</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.follow_pfnmap_start" title="Link to this definition">¶</a><br /></dt>
<dd><p>Look up a pfn mapping at a user virtual address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">follow_pfnmap_args</span> <span class="pre">*args</span></code></dt><dd><p>Pointer to struct <strong>follow_pfnmap_args</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller needs to setup args-&gt;vma and args-&gt;address to point to the
virtual address as the target of such lookup.  On a successful return,
the results will be put into other output fields.</p>
<p>After the caller finished using the fields, the caller must invoke
another <a class="reference internal" href="#c.follow_pfnmap_end" title="follow_pfnmap_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">follow_pfnmap_end()</span></code></a> to proper releases the locks and resources
of such look up request.</p>
<p>During the <a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a> and end() calls, the results in <strong>args</strong> will be valid
as proper locks will be held.  After the end() is called, all the fields
in <strong>follow_pfnmap_args</strong> will be invalid to be further accessed.  Further
use of such information after end() may require proper synchronizations
by the caller with page table updates, otherwise it can create a
security bug.</p>
<p>If the PTE maps a refcounted page, callers are responsible to protect
against invalidation with MMU notifiers; otherwise access to the PFN at
a later point in time can trigger use-after-free.</p>
<p>Only IO mappings and raw PFN mappings are allowed.  The mmap semaphore
should be taken for read, and the mmap semaphore cannot be released
before the end() is invoked.</p>
<p>This function must not be used to modify PTE content.</p>
<p><strong>Return</strong></p>
<p>zero on success, negative otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.follow_pfnmap_end">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">follow_pfnmap_end</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">follow_pfnmap_args</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.follow_pfnmap_end" title="Link to this definition">¶</a><br /></dt>
<dd><p>End a <a class="reference internal" href="#c.follow_pfnmap_start" title="follow_pfnmap_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">follow_pfnmap_start()</span></code></a> process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">follow_pfnmap_args</span> <span class="pre">*args</span></code></dt><dd><p>Pointer to struct <strong>follow_pfnmap_args</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be used in pair of <a class="reference internal" href="#c.follow_pfnmap_start" title="follow_pfnmap_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">follow_pfnmap_start()</span></code></a>.  See the <a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a> function
above for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_access_phys">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_access_phys</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">write</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_access_phys" title="Link to this definition">¶</a><br /></dt>
<dd><p>generic implementation for iomem mmap access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>the vma to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>userspace address, not relative offset within <strong>vma</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to read/write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write</span></code></dt><dd><p>set to FOLL_WRITE when writing, otherwise reading</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a generic implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">vm_operations_struct.access</span></code> for an
iomem mapping. This callback is used by access_process_vm() when the <strong>vma</strong> is
not page based.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.copy_remote_vm_str">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">copy_remote_vm_str</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tsk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">gup_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_remote_vm_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>copy a string from another process’s address space.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>the task of the target address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>start address to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gup_flags</span></code></dt><dd><p>flags modifying lookup behaviour</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold a reference on <strong>mm</strong>.</p>
<p><strong>Return</strong></p>
<p>number of bytes copied from <strong>addr</strong> (source) to <strong>buf</strong> (destination);
not including the trailing NUL. Always guaranteed to leave NUL-terminated
buffer. On any error, return -EFAULT.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_pfnblock_flags_mask">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_pfnblock_flags_mask</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.get_pfnblock_flags_mask" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_pfnblock_flags_mask" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the requested group of flags for the pageblock_nr_pages block of pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page within the block of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>The target page frame number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>mask of bits that the caller is interested in</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>pageblock_bits flags</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_pfnblock_flags_mask">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_pfnblock_flags_mask</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.set_pfnblock_flags_mask" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_pfnblock_flags_mask" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the requested group of flags for a pageblock_nr_pages block of pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page within the block of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>The flags to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>The target page frame number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>mask of bits that the caller is interested in</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.move_freepages_block_isolate">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">move_freepages_block_isolate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.move_freepages_block_isolate" title="zone"><span class="n"><span class="pre">zone</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zone</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.move_freepages_block_isolate" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">migratetype</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.move_freepages_block_isolate" title="Link to this definition">¶</a><br /></dt>
<dd><p>move free pages in block for page isolation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zone</span> <span class="pre">*zone</span></code></dt><dd><p>the zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the pageblock page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">migratetype</span></code></dt><dd><p>migratetype to set on the pageblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to move_freepages_block(), but handles the special
case encountered in page isolation, where the block of interest
might be part of a larger buddy spanning multiple pageblocks.</p>
<p>Unlike the regular page allocator path, which moves pages while
stealing buddies off the freelist, page isolation is interested in
arbitrary pfn ranges that may have overlapping buddies on both ends.</p>
<p>This function handles that. Straddling buddies are split into
individual pageblocks. Only the block of interest is moved.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if pages could be moved, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__putback_isolated_page">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__putback_isolated_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__putback_isolated_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__putback_isolated_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a now-isolated page back where we got it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>Page that was isolated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Order of the isolated page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mt</span></code></dt><dd><p>The page’s pageblock’s migratetype</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is meant to return a page pulled from the free lists via
__isolate_free_page back to the free lists they were pulled from.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.___free_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">___free_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.___free_pages" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span>, <span class="n"><span class="pre">fpi_t</span></span><span class="w"> </span><span class="n"><span class="pre">fpi_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.___free_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free pages allocated with <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page pointer returned from <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>The order of the allocation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fpi_t</span> <span class="pre">fpi_flags</span></code></dt><dd><p>Free Page Internal flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can free multi-page allocations that are not compound
pages.  It does not check that the <strong>order</strong> passed in matches that of
the allocation, so it is easy to leak memory.  Freeing more memory
than was allocated will probably emit a warning.</p>
<p>If the last reference to this page is speculative, it will be released
by put_page() which only frees the first page of a non-compound
allocation.  To prevent the remaining pages from being leaked, we free
the subsequent pages here.  If you want to use the page’s reference
count to decide when to free the allocation, you should allocate a
compound page, and use put_page() instead of __free_pages().</p>
<p><strong>Context</strong></p>
<p>May be called in interrupt context or while holding a normal
spinlock, but not in NMI context or while holding a raw spinlock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages_exact">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages_exact</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_exact" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate an exact number physically-contiguous pages.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the number of bytes to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP flags for the allocation, must not contain __GFP_COMP</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar to <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a>, except that it allocates the
minimum number of pages to satisfy the request.  <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a> can only
allocate memory in power-of-two pages.</p>
<p>This function is also limited by MAX_PAGE_ORDER.</p>
<p>Memory allocated by this function must be released by <a class="reference internal" href="#c.free_pages_exact" title="free_pages_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_pages_exact()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated area or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages_exact_nid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages_exact_nid</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_exact_nid" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate an exact number of physically-contiguous pages on a node.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>the preferred node ID where memory should be allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the number of bytes to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP flags for the allocation, must not contain __GFP_COMP</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.alloc_pages_exact" title="alloc_pages_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages_exact()</span></code></a>, but try to allocate on node nid first before falling
back.</p>
<p><strong>Return</strong></p>
<p>pointer to the allocated area or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.free_pages_exact">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_pages_exact</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">virt</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.free_pages_exact" title="Link to this definition">¶</a><br /></dt>
<dd><p>release memory allocated via <a class="reference internal" href="#c.alloc_pages_exact" title="alloc_pages_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages_exact()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*virt</span></code></dt><dd><p>the value returned by alloc_pages_exact.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of allocation, same value as passed to <a class="reference internal" href="#c.alloc_pages_exact" title="alloc_pages_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages_exact()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release the memory allocated by a previous call to alloc_pages_exact.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.nr_free_zone_pages">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nr_free_zone_pages</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_zone_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>The zone index of the highest zone</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_zone_pages" title="nr_free_zone_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">nr_free_zone_pages()</span></code></a> counts the number of pages which are beyond the
high watermark within all zones at or below a given zone index.  For each
zone, the number of pages is calculated as:</p>
<blockquote>
<div><p>nr_free_zone_pages = managed_pages - high_pages</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>number of pages beyond high watermark.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.nr_free_buffer_pages">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nr_free_buffer_pages</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_buffer_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_buffer_pages" title="nr_free_buffer_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">nr_free_buffer_pages()</span></code></a> counts the number of pages which are beyond the high
watermark within ZONE_DMA and ZONE_NORMAL.</p>
<p><strong>Return</strong></p>
<p>number of pages beyond high watermark within ZONE_DMA and
ZONE_NORMAL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_next_best_node">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_next_best_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">used_node_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_next_best_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the next node that should appear in a given node’s fallback list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>node whose fallback list we’re appending</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*used_node_mask</span></code></dt><dd><p>nodemask_t of already used nodes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We use a number of factors to determine which is the next node that should
appear on a given node’s fallback list.  The node should not have appeared
already in <strong>node</strong>’s fallback list, and it should be the next closest node
according to the distance array (which contains arbitrary distance values
from each node to each node in the system), and should also prefer nodes
with no CPUs, since presumably they’ll have very little allocation pressure
on them otherwise.</p>
<p><strong>Return</strong></p>
<p>node id of the found node or <code class="docutils literal notranslate"><span class="pre">NUMA_NO_NODE</span></code> if no node is found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.setup_per_zone_wmarks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">setup_per_zone_wmarks</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.setup_per_zone_wmarks" title="Link to this definition">¶</a><br /></dt>
<dd><p>called when min_free_kbytes changes or when memory is hot-{added|removed}</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures that the watermark[min,low,high] values for each zone are set
correctly with respect to min_free_kbytes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_contig_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alloc_contig_range</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">migratetype</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_contig_range" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>tries to allocate given range of pages</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>start PFN to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt><dd><p>one-past-the-last PFN to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">migratetype</span></code></dt><dd><p>migratetype of the underlying pageblocks (either
#MIGRATE_MOVABLE or #MIGRATE_CMA).  All pageblocks
in range must have the same migratetype and it must
be either of the two.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP mask. Node/zone/placement hints are ignored; only some
action and reclaim modifiers are supported. Reclaim modifiers
control allocation behavior during compaction/migration/reclaim.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The PFN range does not have to be pageblock aligned. The PFN range must
belong to a single zone.</p>
<p>The first thing this routine does is attempt to MIGRATE_ISOLATE all
pageblocks in the range.  Once isolated, the pageblocks should not
be modified by others.</p>
<p><strong>Return</strong></p>
<p>zero on success or negative error code.  On success all
pages which PFN is in [start, end) are allocated for the caller and
need to be freed with free_contig_range().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_contig_pages">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_contig_pages</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nodemask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_contig_pages" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>tries to find and allocate contiguous range of pages</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr_pages</span></code></dt><dd><p>Number of contiguous pages to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP mask. Node/zone/placement hints limit the search; only some
action and reclaim modifiers are supported. Reclaim modifiers
control allocation behavior during compaction/migration/reclaim.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>Target node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*nodemask</span></code></dt><dd><p>Mask for other possible nodes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is a wrapper around <a class="reference internal" href="#c.alloc_contig_range" title="alloc_contig_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_contig_range()</span></code></a>. It scans over zones
on an applicable zonelist to find a contiguous pfn range which can then be
tried for allocation with <a class="reference internal" href="#c.alloc_contig_range" title="alloc_contig_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_contig_range()</span></code></a>. This routine is intended
for allocation requests which can not be fulfilled with the buddy allocator.</p>
<p>The allocated memory is always aligned to a page boundary. If nr_pages is a
power of two, then allocated range is also guaranteed to be aligned to same
nr_pages (e.g. 1GB request would be aligned to 1GB).</p>
<p>Allocated pages can be freed with free_contig_range() or by manually calling
__free_page() on each allocated page.</p>
<p><strong>Return</strong></p>
<p>pointer to contiguous pages on success, or NULL if not successful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages_nolock">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages_nolock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_nolock" title="Link to this definition">¶</a><br /></dt>
<dd><p>opportunistic reentrant allocation from any context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>node to allocate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>allocation order size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates pages of a given order from the given node. This is safe to
call from any context (from atomic, NMI, and also reentrant
allocator -&gt; tracepoint -&gt; alloc_pages_nolock_noprof).
Allocation is best effort and to be expected to fail easily so nobody should
rely on the success. Failures are not reported via warn_alloc().
See always fail conditions below.</p>
<p><strong>Return</strong></p>
<p>allocated page or NULL on failure. NULL does not mean EBUSY or EAGAIN.
It means ENOMEM. There is no reason to call it again and expect !NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.numa_nearest_node">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numa_nearest_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.numa_nearest_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find nearest node by state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>Node id to start the search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">state</span></code></dt><dd><p>State to filter the search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup the closest node by distance if <strong>nid</strong> is not in state.</p>
<p><strong>Return</strong></p>
<p>this <strong>node</strong> if it is in state, otherwise the closest node by distance</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.nearest_node_nodemask">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">nearest_node_nodemask</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.nearest_node_nodemask" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the node in <strong>mask</strong> at the nearest distance from <strong>node</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>a valid node ID to start the search from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*mask</span></code></dt><dd><p>a pointer to a nodemask representing the allowed nodes.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function iterates over all nodes in <strong>mask</strong> and calculates the
distance from the starting <strong>node</strong>, then it returns the node ID that is
the closest to <strong>node</strong>, or MAX_NUMNODES if no node is found.</p>
<p>Note that <strong>node</strong> must be a valid node ID usable with node_distance(),
providing an invalid node ID (e.g., NUMA_NO_NODE) may result in crashes
or unexpected behavior.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages_mpol">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages_mpol</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mempolicy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pol</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">ilx</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_mpol" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate pages according to NUMA mempolicy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Order of the page allocation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mempolicy</span> <span class="pre">*pol</span></code></dt><dd><p>Pointer to the NUMA mempolicy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">ilx</span></code></dt><dd><p>Index for interleave mempolicy (also distinguishes <a class="reference internal" href="#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>Preferred node (usually numa_node_id() but <strong>mpol</strong> may override it).</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The page on success or NULL if allocation fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vma_alloc_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vma_alloc_folio</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vma_alloc_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate a folio for a VMA.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Order of the folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>Pointer to VMA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>Virtual address of the allocation.  Must be inside <strong>vma</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a folio for a specific address in <strong>vma</strong>, using the appropriate
NUMA policy.  The caller must hold the mmap_lock of the mm_struct of the
VMA to prevent it from going away.  Should be used for all allocations
for folios that will be mapped into user space, excepting hugetlbfs, and
excepting where direct use of folio_alloc_mpol() is more appropriate.</p>
<p><strong>Return</strong></p>
<p>The folio on success or NULL if allocation fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_pages">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_pages</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate pages.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Power of two of number of pages to allocate.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate 1 &lt;&lt; <strong>order</strong> contiguous pages.  The physical address of the
first page is naturally aligned (eg an order-3 allocation will be aligned
to a multiple of 8 * PAGE_SIZE bytes).  The NUMA policy of the current
process is honoured when in process context.</p>
<p><strong>Context</strong></p>
<p>Can be called from any context, providing the appropriate GFP
flags are used.</p>
<p><strong>Return</strong></p>
<p>The page on success or NULL if allocation fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpol_misplaced">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpol_misplaced</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.mpol_misplaced" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_fault</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vmf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpol_misplaced" title="Link to this definition">¶</a><br /></dt>
<dd><p>check whether current folio node is valid in policy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>folio to be checked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*vmf</span></code></dt><dd><p>structure describing the fault</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>virtual address in <strong>vma</strong> for shared policy lookup and interleave policy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup current policy node id for vma,addr and “compare to” folio’s
node id.  Policy determination “mimics” alloc_page_vma().
Called from fault path where we know the vma and faulting address.</p>
<p><strong>Return</strong></p>
<p>NUMA_NO_NODE if the page is in a node that is valid for this
policy, or a suitable node ID to allocate a replacement folio from.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpol_shared_policy_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpol_shared_policy_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">shared_policy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mempolicy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mpol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpol_shared_policy_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize shared policy for inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">shared_policy</span> <span class="pre">*sp</span></code></dt><dd><p>pointer to inode shared policy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mempolicy</span> <span class="pre">*mpol</span></code></dt><dd><p>struct mempolicy to install</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Install non-NULL <strong>mpol</strong> in inode’s shared policy rb-tree.
On entry, the current task has a reference on a non-NULL <strong>mpol</strong>.
This must be released on exit.
This is called at get_inode() calls and we can use GFP_KERNEL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpol_parse_str">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpol_parse_str</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mempolicy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mpol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpol_parse_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>parse string to mempolicy, for tmpfs mpol mount option.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>string containing mempolicy to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mempolicy</span> <span class="pre">**mpol</span></code></dt><dd><p>pointer to struct mempolicy pointer, returned on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Format of input:</dt><dd><p>&lt;mode&gt;[=&lt;flags&gt;][:&lt;nodelist&gt;]</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, else <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpol_to_str">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpol_to_str</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">maxlen</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mempolicy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpol_to_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>format a mempolicy structure for printing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>to contain formatted mempolicy string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">maxlen</span></code></dt><dd><p>length of <strong>buffer</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mempolicy</span> <span class="pre">*pol</span></code></dt><dd><p>pointer to mempolicy to be formatted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert <strong>pol</strong> into a string.  If <strong>buffer</strong> is too short, truncate the string.
Recommend a <strong>maxlen</strong> of at least 51 for the longest mode, “weighted
interleave”, plus the longest flag flags, “relative|balancing”, and to
display at least a few node ids.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio</span></span></span><a class="headerlink" href="#c.folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Represents a contiguous set of bytes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct folio {
    unsigned long flags;
    union {
        struct list_head lru;
        unsigned int mlock_count;
        struct dev_pagemap *pgmap;
    };
    struct address_space *mapping;
    union {
        pgoff_t index;
        unsigned long share;
    };
    union {
        void *private;
        swp_entry_t swap;
    };
    atomic_t _mapcount;
    atomic_t _refcount;
#ifdef CONFIG_MEMCG;
    unsigned long memcg_data;
#elif defined(CONFIG_SLAB_OBJ_EXT);
    unsigned long _unused_slab_obj_exts;
#endif;
#if defined(WANT_PAGE_VIRTUAL);
    void *virtual;
#endif;
#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS;
    int _last_cpupid;
#endif;
    atomic_t _large_mapcount;
    atomic_t _nr_pages_mapped;
#ifdef CONFIG_64BIT;
    atomic_t _entire_mapcount;
    atomic_t _pincount;
#endif ;
    mm_id_mapcount_t _mm_id_mapcount[2];
    union {
        mm_id_t _mm_id[2];
        unsigned long _mm_ids;
    };
#ifdef NR_PAGES_IN_LARGE_FOLIO;
    unsigned int _nr_pages;
#endif ;
    struct list_head _deferred_list;
#ifndef CONFIG_64BIT;
    atomic_t _entire_mapcount;
    atomic_t _pincount;
#endif ;
    void *_hugetlb_subpool;
    void *_hugetlb_cgroup;
    void *_hugetlb_cgroup_rsvd;
    void *_hugetlb_hwpoison;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Identical to the page flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lru</span></code></dt><dd><p>Least Recently Used list; tracks how recently this folio was used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mlock_count</span></code></dt><dd><p>Number of times this folio has been pinned by mlock().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgmap</span></code></dt><dd><p>Metadata for ZONE_DEVICE mappings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mapping</span></code></dt><dd><p>The file this page belongs to, or refers to the anon_vma for
anonymous memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>Offset within the file, in units of pages.  For anonymous memory,
this is the index from the beginning of the mmap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">share</span></code></dt><dd><p>number of DAX mappings that reference this folio. See
dax_associate_entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>Filesystem per-folio data (see <a class="reference internal" href="#c.folio_attach_private" title="folio_attach_private"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_attach_private()</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swap</span></code></dt><dd><p>Used for swp_entry_t if folio_test_swapcache().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mapcount</span></code></dt><dd><p>Do not access this member directly.  Use <a class="reference internal" href="#c.folio_mapcount" title="folio_mapcount"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mapcount()</span></code></a> to
find out how many times this folio is mapped by userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_refcount</span></code></dt><dd><p>Do not access this member directly.  Use <a class="reference internal" href="#c.folio_ref_count" title="folio_ref_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_ref_count()</span></code></a>
to find how many references there are to this folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memcg_data</span></code></dt><dd><p>Memory Control Group data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_unused_slab_obj_exts</span></code></dt><dd><p>Placeholder to match obj_exts in struct slab.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">virtual</span></code></dt><dd><p>Virtual address in the kernel direct map.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_last_cpupid</span></code></dt><dd><p>IDs of last CPU and last process that accessed the folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_large_mapcount</span></code></dt><dd><p>Do not use directly, call <a class="reference internal" href="#c.folio_mapcount" title="folio_mapcount"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mapcount()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_nr_pages_mapped</span></code></dt><dd><p>Do not use outside of rmap and debug code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_entire_mapcount</span></code></dt><dd><p>Do not use directly, call folio_entire_mapcount().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_pincount</span></code></dt><dd><p>Do not use directly, call <a class="reference internal" href="#c.folio_maybe_dma_pinned" title="folio_maybe_dma_pinned"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_maybe_dma_pinned()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mm_id_mapcount</span></code></dt><dd><p>Do not use outside of rmap code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mm_id</span></code></dt><dd><p>Do not use outside of rmap code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mm_ids</span></code></dt><dd><p>Do not use outside of rmap code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_nr_pages</span></code></dt><dd><p>Do not use directly, call <a class="reference internal" href="#c.folio_nr_pages" title="folio_nr_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_nr_pages()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_deferred_list</span></code></dt><dd><p>Folios to be split under memory pressure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_entire_mapcount</span></code></dt><dd><p>Do not use directly, call folio_entire_mapcount().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_pincount</span></code></dt><dd><p>Do not use directly, call <a class="reference internal" href="#c.folio_maybe_dma_pinned" title="folio_maybe_dma_pinned"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_maybe_dma_pinned()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_hugetlb_subpool</span></code></dt><dd><p>Do not use directly, use accessor in hugetlb.h.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_hugetlb_cgroup</span></code></dt><dd><p>Do not use directly, use accessor in hugetlb_cgroup.h.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_hugetlb_cgroup_rsvd</span></code></dt><dd><p>Do not use directly, use accessor in hugetlb_cgroup.h.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_hugetlb_hwpoison</span></code></dt><dd><p>Do not use directly, call raw_hwp_list_head().</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A folio is a physically, virtually and logically contiguous set
of bytes.  It is a power-of-two in size, and it is aligned to that
same power-of-two.  It is at least as large as <code class="docutils literal notranslate"><span class="pre">PAGE_SIZE</span></code>.  If it is
in the page cache, it is at a file offset which is a multiple of that
power-of-two.  It may be mapped into userspace at an address which is
at an arbitrary page offset, but its kernel virtual address is aligned
to its size.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ptdesc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ptdesc</span></span></span><a class="headerlink" href="#c.ptdesc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Memory descriptor for page tables.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ptdesc {
    unsigned long __page_flags;
    union {
        struct rcu_head pt_rcu_head;
        struct list_head pt_list;
        struct {
            unsigned long _pt_pad_1;
            pgtable_t pmd_huge_pte;
        };
    };
    unsigned long __page_mapping;
    union {
        pgoff_t pt_index;
        struct mm_struct *pt_mm;
        atomic_t pt_frag_refcount;
#ifdef CONFIG_HUGETLB_PMD_PAGE_TABLE_SHARING;
        atomic_t pt_share_count;
#endif;
    };
    union {
        unsigned long _pt_pad_2;
#if ALLOC_SPLIT_PTLOCKS;
        spinlock_t *ptl;
#else;
        spinlock_t ptl;
#endif;
    };
    unsigned int __page_type;
    atomic_t __page_refcount;
#ifdef CONFIG_MEMCG;
    unsigned long pt_memcg_data;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__page_flags</span></code></dt><dd><p>Same as page flags. Powerpc only.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_rcu_head</span></code></dt><dd><p>For freeing page table pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_list</span></code></dt><dd><p>List of used page tables. Used for s390 gmap shadow pages
(which are not linked into the user page tables) and x86
pgds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_pt_pad_1</span></code></dt><dd><p>Padding that aliases with page’s compound head.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmd_huge_pte</span></code></dt><dd><p>Protected by ptdesc-&gt;ptl, used for THPs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__page_mapping</span></code></dt><dd><p>Aliases with page-&gt;mapping. Unused for page tables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_index</span></code></dt><dd><p>Used for s390 gmap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_mm</span></code></dt><dd><p>Used for x86 pgds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_frag_refcount</span></code></dt><dd><p>For fragmented page table tracking. Powerpc only.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_share_count</span></code></dt><dd><p>Used for HugeTLB PMD page table share count.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_pt_pad_2</span></code></dt><dd><p>Padding to ensure proper alignment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptl</span></code></dt><dd><p>Lock for the page table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptl</span></code></dt><dd><p>Lock for the page table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__page_type</span></code></dt><dd><p>Same as page-&gt;page_type. Unused for page tables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__page_refcount</span></code></dt><dd><p>Same as page refcount.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_memcg_data</span></code></dt><dd><p>Memcg data. Tracked for page tables here.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct overlays struct page for now. Do not modify without a good
understanding of the issues.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.vm_fault_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_fault_t</span></span></span><a class="headerlink" href="#c.vm_fault_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return type for page fault handlers.</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>Page fault handlers return a bitmask of <code class="docutils literal notranslate"><span class="pre">VM_FAULT</span></code> values.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.vm_fault_reason">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vm_fault_reason</span></span></span><a class="headerlink" href="#c.vm_fault_reason" title="Link to this definition">¶</a><br /></dt>
<dd><p>Page fault handlers return a bitmask of these values to tell the core VM what happened when handling the fault. Used to decide whether a process gets delivered SIGBUS or just gets major/minor fault counters bumped up.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_OOM</span></code></dt><dd><p>Out Of Memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_SIGBUS</span></code></dt><dd><p>Bad access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_MAJOR</span></code></dt><dd><p>Page read from storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_HWPOISON</span></code></dt><dd><p>Hit poisoned small page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_HWPOISON_LARGE</span></code></dt><dd><p>Hit poisoned large page. Index encoded
in upper bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_SIGSEGV</span></code></dt><dd><p>segmentation fault</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_NOPAGE</span></code></dt><dd><p>-&gt;fault installed the pte, not return page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_LOCKED</span></code></dt><dd><p>-&gt;fault locked the returned page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_RETRY</span></code></dt><dd><p>-&gt;fault blocked, must retry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_FALLBACK</span></code></dt><dd><p>huge page fault failed, fall back to small</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_DONE_COW</span></code></dt><dd><p>-&gt;fault has fully handled COW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_NEEDDSYNC</span></code></dt><dd><p>-&gt;fault did not modify page tables and needs
fsync() to complete (for synchronous page faults
in DAX)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_COMPLETED</span></code></dt><dd><p>-&gt;fault completed, meanwhile mmap lock released</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VM_FAULT_HINDEX_MASK</span></code></dt><dd><p>mask HINDEX value</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.fault_flag">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fault_flag</span></span></span><a class="headerlink" href="#c.fault_flag" title="Link to this definition">¶</a><br /></dt>
<dd><p>Fault flag definitions.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_WRITE</span></code></dt><dd><p>Fault was a write fault.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_MKWRITE</span></code></dt><dd><p>Fault was mkwrite of existing PTE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_ALLOW_RETRY</span></code></dt><dd><p>Allow to retry the fault if blocked.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_RETRY_NOWAIT</span></code></dt><dd><p>Don’t drop mmap_lock and wait when retrying.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_KILLABLE</span></code></dt><dd><p>The fault task is in SIGKILL killable region.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_TRIED</span></code></dt><dd><p>The fault has been tried once.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_USER</span></code></dt><dd><p>The fault originated in userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_REMOTE</span></code></dt><dd><p>The fault is not for current task/mm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_INSTRUCTION</span></code></dt><dd><p>The fault was during an instruction fetch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_INTERRUPTIBLE</span></code></dt><dd><p>The fault can be interrupted by non-fatal signals.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_UNSHARE</span></code></dt><dd><p>The fault is an unsharing request to break COW in a
COW mapping, making sure that an exclusive anon page is
mapped after the fault.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_ORIG_PTE_VALID</span></code></dt><dd><p>whether the fault has vmf-&gt;orig_pte cached.
We should only access orig_pte if this flag set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FAULT_FLAG_VMA_LOCK</span></code></dt><dd><p>The fault is handled under VMA lock.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>About <strong>FAULT_FLAG_ALLOW_RETRY</strong> and <strong>FAULT_FLAG_TRIED</strong>: we can specify
whether we would allow page faults to retry by specifying these two
fault flags correctly.  Currently there can be three legal combinations:</p>
<ol class="loweralpha simple">
<li><dl class="simple">
<dt>ALLOW_RETRY and !TRIED:  this means the page fault allows retry, and</dt><dd><p>this is the first try</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ALLOW_RETRY and TRIED:   this means the page fault allows retry, and</dt><dd><p>we’ve already tried at least once</p>
</dd>
</dl>
</li>
<li><p>!ALLOW_RETRY and !TRIED: this means the page fault does not allow retry</p></li>
</ol>
<p>The unlisted combination (!ALLOW_RETRY &amp;&amp; TRIED) is illegal and should never
be used.  Note that page faults can be allowed to retry for multiple times,
in which case we’ll have an initial fault with flags (a) then later on
continuous faults with flags (b).  We should always try to detect pending
signals before a retry to make sure the continuous page faults can still be
interrupted if necessary.</p>
<p>The combination FAULT_FLAG_WRITE|FAULT_FLAG_UNSHARE is illegal.
FAULT_FLAG_UNSHARE is ignored and treated like an ordinary read fault when
applied to mappings that are not COW mappings.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_is_file_lru">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_is_file_lru</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_is_file_lru" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_is_file_lru" title="Link to this definition">¶</a><br /></dt>
<dd><p>Should the folio be on a file LRU or anon LRU?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to test.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We would like to get this info without a page flag, but the state
needs to survive until the folio is last deleted from the LRU, which
could be as far down as __page_cache_release.</p>
<p><strong>Return</strong></p>
<p>An integer (not a boolean!) used to sort a folio onto the
right LRU list and to account folios correctly.
1 if <strong>folio</strong> is a regular filesystem backed page cache folio
or a lazily freed anonymous folio (e.g. via MADV_FREE).
0 if <strong>folio</strong> is a normal anonymous folio, a tmpfs folio or otherwise
ram or swap backed folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__folio_clear_lru_flags">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__folio_clear_lru_flags</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__folio_clear_lru_flags" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__folio_clear_lru_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear page lru flags before releasing a page.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio that was on lru and now has a zero reference.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_lru_list">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">lru_list</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_lru_list</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_lru_list" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_lru_list" title="Link to this definition">¶</a><br /></dt>
<dd><p>Which LRU list should a folio be on?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to test.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The LRU list a folio should be on, as an index
into the array of LRU lists.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.page_folio">
<span class="sig-name descname"><span class="n"><span class="pre">page_folio</span></span></span><a class="headerlink" href="#c.page_folio" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">page_folio</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>Converts from page to folio.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The page.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Every page is part of a folio.  This function cannot be called on a
NULL pointer.</p>
<p><strong>Context</strong></p>
<p>No reference, nor lock is required on <strong>page</strong>.  If the caller
does not hold a reference, this call may race with a folio split, so
it should re-check the folio still contains this page after gaining
a reference on the folio.</p>
<p><strong>Return</strong></p>
<p>The folio which contains this page.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.folio_page">
<span class="sig-name descname"><span class="n"><span class="pre">folio_page</span></span></span><a class="headerlink" href="#c.folio_page" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">folio_page</span> <span class="pre">(folio,</span> <span class="pre">n)</span></code></p>
<blockquote>
<div><p>Return a page from a folio.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">folio</span></code></dt><dd><p>The folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>The page number to return.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>n</strong> is relative to the start of the folio.  This function does not
check that the page number lies within <strong>folio</strong>; the caller is presumed
to have a reference to the page.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_xor_flags_has_waiters">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_xor_flags_has_waiters</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_xor_flags_has_waiters" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_xor_flags_has_waiters" title="Link to this definition">¶</a><br /></dt>
<dd><p>Change some folio flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>Bits set in this word will be changed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must only be used for flags which are changed with the folio
lock held.  For example, it is unsafe to use for PG_dirty as that
can be set without the folio lock held.  It can also only be used
on flags which are in the range 0-6 as some of the implementations
only affect those bits.</p>
<p><strong>Return</strong></p>
<p>Whether there are tasks waiting on the folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_test_uptodate">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_test_uptodate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_test_uptodate" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_test_uptodate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Is this folio up to date?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The uptodate flag is set on a folio when every byte in the folio is
at least as new as the corresponding bytes on storage.  Anonymous
and CoW folios are always uptodate.  If the folio is not uptodate,
some of the bytes in it may be; see the is_partially_uptodate()
address_space operation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_test_large">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_test_large</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_test_large" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_test_large" title="Link to this definition">¶</a><br /></dt>
<dd><p>Does this folio contain more than one page?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to test.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the folio is larger than one page.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PageSlab">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PageSlab</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.PageSlab" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PageSlab" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determine if the page belongs to the slab allocator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page to test.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>True for slab pages, false for any other kind of page.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PageHuge">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PageHuge</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.PageHuge" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PageHuge" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determine if the page belongs to hugetlbfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page to test.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>True for hugetlbfs pages, false for anon pages or pages
belonging to other filesystems.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_has_private">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_has_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_has_private" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_has_private" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determine if folio has private stuff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if a folio has private stuff, indicating that release routines
should be invoked upon it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fault_flag_allow_retry_first">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fault_flag_allow_retry_first</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.fault_flag" title="fault_flag"><span class="n"><span class="pre">fault_flag</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fault_flag_allow_retry_first" title="Link to this definition">¶</a><br /></dt>
<dd><p>check ALLOW_RETRY the first time</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fault_flag</span> <span class="pre">flags</span></code></dt><dd><p>Fault flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is mostly used for places where we want to try to avoid taking
the mmap_lock for too long a time when waiting for another condition
to change, in which case we can try to be polite to release the
mmap_lock in the first round to avoid potential starvation of other
processes that would also want the mmap_lock.</p>
<p><strong>Return</strong></p>
<p>true if the page fault allows retry and this is the first
attempt of the fault handling; false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_order">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_order</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_order" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_order" title="Link to this definition">¶</a><br /></dt>
<dd><p>The allocation order of a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A folio is composed of 2^order pages.  See get_order() for the definition
of order.</p>
<p><strong>Return</strong></p>
<p>The order of the folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_reset_order">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_reset_order</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_reset_order" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_reset_order" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reset the folio order and derived _nr_pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the order and derived _nr_pages to 0. Must only be used in the
process of splitting large folios.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mapcount">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mapcount</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mapcount" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mapcount" title="Link to this definition">¶</a><br /></dt>
<dd><p>Number of mappings of this folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The folio mapcount corresponds to the number of present user page table
entries that reference any part of a folio. Each such present user page
table entry must be paired with exactly on folio reference.</p>
<p>For ordindary folios, each user page table entry (PTE/PMD/PUD/...) counts
exactly once.</p>
<p>For hugetlb folios, each abstracted “hugetlb” user page table entry that
references the entire folio counts exactly once, even when such special
page table entries are comprised of multiple ordinary page table entries.</p>
<p>Will report 0 for pages which cannot be mapped into userspace, such as
slab, page tables and similar.</p>
<p><strong>Return</strong></p>
<p>The number of times this folio is mapped.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mapped">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mapped</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mapped" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mapped" title="Link to this definition">¶</a><br /></dt>
<dd><p>Is this folio mapped into userspace?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if any page in this folio is referenced by user page tables.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.thp_order">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thp_order</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.thp_order" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thp_order" title="Link to this definition">¶</a><br /></dt>
<dd><p>Order of a transparent huge page.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>Head page of a transparent huge page.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.thp_size">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thp_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.thp_size" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thp_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Size of a transparent huge page.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>Head page of a transparent huge page.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of bytes in this page.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_get" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Increment the reference count on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May be called in any context, as long as you know that
you have a refcount on the folio.  If you do not already have one,
<a class="reference internal" href="#c.folio_try_get" title="folio_try_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_try_get()</span></code></a> may be the right interface for you to use.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_put" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>Decrement the reference count on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the folio’s reference count reaches zero, the memory will be
released back to the page allocator and may be used by another
allocation immediately.  Do not access the memory or the <a class="reference internal" href="#c.folio" title="folio"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span></code></a>
after calling <a class="reference internal" href="#c.folio_put" title="folio_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_put()</span></code></a> unless you can be sure that it wasn’t the
last reference.</p>
<p><strong>Context</strong></p>
<p>May be called in process or interrupt context, but not in NMI
context.  May be called while holding a spinlock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_put_refs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_put_refs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_put_refs" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">refs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_put_refs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reduce the reference count on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">refs</span></code></dt><dd><p>The amount to subtract from the folio’s reference count.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the folio’s reference count reaches zero, the memory will be
released back to the page allocator and may be used by another
allocation immediately.  Do not access the memory or the <a class="reference internal" href="#c.folio" title="folio"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span></code></a>
after calling <a class="reference internal" href="#c.folio_put_refs" title="folio_put_refs"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_put_refs()</span></code></a> unless you can be sure that these weren’t
the last references.</p>
<p><strong>Context</strong></p>
<p>May be called in process or interrupt context, but not in NMI
context.  May be called while holding a spinlock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folios_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folios_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_batch</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folios</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folios_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>Decrement the reference count on an array of folios.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_batch</span> <span class="pre">*folios</span></code></dt><dd><p>The folios.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.folio_put" title="folio_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_put()</span></code></a>, but for a batch of folios.  This is more efficient
than writing the loop yourself as it will optimise the locks which need
to be taken if the folios are freed.  The folios batch is returned
empty and ready to be reused for another batch; there is no need to
reinitialise it.</p>
<p><strong>Context</strong></p>
<p>May be called in process or interrupt context, but not in NMI
context.  May be called while holding a spinlock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_pfn">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_pfn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_pfn" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_pfn" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the Page Frame Number of a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A folio may contain multiple pages.  The pages have consecutive
Page Frame Numbers.</p>
<p><strong>Return</strong></p>
<p>The Page Frame Number of the first page in the folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mk_pte">
<span class="n"><span class="pre">pte_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mk_pte</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mk_pte" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgprot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mk_pte" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a PTE for this folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to create a PTE for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">pgprot</span></code></dt><dd><p>The page protection bits to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a page table entry for the first page of this folio.
This is suitable for passing to set_ptes().</p>
<p><strong>Return</strong></p>
<p>A page table entry suitable for mapping this folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mk_pmd">
<span class="n"><span class="pre">pmd_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mk_pmd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mk_pmd" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">pgprot_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgprot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mk_pmd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a PMD for this folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to create a PMD for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgprot_t</span> <span class="pre">pgprot</span></code></dt><dd><p>The page protection bits to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a page table entry for the first page of this folio.
This is suitable for passing to set_pmd_at().</p>
<p><strong>Return</strong></p>
<p>A page table entry suitable for mapping this folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_maybe_dma_pinned">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_maybe_dma_pinned</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_maybe_dma_pinned" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_maybe_dma_pinned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Report if a folio may be pinned for DMA.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks if a folio has been pinned via a call to
a function in the pin_user_pages() family.</p>
<p>For small folios, the return value is partially fuzzy: false is not fuzzy,
because it means “definitely not pinned for DMA”, but true means “probably
pinned for DMA, but possibly a false positive due to having at least
GUP_PIN_COUNTING_BIAS worth of normal folio references”.</p>
<p>False positives are OK, because: a) it’s unlikely for a folio to
get that many refcounts, and b) all the callers of this routine are
expected to be able to deal gracefully with a false positive.</p>
<p>For most large folios, the result will be exactly correct. That’s because
we have more tracking data available: the _pincount field is used
instead of the GUP_PIN_COUNTING_BIAS scheme.</p>
<p>For more information, please see <a class="reference internal" href="pin_user_pages.html"><span class="doc">pin_user_pages() and related calls</span></a>.</p>
<p><strong>Return</strong></p>
<p>True, if it is likely that the folio has been “dma-pinned”.
False, if the folio is definitely not dma-pinned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.is_zero_page">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_zero_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.is_zero_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.is_zero_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query if a page is a zero page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns true if <strong>page</strong> is one of the permanent zero pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.is_zero_folio">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_zero_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.is_zero_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.is_zero_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query if a folio is a zero page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns true if <strong>folio</strong> is one of the permanent zero pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_nr_pages">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_nr_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_nr_pages" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_nr_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>The number of pages in the folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A positive power of two.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_next">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_next" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_next" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_next" title="Link to this definition">¶</a><br /></dt>
<dd><p>Move to the next physical folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio we’re currently operating on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you have physically contiguous memory which may span more than
one folio (eg a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_vec</span></code>), use this function to move from one
folio to the next.  Do not use it if the memory is only virtually
contiguous as the folios are almost certainly not adjacent to each
other.  This is the folio equivalent to writing <code class="docutils literal notranslate"><span class="pre">page++</span></code>.</p>
<p><strong>Context</strong></p>
<p>We assume that the folios are refcounted and/or locked at a
higher level and do not adjust the reference counts.</p>
<p><strong>Return</strong></p>
<p>The next <a class="reference internal" href="#c.folio" title="folio"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_shift">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_shift</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_shift" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_shift" title="Link to this definition">¶</a><br /></dt>
<dd><p>The size of the memory described by this folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A folio represents a number of bytes which is a power-of-two in size.
This function tells you which power-of-two the folio is.  See also
<a class="reference internal" href="#c.folio_size" title="folio_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_size()</span></code></a> and <a class="reference internal" href="#c.folio_order" title="folio_order"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_order()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>The caller should have a reference on the folio to prevent
it from being split.  It is not necessary for the folio to be locked.</p>
<p><strong>Return</strong></p>
<p>The base-2 logarithm of the size of this folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_size">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_size" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>The number of bytes in a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>The caller should have a reference on the folio to prevent
it from being split.  It is not necessary for the folio to be locked.</p>
<p><strong>Return</strong></p>
<p>The number of bytes in this folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_maybe_mapped_shared">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_maybe_mapped_shared</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_maybe_mapped_shared" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_maybe_mapped_shared" title="Link to this definition">¶</a><br /></dt>
<dd><p>Whether the folio is mapped into the page tables of more than one MM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks if the folio maybe currently mapped into more than one
MM (“maybe mapped shared”), or if the folio is certainly mapped into a single
MM (“mapped exclusively”).</p>
<p>For KSM folios, this function also returns “mapped shared” when a folio is
mapped multiple times into the same MM, because the individual page mappings
are independent.</p>
<p>For small anonymous folios and anonymous hugetlb folios, the return
value will be exactly correct: non-KSM folios can only be mapped at most once
into an MM, and they cannot be partially mapped. KSM folios are
considered shared even if mapped multiple times into the same MM.</p>
<dl class="simple">
<dt>For other folios, the result can be fuzzy:</dt><dd><ol class="arabic simple">
<li><p>For partially-mappable large folios (THP), the return value can wrongly
indicate “mapped shared” (false positive) if a folio was mapped by
more than two MMs at one point in time.</p></li>
<li><p>For pagecache folios (including hugetlb), the return value can wrongly
indicate “mapped shared” (false positive) when two VMAs in the same MM
cover the same file range.</p></li>
</ol>
</dd>
</dl>
<p>Further, this function only considers current page table mappings that
are tracked using the folio mapcount(s).</p>
<dl class="simple">
<dt>This function does not consider:</dt><dd><ol class="arabic simple">
<li><p>If the folio might get mapped in the (near) future (e.g., swapcache,
pagecache, temporary unmapping for migration).</p></li>
<li><p>If the folio is mapped differently (VM_PFNMAP).</p></li>
<li><p>If hugetlb page table sharing applies. Callers might want to check
hugetlb_pmd_shared().</p></li>
</ol>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Whether the folio is estimated to be mapped into more than one MM.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_expected_ref_count">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_expected_ref_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_expected_ref_count" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_expected_ref_count" title="Link to this definition">¶</a><br /></dt>
<dd><p>calculate the expected folio refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>the folio</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the expected folio refcount, taking references from the pagecache,
swapcache, PG_private and page table mappings into account. Useful in
combination with <a class="reference internal" href="#c.folio_ref_count" title="folio_ref_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_ref_count()</span></code></a> to detect unexpected references (e.g.,
GUP or other temporary references).</p>
<p>Does currently not consider references from the LRU cache. If the folio
was isolated from the LRU (which is the case during migration or split),
the LRU cache does not apply.</p>
<p>Calling this function on an unmapped folio -- !<a class="reference internal" href="#c.folio_mapped" title="folio_mapped"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mapped()</span></code></a> -- that is
locked will return a stable result.</p>
<p>Calling this function on a mapped folio will not result in a stable result,
because nothing stops additional page table mappings from coming (e.g.,
fork()) or going (e.g., munmap()).</p>
<p>Calling this function without the folio lock will also not result in a
stable result: for example, the folio might get dropped from the swapcache
concurrently.</p>
<p>However, even when called without the folio lock or on a mapped folio,
this function can be used to detect unexpected references early (for example,
if it makes sense to even lock the folio and unmap it).</p>
<p>The caller must add any reference (e.g., from <a class="reference internal" href="#c.folio_try_get" title="folio_try_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_try_get()</span></code></a>) it might be
holding itself to the result.</p>
<p>Returns the expected folio refcount.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pagetable_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ptdesc" title="ptdesc"><span class="n"><span class="pre">ptdesc</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pagetable_alloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pagetable_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate pagetables</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>desired pagetable order</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>pagetable_alloc allocates memory for page tables as well as a page table
descriptor to describe that memory.</p>
<p><strong>Return</strong></p>
<p>The ptdesc describing the allocated page tables.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pagetable_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pagetable_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ptdesc" title="ptdesc"><span class="n"><span class="pre">ptdesc</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pagetable_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free pagetables</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ptdesc</span> <span class="pre">*pt</span></code></dt><dd><p>The page table descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>pagetable_free frees the memory of all page tables described by a page
table descriptor and the memory for the descriptor itself.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vma_lookup">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vma_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vma_lookup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find a VMA at a specific address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>The process address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>The user address.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The vm_area_struct at the given address, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vma_is_special_huge">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vma_is_special_huge</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vma_is_special_huge" title="Link to this definition">¶</a><br /></dt>
<dd><p>Are transhuge page-table entries considered special?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>Pointer to the struct vm_area_struct to consider</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Whether transhuge page-table entries are considered “special” following
the definition in vm_normal_page().</p>
<p><strong>Return</strong></p>
<p>true if transhuge page-table entries should be considered special,
false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_ref_count">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_ref_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_ref_count" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_ref_count" title="Link to this definition">¶</a><br /></dt>
<dd><p>The reference count on this folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The refcount is usually incremented by calls to <a class="reference internal" href="#c.folio_get" title="folio_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_get()</span></code></a> and
decremented by calls to <a class="reference internal" href="#c.folio_put" title="folio_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_put()</span></code></a>.  Some typical users of the
folio refcount:</p>
<ul class="simple">
<li><p>Each reference from a page table</p></li>
<li><p>The page cache</p></li>
<li><p>Filesystem private data</p></li>
<li><p>The LRU list</p></li>
<li><p>Pipes</p></li>
<li><p>Direct IO which references this page in the process address space</p></li>
</ul>
<p><strong>Return</strong></p>
<p>The number of references to this folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_try_get">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_try_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_try_get" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_try_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempt to increase the refcount on a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you do not already have a reference to a folio, you can attempt to
get one using this function.  It may fail if, for example, the folio
has been freed since you found a pointer to it, or it is frozen for
the purposes of splitting or migration.</p>
<p><strong>Return</strong></p>
<p>True if the reference count was successfully incremented.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.is_highmem">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_highmem</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.is_highmem" title="zone"><span class="n"><span class="pre">zone</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zone</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.is_highmem" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper function to quickly check if a struct zone is a highmem zone or not. This is an attempt to keep references to ZONE_{DMA/NORMAL/HIGHMEM/etc} in general code to a minimum.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zone</span> <span class="pre">*zone</span></code></dt><dd><p>pointer to struct zone variable</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 for a highmem zone, 0 otherwise</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_online_pgdat">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_online_pgdat</span></span></span><a class="headerlink" href="#c.for_each_online_pgdat" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_online_pgdat</span> <span class="pre">(pgdat)</span></code></p>
<blockquote>
<div><p>helper macro to iterate over all online nodes</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pgdat</span></code></dt><dd><p>pointer to a pg_data_t variable</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_zone">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_zone</span></span></span><a class="headerlink" href="#c.for_each_zone" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_zone</span> <span class="pre">(zone)</span></code></p>
<blockquote>
<div><p>helper macro to iterate over all memory zones</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">zone</span></code></dt><dd><p>pointer to struct zone variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The user only needs to declare the zone variable, for_each_zone
fills it in.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.next_zones_zonelist">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zoneref</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">next_zones_zonelist</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zoneref</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">zone_type</span></span><span class="w"> </span><span class="n"><span class="pre">highest_zoneidx</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nodes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.next_zones_zonelist" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the next zone at or below highest_zoneidx within the allowed nodemask using a cursor within a zonelist as a starting point</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zoneref</span> <span class="pre">*z</span></code></dt><dd><p>The cursor used as a starting point for the search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">zone_type</span> <span class="pre">highest_zoneidx</span></code></dt><dd><p>The zone index of the highest zone to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*nodes</span></code></dt><dd><p>An optional nodemask to filter the zonelist with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the next zone at or below a given zone index that is
within the allowed nodemask using a cursor as the starting point for the
search. The zoneref returned is a cursor that represents the current zone
being examined. It should be advanced by one before calling
next_zones_zonelist again.</p>
<p><strong>Return</strong></p>
<p>the next zone at or below highest_zoneidx within the allowed
nodemask using a cursor within a zonelist as a starting point</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.first_zones_zonelist">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zoneref</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">first_zones_zonelist</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.first_zones_zonelist" title="zonelist"><span class="n"><span class="pre">zonelist</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zonelist</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">zone_type</span></span><span class="w"> </span><span class="n"><span class="pre">highest_zoneidx</span></span>, <span class="n"><span class="pre">nodemask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nodes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.first_zones_zonelist" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the first zone at or below highest_zoneidx within the allowed nodemask in a zonelist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zonelist</span> <span class="pre">*zonelist</span></code></dt><dd><p>The zonelist to search for a suitable zone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">zone_type</span> <span class="pre">highest_zoneidx</span></code></dt><dd><p>The zone index of the highest zone to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask_t</span> <span class="pre">*nodes</span></code></dt><dd><p>An optional nodemask to filter the zonelist with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the first zone at or below a given zone index that is
within the allowed nodemask. The zoneref returned is a cursor that can be
used to iterate the zonelist with next_zones_zonelist by advancing it by
one before calling.</p>
<p>When no eligible zone is found, zoneref-&gt;zone is NULL (zoneref itself is
never NULL). This may happen either genuinely, or due to concurrent nodemask
update due to cpuset modification.</p>
<p><strong>Return</strong></p>
<p>Zoneref pointer for the first suitable zone found</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_zone_zonelist_nodemask">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_zone_zonelist_nodemask</span></span></span><a class="headerlink" href="#c.for_each_zone_zonelist_nodemask" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_zone_zonelist_nodemask</span> <span class="pre">(zone,</span> <span class="pre">z,</span> <span class="pre">zlist,</span> <span class="pre">highidx,</span> <span class="pre">nodemask)</span></code></p>
<blockquote>
<div><p>helper macro to iterate over valid zones in a zonelist at or below a given zone index and within a nodemask</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">zone</span></code></dt><dd><p>The current zone in the iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code></dt><dd><p>The current pointer within zonelist-&gt;_zonerefs being iterated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zlist</span></code></dt><dd><p>The zonelist being iterated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">highidx</span></code></dt><dd><p>The zone index of the highest zone to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodemask</span></code></dt><dd><p>Nodemask allowed by the allocator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator iterates though all zones at or below a given zone index and
within a given nodemask</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_zone_zonelist">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_zone_zonelist</span></span></span><a class="headerlink" href="#c.for_each_zone_zonelist" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_zone_zonelist</span> <span class="pre">(zone,</span> <span class="pre">z,</span> <span class="pre">zlist,</span> <span class="pre">highidx)</span></code></p>
<blockquote>
<div><p>helper macro to iterate over valid zones in a zonelist at or below a given zone index</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">zone</span></code></dt><dd><p>The current zone in the iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code></dt><dd><p>The current pointer within zonelist-&gt;zones being iterated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zlist</span></code></dt><dd><p>The zonelist being iterated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">highidx</span></code></dt><dd><p>The zone index of the highest zone to return</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator iterates though all zones at or below a given zone index.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pfn_valid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pfn_valid</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pfn_valid" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if there is a valid memory map entry for a PFN</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>the page frame number to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if there is a valid memory map entry aka struct page for the <strong>pfn</strong>.
Note, that availability of the memory map entry does not imply that
there is actual usable memory at that <strong>pfn</strong>. The struct page may
represent a hole or an unusable page frame.</p>
<p><strong>Return</strong></p>
<p>1 for PFNs that have memory map entries and 0 otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mapping">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mapping" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the mapping where this folio is stored.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For folios which are in the page cache, return the mapping that this
page belongs to.  Folios in the swap cache return the swap mapping
this page is stored in (which is different from the mapping for the
swap file or swap device where the data is stored).</p>
<p>You can call this for folios which aren’t in the swap cache or page
cache and it will return NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__anon_vma_prepare">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__anon_vma_prepare</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__anon_vma_prepare" title="Link to this definition">¶</a><br /></dt>
<dd><p>attach an anon_vma to a memory region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>the memory region in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This makes sure the memory mapping described by ‘vma’ has
an ‘anon_vma’ attached to it, so that we can associate the
anonymous pages mapped into it with that anon_vma.</p>
<p>The common case will be that we already have one, which
is handled inline by anon_vma_prepare(). But if
not we either need to find an adjacent mapping that we
can re-use the anon_vma from (very common when the only
reason for splitting a vma has been mprotect()), or we
allocate a new one.</p>
<p>Anon-vma allocations are very subtle, because we may have
optimistically looked up an anon_vma in folio_lock_anon_vma_read()
and that may actually touch the rwsem even in the newly
allocated vma (it depends on RCU to make sure that the
anon_vma isn’t actually destroyed).</p>
<p>As a result, we need to do proper anon_vma locking even
for the new allocation. At the same time, we do not want
to do any locking for the common case of already having
an anon_vma.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_address_in_vma">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_address_in_vma</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_address_in_vma" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_address_in_vma" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_address_in_vma" title="Link to this definition">¶</a><br /></dt>
<dd><p>The virtual address of a page in this VMA.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio containing the page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page within the folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The VMA we need to know the address in.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates the user virtual address of this page in the specified VMA.
It is the caller’s responsibility to check the page is actually
within the VMA.  There may not currently be a PTE pointing at this
page, but if a page fault occurs at this address, this is the page
which will be accessed.</p>
<p><strong>Context</strong></p>
<p>Caller should hold a reference to the folio.  Caller should
hold a lock (eg the i_mmap_lock or the mmap_lock) which keeps the
VMA from being altered.</p>
<p><strong>Return</strong></p>
<p>The virtual address corresponding to this page in the VMA.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_referenced">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_referenced</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_referenced" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">is_locked</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_referenced" title="Link to this definition">¶</a><br /></dt>
<dd><p>Test if the folio was referenced.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to test.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">is_locked</span></code></dt><dd><p>Caller holds lock on the folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>target memory cgroup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*vm_flags</span></code></dt><dd><p>A combination of all the vma-&gt;vm_flags which referenced the folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Quick test_and_clear_referenced for all mappings of a folio,</p>
<p><strong>Return</strong></p>
<p>The number of mappings which referenced the folio. Return -1 if
the function bailed out due to rmap lock contention.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mapping_wrprotect_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mapping_wrprotect_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgoff</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mapping_wrprotect_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write-protect all mappings in a specified range.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The mapping whose reverse mapping should be traversed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">pgoff</span></code></dt><dd><p>The page offset at which <strong>pfn</strong> is mapped within <strong>mapping</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>The PFN of the page mapped in <strong>mapping</strong> at <strong>pgoff</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr_pages</span></code></dt><dd><p>The number of physically contiguous base pages spanned.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Traverses the reverse mapping, finding all VMAs which contain a shared
mapping of the pages in the specified range in <strong>mapping</strong>, and write-protects
them (that is, updates the page tables to mark the mappings read-only such
that a write protection fault arises when the mappings are written to).</p>
<p>The <strong>pfn</strong> value need not refer to a folio, but rather can reference a kernel
allocation which is mapped into userland. We therefore do not require that
the page maps to a folio with a valid mapping or index field, rather the
caller specifies these in <strong>mapping</strong> and <strong>pgoff</strong>.</p>
<p><strong>Return</strong></p>
<p>the number of write-protected PTEs, or an error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pfn_mkclean_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pfn_mkclean_range</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgoff</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pfn_mkclean_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Cleans the PTEs (including PMDs) mapped with range of [<strong>pfn</strong>, <strong>pfn</strong> + <strong>nr_pages</strong>) at the specific offset (<strong>pgoff</strong>) within the <strong>vma</strong> of shared mappings. And since clean PTEs should also be readonly, write protects them too.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>start pfn.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr_pages</span></code></dt><dd><p>number of physically contiguous pages srarting with <strong>pfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">pgoff</span></code></dt><dd><p>page offset that the <strong>pfn</strong> mapped with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vma that <strong>pfn</strong> mapped within.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of cleaned PTEs (including PMDs).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_move_anon_rmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_move_anon_rmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_move_anon_rmap" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_move_anon_rmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>move a folio to our anon_vma</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to move to our anon_vma</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vma the folio belongs to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a folio belongs exclusively to one process after a COW event,
that folio can be moved into the anon_vma that belongs to just that
process, so the rmap code will not search the parent or sibling processes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__folio_set_anon">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__folio_set_anon</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__folio_set_anon" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">exclusive</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__folio_set_anon" title="Link to this definition">¶</a><br /></dt>
<dd><p>set up a new anonymous rmap for a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to set up the new anonymous rmap for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VM area to add the folio to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>User virtual address of the mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">exclusive</span></code></dt><dd><p>Whether the folio is exclusive to the process.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__page_check_anon_rmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__page_check_anon_rmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__page_check_anon_rmap" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__page_check_anon_rmap" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__page_check_anon_rmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>sanity check anonymous rmap addition</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio containing <strong>page</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page to check the mapping of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>the vm area in which the mapping is added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>the user virtual address mapped</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_anon_rmap_ptes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_anon_rmap_ptes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_anon_rmap_ptes" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_anon_rmap_ptes" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span>, <span class="n"><span class="pre">rmap_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_anon_rmap_ptes" title="Link to this definition">¶</a><br /></dt>
<dd><p>add PTE mappings to a page range of an anon folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to add the mappings to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The first page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>The number of pages which will be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vm area in which the mappings are added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>The user virtual address of the first page to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmap_t</span> <span class="pre">flags</span></code></dt><dd><p>The rmap flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page range of folio is defined by [first_page, first_page + nr_pages)</p>
<p>The caller needs to hold the page table lock, and the page must be locked in
the anon_vma case: to serialize mapping,index checking after setting,
and to ensure that an anon folio is not being upgraded racily to a KSM folio
(but KSM folios are never downgraded).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_anon_rmap_pmd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_anon_rmap_pmd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_anon_rmap_pmd" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_anon_rmap_pmd" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span>, <span class="n"><span class="pre">rmap_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_anon_rmap_pmd" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a PMD mapping to a page range of an anon folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to add the mapping to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The first page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vm area in which the mapping is added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>The user virtual address of the first page to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmap_t</span> <span class="pre">flags</span></code></dt><dd><p>The rmap flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page range of folio is defined by [first_page, first_page + HPAGE_PMD_NR)</p>
<p>The caller needs to hold the page table lock, and the page must be locked in
the anon_vma case: to serialize mapping,index checking after setting.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_new_anon_rmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_new_anon_rmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_new_anon_rmap" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">address</span></span>, <span class="n"><span class="pre">rmap_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_new_anon_rmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add mapping to a new anonymous folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to add the mapping to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>the vm area in which the mapping is added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>the user virtual address mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rmap_t</span> <span class="pre">flags</span></code></dt><dd><p>The rmap flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like folio_add_anon_rmap_*() but must only be called on <em>new</em> folios.
This means the inc-and-test can be bypassed.
The folio doesn’t necessarily need to be locked while it’s exclusive
unless two threads map it concurrently. However, the folio must be
locked if it’s shared.</p>
<p>If the folio is pmd-mappable, it is accounted as a THP.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_file_rmap_ptes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_file_rmap_ptes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_file_rmap_ptes" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_file_rmap_ptes" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_file_rmap_ptes" title="Link to this definition">¶</a><br /></dt>
<dd><p>add PTE mappings to a page range of a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to add the mappings to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The first page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>The number of pages that will be mapped using PTEs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vm area in which the mappings are added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page range of the folio is defined by [page, page + nr_pages)</p>
<p>The caller needs to hold the page table lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_file_rmap_pmd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_file_rmap_pmd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_file_rmap_pmd" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_file_rmap_pmd" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_file_rmap_pmd" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a PMD mapping to a page range of a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to add the mapping to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The first page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vm area in which the mapping is added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page range of the folio is defined by [page, page + HPAGE_PMD_NR)</p>
<p>The caller needs to hold the page table lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_file_rmap_pud">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_file_rmap_pud</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_file_rmap_pud" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_file_rmap_pud" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_file_rmap_pud" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a PUD mapping to a page range of a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to add the mapping to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The first page to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vm area in which the mapping is added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page range of the folio is defined by [page, page + HPAGE_PUD_NR)</p>
<p>The caller needs to hold the page table lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_remove_rmap_ptes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_remove_rmap_ptes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_remove_rmap_ptes" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_remove_rmap_ptes" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_remove_rmap_ptes" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove PTE mappings from a page range of a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to remove the mappings from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The first page to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>The number of pages that will be removed from the mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vm area from which the mappings are removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page range of the folio is defined by [page, page + nr_pages)</p>
<p>The caller needs to hold the page table lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_remove_rmap_pmd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_remove_rmap_pmd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_remove_rmap_pmd" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_remove_rmap_pmd" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_remove_rmap_pmd" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a PMD mapping from a page range of a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to remove the mapping from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The first page to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vm area from which the mapping is removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page range of the folio is defined by [page, page + HPAGE_PMD_NR)</p>
<p>The caller needs to hold the page table lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_remove_rmap_pud">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_remove_rmap_pud</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_remove_rmap_pud" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_remove_rmap_pud" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_remove_rmap_pud" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a PUD mapping from a page range of a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to remove the mapping from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The first page to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The vm area from which the mapping is removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page range of the folio is defined by [page, page + HPAGE_PUD_NR)</p>
<p>The caller needs to hold the page table lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.try_to_unmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">try_to_unmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.try_to_unmap" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">ttu_flags</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_unmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Try to remove all page table mappings to a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to unmap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ttu_flags</span> <span class="pre">flags</span></code></dt><dd><p>action and flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries to remove all the page table entries which are mapping this
folio.  It is the caller’s responsibility to check if the folio is
still mapped if needed (use TTU_SYNC to prevent accounting races).</p>
<p><strong>Context</strong></p>
<p>Caller must hold the folio lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.try_to_migrate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">try_to_migrate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.try_to_migrate" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">ttu_flags</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_migrate" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to replace all page table mappings with swap entries</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>the folio to replace page table entries for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ttu_flags</span> <span class="pre">flags</span></code></dt><dd><p>action and flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries to remove all the page table entries which are mapping this folio and
replace them with special swap entries. Caller must hold the folio lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.make_device_exclusive">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">make_device_exclusive</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">foliop</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.make_device_exclusive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Mark a page for exclusive use by a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>mm_struct of associated target process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>the virtual address to mark for exclusive device access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*owner</span></code></dt><dd><p>passed to MMU_NOTIFY_EXCLUSIVE range notifier to allow filtering</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">**foliop</span></code></dt><dd><p>folio pointer will be stored here on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the page mapped at the given address, grabs a
folio reference, locks the folio and replaces the PTE with special
device-exclusive PFN swap entry, preventing access through the process
page tables. The function will return with the folio locked and referenced.</p>
<p>On fault, the device-exclusive entries are replaced with the original PTE
under folio lock, after calling MMU notifiers.</p>
<p>Only anonymous non-hugetlb folios are supported and the VMA must have
write permissions such that we can fault in the anonymous page writable
in order to mark it exclusive. The caller must hold the mmap_lock in read
mode.</p>
<p>A driver using this to program access from a device must use a mmu notifier
critical section to hold a device specific lock during programming. Once
programming is complete it should drop the folio lock and reference after
which point CPU access to the page will revoke the exclusive access.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><p>This function always operates on individual PTEs mapping individual
pages. PMD-sized THPs are first remapped to be mapped by PTEs before
the conversion happens on a single PTE corresponding to <strong>addr</strong>.</p></li>
<li><p>While concurrent access through the process page tables is prevented,
concurrent access through other page references (e.g., earlier GUP
invocation) is not handled and not supported.</p></li>
<li><p>device-exclusive entries are considered “clean” and “old” by core-mm.
Device drivers must update the folio state when informed by MMU
notifiers.</p></li>
</ol>
</div></blockquote>
<p><strong>Return</strong></p>
<p>pointer to mapped page on success, otherwise a negative error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__rmap_walk_file">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__rmap_walk_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__rmap_walk_file" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgoff_start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rmap_walk_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rwc</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">locked</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__rmap_walk_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>Traverse the reverse mapping for a file-backed mapping of a page mapped within a specified page cache object at a specified offset.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Either the folio whose mappings to traverse, or if NULL,
the callbacks specified in <strong>rwc</strong> will be configured such
as to be able to look up mappings correctly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The page cache object whose mapping VMAs we intend to
traverse. If <strong>folio</strong> is non-NULL, this should be equal to
folio_mapping(folio).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">pgoff_start</span></code></dt><dd><p>The offset within <strong>mapping</strong> of the page which we are
looking up. If <strong>folio</strong> is non-NULL, this should be equal
to folio_pgoff(folio).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr_pages</span></code></dt><dd><p>The number of pages mapped by the mapping. If <strong>folio</strong> is
non-NULL, this should be equal to folio_nr_pages(folio).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rmap_walk_control</span> <span class="pre">*rwc</span></code></dt><dd><p>The reverse mapping walk control object describing how
the traversal should proceed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">locked</span></code></dt><dd><p>Is the <strong>mapping</strong> already locked? If not, we acquire the
lock.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.migrate_folio">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">migrate_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">migrate_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.migrate_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Simple folio migration.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space containing the folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*dst</span></code></dt><dd><p>The folio to migrate the data to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*src</span></code></dt><dd><p>The folio containing the current data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">migrate_mode</span> <span class="pre">mode</span></code></dt><dd><p>How to migrate the page.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Common logic to directly migrate a single LRU folio suitable for
folios that do not have private data.</p>
<p>Folios are locked upon entry and exit.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.buffer_migrate_folio">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">buffer_migrate_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">migrate_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.buffer_migrate_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Migration function for folios with buffers.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space containing <strong>src</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*dst</span></code></dt><dd><p>The folio to migrate to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*src</span></code></dt><dd><p>The folio to migrate from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">migrate_mode</span> <span class="pre">mode</span></code></dt><dd><p>How to migrate the folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can only be used if the underlying filesystem guarantees
that no other references to <strong>src</strong> exist. For example attached buffer
heads are accessed only under the folio lock.  If your filesystem cannot
provide this guarantee, <a class="reference internal" href="#c.buffer_migrate_folio_norefs" title="buffer_migrate_folio_norefs"><code class="xref c c-func docutils literal notranslate"><span class="pre">buffer_migrate_folio_norefs()</span></code></a> may be more
appropriate.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.buffer_migrate_folio_norefs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">buffer_migrate_folio_norefs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">migrate_mode</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.buffer_migrate_folio_norefs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Migration function for folios with buffers.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space containing <strong>src</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*dst</span></code></dt><dd><p>The folio to migrate to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*src</span></code></dt><dd><p>The folio to migrate from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">migrate_mode</span> <span class="pre">mode</span></code></dt><dd><p>How to migrate the folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.buffer_migrate_folio" title="buffer_migrate_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">buffer_migrate_folio()</span></code></a> except that this variant is more careful
and checks that there are also no buffer head references. This function
is the right one for mappings where buffer heads are directly looked
up and referenced (such as block device mappings).</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.do_mmap">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">do_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.do_mmap" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="n"><span class="pre">vm_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">vm_flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pgoff</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">populate</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.do_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Perform a userland memory mapping into the current process address space of length <strong>len</strong> with protection bits <strong>prot</strong>, mmap flags <strong>flags</strong> (from which VMA flags will be inferred), and any additional VMA flags to apply <strong>vm_flags</strong>. If this is a file-backed mapping then the file is specified in <strong>file</strong> and page offset into the file via <strong>pgoff</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>An optional <a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a> pointer describing the file which is to be
mapped, if a file-backed mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>If non-zero, hints at (or if <strong>flags</strong> has MAP_FIXED set, specifies) the
address at which to perform this mapping. See mmap (2) for details. Must be
page-aligned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt><dd><p>The length of the mapping. Will be page-aligned and must be at least 1
page in size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">prot</span></code></dt><dd><p>Protection bits describing access required to the mapping. See mmap
(2) for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>Flags specifying how the mapping should be performed, see mmap (2)
for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_flags_t</span> <span class="pre">vm_flags</span></code></dt><dd><p>VMA flags which should be set by default, or 0 otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt><dd><p>Page offset into the <strong>file</strong> if file-backed, should be 0 otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*populate</span></code></dt><dd><p>A pointer to a value which will be set to 0 if no population of
the range is required, or the number of bytes to populate if it is. Must be
non-NULL. See mmap (2) for details as to under what circumstances population
of the range occurs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*uf</span></code></dt><dd><p>An optional pointer to a list head to track userfaultfd unmap events
should unmapping events arise. If provided, it is up to the caller to manage
this.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does not perform security checks on the file and assumes, if
<strong>uf</strong> is non-NULL, the caller has provided a list head to track unmap events
for userfaultfd <strong>uf</strong>.</p>
<p>It also simply indicates whether memory population is required by setting
<strong>populate</strong>, which must be non-NULL, expecting the caller to actually perform
this task itself if appropriate.</p>
<p>This function will invoke architecture-specific (and if provided and
relevant, file system-specific) logic to determine the most appropriate
unmapped area in which to place the mapping if not MAP_FIXED.</p>
<p>Callers which require userland mmap() behaviour should invoke vm_mmap(),
which is also exported for module use.</p>
<p>Those which require this behaviour less security checks, userfaultfd and
populate behaviour, and who handle the mmap write lock themselves, should
call this function.</p>
<p>Note that the returned address may reside within a merged VMA if an
appropriate merge were to take place, so it doesn’t necessarily specify the
start of a VMA, rather only the start of a valid mapped range of length
<strong>len</strong> bytes, rounded down to the nearest page size.</p>
<p>The caller must write-lock current-&gt;mm-&gt;mmap_lock.</p>
<p><strong>Return</strong></p>
<p>Either an error, or the address at which the requested mapping has
been performed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_vma_intersection">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_vma_intersection</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start_addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">end_addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_vma_intersection" title="Link to this definition">¶</a><br /></dt>
<dd><p>Look up the first VMA which intersects the interval</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>The process address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start_addr</span></code></dt><dd><p>The inclusive start user address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_addr</span></code></dt><dd><p>The exclusive end user address.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The first VMA within the provided range, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.  Assumes
start_addr &lt; end_addr.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_vma">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_vma</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_vma" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the VMA for a given address, or the next VMA.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>The mm_struct to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>The address</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The VMA associated with addr, or the next VMA.
May return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in the case of no VMA at addr or above.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_vma_prev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_vma_prev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pprev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_vma_prev" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the VMA for a given address, or the next vma and set <code class="docutils literal notranslate"><span class="pre">pprev</span></code> to the previous VMA, if any.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>The mm_struct to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>The address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">**pprev</span></code></dt><dd><p>The pointer to set to the previous VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that RCU lock is missing here since the external mmap_lock() is used
instead.</p>
<p><strong>Return</strong></p>
<p>The VMA associated with <strong>addr</strong>, or the next vma.
May return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in the case of no vma at addr or above.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min_count</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a newly allocated object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to beginning of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_count</span></code></dt><dd><p>minimum number of references to this object. If during memory
scanning a number of references less than <strong>min_count</strong> is found,
the object is reported as a memory leak. If <strong>min_count</strong> is 0,
the object is never reported as a leak. If <strong>min_count</strong> is -1,
the object is ignored (not scanned and not reported as a leak)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p><a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> flags used for kmemleak internal memory allocations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the kernel allocators when a new object
(memory block) is allocated (kmem_cache_alloc, kmalloc etc.).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_alloc_percpu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_alloc_percpu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__percpu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_alloc_percpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a newly allocated __percpu object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*ptr</span></code></dt><dd><p>__percpu pointer to beginning of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>flags used for kmemleak internal memory allocations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the kernel percpu allocator when a new object
(memory block) is allocated (alloc_percpu).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_vmalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_vmalloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">area</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_vmalloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a newly vmalloc’ed object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vm_struct</span> <span class="pre">*area</span></code></dt><dd><p>pointer to vm_struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>__vmalloc() flags used for kmemleak internal memory allocations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the vmalloc() kernel allocator when a new
object (memory block) is allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a previously registered object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to beginning of the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the kernel allocators when an object (memory
block) is freed (kmem_cache_free, kfree, vfree etc.).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_free_part">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_free_part</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_free_part" title="Link to this definition">¶</a><br /></dt>
<dd><p>partially unregister a previously registered object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to the beginning or inside the object. This also
represents the start of the range to be freed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size to be unregistered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called when only a part of a memory block is freed
(usually from the bootmem allocator).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_free_percpu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_free_percpu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__percpu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_free_percpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a previously registered __percpu object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*ptr</span></code></dt><dd><p>__percpu pointer to beginning of the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the kernel percpu allocator when an object
(memory block) is freed (free_percpu).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_update_trace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_update_trace</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_update_trace" title="Link to this definition">¶</a><br /></dt>
<dd><p>update object allocation stack trace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to beginning of the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Override the object allocation stack trace for cases where the actual
allocation place is not always useful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_not_leak">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_not_leak</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_not_leak" title="Link to this definition">¶</a><br /></dt>
<dd><p>mark an allocated object as false positive</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to beginning of the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function on an object will cause the memory block to no longer
be reported as leak and always be scanned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_transient_leak">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_transient_leak</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_transient_leak" title="Link to this definition">¶</a><br /></dt>
<dd><p>mark an allocated object as transient false positive</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to beginning of the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function on an object will cause the memory block to not be
reported as a leak temporarily. This may happen, for example, if the object
is part of a singly linked list and the -&gt;next reference to it is changed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_ignore_percpu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_ignore_percpu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__percpu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_ignore_percpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>similar to kmemleak_ignore but taking a percpu address argument</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*ptr</span></code></dt><dd><p>percpu address of the object</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_ignore">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_ignore</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_ignore" title="Link to this definition">¶</a><br /></dt>
<dd><p>ignore an allocated object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to beginning of the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function on an object will cause the memory block to be
ignored (not scanned and not reported as a leak). This is usually done when
it is known that the corresponding block is not a leak and does not contain
any references to other allocated memory blocks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_scan_area">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_scan_area</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_scan_area" title="Link to this definition">¶</a><br /></dt>
<dd><p>limit the range to be scanned in an allocated object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to beginning or inside the object. This also
represents the start of the scan area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the scan area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p><a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> flags used for kmemleak internal memory allocations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used when it is known that only certain parts of an object
contain references to other objects. Kmemleak will only scan these areas
reducing the number false negatives.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_no_scan">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_no_scan</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_no_scan" title="Link to this definition">¶</a><br /></dt>
<dd><p>do not scan an allocated object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to beginning of the object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function notifies kmemleak not to scan the given memory block. Useful
in situations where it is known that the given object does not contain any
references to other objects. Kmemleak will not scan such objects reducing
the number of false negatives.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_alloc_phys">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_alloc_phys</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">phys_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">phys</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_alloc_phys" title="Link to this definition">¶</a><br /></dt>
<dd><p>similar to kmemleak_alloc but taking a physical address argument</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">phys</span></code></dt><dd><p>physical address of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p><a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> flags used for kmemleak internal memory allocations</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_free_part_phys">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_free_part_phys</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">phys_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">phys</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_free_part_phys" title="Link to this definition">¶</a><br /></dt>
<dd><p>similar to kmemleak_free_part but taking a physical address argument</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">phys</span></code></dt><dd><p>physical address if the beginning or inside an object. This
also represents the start of the range to be freed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size to be unregistered</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemleak_ignore_phys">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__ref</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kmemleak_ignore_phys</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">phys_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">phys</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemleak_ignore_phys" title="Link to this definition">¶</a><br /></dt>
<dd><p>similar to kmemleak_ignore but taking a physical address argument</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">phys</span></code></dt><dd><p>physical address of the object</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_memremap_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_memremap_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dev_pagemap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pgmap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_memremap_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>remap and provide memmap backing for the given resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>hosting device for <strong>res</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pagemap</span> <span class="pre">*pgmap</span></code></dt><dd><p>pointer to a struct dev_pagemap</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<dl class="simple">
<dt>1/ At a minimum the range and type members of <strong>pgmap</strong> must be initialized</dt><dd><p>by the caller before passing it to this function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>2/ The altmap field may optionally be initialized, in which case</dt><dd><p>PGMAP_ALTMAP_VALID must be set in pgmap-&gt;flags.</p>
</dd>
<dt>3/ The ref field may optionally be provided, in which pgmap-&gt;ref must be</dt><dd><p>‘live’ on entry and will be killed and reaped at
devm_memremap_pages_release() time, or if this routine fails.</p>
</dd>
<dt>4/ range is expected to be a host memory range that could feasibly be</dt><dd><p>treated as a “System RAM” range, i.e. not a device mmio range, but
this is not enforced.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_dev_pagemap">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dev_pagemap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_dev_pagemap</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dev_pagemap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pgmap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_dev_pagemap" title="Link to this definition">¶</a><br /></dt>
<dd><p>take a new live reference on the dev_pagemap for <strong>pfn</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>page frame number to lookup page_map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pagemap</span> <span class="pre">*pgmap</span></code></dt><dd><p>optional known pgmap that already has a reference</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>pgmap</strong> is non-NULL and covers <strong>pfn</strong> it will be returned as-is.  If <strong>pgmap</strong>
is non-NULL but does not cover <strong>pfn</strong> the reference to it will be released.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vma_kernel_pagesize">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vma_kernel_pagesize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vma_kernel_pagesize" title="Link to this definition">¶</a><br /></dt>
<dd><p>Page size granularity for this VMA.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>The user mapping.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Folios in this VMA will be aligned to, and at least the size of the
number of bytes returned by this function.</p>
<p><strong>Return</strong></p>
<p>The default size of the folios allocated when backing a VMA.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_isolate_hugetlb">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_isolate_hugetlb</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_isolate_hugetlb" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_isolate_hugetlb" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to isolate an allocated hugetlb folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>the folio to isolate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the list to add the folio to on success</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Isolate an allocated (refcount &gt; 0) hugetlb folio, marking it as
isolated/non-migratable, and moving it from the active list to the
given list.</p>
<p>Isolation will fail if <strong>folio</strong> is not an allocated hugetlb folio, or if
it is already isolated/non-migratable.</p>
<p>On success, an additional folio reference is taken that must be dropped
using <a class="reference internal" href="#c.folio_putback_hugetlb" title="folio_putback_hugetlb"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_putback_hugetlb()</span></code></a> to undo the isolation.</p>
<p><strong>Return</strong></p>
<p>True if isolation worked, otherwise False.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_putback_hugetlb">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_putback_hugetlb</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_putback_hugetlb" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_putback_hugetlb" title="Link to this definition">¶</a><br /></dt>
<dd><p>unisolate a hugetlb folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>the isolated hugetlb folio</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Putback/un-isolate the hugetlb folio that was previous isolated using
<a class="reference internal" href="#c.folio_isolate_hugetlb" title="folio_isolate_hugetlb"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_isolate_hugetlb()</span></code></a>: marking it non-isolated/migratable and putting it
back onto the active list.</p>
<p>Will drop the additional folio reference obtained through
<a class="reference internal" href="#c.folio_isolate_hugetlb" title="folio_isolate_hugetlb"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_isolate_hugetlb()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mark_accessed">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mark_accessed</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mark_accessed" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mark_accessed" title="Link to this definition">¶</a><br /></dt>
<dd><p>Mark a folio as having seen activity.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to mark.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will perform one of the following transitions:</p>
<ul class="simple">
<li><p>inactive,unreferenced      -&gt;      inactive,referenced</p></li>
<li><p>inactive,referenced        -&gt;      active,unreferenced</p></li>
<li><p>active,unreferenced        -&gt;      active,referenced</p></li>
</ul>
<p>When a newly allocated folio is not yet visible, so safe for non-atomic ops,
__folio_set_referenced() may be substituted for <a class="reference internal" href="#c.folio_mark_accessed" title="folio_mark_accessed"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mark_accessed()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_lru">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_lru</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_lru" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_lru" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add a folio to an LRU list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to be added to the LRU.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue the folio for addition to the LRU. The decision on whether
to add the page to the [in]active [file|anon] list is deferred until the
folio_batch is drained. This gives a chance for the caller of <a class="reference internal" href="#c.folio_add_lru" title="folio_add_lru"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_add_lru()</span></code></a>
have the folio added to the active list using <a class="reference internal" href="#c.folio_mark_accessed" title="folio_mark_accessed"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mark_accessed()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_add_lru_vma">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_add_lru_vma</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_add_lru_vma" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_add_lru_vma" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add a folio to the appropate LRU list for this VMA.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to be added to the LRU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VMA in which the folio is mapped.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the VMA is mlocked, <strong>folio</strong> is added to the unevictable list.
Otherwise, it is treated the same way as <a class="reference internal" href="#c.folio_add_lru" title="folio_add_lru"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_add_lru()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.deactivate_file_folio">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">deactivate_file_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.deactivate_file_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.deactivate_file_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Deactivate a file folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to deactivate.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function hints to the VM that <strong>folio</strong> is a good reclaim candidate,
for example if its invalidation fails due to the folio being dirty
or under writeback.</p>
<p><strong>Context</strong></p>
<p>Caller holds a reference on the folio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_mark_lazyfree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_mark_lazyfree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_mark_lazyfree" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_mark_lazyfree" title="Link to this definition">¶</a><br /></dt>
<dd><p>make an anon folio lazyfree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>folio to deactivate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.folio_mark_lazyfree" title="folio_mark_lazyfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mark_lazyfree()</span></code></a> moves <strong>folio</strong> to the inactive file list.
This is done to accelerate the reclaim of <strong>folio</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folios_put_refs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folios_put_refs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_batch</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folios</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">refs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folios_put_refs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reduce the reference count on a batch of folios.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_batch</span> <span class="pre">*folios</span></code></dt><dd><p>The folios.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*refs</span></code></dt><dd><p>The number of refs to subtract from each folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.folio_put" title="folio_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_put()</span></code></a>, but for a batch of folios.  This is more efficient
than writing the loop yourself as it will optimise the locks which need
to be taken if the folios are freed.  The folios batch is returned
empty and ready to be reused for another batch; there is no need
to reinitialise it.  If <strong>refs</strong> is NULL, we subtract one from each
folio refcount.</p>
<p><strong>Context</strong></p>
<p>May be called in process or interrupt context, but not in NMI
context.  May be called while holding a spinlock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.release_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">release_pages</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">release_pages_arg</span></span><span class="w"> </span><span class="n"><span class="pre">arg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.release_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>batched put_page()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">release_pages_arg</span> <span class="pre">arg</span></code></dt><dd><p>array of pages to release</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>number of pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement the reference count on all the pages in <strong>arg</strong>.  If it
fell to zero, remove the page from the LRU and free it.</p>
<p>Note that the argument can be an array of pages, encoded pages,
or folio pointers. We ignore any encoded bits, and turn any of
them into just a folio that gets free’d.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_batch_remove_exceptionals">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_batch_remove_exceptionals</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_batch</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fbatch</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_batch_remove_exceptionals" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prune non-folios from a batch.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_batch</span> <span class="pre">*fbatch</span></code></dt><dd><p>The batch to prune</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>find_get_entries() fills a batch with both folios and shadow/swap/DAX
entries.  This function prunes all the non-folio entries from <strong>fbatch</strong>
without leaving holes, so that it can be passed on to folio-only batch
operations.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_register_driver">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_register_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zpool_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_register_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a zpool implementation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool_driver</span> <span class="pre">*driver</span></code></dt><dd><p>driver to register</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_unregister_driver">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_unregister_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zpool_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_unregister_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a zpool implementation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool_driver</span> <span class="pre">*driver</span></code></dt><dd><p>driver to unregister.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Module usage counting is used to prevent using a driver
while/after unloading, so if this is called from module
exit function, this should never fail; if called from
other than the module exit function, and this returns
failure, the driver is in use and must remain available.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_has_pool">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_has_pool</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_has_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check if the pool driver is available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*type</span></code></dt><dd><p>The type of the zpool to check (e.g. zsmalloc)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This checks if the <strong>type</strong> pool driver is available.  This will try to load
the requested module, if needed, but there is no guarantee the module will
still be loaded and available immediately after calling.  If this returns
true, the caller should assume the pool is available, but must be prepared
to handle the <strong><a class="reference internal" href="#c.zpool_create_pool" title="zpool_create_pool"><code class="xref c c-func docutils literal notranslate"><span class="pre">zpool_create_pool()</span></code></a></strong> returning failure.  However if this
returns false, the caller should assume the requested pool type is not
available; either the requested pool type module does not exist, or could
not be loaded, and calling <strong><a class="reference internal" href="#c.zpool_create_pool" title="zpool_create_pool"><code class="xref c c-func docutils literal notranslate"><span class="pre">zpool_create_pool()</span></code></a></strong> with the pool type will
fail.</p>
<p>The <strong>type</strong> string must be null-terminated.</p>
<p><strong>Return</strong></p>
<p>true if <strong>type</strong> pool is available, false if not</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_create_pool">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">zpool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">zpool_create_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_create_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a new zpool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*type</span></code></dt><dd><p>The type of the zpool to create (e.g. zsmalloc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>The name of the zpool (e.g. zram0, zswap)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP flags to use when allocating the pool.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new zpool of the specified type.  The gfp flags will be
used when allocating memory, if the implementation supports it.  If the
ops param is NULL, then the created zpool will not be evictable.</p>
<p>Implementations must guarantee this to be thread-safe.</p>
<p>The <strong>type</strong> and <strong>name</strong> strings must be null-terminated.</p>
<p><strong>Return</strong></p>
<p>New zpool on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_destroy_pool">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_destroy_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.zpool_destroy_pool" title="zpool"><span class="n"><span class="pre">zpool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zpool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_destroy_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>Destroy a zpool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool</span> <span class="pre">*zpool</span></code></dt><dd><p>The zpool to destroy.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implementations must guarantee this to be thread-safe,
however only when destroying different pools.  The same
pool should only be destroyed once, and should not be used
after it is destroyed.</p>
<p>This destroys an existing zpool.  The zpool should not be in use.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_get_type">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">zpool_get_type</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.zpool_get_type" title="zpool"><span class="n"><span class="pre">zpool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zpool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_get_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the type of the zpool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool</span> <span class="pre">*zpool</span></code></dt><dd><p>The zpool to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the type of the pool.</p>
<p>Implementations must guarantee this to be thread-safe.</p>
<p><strong>Return</strong></p>
<p>The type of zpool.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_malloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_malloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.zpool_malloc" title="zpool"><span class="n"><span class="pre">zpool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zpool</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handle</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_malloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool</span> <span class="pre">*zpool</span></code></dt><dd><p>The zpool to allocate from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The amount of memory to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP flags to use when allocating memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*handle</span></code></dt><dd><p>Pointer to the handle to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>The preferred node id.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allocates the requested amount of memory from the pool.
The gfp flags will be used when allocating memory, if the
implementation supports it.  The provided <strong>handle</strong> will be
set to the allocated object handle. The allocation will
prefer the NUMA node specified by <strong>nid</strong>.</p>
<p>Implementations must guarantee this to be thread-safe.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative value on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.zpool_free" title="zpool"><span class="n"><span class="pre">zpool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zpool</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free previously allocated memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool</span> <span class="pre">*zpool</span></code></dt><dd><p>The zpool that allocated the memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">handle</span></code></dt><dd><p>The handle to the memory to free.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This frees previously allocated memory.  This does not guarantee
that the pool will actually free memory, only that the memory
in the pool will become available for use by the pool.</p>
<p>Implementations must guarantee this to be thread-safe,
however only when freeing different handles.  The same
handle should only be freed once, and should not be used
after freeing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_obj_read_begin">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">zpool_obj_read_begin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.zpool_obj_read_begin" title="zpool"><span class="n"><span class="pre">zpool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zpool</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">local_copy</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_obj_read_begin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Start reading from a previously allocated handle.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool</span> <span class="pre">*zpool</span></code></dt><dd><p>The zpool that the handle was allocated from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">handle</span></code></dt><dd><p>The handle to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*local_copy</span></code></dt><dd><p>A local buffer to use if needed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This starts a read operation of a previously allocated handle. The passed
<strong>local_copy</strong> buffer may be used if needed by copying the memory into.
<a class="reference internal" href="#c.zpool_obj_read_end" title="zpool_obj_read_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">zpool_obj_read_end()</span></code></a> MUST be called after the read is completed to undo any
actions taken (e.g. release locks).</p>
<p><strong>Return</strong></p>
<p>A pointer to the handle memory to be read, if <strong>local_copy</strong> is used,
the returned pointer is <strong>local_copy</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_obj_read_end">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_obj_read_end</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.zpool_obj_read_end" title="zpool"><span class="n"><span class="pre">zpool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zpool</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handle_mem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_obj_read_end" title="Link to this definition">¶</a><br /></dt>
<dd><p>Finish reading from a previously allocated handle.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool</span> <span class="pre">*zpool</span></code></dt><dd><p>The zpool that the handle was allocated from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">handle</span></code></dt><dd><p>The handle to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*handle_mem</span></code></dt><dd><p>The pointer returned by <a class="reference internal" href="#c.zpool_obj_read_begin" title="zpool_obj_read_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">zpool_obj_read_begin()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finishes a read operation previously started by <a class="reference internal" href="#c.zpool_obj_read_begin" title="zpool_obj_read_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">zpool_obj_read_begin()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_obj_write">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_obj_write</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.zpool_obj_write" title="zpool"><span class="n"><span class="pre">zpool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zpool</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handle_mem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">mem_len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_obj_write" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write to a previously allocated handle.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool</span> <span class="pre">*zpool</span></code></dt><dd><p>The zpool that the handle was allocated from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">handle</span></code></dt><dd><p>The handle to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*handle_mem</span></code></dt><dd><p>The memory to copy from into the handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">mem_len</span></code></dt><dd><p>The length of memory to be written.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.zpool_get_total_pages">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">zpool_get_total_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.zpool_get_total_pages" title="zpool"><span class="n"><span class="pre">zpool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">zpool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.zpool_get_total_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>The total size of the pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">zpool</span> <span class="pre">*zpool</span></code></dt><dd><p>The zpool to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the total size in pages of the pool.</p>
<p><strong>Return</strong></p>
<p>Total size of the zpool in pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_css_from_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cgroup_subsys_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_css_from_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.mem_cgroup_css_from_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_css_from_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>css of the memcg associated with a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>folio of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If memcg is bound to the default hierarchy, css of the memcg associated
with <strong>folio</strong> is returned.  The returned css remains associated with <strong>folio</strong>
until it is released.</p>
<p>If memcg is bound to a traditional hierarchy, the css of root_mem_cgroup
is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.page_cgroup_ino">
<span class="n"><span class="pre">ino_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">page_cgroup_ino</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.page_cgroup_ino" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cgroup_ino" title="Link to this definition">¶</a><br /></dt>
<dd><p>return inode number of the memcg a page is charged to</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look up the closest online ancestor of the memory cgroup <strong>page</strong> is charged to
and return its inode number or 0 if <strong>page</strong> is not charged to any cgroup. It
is safe to call this function without holding a reference to <strong>page</strong>.</p>
<p>Note, this function is inherently racy, because there is nothing to prevent
the cgroup inode from getting torn down and potentially reallocated a moment
after <a class="reference internal" href="#c.page_cgroup_ino" title="page_cgroup_ino"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_cgroup_ino()</span></code></a> returns, so it only should be used by callers that
do not care (such as procfs interfaces).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mod_memcg_state">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mod_memcg_state</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">memcg_stat_item</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">val</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_memcg_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>update cgroup memory statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>the memory cgroup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">memcg_stat_item</span> <span class="pre">idx</span></code></dt><dd><p>the stat item - can be enum memcg_stat_item or enum node_stat_item</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>delta to add to the counter, can be negative</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__mod_lruvec_state">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__mod_lruvec_state</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__mod_lruvec_state" title="lruvec"><span class="n"><span class="pre">lruvec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lruvec</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">node_stat_item</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">val</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__mod_lruvec_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>update lruvec memory statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lruvec</span> <span class="pre">*lruvec</span></code></dt><dd><p>the lruvec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">node_stat_item</span> <span class="pre">idx</span></code></dt><dd><p>the stat item</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>delta to add to the counter, can be negative</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The lruvec is the intersection of the NUMA node and a cgroup. This
function updates the all three counters that are affected by a
change of state at this level: per-node, per-cgroup, per-lruvec.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.count_memcg_events">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">count_memcg_events</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">vm_event_item</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.count_memcg_events" title="Link to this definition">¶</a><br /></dt>
<dd><p>account VM events in a cgroup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>the memory cgroup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vm_event_item</span> <span class="pre">idx</span></code></dt><dd><p>the event item</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">count</span></code></dt><dd><p>the number of events that occurred</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_mem_cgroup_from_mm">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_mem_cgroup_from_mm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_mem_cgroup_from_mm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Obtain a reference on given mm_struct’s memcg.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>mm from which memcg should be extracted. It can be NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain a reference on mm-&gt;memcg and returns it if successful. If mm
is NULL, then the memcg is chosen as follows:
1) The active memcg, if set.
2) current-&gt;mm-&gt;memcg, if available
3) root memcg
If mem_cgroup is disabled, NULL is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_mem_cgroup_from_current">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_mem_cgroup_from_current</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_mem_cgroup_from_current" title="Link to this definition">¶</a><br /></dt>
<dd><p>Obtain a reference on current task’s memcg.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_mem_cgroup_from_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_mem_cgroup_from_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.get_mem_cgroup_from_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_mem_cgroup_from_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Obtain a reference on a given folio’s memcg.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>folio from which memcg should be extracted.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_iter">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_iter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup_reclaim_cookie</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reclaim</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_iter" title="Link to this definition">¶</a><br /></dt>
<dd><p>iterate over memory cgroup hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*root</span></code></dt><dd><p>hierarchy root</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*prev</span></code></dt><dd><p>previously returned memcg, NULL on first invocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup_reclaim_cookie</span> <span class="pre">*reclaim</span></code></dt><dd><p>cookie for shared reclaim walks, NULL for full walks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns references to children of the hierarchy below <strong>root</strong>, or
<strong>root</strong> itself, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> after a full round-trip.</p>
<p>Caller must pass the return value in <strong>prev</strong> on subsequent
invocations for reference counting, or use <a class="reference internal" href="#c.mem_cgroup_iter_break" title="mem_cgroup_iter_break"><code class="xref c c-func docutils literal notranslate"><span class="pre">mem_cgroup_iter_break()</span></code></a>
to cancel a hierarchy walk before the round-trip is complete.</p>
<p>Reclaimers can specify a node in <strong>reclaim</strong> to divide up the memcgs
in the hierarchy among all concurrent reclaimers operating on the
same node.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_iter_break">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_iter_break</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_iter_break" title="Link to this definition">¶</a><br /></dt>
<dd><p>abort a hierarchy walk prematurely</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*root</span></code></dt><dd><p>hierarchy root</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*prev</span></code></dt><dd><p>last visited hierarchy member as returned by <a class="reference internal" href="#c.mem_cgroup_iter" title="mem_cgroup_iter"><code class="xref c c-func docutils literal notranslate"><span class="pre">mem_cgroup_iter()</span></code></a></p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_scan_tasks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_scan_tasks</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_scan_tasks" title="Link to this definition">¶</a><br /></dt>
<dd><p>iterate over tasks of a memory cgroup hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>hierarchy root</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">task_struct</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to call for each task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>argument passed to <strong>fn</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function iterates over tasks attached to <strong>memcg</strong> or to any of its
descendants and calls <strong>fn</strong> for each task. If <strong>fn</strong> returns a non-zero
value, the function breaks the iteration loop. Otherwise, it will iterate
over all tasks and return 0.</p>
<p>This function must not be called for the root memory cgroup.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_lruvec_lock">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lruvec</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_lruvec_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_lruvec_lock" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_lruvec_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lock the lruvec for a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Pointer to the folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are safe to use under any of the following conditions:
- folio locked
- folio_test_lru false
- folio frozen (refcount of 0)</p>
<p><strong>Return</strong></p>
<p>The lruvec this folio is on with its lock held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_lruvec_lock_irq">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lruvec</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_lruvec_lock_irq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_lruvec_lock_irq" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_lruvec_lock_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lock the lruvec for a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Pointer to the folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are safe to use under any of the following conditions:
- folio locked
- folio_test_lru false
- folio frozen (refcount of 0)</p>
<p><strong>Return</strong></p>
<p>The lruvec this folio is on with its lock held and interrupts
disabled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_lruvec_lock_irqsave">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lruvec</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folio_lruvec_lock_irqsave</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_lruvec_lock_irqsave" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_lruvec_lock_irqsave" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lock the lruvec for a folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Pointer to the folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*flags</span></code></dt><dd><p>Pointer to irqsave flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are safe to use under any of the following conditions:
- folio locked
- folio_test_lru false
- folio frozen (refcount of 0)</p>
<p><strong>Return</strong></p>
<p>The lruvec this folio is on with its lock held and interrupts
disabled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_update_lru_size">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_update_lru_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.mem_cgroup_update_lru_size" title="lruvec"><span class="n"><span class="pre">lruvec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lruvec</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">lru_list</span></span><span class="w"> </span><span class="n"><span class="pre">lru</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">zid</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_update_lru_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>account for adding or removing an lru page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lruvec</span> <span class="pre">*lruvec</span></code></dt><dd><p>mem_cgroup per zone lru vector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">lru_list</span> <span class="pre">lru</span></code></dt><dd><p>index of lru list the page is sitting on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">zid</span></code></dt><dd><p>zone id of the accounted pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>positive when adding or negative when removing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called under lru_lock, just before a page is added
to or just after a page is removed from an lru list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_margin">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_margin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_margin" title="Link to this definition">¶</a><br /></dt>
<dd><p>calculate chargeable space of a memory cgroup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>the memory cgroup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the maximum amount of memory <strong>mem</strong> can be charged with, in
pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_print_oom_context">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_print_oom_context</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_print_oom_context" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print OOM information relevant to memory controller.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>The memory cgroup that went over limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>Task that is going to be killed</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p><strong>memcg</strong> and <strong>p</strong>’s mem_cgroup can be different when hierarchy is
enabled</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_print_oom_meminfo">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_print_oom_meminfo</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_print_oom_meminfo" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print OOM memory information relevant to memory controller.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>The memory cgroup that went over limit</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_get_oom_group">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_get_oom_group</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">victim</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">oom_domain</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_get_oom_group" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a memory cgroup to clean up after OOM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*victim</span></code></dt><dd><p>task to be killed by the OOM killer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*oom_domain</span></code></dt><dd><p>memcg in case of memcg OOM, NULL in case of system-wide OOM</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to a memory cgroup, which has to be cleaned up
by killing all belonging OOM-killable tasks.</p>
<p>Caller has to call mem_cgroup_put() on the returned non-NULL memcg.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.consume_stock">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">consume_stock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.consume_stock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Try to consume stocked charge on this cpu.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>memcg to consume from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>how many pages to charge.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Consume the cached charge if enough nr_pages are present otherwise return
failure. Also return failure for charge request larger than
MEMCG_CHARGE_BATCH or if the local lock is already taken.</p>
<p>returns true if successful, false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__memcg_kmem_charge_page">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__memcg_kmem_charge_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__memcg_kmem_charge_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__memcg_kmem_charge_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>charge a kmem page to the current memory cgroup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to charge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>reclaim mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>allocation order</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, an error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__memcg_kmem_uncharge_page">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__memcg_kmem_uncharge_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__memcg_kmem_uncharge_page" title="page"><span class="n"><span class="pre">page</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">page</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__memcg_kmem_uncharge_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>uncharge a kmem page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page to uncharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>allocation order</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_wb_stats">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_wb_stats</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bdi_writeback</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wb</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pfilepages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pheadroom</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdirty</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwriteback</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_wb_stats" title="Link to this definition">¶</a><br /></dt>
<dd><p>retrieve writeback related stats from its memcg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bdi_writeback</span> <span class="pre">*wb</span></code></dt><dd><p>bdi_writeback in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*pfilepages</span></code></dt><dd><p>out parameter for number of file pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*pheadroom</span></code></dt><dd><p>out parameter for number of allocatable pages according to memcg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*pdirty</span></code></dt><dd><p>out parameter for number of dirty pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*pwriteback</span></code></dt><dd><p>out parameter for number of pages under writeback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the numbers of file, headroom, dirty, and writeback pages in
<strong>wb</strong>’s memcg.  File, dirty and writeback are self-explanatory.  Headroom
is a bit more involved.</p>
<p>A memcg’s headroom is “min(max, high) - used”.  In the hierarchy, the
headroom is calculated as the lowest headroom of itself and the
ancestors.  Note that this doesn’t consider the actual amount of
available memory in the system.  The caller should further cap
<strong>*pheadroom</strong> accordingly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_from_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_from_id</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">short</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_from_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>look up a memcg from a memcg id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">id</span></code></dt><dd><p>the memcg id to look up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_css_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_css_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cgroup_subsys_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">css</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_css_reset" title="Link to this definition">¶</a><br /></dt>
<dd><p>reset the states of a mem_cgroup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*css</span></code></dt><dd><p>the target css</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the states of the mem_cgroup associated with <strong>css</strong>.  This is
invoked when the userland requests disabling on the default hierarchy
but the memcg is pinned through dependency.  The memcg should stop
applying policies and should revert to the vanilla state as it may be
made visible again.</p>
<p>The current implementation only resets the essential configurations.
This needs to be expanded to cover all the visible parts.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_calculate_protection">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_calculate_protection</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_calculate_protection" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if memory consumption is in the normal range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*root</span></code></dt><dd><p>the top ancestor of the sub-tree being checked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>the memory cgroup to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>WARNING: This function is not stateless! It can only be used as part</dt><dd><p>of a top-down tree iteration, not for isolated queries.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_charge_hugetlb">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_charge_hugetlb</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.mem_cgroup_charge_hugetlb" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_charge_hugetlb" title="Link to this definition">¶</a><br /></dt>
<dd><p>charge the memcg for a hugetlb folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>folio being charged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>reclaim mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called when allocating a huge page folio, after the page has
already been obtained and charged to the appropriate hugetlb cgroup
controller (if it is enabled).</p>
<p>Returns ENOMEM if the memcg is already full.
Returns 0 if either the charge was successful, or if we skip the charging.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_swapin_charge_folio">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_swapin_charge_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.mem_cgroup_swapin_charge_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="n"><span class="pre">swp_entry_t</span></span><span class="w"> </span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_swapin_charge_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Charge a newly allocated folio for swapin.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>folio to charge.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>mm context of the victim</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>reclaim mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swp_entry_t</span> <span class="pre">entry</span></code></dt><dd><p>swap entry for which the folio is allocated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function charges a folio allocated for swapin. Please call this before
adding the folio to the swapcache.</p>
<p>Returns 0 on success. Otherwise, an error code is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_replace_folio">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_replace_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_replace_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Charge a folio’s replacement.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*old</span></code></dt><dd><p>Currently circulating folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*new</span></code></dt><dd><p>Replacement folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Charge <strong>new</strong> as a replacement folio for <strong>old</strong>. <strong>old</strong> will
be uncharged upon free.</p>
<p>Both folios must be locked, <strong>new-&gt;mapping</strong> must be set up.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_migrate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_migrate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_migrate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Transfer the memcg data from the old to the new folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*old</span></code></dt><dd><p>Currently circulating folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*new</span></code></dt><dd><p>Replacement folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transfer the memcg data from the old folio to the new folio for migration.
The old folio’s data info will be cleared. Note that the memory counters
will remain unchanged throughout the process.</p>
<p>Both folios must be locked, <strong>new-&gt;mapping</strong> must be set up.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_charge_skmem">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_charge_skmem</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_charge_skmem" title="Link to this definition">¶</a><br /></dt>
<dd><p>charge socket memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>memcg to charge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>number of pages to charge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>reclaim mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Charges <strong>nr_pages</strong> to <strong>memcg</strong>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the charge fit within
<strong>memcg</strong>’s configured limit, <code class="docutils literal notranslate"><span class="pre">false</span></code> if it doesn’t.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mem_cgroup_uncharge_skmem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_cgroup_uncharge_skmem</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">memcg</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mem_cgroup_uncharge_skmem" title="Link to this definition">¶</a><br /></dt>
<dd><p>uncharge socket memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_cgroup</span> <span class="pre">*memcg</span></code></dt><dd><p>memcg to uncharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>number of pages to uncharge</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__mem_cgroup_try_charge_swap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__mem_cgroup_try_charge_swap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__mem_cgroup_try_charge_swap" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">swp_entry_t</span></span><span class="w"> </span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__mem_cgroup_try_charge_swap" title="Link to this definition">¶</a><br /></dt>
<dd><p>try charging swap space for a folio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>folio being added to swap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swp_entry_t</span> <span class="pre">entry</span></code></dt><dd><p>swap entry to charge</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to charge <strong>folio</strong>’s memcg for the swap space at <strong>entry</strong>.</p>
<p>Returns 0 on success, -ENOMEM on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__mem_cgroup_uncharge_swap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__mem_cgroup_uncharge_swap</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">swp_entry_t</span></span><span class="w"> </span><span class="n"><span class="pre">entry</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__mem_cgroup_uncharge_swap" title="Link to this definition">¶</a><br /></dt>
<dd><p>uncharge swap space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">swp_entry_t</span> <span class="pre">entry</span></code></dt><dd><p>swap entry to uncharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>the amount of swap space to uncharge</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.obj_cgroup_may_zswap">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">obj_cgroup_may_zswap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">obj_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objcg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.obj_cgroup_may_zswap" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if this cgroup can zswap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">obj_cgroup</span> <span class="pre">*objcg</span></code></dt><dd><p>the object cgroup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the hierarchical zswap limit has been reached.</p>
<p>This doesn’t check for specific headroom, and it is not atomic
either. But with zswap, the size of the allocation is only known
once compression has occurred, and this optimistic pre-check avoids
spending cycles on compression when there is already no room left
or zswap is disabled altogether somewhere in the hierarchy.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.obj_cgroup_charge_zswap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">obj_cgroup_charge_zswap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">obj_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objcg</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.obj_cgroup_charge_zswap" title="Link to this definition">¶</a><br /></dt>
<dd><p>charge compression backend memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">obj_cgroup</span> <span class="pre">*objcg</span></code></dt><dd><p>the object cgroup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of compressed object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This forces the charge after <a class="reference internal" href="#c.obj_cgroup_may_zswap" title="obj_cgroup_may_zswap"><code class="xref c c-func docutils literal notranslate"><span class="pre">obj_cgroup_may_zswap()</span></code></a> allowed
compression and storage in zwap for this cgroup to go ahead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.obj_cgroup_uncharge_zswap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">obj_cgroup_uncharge_zswap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">obj_cgroup</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objcg</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.obj_cgroup_uncharge_zswap" title="Link to this definition">¶</a><br /></dt>
<dd><p>uncharge compression backend memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">obj_cgroup</span> <span class="pre">*objcg</span></code></dt><dd><p>the object cgroup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of compressed object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uncharges zswap memory on page in.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_recalc_inode">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">shmem_recalc_inode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.shmem_recalc_inode" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">alloced</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">swapped</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_recalc_inode" title="Link to this definition">¶</a><br /></dt>
<dd><p>recalculate the block usage of an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to recalc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">alloced</span></code></dt><dd><p>the change in number of pages allocated to inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">swapped</span></code></dt><dd><p>the change in number of pages swapped from inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We have to calculate the free blocks since the mm can drop
undirtied hole pages behind our back.</p>
<p>But normally   info-&gt;alloced == inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped
So mm freed is info-&gt;alloced - (inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_mapping_size_orders">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">shmem_mapping_size_orders</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">write_end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_mapping_size_orders" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get allowable folio orders for the given file size.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>Target address_space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>The page index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">write_end</span></code></dt><dd><p>end of a write, could extend inode size.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns huge orders for folios (when supported) based on the file size
which the mapping currently allows at the given index. The index is relevant
due to alignment considerations the mapping might have. The returned order
may be less than the size passed.</p>
<p><strong>Return</strong></p>
<p>The orders.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_writeout">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">shmem_writeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.shmem_writeout" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">writeback_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wbc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_writeout" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write the folio to swap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*wbc</span></code></dt><dd><p>How writeback is to be done</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move the folio from the page cache to the swap cache.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_get_folio">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">shmem_get_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.shmem_get_folio" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">write_end</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">foliop</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">sgp_type</span></span><span class="w"> </span><span class="n"><span class="pre">sgp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_get_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>find, and lock a shmem folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the page index.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">write_end</span></code></dt><dd><p>end of a write, could extend inode size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">**foliop</span></code></dt><dd><p>pointer to the folio if found</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">sgp_type</span> <span class="pre">sgp</span></code></dt><dd><p>SGP_* flags to control behavior</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache entry at <strong>inode</strong> &amp; <strong>index</strong>.  If a folio is
present, it is returned locked with an increased refcount.</p>
<p>If the caller modifies data in the folio, it must call <a class="reference internal" href="#c.folio_mark_dirty" title="folio_mark_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mark_dirty()</span></code></a>
before unlocking the folio to ensure that the folio is not reclaimed.
There is no need to reserve space before calling <a class="reference internal" href="#c.folio_mark_dirty" title="folio_mark_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_mark_dirty()</span></code></a>.</p>
<dl class="simple">
<dt>When no folio is found, the behavior depends on <strong>sgp</strong>:</dt><dd><ul class="simple">
<li><p>for SGP_READ, <strong>*foliop</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and 0 is returned</p></li>
<li><p>for SGP_NOALLOC, <strong>*foliop</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and -ENOENT is returned</p></li>
<li><p>for all other flags a new folio is allocated, inserted into the
page cache and returned locked in <strong>foliop</strong>.</p></li>
</ul>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>0 if successful, else a negative error code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_kernel_file_setup">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">shmem_kernel_file_setup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_kernel_file_setup" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an unlinked file living in tmpfs which must be kernel internal. There will be NO LSM permission checks against the underlying inode. So users of this interface must do LSM checks at a higher layer. The users are the big_key and shm implementations. LSM checks are provided at the key or shm level rather than the inode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name for dentry (to be seen in /proc/&lt;pid&gt;/maps)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">size</span></code></dt><dd><p>size to be set for the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>VM_NORESERVE suppresses pre-accounting of the entire object size</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_file_setup">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">shmem_file_setup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_file_setup" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an unlinked file living in tmpfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name for dentry (to be seen in /proc/&lt;pid&gt;/maps)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">size</span></code></dt><dd><p>size to be set for the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>VM_NORESERVE suppresses pre-accounting of the entire object size</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_file_setup_with_mnt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">shmem_file_setup_with_mnt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vfsmount</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mnt</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_file_setup_with_mnt" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an unlinked file living in tmpfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*mnt</span></code></dt><dd><p>the tmpfs mount where the file will be created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name for dentry (to be seen in /proc/&lt;pid&gt;/maps)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">size</span></code></dt><dd><p>size to be set for the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>VM_NORESERVE suppresses pre-accounting of the entire object size</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_zero_setup">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">shmem_zero_setup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_zero_setup" title="Link to this definition">¶</a><br /></dt>
<dd><p>setup a shared anonymous mapping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>the vma to be mmapped is prepared by do_mmap</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.shmem_read_folio_gfp">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">shmem_read_folio_gfp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.shmem_read_folio_gfp" title="Link to this definition">¶</a><br /></dt>
<dd><p>read into page cache, using specified page allocation flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the folio’s address_space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt><dd><p>the folio index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the page allocator flags to use if allocating</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This behaves as a tmpfs “read_cache_page_gfp(mapping, index, gfp)”,
with any new page allocations done using the specified allocation flags.
But <a class="reference internal" href="#c.read_cache_page_gfp" title="read_cache_page_gfp"><code class="xref c c-func docutils literal notranslate"><span class="pre">read_cache_page_gfp()</span></code></a> uses the -&gt;read_folio() method: which does not
suit tmpfs, since it may have pages in swapcache, and needs to find those
for itself; although drivers/gpu/drm i915 and ttm rely upon this support.</p>
<p>i915_gem_object_get_pages_gtt() mixes __GFP_NORETRY | __GFP_NOWARN in
with the mapping_gfp_mask(), to avoid OOMing the machine unnecessarily.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.migrate_vma_setup">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">migrate_vma_setup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">migrate_vma</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.migrate_vma_setup" title="Link to this definition">¶</a><br /></dt>
<dd><p>prepare to migrate a range of memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">migrate_vma</span> <span class="pre">*args</span></code></dt><dd><p>contains the vma, start, and pfns arrays for the migration</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>negative errno on failures, 0 when 0 or more pages were migrated
without an error.</p>
<p><strong>Description</strong></p>
<p>Prepare to migrate a range of memory virtual address range by collecting all
the pages backing each virtual address in the range, saving them inside the
src array.  Then lock those pages and unmap them. Once the pages are locked
and unmapped, check whether each page is pinned or not.  Pages that aren’t
pinned have the MIGRATE_PFN_MIGRATE flag set (by this function) in the
corresponding src array entry.  Then restores any pages that are pinned, by
remapping and unlocking those pages.</p>
<p>The caller should then allocate destination memory and copy source memory to
it for all those entries (ie with MIGRATE_PFN_VALID and MIGRATE_PFN_MIGRATE
flag set).  Once these are allocated and copied, the caller must update each
corresponding entry in the dst array with the pfn value of the destination
page and with MIGRATE_PFN_VALID. Destination pages must be locked via
<a class="reference internal" href="#c.lock_page" title="lock_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">lock_page()</span></code></a>.</p>
<p>Note that the caller does not have to migrate all the pages that are marked
with MIGRATE_PFN_MIGRATE flag in src array unless this is a migration from
device memory to system memory.  If the caller cannot migrate a device page
back to system memory, then it must return VM_FAULT_SIGBUS, which has severe
consequences for the userspace process, so it must be avoided if at all
possible.</p>
<p>For empty entries inside CPU page table (pte_none() or pmd_none() is true) we
do set MIGRATE_PFN_MIGRATE flag inside the corresponding source array thus
allowing the caller to allocate device memory for those unbacked virtual
addresses.  For this the caller simply has to allocate device memory and
properly set the destination entry like for regular migration.  Note that
this can still fail, and thus inside the device driver you must check if the
migration was successful for those entries after calling <a class="reference internal" href="#c.migrate_vma_pages" title="migrate_vma_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_pages()</span></code></a>,
just like for regular migration.</p>
<p>After that, the callers must call <a class="reference internal" href="#c.migrate_vma_pages" title="migrate_vma_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_pages()</span></code></a> to go over each entry
in the src array that has the MIGRATE_PFN_VALID and MIGRATE_PFN_MIGRATE flag
set. If the corresponding entry in dst array has MIGRATE_PFN_VALID flag set,
then <a class="reference internal" href="#c.migrate_vma_pages" title="migrate_vma_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_pages()</span></code></a> to migrate struct page information from the source
struct page to the destination struct page.  If it fails to migrate the
struct page information, then it clears the MIGRATE_PFN_MIGRATE flag in the
src array.</p>
<p>At this point all successfully migrated pages have an entry in the src
array with MIGRATE_PFN_VALID and MIGRATE_PFN_MIGRATE flag set and the dst
array entry with MIGRATE_PFN_VALID flag set.</p>
<p>Once <a class="reference internal" href="#c.migrate_vma_pages" title="migrate_vma_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_pages()</span></code></a> returns the caller may inspect which pages were
successfully migrated, and which were not.  Successfully migrated pages will
have the MIGRATE_PFN_MIGRATE flag set for their src array entry.</p>
<p>It is safe to update device page table after <a class="reference internal" href="#c.migrate_vma_pages" title="migrate_vma_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_pages()</span></code></a> because
both destination and source page are still locked, and the mmap_lock is held
in read mode (hence no one can unmap the range being migrated).</p>
<p>Once the caller is done cleaning up things and updating its page table (if it
chose to do so, this is not an obligation) it finally calls
<a class="reference internal" href="#c.migrate_vma_finalize" title="migrate_vma_finalize"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_finalize()</span></code></a> to update the CPU page table to point to new pages
for successfully migrated pages or otherwise restore the CPU page table to
point to the original source pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.migrate_device_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">migrate_device_pages</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src_pfns</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst_pfns</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">npages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.migrate_device_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>migrate meta-data from src page to dst page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src_pfns</span></code></dt><dd><p>src_pfns returned from <a class="reference internal" href="#c.migrate_device_range" title="migrate_device_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_device_range()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst_pfns</span></code></dt><dd><p>array of pfns allocated by the driver to migrate memory to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">npages</span></code></dt><dd><p>number of pages in the range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Equivalent to <a class="reference internal" href="#c.migrate_vma_pages" title="migrate_vma_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_pages()</span></code></a>. This is called to migrate struct page
meta-data from source struct page to destination.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.migrate_vma_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">migrate_vma_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">migrate_vma</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">migrate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.migrate_vma_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>migrate meta-data from src page to dst page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">migrate_vma</span> <span class="pre">*migrate</span></code></dt><dd><p>migrate struct containing all migration information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This migrates struct page meta-data from source struct page to destination
struct page. This effectively finishes the migration from source page to the
destination page.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.migrate_vma_finalize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">migrate_vma_finalize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">migrate_vma</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">migrate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.migrate_vma_finalize" title="Link to this definition">¶</a><br /></dt>
<dd><p>restore CPU page table entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">migrate_vma</span> <span class="pre">*migrate</span></code></dt><dd><p>migrate struct containing all migration information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This replaces the special migration pte entry with either a mapping to the
new page if migration was successful for that page, or to the original page
otherwise.</p>
<p>This also unlocks the pages and puts them back on the lru, or drops the extra
refcount, for device pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.migrate_device_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">migrate_device_range</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src_pfns</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">npages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.migrate_device_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>migrate device private pfns to normal memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src_pfns</span></code></dt><dd><p>array large enough to hold migrating source device private pfns.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>starting pfn in the range to migrate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">npages</span></code></dt><dd><p>number of pages to migrate.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.migrate_vma_setup" title="migrate_vma_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_setup()</span></code></a> is similar in concept to <a class="reference internal" href="#c.migrate_vma_setup" title="migrate_vma_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_setup()</span></code></a> except that
instead of looking up pages based on virtual address mappings a range of
device pfns that should be migrated to system memory is used instead.</p>
<p>This is useful when a driver needs to free device memory but doesn’t know the
virtual mappings of every page that may be in device memory. For example this
is often the case when a driver is being unloaded or unbound from a device.</p>
<p>Like <a class="reference internal" href="#c.migrate_vma_setup" title="migrate_vma_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_vma_setup()</span></code></a> this function will take a reference and lock any
migrating pages that aren’t free before unmapping them. Drivers may then
allocate destination pages and start copying data from the device to CPU
memory before calling <a class="reference internal" href="#c.migrate_device_pages" title="migrate_device_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_device_pages()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.migrate_device_pfns">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">migrate_device_pfns</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src_pfns</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">npages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.migrate_device_pfns" title="Link to this definition">¶</a><br /></dt>
<dd><p>migrate device private pfns to normal memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src_pfns</span></code></dt><dd><p>pre-popluated array of source device private pfns to migrate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">npages</span></code></dt><dd><p>number of pages to migrate.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.migrate_device_range" title="migrate_device_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">migrate_device_range()</span></code></a> but supports non-contiguous pre-popluated
array of device pages to migrate.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.wp_walk">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wp_walk</span></span></span><a class="headerlink" href="#c.wp_walk" title="Link to this definition">¶</a><br /></dt>
<dd><p>Private struct for pagetable walk callbacks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct wp_walk {
    struct mmu_notifier_range range;
    unsigned long tlbflush_start;
    unsigned long tlbflush_end;
    unsigned long total;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">range</span></code></dt><dd><p>Range for mmu notifiers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tlbflush_start</span></code></dt><dd><p>Address of first modified pte</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tlbflush_end</span></code></dt><dd><p>Address of last modified pte + 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total</span></code></dt><dd><p>Total number of modified ptes</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wp_pte">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wp_pte</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pte_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pte</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_walk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">walk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wp_pte" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write-protect a pte</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pte_t</span> <span class="pre">*pte</span></code></dt><dd><p>Pointer to the pte</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>The start of protecting virtual address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt><dd><p>The end of protecting virtual address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_walk</span> <span class="pre">*walk</span></code></dt><dd><p>pagetable walk callback argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function write-protects a pte and records the range in
virtual address space of touched ptes for efficient range TLB flushes.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.clean_walk">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clean_walk</span></span></span><a class="headerlink" href="#c.clean_walk" title="Link to this definition">¶</a><br /></dt>
<dd><p>Private struct for the clean_record_pte function.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct clean_walk {
    struct wp_walk base;
    pgoff_t bitmap_pgoff;
    unsigned long *bitmap;
    pgoff_t start;
    pgoff_t end;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p><a class="reference internal" href="#c.wp_walk" title="wp_walk"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wp_walk</span></code></a> we derive from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitmap_pgoff</span></code></dt><dd><p>Address_space Page offset of the first bit in <strong>bitmap</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitmap</span></code></dt><dd><p>Bitmap with one bit for each page offset in the address_space range
covered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Address_space page offset of first modified pte relative
to <strong>bitmap_pgoff</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt><dd><p>Address_space page offset of last modified pte relative
to <strong>bitmap_pgoff</strong></p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clean_record_pte">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clean_record_pte</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pte_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pte</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_walk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">walk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clean_record_pte" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clean a pte and record its address space offset in a bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pte_t</span> <span class="pre">*pte</span></code></dt><dd><p>Pointer to the pte</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>The start of virtual address to be clean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt><dd><p>The end of virtual address to be clean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_walk</span> <span class="pre">*walk</span></code></dt><dd><p>pagetable walk callback argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function cleans a pte and records the range in
virtual address space of touched ptes for efficient TLB flushes.
It also records dirty ptes in a bitmap representing page offsets
in the address_space, as well as the first and last of the bits
touched.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wp_shared_mapping_range">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wp_shared_mapping_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">first_index</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wp_shared_mapping_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write-protect all ptes in an address space range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space we want to write protect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">first_index</span></code></dt><dd><p>The first page offset in the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">nr</span></code></dt><dd><p>Number of incremental page offsets to cover</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function currently skips transhuge page-table entries, since
it’s intended for dirty-tracking on the PTE level. It will warn on
encountering transhuge write-enabled entries, though, and can easily be
extended to handle them as well.</p>
<p><strong>Return</strong></p>
<p>The number of ptes actually write-protected. Note that
already write-protected ptes are not counted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clean_record_shared_mapping_range">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clean_record_shared_mapping_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">first_index</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="n"><span class="pre">bitmap_pgoff</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bitmap</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">pgoff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clean_record_shared_mapping_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clean and record all ptes in an address space range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address_space we want to clean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">first_index</span></code></dt><dd><p>The first page offset in the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">nr</span></code></dt><dd><p>Number of incremental page offsets to cover</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">bitmap_pgoff</span></code></dt><dd><p>The page offset of the first bit in <strong>bitmap</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*bitmap</span></code></dt><dd><p>Pointer to a bitmap of at least <strong>nr</strong> bits. The bitmap needs to
cover the whole range <strong>first_index</strong>..**first_index** + <strong>nr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">*start</span></code></dt><dd><p>Pointer to number of the first set bit in <strong>bitmap</strong>.
is modified as new bits are set by the function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pgoff_t</span> <span class="pre">*end</span></code></dt><dd><p>Pointer to the number of the last set bit in <strong>bitmap</strong>.
none set. The value is modified as new bits are set by the function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When this function returns there is no guarantee that a CPU has
not already dirtied new ptes. However it will not clean any ptes not
reported in the bitmap. The guarantees are as follows:</p>
<ul class="simple">
<li><p>All ptes dirty when the function starts executing will end up recorded
in the bitmap.</p></li>
<li><p>All ptes dirtied after that will either remain dirty, be recorded in the
bitmap or both.</p></li>
</ul>
<p>If a caller needs to make sure all dirty ptes are picked up and none
additional are added, it first needs to write-protect the address-space
range and make sure new writers are blocked in page_mkwrite() or
pfn_mkwrite(). And then after a TLB flush following the write-protection
pick up all dirty bits.</p>
<p>This function currently skips transhuge page-table entries, since
it’s intended for dirty-tracking on the PTE level. It will warn on
encountering transhuge dirty entries, though, and can easily be extended
to handle them as well.</p>
<p><strong>Return</strong></p>
<p>The number of dirty ptes actually cleaned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_addr_in_chunk">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_addr_in_chunk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_addr_in_chunk" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if the address is served from this chunk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>percpu address</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the address is served from this chunk.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_check_block_hint">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_check_block_hint</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_block_md</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">block</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_check_block_hint" title="Link to this definition">¶</a><br /></dt>
<dd><p>check against the contig hint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_block_md</span> <span class="pre">*block</span></code></dt><dd><p>block of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>size of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment of area (max PAGE_SIZE)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if the allocation can fit in the block’s contig hint.
Note, a chunk uses the same hints as a block so this can also check against
the chunk’s contig hint.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_next_md_free_region">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_next_md_free_region</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bit_off</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_next_md_free_region" title="Link to this definition">¶</a><br /></dt>
<dd><p>finds the next hint free area</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*bit_off</span></code></dt><dd><p>chunk offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*bits</span></code></dt><dd><p>size of free area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pcpu_for_each_md_free_region.  It checks
block-&gt;contig_hint and performs aggregation across blocks to find the
next hint.  It modifies bit_off and bits in-place to be consumed in the
loop.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_next_fit_region">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_next_fit_region</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">alloc_bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bit_off</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_next_fit_region" title="Link to this definition">¶</a><br /></dt>
<dd><p>finds fit areas for a given allocation request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">alloc_bits</span></code></dt><dd><p>size of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">align</span></code></dt><dd><p>alignment of area (max PAGE_SIZE)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*bit_off</span></code></dt><dd><p>chunk offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*bits</span></code></dt><dd><p>size of free area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the next free region that is viable for use with a given size and
alignment.  This only returns if there is a valid area to be used for this
allocation.  block-&gt;first_free is returned if the allocation request fits
within the block to see if the request can be fulfilled prior to the contig
hint.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_mem_zalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_mem_zalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_mem_zalloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>bytes to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate <strong>size</strong> bytes.  If <strong>size</strong> is smaller than PAGE_SIZE,
<a class="reference internal" href="#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a> is used; otherwise, the equivalent of vzalloc() is used.
This is to facilitate passing through whitelisted flags.  The
returned memory is always zeroed.</p>
<p><strong>Return</strong></p>
<p>Pointer to the allocated area on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_mem_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_mem_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_mem_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>free memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free <strong>ptr</strong>.  <strong>ptr</strong> should have been allocated using <a class="reference internal" href="#c.pcpu_mem_zalloc" title="pcpu_mem_zalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcpu_mem_zalloc()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_chunk_relocate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_chunk_relocate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">oslot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_chunk_relocate" title="Link to this definition">¶</a><br /></dt>
<dd><p>put chunk in the appropriate chunk slot</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oslot</span></code></dt><dd><p>the previous slot it was on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called after an allocation or free changed <strong>chunk</strong>.
New slot according to the changed state is determined and <strong>chunk</strong> is
moved to the slot.  Note that the reserved chunk is never put on
chunk slots.</p>
<p><strong>Context</strong></p>
<p>pcpu_lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_block_update">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_block_update</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_block_md</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">block</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_block_update" title="Link to this definition">¶</a><br /></dt>
<dd><p>updates a block given a free area</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_block_md</span> <span class="pre">*block</span></code></dt><dd><p>block of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">start</span></code></dt><dd><p>start offset in block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">end</span></code></dt><dd><p>end offset in block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates a block given a known free area.  The region [start, end) is
expected to be the entirety of the free area within a block.  Chooses
the best starting offset if the contig hints are equal.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_chunk_refresh_hint">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_chunk_refresh_hint</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">full_scan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_chunk_refresh_hint" title="Link to this definition">¶</a><br /></dt>
<dd><p>updates metadata about a chunk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">full_scan</span></code></dt><dd><p>if we should scan from the beginning</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates over the metadata blocks to find the largest contig area.
A full scan can be avoided on the allocation path as this is triggered
if we broke the contig_hint.  In doing so, the scan_hint will be before
the contig_hint or after if the scan_hint == contig_hint.  This cannot
be prevented on freeing as we want to find the largest area possibly
spanning blocks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_block_refresh_hint">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_block_refresh_hint</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_block_refresh_hint" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the metadata block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans over the block beginning at first_free and updates the block
metadata accordingly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_block_update_hint_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_block_update_hint_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bit_off</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_block_update_hint_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>update hint on allocation path</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bit_off</span></code></dt><dd><p>chunk offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>size of request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates metadata for the allocation path.  The metadata only has to be
refreshed by a full scan iff the chunk’s contig hint is broken.  Block level
scans are required if the block’s contig hint is broken.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_block_update_hint_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_block_update_hint_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bit_off</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_block_update_hint_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>updates the block hints on the free path</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bit_off</span></code></dt><dd><p>chunk offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>size of request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates metadata for the allocation path.  This avoids a blind block
refresh by making use of the block contig hints.  If this fails, it scans
forward and backward to determine the extent of the free area.  This is
capped at the boundary of blocks.</p>
<p>A chunk update is triggered if a page becomes free, a block becomes free,
or the free spans across blocks.  This tradeoff is to minimize iterating
over the block metadata to update chunk_md-&gt;contig_hint.
chunk_md-&gt;contig_hint may be off by up to a page, but it will never be more
than the available space.  If the contig hint is contained in one block, it
will be accurate.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_is_populated">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_is_populated</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bit_off</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">next_off</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_is_populated" title="Link to this definition">¶</a><br /></dt>
<dd><p>determines if the region is populated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bit_off</span></code></dt><dd><p>chunk offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>size of area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*next_off</span></code></dt><dd><p>return value for the next offset to start searching</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For atomic allocations, check if the backing pages are populated.</p>
<p><strong>Return</strong></p>
<p>Bool if the backing pages are populated.
next_index is to skip over unpopulated blocks in pcpu_find_block_fit.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_find_block_fit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_find_block_fit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">alloc_bits</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">pop_only</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_find_block_fit" title="Link to this definition">¶</a><br /></dt>
<dd><p>finds the block index to start searching</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">alloc_bits</span></code></dt><dd><p>size of request in allocation units</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment of area (max PAGE_SIZE bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">pop_only</span></code></dt><dd><p>use populated regions only</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a chunk and an allocation spec, find the offset to begin searching
for a free region.  This iterates over the bitmap metadata blocks to
find an offset that will be guaranteed to fit the requirements.  It is
not quite first fit as if the allocation does not fit in the contig hint
of a block or chunk, it is skipped.  This errs on the side of caution
to prevent excess iteration.  Poor alignment can cause the allocator to
skip over blocks and chunks that have valid free areas.</p>
<p><strong>Return</strong></p>
<p>The offset in the bitmap to begin searching.
-1 if no offset is found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_alloc_area">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_alloc_area</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">alloc_bits</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_alloc_area" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocates an area from a pcpu_chunk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">alloc_bits</span></code></dt><dd><p>size of request in allocation units</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment of area (max PAGE_SIZE)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">start</span></code></dt><dd><p>bit_off to start searching</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes in a <strong>start</strong> offset to begin searching to fit an
allocation of <strong>alloc_bits</strong> with alignment <strong>align</strong>.  It needs to scan
the allocation map because if it fits within the block’s contig hint,
<strong>start</strong> will be block-&gt;first_free. This is an attempt to fill the
allocation prior to breaking the contig hint.  The allocation and
boundary maps are updated accordingly if it confirms a valid
free area.</p>
<p><strong>Return</strong></p>
<p>Allocated addr offset in <strong>chunk</strong> on success.
-1 if no matching area is found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_free_area">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_free_area</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">off</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_free_area" title="Link to this definition">¶</a><br /></dt>
<dd><p>frees the corresponding offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>chunk of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">off</span></code></dt><dd><p>addr offset into chunk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function determines the size of an allocation to free using
the boundary bitmap and clears the allocation map.</p>
<p><strong>Return</strong></p>
<p>Number of freed bytes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_alloc_first_chunk">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_alloc_first_chunk</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">tmp_addr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">map_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_alloc_first_chunk" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates chunks that serve the first chunk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">tmp_addr</span></code></dt><dd><p>the start of the region served</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">map_size</span></code></dt><dd><p>size of the region served</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is responsible for creating the chunks that serve the first chunk.  The
base_addr is page aligned down of <strong>tmp_addr</strong> while the region end is page
aligned up.  Offsets are kept track of to determine the region served. All
this is done to appease the bitmap allocator in avoiding partial blocks.</p>
<p><strong>Return</strong></p>
<p>Chunk serving the region at <strong>tmp_addr</strong> of <strong>map_size</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_chunk_populated">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_chunk_populated</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">page_start</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">page_end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_chunk_populated" title="Link to this definition">¶</a><br /></dt>
<dd><p>post-population bookkeeping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>pcpu_chunk which got populated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page_start</span></code></dt><dd><p>the start page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page_end</span></code></dt><dd><p>the end page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pages in [<strong>page_start</strong>,**page_end**) have been populated to <strong>chunk</strong>.  Update
the bookkeeping information accordingly.  Must be called after each
successful population.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_chunk_depopulated">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_chunk_depopulated</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chunk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">page_start</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">page_end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_chunk_depopulated" title="Link to this definition">¶</a><br /></dt>
<dd><p>post-depopulation bookkeeping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_chunk</span> <span class="pre">*chunk</span></code></dt><dd><p>pcpu_chunk which got depopulated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page_start</span></code></dt><dd><p>the start page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page_end</span></code></dt><dd><p>the end page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pages in [<strong>page_start</strong>,**page_end**) have been depopulated from <strong>chunk</strong>.
Update the bookkeeping information accordingly.  Must be called after
each successful depopulation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_chunk_addr_search">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_chunk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_chunk_addr_search</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_chunk_addr_search" title="Link to this definition">¶</a><br /></dt>
<dd><p>determine chunk containing specified address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>address for which the chunk needs to be determined.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an internal function that handles all but static allocations.
Static percpu address values should never be passed into the allocator.</p>
<p><strong>Return</strong></p>
<p>The address of the found chunk.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__percpu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_alloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">reserved</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>the percpu allocator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of area to allocate in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment of area (max PAGE_SIZE)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">reserved</span></code></dt><dd><p>allocate from the reserved chunk if available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate percpu area of <strong>size</strong> bytes aligned at <strong>align</strong>.  If <strong>gfp</strong> doesn’t
contain <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>, the allocation is atomic. If <strong>gfp</strong> has __GFP_NOWARN
then no warning will be triggered on invalid or failed allocation
requests.</p>
<p><strong>Return</strong></p>
<p>Percpu pointer to the allocated area on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_balance_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_balance_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">empty_only</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_balance_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>manage the amount of free chunks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">empty_only</span></code></dt><dd><p>free chunks only if there are no populated pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If empty_only is <code class="docutils literal notranslate"><span class="pre">false</span></code>, reclaim all fully free chunks regardless of the
number of populated pages.  Otherwise, only reclaim chunks that have no
populated pages.</p>
<p><strong>Context</strong></p>
<p>pcpu_lock (can be dropped temporarily)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_balance_populated">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_balance_populated</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_balance_populated" title="Link to this definition">¶</a><br /></dt>
<dd><p>manage the amount of populated pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maintain a certain amount of populated pages to satisfy atomic allocations.
It is possible that this is called when physical memory is scarce causing
OOM killer to be triggered.  We should avoid doing so until an actual
allocation causes the failure as it is possible that requests can be
serviced from already backed regions.</p>
<p><strong>Context</strong></p>
<p>pcpu_lock (can be dropped temporarily)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_reclaim_populated">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_reclaim_populated</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_reclaim_populated" title="Link to this definition">¶</a><br /></dt>
<dd><p>scan over to_depopulate chunks and free empty pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan over chunks in the depopulate list and try to release unused populated
pages back to the system.  Depopulated chunks are sidelined to prevent
repopulating these pages unless required.  Fully free chunks are reintegrated
and freed accordingly (1 is kept around).  If we drop below the empty
populated pages threshold, reintegrate the chunk if it has empty free pages.
Each chunk is scanned in the reverse order to keep populated pages close to
the beginning of the chunk.</p>
<p><strong>Context</strong></p>
<p>pcpu_lock (can be dropped temporarily)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_balance_workfn">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_balance_workfn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_balance_workfn" title="Link to this definition">¶</a><br /></dt>
<dd><p>manage the amount of free chunks and populated pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>unused</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each chunk type, manage the number of fully free chunks and the number of
populated pages.  An important thing to consider is when pages are freed and
how they contribute to the global counts.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.free_percpu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_percpu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__percpu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.free_percpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>free percpu area</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to area to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free percpu area <strong>ptr</strong>.</p>
<p><strong>Context</strong></p>
<p>Can be called from atomic context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.is_kernel_percpu_address">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_kernel_percpu_address</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.is_kernel_percpu_address" title="Link to this definition">¶</a><br /></dt>
<dd><p>test whether address is from static percpu area</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>address to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test whether <strong>addr</strong> belongs to in-kernel static percpu area.  Module
static percpu areas are not considered.  For those, use
is_module_percpu_address().</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>addr</strong> is from in-kernel static percpu area, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.per_cpu_ptr_to_phys">
<span class="n"><span class="pre">phys_addr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">per_cpu_ptr_to_phys</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.per_cpu_ptr_to_phys" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert translated percpu address to physical address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>the address to be converted to physical address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given <strong>addr</strong> which is dereferenceable address obtained via one of
percpu access macros, this function translates it into its physical
address.  The caller is responsible for ensuring <strong>addr</strong> stays valid
until this function finishes.</p>
<p>percpu allocator has special setup for the first chunk, which currently
supports either embedding in linear address space or vmalloc mapping,
and, from the second one, the backing allocator (currently either vm or
km) provides translation.</p>
<p>The addr can be translated simply without checking if it falls into the
first chunk. But the current code reflects better how percpu allocator
actually works, and the verification can discover both bugs in percpu
allocator itself and <a class="reference internal" href="#c.per_cpu_ptr_to_phys" title="per_cpu_ptr_to_phys"><code class="xref c c-func docutils literal notranslate"><span class="pre">per_cpu_ptr_to_phys()</span></code></a> callers. So we keep current
code.</p>
<p><strong>Return</strong></p>
<p>The physical address for <strong>addr</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_alloc_alloc_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_alloc_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_alloc_alloc_info</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_groups</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_units</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_alloc_alloc_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate percpu allocation info</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_groups</span></code></dt><dd><p>the number of groups</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_units</span></code></dt><dd><p>the number of units</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate ai which is large enough for <strong>nr_groups</strong> groups containing
<strong>nr_units</strong> units.  The returned ai’s groups[0].cpu_map points to the
cpu_map array which is long enough for <strong>nr_units</strong> and filled with
NR_CPUS.  It’s the caller’s responsibility to initialize cpu_map
pointer of other groups.</p>
<p><strong>Return</strong></p>
<p>Pointer to the allocated pcpu_alloc_info on success, NULL on
failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_free_alloc_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_free_alloc_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_alloc_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ai</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_free_alloc_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>free percpu allocation info</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcpu_alloc_info</span> <span class="pre">*ai</span></code></dt><dd><p>pcpu_alloc_info to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free <strong>ai</strong> which was allocated by <a class="reference internal" href="#c.pcpu_alloc_alloc_info" title="pcpu_alloc_alloc_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcpu_alloc_alloc_info()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_dump_alloc_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_dump_alloc_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lvl</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_alloc_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ai</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_dump_alloc_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>print out information about pcpu_alloc_info</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*lvl</span></code></dt><dd><p>loglevel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pcpu_alloc_info</span> <span class="pre">*ai</span></code></dt><dd><p>allocation info to dump</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Print out information about <strong>ai</strong> using loglevel <strong>lvl</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_setup_first_chunk">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_setup_first_chunk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_alloc_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ai</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">base_addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_setup_first_chunk" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize the first percpu chunk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pcpu_alloc_info</span> <span class="pre">*ai</span></code></dt><dd><p>pcpu_alloc_info describing how to percpu area is shaped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*base_addr</span></code></dt><dd><p>mapped address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the first percpu chunk which contains the kernel static
percpu area.  This function is to be called from arch percpu area
setup path.</p>
<p><strong>ai</strong> contains all information necessary to initialize the first
chunk and prime the dynamic percpu allocator.</p>
<p><strong>ai-&gt;static_size</strong> is the size of static percpu area.</p>
<p><strong>ai-&gt;reserved_size</strong>, if non-zero, specifies the amount of bytes to
reserve after the static area in the first chunk.  This reserves
the first chunk such that it’s available only through reserved
percpu allocation.  This is primarily used to serve module percpu
static areas on architectures where the addressing model has
limited offset range for symbol relocations to guarantee module
percpu symbols fall inside the relocatable range.</p>
<p><strong>ai-&gt;dyn_size</strong> determines the number of bytes available for dynamic
allocation in the first chunk.  The area between <strong>ai-&gt;static_size</strong> +
<strong>ai-&gt;reserved_size</strong> + <strong>ai-&gt;dyn_size</strong> and <strong>ai-&gt;unit_size</strong> is unused.</p>
<p><strong>ai-&gt;unit_size</strong> specifies unit size and must be aligned to PAGE_SIZE
and equal to or larger than <strong>ai-&gt;static_size</strong> + <strong>ai-&gt;reserved_size</strong> +
<strong>ai-&gt;dyn_size</strong>.</p>
<p><strong>ai-&gt;atom_size</strong> is the allocation atom size and used as alignment
for vm areas.</p>
<p><strong>ai-&gt;alloc_size</strong> is the allocation size and always multiple of
<strong>ai-&gt;atom_size</strong>.  This is larger than <strong>ai-&gt;atom_size</strong> if
<strong>ai-&gt;unit_size</strong> is larger than <strong>ai-&gt;atom_size</strong>.</p>
<p><strong>ai-&gt;nr_groups</strong> and <strong>ai-&gt;groups</strong> describe virtual memory layout of
percpu areas.  Units which should be colocated are put into the
same group.  Dynamic VM areas will be allocated according to these
groupings.  If <strong>ai-&gt;nr_groups</strong> is zero, a single group containing
all units is assumed.</p>
<p>The caller should have mapped the first chunk at <strong>base_addr</strong> and
copied static data to each unit.</p>
<p>The first chunk will always contain a static and a dynamic region.
However, the static region is not managed by any chunk.  If the first
chunk also contains a reserved region, it is served by two chunks -
one for the reserved region and one for the dynamic region.  They
share the same vm, but use offset regions in the area allocation map.
The chunk serving the dynamic region is circulated in the chunk slots
and available for dynamic allocation like any other chunk.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_build_alloc_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pcpu_alloc_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_build_alloc_info</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">reserved_size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">dyn_size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">atom_size</span></span>, <span class="n"><span class="pre">pcpu_fc_cpu_distance_fn_t</span></span><span class="w"> </span><span class="n"><span class="pre">cpu_distance_fn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_build_alloc_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>build alloc_info considering distances between CPUs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">reserved_size</span></code></dt><dd><p>the size of reserved percpu area in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dyn_size</span></code></dt><dd><p>minimum free size for dynamic allocation in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">atom_size</span></code></dt><dd><p>allocation atom size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcpu_fc_cpu_distance_fn_t</span> <span class="pre">cpu_distance_fn</span></code></dt><dd><p>callback to determine distance between cpus, optional</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function determines grouping of units, their mappings to cpus
and other parameters considering needed percpu size, allocation
atom size and distances between CPUs.</p>
<p>Groups are always multiples of atom size and CPUs which are of
LOCAL_DISTANCE both ways are grouped together and share space for
units in the same group.  The returned configuration is guaranteed
to have CPUs on different nodes on different groups and &gt;=75% usage
of allocated virtual address space.</p>
<p><strong>Return</strong></p>
<p>On success, pointer to the new allocation_info is returned.  On
failure, ERR_PTR value is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_embed_first_chunk">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_embed_first_chunk</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">reserved_size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">dyn_size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">atom_size</span></span>, <span class="n"><span class="pre">pcpu_fc_cpu_distance_fn_t</span></span><span class="w"> </span><span class="n"><span class="pre">cpu_distance_fn</span></span>, <span class="n"><span class="pre">pcpu_fc_cpu_to_node_fn_t</span></span><span class="w"> </span><span class="n"><span class="pre">cpu_to_nd_fn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_embed_first_chunk" title="Link to this definition">¶</a><br /></dt>
<dd><p>embed the first percpu chunk into bootmem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">reserved_size</span></code></dt><dd><p>the size of reserved percpu area in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dyn_size</span></code></dt><dd><p>minimum free size for dynamic allocation in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">atom_size</span></code></dt><dd><p>allocation atom size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcpu_fc_cpu_distance_fn_t</span> <span class="pre">cpu_distance_fn</span></code></dt><dd><p>callback to determine distance between cpus, optional</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcpu_fc_cpu_to_node_fn_t</span> <span class="pre">cpu_to_nd_fn</span></code></dt><dd><p>callback to convert cpu to it’s node, optional</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper to ease setting up embedded first percpu chunk and
can be called where <a class="reference internal" href="#c.pcpu_setup_first_chunk" title="pcpu_setup_first_chunk"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcpu_setup_first_chunk()</span></code></a> is expected.</p>
<p>If this function is used to setup the first chunk, it is allocated
by calling pcpu_fc_alloc and used as-is without being mapped into
vmalloc area.  Allocations are always whole multiples of <strong>atom_size</strong>
aligned to <strong>atom_size</strong>.</p>
<p>This enables the first chunk to piggy back on the linear physical
mapping which often uses larger page size.  Please note that this
can result in very sparse cpu-&gt;unit mapping on NUMA machines thus
requiring large vmalloc address space.  Don’t use this allocator if
vmalloc space is not orders of magnitude larger than distances
between node memory addresses (ie. 32bit NUMA machines).</p>
<p><strong>dyn_size</strong> specifies the minimum dynamic area size.</p>
<p>If the needed size is smaller than the minimum or specified unit
size, the leftover is returned using pcpu_fc_free.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pcpu_page_first_chunk">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pcpu_page_first_chunk</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">reserved_size</span></span>, <span class="n"><span class="pre">pcpu_fc_cpu_to_node_fn_t</span></span><span class="w"> </span><span class="n"><span class="pre">cpu_to_nd_fn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pcpu_page_first_chunk" title="Link to this definition">¶</a><br /></dt>
<dd><p>map the first chunk using PAGE_SIZE pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">reserved_size</span></code></dt><dd><p>the size of reserved percpu area in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcpu_fc_cpu_to_node_fn_t</span> <span class="pre">cpu_to_nd_fn</span></code></dt><dd><p>callback to convert cpu to it’s node, optional</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper to ease setting up page-remapped first percpu
chunk and can be called where <a class="reference internal" href="#c.pcpu_setup_first_chunk" title="pcpu_setup_first_chunk"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcpu_setup_first_chunk()</span></code></a> is expected.</p>
<p>This is the basic allocator.  Static percpu area is allocated
page-by-page into vmalloc area.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.copy_from_user_nofault">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">copy_from_user_nofault</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_from_user_nofault" title="Link to this definition">¶</a><br /></dt>
<dd><p>safely attempt to read from a user-space location</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dst</span></code></dt><dd><p>pointer to the buffer that shall take the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*src</span></code></dt><dd><p>address to read from. This must be a user address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the data chunk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Safely read from user address <strong>src</strong> to the buffer at <strong>dst</strong>. If a kernel fault
happens, handle that and return -EFAULT.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.copy_to_user_nofault">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">copy_to_user_nofault</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_to_user_nofault" title="Link to this definition">¶</a><br /></dt>
<dd><p>safely attempt to write to a user-space location</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*dst</span></code></dt><dd><p>address to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>pointer to the data that shall be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the data chunk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Safely write to address <strong>dst</strong> from the buffer at <strong>src</strong>.  If a kernel fault
happens, handle that and return -EFAULT.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strncpy_from_user_nofault">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strncpy_from_user_nofault</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">unsafe_addr</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strncpy_from_user_nofault" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>Copy a NUL terminated string from unsafe user address.</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*dst</span></code></dt><dd><p>Destination address, in kernel space.  This buffer must be at
least <strong>count</strong> bytes long.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*unsafe_addr</span></code></dt><dd><p>Unsafe user address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">count</span></code></dt><dd><p>Maximum number of bytes to copy, including the trailing NUL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies a NUL-terminated string from unsafe user address to kernel buffer.</p>
<p>On success, returns the length of the string INCLUDING the trailing NUL.</p>
<p>If access fails, returns -EFAULT (some data may have been copied
and the trailing NUL added).</p>
<p>If <strong>count</strong> is smaller than the length of the string, copies <strong>count</strong>-1 bytes,
sets the last byte of <strong>dst</strong> buffer to NUL and returns <strong>count</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strnlen_user_nofault">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strnlen_user_nofault</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">unsafe_addr</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strnlen_user_nofault" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>Get the size of a user string INCLUDING final NUL.</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*unsafe_addr</span></code></dt><dd><p>The string to measure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">count</span></code></dt><dd><p>Maximum count (including NUL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the size of a NUL-terminated string in user space without pagefault.</p>
<p>Returns the size of the string INCLUDING the terminating NUL.</p>
<p>If the string is too long, returns a number larger than <strong>count</strong>. User
has to check the return value against “&gt; count”.
On exception (or invalid count), returns 0.</p>
<p>Unlike strnlen_user, this can be used from IRQ handler etc. because
it disables pagefaults.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.writeback_throttling_sane">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeback_throttling_sane</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scan_control</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.writeback_throttling_sane" title="Link to this definition">¶</a><br /></dt>
<dd><p>is the usual dirty throttling mechanism available?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scan_control</span> <span class="pre">*sc</span></code></dt><dd><p>scan_control in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The normal page dirty throttling mechanism in balance_dirty_pages() is
completely broken with the legacy memcg and direct stalling in
shrink_folio_list() is used for throttling instead, which lacks all the
niceties such as fairness, adaptive pausing, bandwidth proportional
allocation and configurability.</p>
<p>This function tests whether the vmscan currently in progress can assume
that the normal dirty throttling mechanism is operational.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lruvec_lru_size">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lruvec_lru_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.lruvec_lru_size" title="lruvec"><span class="n"><span class="pre">lruvec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lruvec</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">lru_list</span></span><span class="w"> </span><span class="n"><span class="pre">lru</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">zone_idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lruvec_lru_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of pages on the given LRU list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lruvec</span> <span class="pre">*lruvec</span></code></dt><dd><p>lru vector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">lru_list</span> <span class="pre">lru</span></code></dt><dd><p>lru to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">zone_idx</span></code></dt><dd><p>zones to consider (use MAX_NR_ZONES - 1 for the whole LRU list)</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.remove_mapping">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">remove_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.remove_mapping" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempt to remove a folio from its mapping.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to remove.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the folio is dirty, under writeback or if someone else has a ref
on it, removal will fail.</p>
<p><strong>Return</strong></p>
<p>The number of pages removed from the mapping.  0 if the folio
could not be removed.</p>
<p><strong>Context</strong></p>
<p>The caller should have a single refcount on the folio and
hold its lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_putback_lru">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_putback_lru</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_putback_lru" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_putback_lru" title="Link to this definition">¶</a><br /></dt>
<dd><p>Put previously isolated folio onto appropriate LRU list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to be returned to an LRU list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add previously isolated <strong>folio</strong> to appropriate LRU list.
The folio may still be unevictable for other reasons.</p>
<p><strong>Context</strong></p>
<p>lru_lock must not be held, interrupts must be enabled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folio_isolate_lru">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_isolate_lru</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folio_isolate_lru" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_isolate_lru" title="Link to this definition">¶</a><br /></dt>
<dd><p>Try to isolate a folio from its LRU list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>Folio to isolate from its LRU list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Isolate a <strong>folio</strong> from an LRU list and adjust the vmstat statistic
corresponding to whatever LRU list the folio was on.</p>
<p>The folio will have its LRU flag cleared.  If it was found on the
active list, it will have the Active flag set.  If it was found on the
unevictable list, it will have the Unevictable flag set.  These flags
may need to be cleared by the caller before letting the page go.</p>
<ol class="arabic simple">
<li><p>Must be called with an elevated refcount on the folio. This is a
fundamental difference from isolate_lru_folios() (which is called
without a stable reference).</p></li>
<li><p>The lru_lock must not be held.</p></li>
<li><p>Interrupts must be enabled.</p></li>
</ol>
<p><strong>Context</strong></p>
<p><strong>Return</strong></p>
<p>true if the folio was removed from an LRU list.
false if the folio was not on an LRU list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.check_move_unevictable_folios">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">check_move_unevictable_folios</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_batch</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fbatch</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.check_move_unevictable_folios" title="Link to this definition">¶</a><br /></dt>
<dd><p>Move evictable folios to appropriate zone lru list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_batch</span> <span class="pre">*fbatch</span></code></dt><dd><p>Batch of lru folios to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks folios for evictability, if an evictable folio is in the unevictable
lru list, moves it to the appropriate evictable lru list. This function
should be only used for lru folios.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__remove_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__remove_pages</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vmem_altmap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">altmap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__remove_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove sections of pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>starting pageframe (must be aligned to start of a section)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr_pages</span></code></dt><dd><p>number of pages to remove (must be multiple of section size)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vmem_altmap</span> <span class="pre">*altmap</span></code></dt><dd><p>alternative device page map or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if default memmap is used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generic helper function to remove section mappings and sysfs entries
for the section of the memory we are removing. Caller needs to make
sure that pages are marked reserved and zones are adjust properly by
calling offline_pages().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.try_offline_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">try_offline_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.try_offline_node" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>the node ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Offline a node if all memory sections and cpus of the node are removed.</p>
<p><strong>NOTE</strong></p>
<p>The caller must call lock_device_hotplug() to serialize hotplug
and online/offline operations before this call.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__remove_memory">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__remove_memory</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__remove_memory" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove memory if every memory block is offline</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>physical address of the region to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>size of the region to remove</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>The caller must call lock_device_hotplug() to serialize hotplug
and online/offline operations before this call, as required by
<a class="reference internal" href="#c.try_offline_node" title="try_offline_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_offline_node()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mmu_interval_read_begin">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mmu_interval_read_begin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mmu_interval_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interval_sub</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mmu_interval_read_begin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Begin a read side critical section against a VA range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmu_interval_notifier</span> <span class="pre">*interval_sub</span></code></dt><dd><p>The interval subscription</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>mmu_iterval_read_begin()/mmu_iterval_read_retry() implement a
collision-retry scheme similar to seqcount for the VA range under
subscription. If the mm invokes invalidation during the critical section
then mmu_interval_read_retry() will return true.</p>
<p>This is useful to obtain shadow PTEs where teardown or setup of the SPTEs
require a blocking context.  The critical region formed by this can sleep,
and the required ‘user_lock’ can also be a sleeping lock.</p>
<p>The caller is required to provide a ‘user_lock’ to serialize both teardown
and setup.</p>
<p>The return value should be passed to mmu_interval_read_retry().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mmu_notifier_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mmu_notifier_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mmu_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">subscription</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mmu_notifier_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register a notifier on a mm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmu_notifier</span> <span class="pre">*subscription</span></code></dt><dd><p>The notifier to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>The mm to attach the notifier to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must not hold mmap_lock nor any other VM related lock when calling
this registration function. Must also ensure mm_users can’t go down
to zero while this runs to avoid races with mmu_notifier_release,
so mm has to be current-&gt;mm or the mm should be pinned safely such
as with get_task_mm(). If the mm is not current-&gt;mm, the mm_users
pin should be released by calling mmput after mmu_notifier_register
returns.</p>
<p>mmu_notifier_unregister() or <a class="reference internal" href="#c.mmu_notifier_put" title="mmu_notifier_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_notifier_put()</span></code></a> must be always called to
unregister the notifier.</p>
<p>While the caller has a mmu_notifier get the subscription-&gt;mm pointer will remain
valid, and can be converted to an active mm pointer via mmget_not_zero().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mmu_notifier_get_locked">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mmu_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mmu_notifier_get_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mmu_notifier_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mmu_notifier_get_locked" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the single struct mmu_notifier for the mm &amp; ops</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mmu_notifier_ops</span> <span class="pre">*ops</span></code></dt><dd><p>The operations struct being subscribe with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>The mm to attach notifiers too</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function either allocates a new mmu_notifier via
ops-&gt;alloc_notifier(), or returns an already existing notifier on the
list. The value of the ops pointer is used to determine when two notifiers
are the same.</p>
<p>Each call to mmu_notifier_get() must be paired with a call to
<a class="reference internal" href="#c.mmu_notifier_put" title="mmu_notifier_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_notifier_put()</span></code></a>. The caller must hold the write side of mm-&gt;mmap_lock.</p>
<p>While the caller has a mmu_notifier get the mm pointer will remain valid,
and can be converted to an active mm pointer via mmget_not_zero().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mmu_notifier_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mmu_notifier_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mmu_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">subscription</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mmu_notifier_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release the reference on the notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmu_notifier</span> <span class="pre">*subscription</span></code></dt><dd><p>The notifier to act on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be paired with each mmu_notifier_get(), it releases the
reference obtained by the get. If this is the last reference then process
to free the notifier will be run asynchronously.</p>
<p>Unlike mmu_notifier_unregister() the get/put flow only calls ops-&gt;release
when the mm_struct is destroyed. Instead free_notifier is always called to
release any resources held by the user.</p>
<p>As ops-&gt;release is not guaranteed to be called, the user must ensure that
all sptes are dropped, and no new sptes can be established before
<a class="reference internal" href="#c.mmu_notifier_put" title="mmu_notifier_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_notifier_put()</span></code></a> is called.</p>
<p>This function can be called from the ops-&gt;release callback, however the
caller must still ensure it is called pairwise with mmu_notifier_get().</p>
<p>Modules calling this function must call <a class="reference internal" href="#c.mmu_notifier_synchronize" title="mmu_notifier_synchronize"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_notifier_synchronize()</span></code></a> in
their __exit functions to ensure the async work is completed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mmu_interval_notifier_insert">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mmu_interval_notifier_insert</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mmu_interval_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interval_sub</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mmu_interval_notifier_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mmu_interval_notifier_insert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Insert an interval notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmu_interval_notifier</span> <span class="pre">*interval_sub</span></code></dt><dd><p>Interval subscription to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>mm_struct to attach to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>Starting virtual address to monitor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">length</span></code></dt><dd><p>Length of the range to monitor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mmu_interval_notifier_ops</span> <span class="pre">*ops</span></code></dt><dd><p>Interval notifier operations to be called on matching events</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function subscribes the interval notifier for notifications from the
mm.  Upon return the ops related to mmu_interval_notifier will be called
whenever an event that intersects with the given range occurs.</p>
<p>Upon return the range_notifier may not be present in the interval tree yet.
The caller must use the normal interval notifier read flow via
<a class="reference internal" href="#c.mmu_interval_read_begin" title="mmu_interval_read_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_interval_read_begin()</span></code></a> to establish SPTEs for this range.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mmu_interval_notifier_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mmu_interval_notifier_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mmu_interval_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interval_sub</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mmu_interval_notifier_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove a interval notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmu_interval_notifier</span> <span class="pre">*interval_sub</span></code></dt><dd><p>Interval subscription to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be paired with <a class="reference internal" href="#c.mmu_interval_notifier_insert" title="mmu_interval_notifier_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_interval_notifier_insert()</span></code></a>. It cannot
be called from any ops callback.</p>
<p>Once this returns ops callbacks are no longer running on other CPUs and
will not be called in future.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mmu_notifier_synchronize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mmu_notifier_synchronize</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mmu_notifier_synchronize" title="Link to this definition">¶</a><br /></dt>
<dd><p>Ensure all mmu_notifiers are freed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function ensures that all outstanding async SRU work from
<a class="reference internal" href="#c.mmu_notifier_put" title="mmu_notifier_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_notifier_put()</span></code></a> is completed. After it returns any mmu_notifier_ops
associated with an unused mmu_notifier will no longer be called.</p>
<p>Before using the caller must ensure that all of its mmu_notifiers have been
fully released via <a class="reference internal" href="#c.mmu_notifier_put" title="mmu_notifier_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_notifier_put()</span></code></a>.</p>
<p>Modules using the <a class="reference internal" href="#c.mmu_notifier_put" title="mmu_notifier_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmu_notifier_put()</span></code></a> API should call this in their __exit
function to avoid module unloading races.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.balloon_page_list_enqueue">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">balloon_page_list_enqueue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">balloon_dev_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b_dev_info</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.balloon_page_list_enqueue" title="Link to this definition">¶</a><br /></dt>
<dd><p>inserts a list of pages into the balloon page list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">balloon_dev_info</span> <span class="pre">*b_dev_info</span></code></dt><dd><p>balloon device descriptor where we will insert a new page to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*pages</span></code></dt><dd><p>pages to enqueue - allocated using balloon_page_alloc.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Driver must call this function to properly enqueue balloon pages before
definitively removing them from the guest system.</p>
<p><strong>Return</strong></p>
<p>number of pages that were enqueued.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.balloon_page_list_dequeue">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">balloon_page_list_dequeue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">balloon_dev_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b_dev_info</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_req_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.balloon_page_list_dequeue" title="Link to this definition">¶</a><br /></dt>
<dd><p>removes pages from balloon’s page list and returns a list of the pages.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">balloon_dev_info</span> <span class="pre">*b_dev_info</span></code></dt><dd><p>balloon device descriptor where we will grab a page from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*pages</span></code></dt><dd><p>pointer to the list of pages that would be returned to the caller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n_req_pages</span></code></dt><dd><p>number of requested pages.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Driver must call this function to properly de-allocate a previous enlisted
balloon pages before definitively releasing it back to the guest system.
This function tries to remove <strong>n_req_pages</strong> from the ballooned pages and
return them to the caller in the <strong>pages</strong> list.</p>
<p>Note that this function may fail to dequeue some pages even if the balloon
isn’t empty - since the page list can be temporarily empty due to compaction
of isolated pages.</p>
<p><strong>Return</strong></p>
<p>number of pages that were added to the <strong>pages</strong> list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmf_insert_pfn_pmd">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vmf_insert_pfn_pmd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_fault</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vmf</span></span>, <span class="n"><span class="pre">pfn_t</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">write</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmf_insert_pfn_pmd" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert a pmd size pfn</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*vmf</span></code></dt><dd><p>Structure describing the fault</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfn_t</span> <span class="pre">pfn</span></code></dt><dd><p>pfn to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">write</span></code></dt><dd><p>whether it’s a write fault</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a pmd size pfn. See <a class="reference internal" href="#c.vmf_insert_pfn" title="vmf_insert_pfn"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmf_insert_pfn()</span></code></a> for additional info.</p>
<p><strong>Return</strong></p>
<p>vm_fault_t value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmf_insert_pfn_pud">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vmf_insert_pfn_pud</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_fault</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vmf</span></span>, <span class="n"><span class="pre">pfn_t</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">write</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmf_insert_pfn_pud" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert a pud size pfn</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*vmf</span></code></dt><dd><p>Structure describing the fault</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfn_t</span> <span class="pre">pfn</span></code></dt><dd><p>pfn to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">write</span></code></dt><dd><p>whether it’s a write fault</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a pud size pfn. See <a class="reference internal" href="#c.vmf_insert_pfn" title="vmf_insert_pfn"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmf_insert_pfn()</span></code></a> for additional info.</p>
<p><strong>Return</strong></p>
<p>vm_fault_t value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmf_insert_folio_pud">
<a class="reference internal" href="#c.vm_fault_t" title="vm_fault_t"><span class="n"><span class="pre">vm_fault_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vmf_insert_folio_pud</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_fault</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vmf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.vmf_insert_folio_pud" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">write</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmf_insert_folio_pud" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert a pud size folio mapped by a pud entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*vmf</span></code></dt><dd><p>Structure describing the fault</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>folio to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">write</span></code></dt><dd><p>whether it’s a write fault</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>vm_fault_t value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.io_mapping_map_user">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">io_mapping_map_user</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">io_mapping</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iomap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pfn</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.io_mapping_map_user" title="Link to this definition">¶</a><br /></dt>
<dd><p>remap an I/O mapping to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">io_mapping</span> <span class="pre">*iomap</span></code></dt><dd><p>the source io_mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>user vma to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>target user address to start at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt><dd><p>physical address of kernel memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>size of map area</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>this is only safe if the mm semaphore is held when called.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/mm-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>