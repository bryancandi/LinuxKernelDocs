<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Folio Queue &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="XArray" href="xarray.html" />
    <link rel="prev" title="Generic Associative Array Implementation" href="assoc_array.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.15.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kobject.html">Everything you never wanted to know about kobjects, ksets, and ktypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="kref.html">Adding reference counters (krefs) to kernel objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="cleanup.html">Scope-based Cleanup Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Folio Queue</a></li>
<li class="toctree-l3"><a class="reference internal" href="xarray.html">XArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="maple_tree.html">Maple Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="idr.html">ID Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="circular-buffers.html">Circular Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="rbtree.html">Red-black Trees (rbtree) in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-radix-tree.html">Generic radix trees/sparse arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="packing.html">Generic bitfield packing and unpacking functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="this_cpu_ops.html">this_cpu operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="timekeeping.html">ktime accessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="errseq.html">The errseq_t datatype</a></li>
<li class="toctree-l3"><a class="reference internal" href="wrappers/atomic_t.html">Atomic types</a></li>
<li class="toctree-l3"><a class="reference internal" href="wrappers/atomic_bitops.html">Atomic bitops</a></li>
<li class="toctree-l3"><a class="reference internal" href="floating-point.html">Floating-point API</a></li>
<li class="toctree-l3"><a class="reference internal" href="union_find.html">Union-Find in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="min_heap.html">Min Heap API</a></li>
<li class="toctree-l3"><a class="reference internal" href="parser.html">Generic parser</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/folio_queue.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="folio-queue">
<h1>Folio Queue<a class="headerlink" href="#folio-queue" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>David Howells &lt;<a class="reference external" href="mailto:dhowells&#37;&#52;&#48;redhat&#46;com">dhowells<span>&#64;</span>redhat<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>The folio_queue struct forms a single segment in a segmented list of folios
that can be used to form an I/O buffer.  As such, the list can be iterated over
using the ITER_FOLIOQ iov_iter type.</p>
<p>The publicly accessible members of the structure are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct folio_queue {
        struct folio_queue *next;
        struct folio_queue *prev;
        ...
};
</pre></div>
</div>
<p>A pair of pointers are provided, <code class="docutils literal notranslate"><span class="pre">next</span></code> and <code class="docutils literal notranslate"><span class="pre">prev</span></code>, that point to the
segments on either side of the segment being accessed.  Whilst this is a
doubly-linked list, it is intentionally not a circular list; the outward
sibling pointers in terminal segments should be NULL.</p>
<p>Each segment in the list also stores:</p>
<blockquote>
<div><ul class="simple">
<li><p>an ordered sequence of folio pointers,</p></li>
<li><p>the size of each folio and</p></li>
<li><p>three 1-bit marks per folio,</p></li>
</ul>
</div></blockquote>
<p>but hese should not be accessed directly as the underlying data structure may
change, but rather the access functions outlined below should be used.</p>
<p>The facility can be made accessible by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/folio_queue.h&gt;
</pre></div>
</div>
<p>and to use the iterator:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/uio.h&gt;
</pre></div>
</div>
</section>
<section id="initialisation">
<h2>Initialisation<a class="headerlink" href="#initialisation" title="Link to this heading">¶</a></h2>
<p>A segment should be initialised by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void folioq_init(struct folio_queue *folioq);
</pre></div>
</div>
<p>with a pointer to the segment to be initialised.  Note that this will not
necessarily initialise all the folio pointers, so care must be taken to check
the number of folios added.</p>
</section>
<section id="adding-and-removing-folios">
<h2>Adding and removing folios<a class="headerlink" href="#adding-and-removing-folios" title="Link to this heading">¶</a></h2>
<p>Folios can be set in the next unused slot in a segment struct by calling one
of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned int folioq_append(struct folio_queue *folioq,
                           struct folio *folio);

unsigned int folioq_append_mark(struct folio_queue *folioq,
                                struct folio *folio);
</pre></div>
</div>
<p>Both functions update the stored folio count, store the folio and note its
size.  The second function also sets the first mark for the folio added.  Both
functions return the number of the slot used.  [!] Note that no attempt is made
to check that the capacity wasn’t overrun and the list will not be extended
automatically.</p>
<p>A folio can be excised by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void folioq_clear(struct folio_queue *folioq, unsigned int slot);
</pre></div>
</div>
<p>This clears the slot in the array and also clears all the marks for that folio,
but doesn’t change the folio count - so future accesses of that slot must check
if the slot is occupied.</p>
</section>
<section id="querying-information-about-a-folio">
<h2>Querying information about a folio<a class="headerlink" href="#querying-information-about-a-folio" title="Link to this heading">¶</a></h2>
<p>Information about the folio in a particular slot may be queried by the
following function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct folio *folioq_folio(const struct folio_queue *folioq,
                           unsigned int slot);
</pre></div>
</div>
<p>If a folio has not yet been set in that slot, this may yield an undefined
pointer.  The size of the folio in a slot may be queried with either of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned int folioq_folio_order(const struct folio_queue *folioq,
                                unsigned int slot);

size_t folioq_folio_size(const struct folio_queue *folioq,
                         unsigned int slot);
</pre></div>
</div>
<p>The first function returns the size as an order and the second as a number of
bytes.</p>
</section>
<section id="querying-information-about-a-folio-queue">
<h2>Querying information about a folio_queue<a class="headerlink" href="#querying-information-about-a-folio-queue" title="Link to this heading">¶</a></h2>
<p>Information may be retrieved about a particular segment with the following
functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned int folioq_nr_slots(const struct folio_queue *folioq);

unsigned int folioq_count(struct folio_queue *folioq);

bool folioq_full(struct folio_queue *folioq);
</pre></div>
</div>
<p>The first function returns the maximum capacity of a segment.  It must not be
assumed that this won’t vary between segments.  The second returns the number
of folios added to a segments and the third is a shorthand to indicate if the
segment has been filled to capacity.</p>
<p>Not that the count and fullness are not affected by clearing folios from the
segment.  These are more about indicating how many slots in the array have been
initialised, and it assumed that slots won’t get reused, but rather the segment
will get discarded as the queue is consumed.</p>
</section>
<section id="folio-marks">
<h2>Folio marks<a class="headerlink" href="#folio-marks" title="Link to this heading">¶</a></h2>
<p>Folios within a queue can also have marks assigned to them.  These marks can be
used to note information such as if a folio needs <a class="reference internal" href="mm-api.html#c.folio_put" title="folio_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">folio_put()</span></code></a> calling upon it.
There are three marks available to be set for each folio.</p>
<p>The marks can be set by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void folioq_mark(struct folio_queue *folioq, unsigned int slot);
void folioq_mark2(struct folio_queue *folioq, unsigned int slot);
void folioq_mark3(struct folio_queue *folioq, unsigned int slot);
</pre></div>
</div>
<p>Cleared by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void folioq_unmark(struct folio_queue *folioq, unsigned int slot);
void folioq_unmark2(struct folio_queue *folioq, unsigned int slot);
void folioq_unmark3(struct folio_queue *folioq, unsigned int slot);
</pre></div>
</div>
<p>And the marks can be queried by:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool folioq_is_marked(const struct folio_queue *folioq, unsigned int slot);
bool folioq_is_marked2(const struct folio_queue *folioq, unsigned int slot);
bool folioq_is_marked3(const struct folio_queue *folioq, unsigned int slot);
</pre></div>
</div>
<p>The marks can be used for any purpose and are not interpreted by this API.</p>
</section>
<section id="folio-queue-iteration">
<h2>Folio queue iteration<a class="headerlink" href="#folio-queue-iteration" title="Link to this heading">¶</a></h2>
<p>A list of segments may be iterated over using the I/O iterator facility using
an <code class="docutils literal notranslate"><span class="pre">iov_iter</span></code> iterator of <code class="docutils literal notranslate"><span class="pre">ITER_FOLIOQ</span></code> type.  The iterator may be
initialised with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void iov_iter_folio_queue(struct iov_iter *i, unsigned int direction,
                          const struct folio_queue *folioq,
                          unsigned int first_slot, unsigned int offset,
                          size_t count);
</pre></div>
</div>
<p>This may be told to start at a particular segment, slot and offset within a
queue.  The iov iterator functions will follow the next pointers when advancing
and prev pointers when reverting when needed.</p>
</section>
<section id="lockless-simultaneous-production-consumption-issues">
<h2>Lockless simultaneous production/consumption issues<a class="headerlink" href="#lockless-simultaneous-production-consumption-issues" title="Link to this heading">¶</a></h2>
<p>If properly managed, the list can be extended by the producer at the head end
and shortened by the consumer at the tail end simultaneously without the need
to take locks.  The ITER_FOLIOQ iterator inserts appropriate barriers to aid
with this.</p>
<p>Care must be taken when simultaneously producing and consuming a list.  If the
last segment is reached and the folios it refers to are entirely consumed by
the IOV iterators, an iov_iter struct will be left pointing to the last segment
with a slot number equal to the capacity of that segment.  The iterator will
try to continue on from this if there’s another segment available when it is
used again, but care must be taken lest the segment got removed and freed by
the consumer before the iterator was advanced.</p>
<p>It is recommended that the queue always contain at least one segment, even if
that segment has never been filled or is entirely spent.  This prevents the
head and tail pointers from collapsing.</p>
</section>
<section id="api-function-reference">
<h2>API Function Reference<a class="headerlink" href="#api-function-reference" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">rreq_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialise a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rreq_id</span></code></dt><dd><p>The request identifier to use in tracelines.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise a folio queue segment and set an identifier to be used in traces.</p>
<p>Note that the folio pointers are left uninitialised.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_nr_slots">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_nr_slots</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_nr_slots" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query the capacity of a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Query the number of folios that a particular folio queue segment might hold.
[!] NOTE: This must not be assumed to be the same for every segment!</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_count">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_count" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query the occupancy of a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Query the number of folios that have been added to a folio queue segment.
Note that this is not decreased as folios are removed from a segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_full">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_full" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query if a folio queue segment is full</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Query if a folio queue segment is fully occupied.  Note that this does not
change if folios are removed from a segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_is_marked">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_is_marked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_is_marked" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check first folio mark in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if the first mark is set for the folio in the specified slot in a
folio queue segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_mark">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_mark</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_mark" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the first mark on a folio in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the first mark for the folio in the specified slot in a folio queue
segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_unmark">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_unmark</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_unmark" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear the first mark on a folio in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear the first mark for the folio in the specified slot in a folio queue
segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_is_marked2">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_is_marked2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_is_marked2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check second folio mark in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if the second mark is set for the folio in the specified slot in a
folio queue segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_mark2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_mark2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_mark2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the second mark on a folio in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the second mark for the folio in the specified slot in a folio queue
segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_unmark2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_unmark2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_unmark2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear the second mark on a folio in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear the second mark for the folio in the specified slot in a folio queue
segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_is_marked3">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_is_marked3</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_is_marked3" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check third folio mark in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if the third mark is set for the folio in the specified slot in a
folio queue segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_mark3">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_mark3</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_mark3" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the third mark on a folio in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the third mark for the folio in the specified slot in a folio queue
segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_unmark3">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_unmark3</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_unmark3" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear the third mark on a folio in a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The slot number of the folio to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear the third mark for the folio in the specified slot in a folio queue
segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_append">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_append</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folioq_append" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_append" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add a folio to a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to add to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a folio to the tail of the sequence in a folio queue segment, increasing
the occupancy count and returning the slot number for the folio just added.
The folio size is extracted and stored in the queue and the marks are left
unmodified.</p>
<p>Note that it’s left up to the caller to check that the segment capacity will
not be exceeded and to extend the queue.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_append_mark">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_append_mark</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.folioq_append_mark" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_append_mark" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add a folio to a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to add to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a folio to the tail of the sequence in a folio queue segment, increasing
the occupancy count and returning the slot number for the folio just added.
The folio size is extracted and stored in the queue, the first mark is set
and and the second and third marks are left unmodified.</p>
<p>Note that it’s left up to the caller to check that the segment capacity will
not be exceeded and to extend the queue.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_folio">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="mm-api.html#c.folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">folioq_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a folio from a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The folio slot to access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the folio in the specified slot from a folio queue segment.  Note
that no bounds check is made and if the slot hasn’t been added into yet, the
pointer will be undefined.  If the slot has been cleared, NULL will be
returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_folio_order">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_folio_order</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_folio_order" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the order of a folio from a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The folio slot to access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the order of the folio in the specified slot from a folio queue
segment.  Note that no bounds check is made and if the slot hasn’t been
added into yet, the order returned will be 0.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_folio_size">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_folio_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_folio_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the size of a folio from a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The folio slot to access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the size of the folio in the specified slot from a folio queue
segment.  Note that no bounds check is made and if the slot hasn’t been
added into yet, the size returned will be PAGE_SIZE.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.folioq_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folioq_clear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">folio_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folioq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">slot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.folioq_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear a folio from a folio queue segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_queue</span> <span class="pre">*folioq</span></code></dt><dd><p>The segment to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">slot</span></code></dt><dd><p>The folio slot to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear a folio from a sequence in a folio queue segment and clear its marks.
The occupancy count is left unchanged.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/folio_queue.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>