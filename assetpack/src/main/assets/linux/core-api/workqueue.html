<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Workqueue &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="General notification mechanism" href="watch_queue.html" />
    <link rel="prev" title="The Linux Kernel API" href="kernel-api.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kernel-api.html">The Linux Kernel API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Workqueue</a></li>
<li class="toctree-l3"><a class="reference internal" href="watch_queue.html">General notification mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-basics.html">Message logging with printk</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-formats.html">How to get printk format specifiers right</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-index.html">Printk Index</a></li>
<li class="toctree-l3"><a class="reference internal" href="symbol-namespaces.html">Symbol Namespaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="asm-annotations.html">Assembler Annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/workqueue.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../translations/zh_CN/core-api/workqueue.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="workqueue">
<h1>Workqueue<a class="headerlink" href="#workqueue" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Date<span class="colon">:</span></dt>
<dd class="field-odd"><p>September, 2010</p>
</dd>
<dt class="field-even">Author<span class="colon">:</span></dt>
<dd class="field-even"><p>Tejun Heo &lt;<a class="reference external" href="mailto:tj&#37;&#52;&#48;kernel&#46;org">tj<span>&#64;</span>kernel<span>&#46;</span>org</a>&gt;</p>
</dd>
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Florian Mickler &lt;<a class="reference external" href="mailto:florian&#37;&#52;&#48;mickler&#46;org">florian<span>&#64;</span>mickler<span>&#46;</span>org</a>&gt;</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>There are many cases where an asynchronous process execution context
is needed and the workqueue (wq) API is the most commonly used
mechanism for such cases.</p>
<p>When such an asynchronous execution context is needed, a work item
describing which function to execute is put on a queue.  An
independent thread serves as the asynchronous execution context.  The
queue is called workqueue and the thread is called worker.</p>
<p>While there are work items on the workqueue the worker executes the
functions associated with the work items one after the other.  When
there is no work item left on the workqueue the worker becomes idle.
When a new work item gets queued, the worker begins executing again.</p>
</section>
<section id="why-concurrency-managed-workqueue">
<h2>Why Concurrency Managed Workqueue?<a class="headerlink" href="#why-concurrency-managed-workqueue" title="Link to this heading">¶</a></h2>
<p>In the original wq implementation, a multi threaded (MT) wq had one
worker thread per CPU and a single threaded (ST) wq had one worker
thread system-wide.  A single MT wq needed to keep around the same
number of workers as the number of CPUs.  The kernel grew a lot of MT
wq users over the years and with the number of CPU cores continuously
rising, some systems saturated the default 32k PID space just booting
up.</p>
<p>Although MT wq wasted a lot of resource, the level of concurrency
provided was unsatisfactory.  The limitation was common to both ST and
MT wq albeit less severe on MT.  Each wq maintained its own separate
worker pool.  An MT wq could provide only one execution context per CPU
while an ST wq one for the whole system.  Work items had to compete for
those very limited execution contexts leading to various problems
including proneness to deadlocks around the single execution context.</p>
<p>The tension between the provided level of concurrency and resource
usage also forced its users to make unnecessary tradeoffs like libata
choosing to use ST wq for polling PIOs and accepting an unnecessary
limitation that no two polling PIOs can progress at the same time.  As
MT wq don’t provide much better concurrency, users which require
higher level of concurrency, like async or fscache, had to implement
their own thread pool.</p>
<p>Concurrency Managed Workqueue (cmwq) is a reimplementation of wq with
focus on the following goals.</p>
<ul class="simple">
<li><p>Maintain compatibility with the original workqueue API.</p></li>
<li><p>Use per-CPU unified worker pools shared by all wq to provide
flexible level of concurrency on demand without wasting a lot of
resource.</p></li>
<li><p>Automatically regulate worker pool and level of concurrency so that
the API users don’t need to worry about such details.</p></li>
</ul>
</section>
<section id="the-design">
<h2>The Design<a class="headerlink" href="#the-design" title="Link to this heading">¶</a></h2>
<p>In order to ease the asynchronous execution of functions a new
abstraction, the work item, is introduced.</p>
<p>A work item is a simple struct that holds a pointer to the function
that is to be executed asynchronously.  Whenever a driver or subsystem
wants a function to be executed asynchronously it has to set up a work
item pointing to that function and queue that work item on a
workqueue.</p>
<p>A work item can be executed in either a thread or the BH (softirq) context.</p>
<p>For threaded workqueues, special purpose threads, called [k]workers, execute
the functions off of the queue, one after the other. If no work is queued,
the worker threads become idle. These worker threads are managed in
worker-pools.</p>
<p>The cmwq design differentiates between the user-facing workqueues that
subsystems and drivers queue work items on and the backend mechanism
which manages worker-pools and processes the queued work items.</p>
<p>There are two worker-pools, one for normal work items and the other
for high priority ones, for each possible CPU and some extra
worker-pools to serve work items queued on unbound workqueues - the
number of these backing pools is dynamic.</p>
<p>BH workqueues use the same framework. However, as there can only be one
concurrent execution context, there’s no need to worry about concurrency.
Each per-CPU BH worker pool contains only one pseudo worker which represents
the BH execution context. A BH workqueue can be considered a convenience
interface to softirq.</p>
<p>Subsystems and drivers can create and queue work items through special
workqueue API functions as they see fit. They can influence some
aspects of the way the work items are executed by setting flags on the
workqueue they are putting the work item on. These flags include
things like CPU locality, concurrency limits, priority and more.  To
get a detailed overview refer to the API description of
<code class="docutils literal notranslate"><span class="pre">alloc_workqueue()</span></code> below.</p>
<p>When a work item is queued to a workqueue, the target worker-pool is
determined according to the queue parameters and workqueue attributes
and appended on the shared worklist of the worker-pool.  For example,
unless specifically overridden, a work item of a bound workqueue will
be queued on the worklist of either normal or highpri worker-pool that
is associated to the CPU the issuer is running on.</p>
<p>For any thread pool implementation, managing the concurrency level
(how many execution contexts are active) is an important issue.  cmwq
tries to keep the concurrency at a minimal but sufficient level.
Minimal to save resources and sufficient in that the system is used at
its full capacity.</p>
<p>Each worker-pool bound to an actual CPU implements concurrency
management by hooking into the scheduler.  The worker-pool is notified
whenever an active worker wakes up or sleeps and keeps track of the
number of the currently runnable workers.  Generally, work items are
not expected to hog a CPU and consume many cycles.  That means
maintaining just enough concurrency to prevent work processing from
stalling should be optimal.  As long as there are one or more runnable
workers on the CPU, the worker-pool doesn’t start execution of a new
work, but, when the last running worker goes to sleep, it immediately
schedules a new worker so that the CPU doesn’t sit idle while there
are pending work items.  This allows using a minimal number of workers
without losing execution bandwidth.</p>
<p>Keeping idle workers around doesn’t cost other than the memory space
for kthreads, so cmwq holds onto idle ones for a while before killing
them.</p>
<p>For unbound workqueues, the number of backing pools is dynamic.
Unbound workqueue can be assigned custom attributes using
<code class="docutils literal notranslate"><span class="pre">apply_workqueue_attrs()</span></code> and workqueue will automatically create
backing worker pools matching the attributes.  The responsibility of
regulating concurrency level is on the users.  There is also a flag to
mark a bound wq to ignore the concurrency management.  Please refer to
the API section for details.</p>
<p>Forward progress guarantee relies on that workers can be created when
more execution contexts are necessary, which in turn is guaranteed
through the use of rescue workers.  All work items which might be used
on code paths that handle memory reclaim are required to be queued on
wq’s that have a rescue-worker reserved for execution under memory
pressure.  Else it is possible that the worker-pool deadlocks waiting
for execution contexts to free up.</p>
</section>
<section id="application-programming-interface-api">
<h2>Application Programming Interface (API)<a class="headerlink" href="#application-programming-interface-api" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">alloc_workqueue()</span></code> allocates a wq.  The original
<code class="docutils literal notranslate"><span class="pre">create_*workqueue()</span></code> functions are deprecated and scheduled for
removal.  <code class="docutils literal notranslate"><span class="pre">alloc_workqueue()</span></code> takes three arguments - <code class="docutils literal notranslate"><span class="pre">&#64;name</span></code>,
<code class="docutils literal notranslate"><span class="pre">&#64;flags</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;max_active</span></code>.  <code class="docutils literal notranslate"><span class="pre">&#64;name</span></code> is the name of the wq and
also used as the name of the rescuer thread if there is one.</p>
<p>A wq no longer manages execution resources but serves as a domain for
forward progress guarantee, flush and work item attributes. <code class="docutils literal notranslate"><span class="pre">&#64;flags</span></code>
and <code class="docutils literal notranslate"><span class="pre">&#64;max_active</span></code> control how work items are assigned execution
resources, scheduled and executed.</p>
<section id="flags">
<h3><code class="docutils literal notranslate"><span class="pre">flags</span></code><a class="headerlink" href="#flags" title="Link to this heading">¶</a></h3>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">WQ_BH</span></code></dt><dd><p>BH workqueues can be considered a convenience interface to softirq. BH
workqueues are always per-CPU and all BH work items are executed in the
queueing CPU’s softirq context in the queueing order.</p>
<p>All BH workqueues must have 0 <code class="docutils literal notranslate"><span class="pre">max_active</span></code> and <code class="docutils literal notranslate"><span class="pre">WQ_HIGHPRI</span></code> is the
only allowed additional flag.</p>
<p>BH work items cannot sleep. All other features such as delayed queueing,
flushing and canceling are supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WQ_UNBOUND</span></code></dt><dd><p>Work items queued to an unbound wq are served by the special
worker-pools which host workers which are not bound to any
specific CPU.  This makes the wq behave as a simple execution
context provider without concurrency management.  The unbound
worker-pools try to start execution of work items as soon as
possible.  Unbound wq sacrifices locality but is useful for
the following cases.</p>
<ul class="simple">
<li><p>Wide fluctuation in the concurrency level requirement is
expected and using bound wq may end up creating large number
of mostly unused workers across different CPUs as the issuer
hops through different CPUs.</p></li>
<li><p>Long running CPU intensive workloads which can be better
managed by the system scheduler.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WQ_FREEZABLE</span></code></dt><dd><p>A freezable wq participates in the freeze phase of the system
suspend operations.  Work items on the wq are drained and no
new work item starts execution until thawed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WQ_MEM_RECLAIM</span></code></dt><dd><p>All wq which might be used in the memory reclaim paths <strong>MUST</strong>
have this flag set.  The wq is guaranteed to have at least one
execution context regardless of memory pressure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WQ_HIGHPRI</span></code></dt><dd><p>Work items of a highpri wq are queued to the highpri
worker-pool of the target cpu.  Highpri worker-pools are
served by worker threads with elevated nice level.</p>
<p>Note that normal and highpri worker-pools don’t interact with
each other.  Each maintains its separate pool of workers and
implements concurrency management among its workers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WQ_CPU_INTENSIVE</span></code></dt><dd><p>Work items of a CPU intensive wq do not contribute to the
concurrency level.  In other words, runnable CPU intensive
work items will not prevent other work items in the same
worker-pool from starting execution.  This is useful for bound
work items which are expected to hog CPU cycles so that their
execution is regulated by the system scheduler.</p>
<p>Although CPU intensive work items don’t contribute to the
concurrency level, start of their executions is still
regulated by the concurrency management and runnable
non-CPU-intensive work items can delay execution of CPU
intensive work items.</p>
<p>This flag is meaningless for unbound wq.</p>
</dd>
</dl>
</section>
<section id="max-active">
<h3><code class="docutils literal notranslate"><span class="pre">max_active</span></code><a class="headerlink" href="#max-active" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">&#64;max_active</span></code> determines the maximum number of execution contexts per
CPU which can be assigned to the work items of a wq. For example, with
<code class="docutils literal notranslate"><span class="pre">&#64;max_active</span></code> of 16, at most 16 work items of the wq can be executing
at the same time per CPU. This is always a per-CPU attribute, even for
unbound workqueues.</p>
<p>The maximum limit for <code class="docutils literal notranslate"><span class="pre">&#64;max_active</span></code> is 2048 and the default value used
when 0 is specified is 1024. These values are chosen sufficiently high
such that they are not the limiting factor while providing protection in
runaway cases.</p>
<p>The number of active work items of a wq is usually regulated by the
users of the wq, more specifically, by how many work items the users
may queue at the same time.  Unless there is a specific need for
throttling the number of active work items, specifying ‘0’ is
recommended.</p>
<p>Some users depend on strict execution ordering where only one work item
is in flight at any given time and the work items are processed in
queueing order. While the combination of <code class="docutils literal notranslate"><span class="pre">&#64;max_active</span></code> of 1 and
<code class="docutils literal notranslate"><span class="pre">WQ_UNBOUND</span></code> used to achieve this behavior, this is no longer the
case. Use <a class="reference internal" href="#c.alloc_ordered_workqueue" title="alloc_ordered_workqueue"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_ordered_workqueue()</span></code></a> instead.</p>
</section>
</section>
<section id="example-execution-scenarios">
<h2>Example Execution Scenarios<a class="headerlink" href="#example-execution-scenarios" title="Link to this heading">¶</a></h2>
<p>The following example execution scenarios try to illustrate how cmwq
behave under different configurations.</p>
<blockquote>
<div><p>Work items w0, w1, w2 are queued to a bound wq q0 on the same CPU.
w0 burns CPU for 5ms then sleeps for 10ms then burns CPU for 5ms
again before finishing.  w1 and w2 burn CPU for 5ms then sleep for
10ms.</p>
</div></blockquote>
<p>Ignoring all other tasks, works and processing overhead, and assuming
simple FIFO scheduling, the following is one highly simplified version
of possible sequences of events with the original wq.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TIME IN MSECS  EVENT
0              w0 starts and burns CPU
5              w0 sleeps
15             w0 wakes up and burns CPU
20             w0 finishes
20             w1 starts and burns CPU
25             w1 sleeps
35             w1 wakes up and finishes
35             w2 starts and burns CPU
40             w2 sleeps
50             w2 wakes up and finishes
</pre></div>
</div>
<p>And with cmwq with <code class="docutils literal notranslate"><span class="pre">&#64;max_active</span></code> &gt;= 3,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TIME IN MSECS  EVENT
0              w0 starts and burns CPU
5              w0 sleeps
5              w1 starts and burns CPU
10             w1 sleeps
10             w2 starts and burns CPU
15             w2 sleeps
15             w0 wakes up and burns CPU
20             w0 finishes
20             w1 wakes up and finishes
25             w2 wakes up and finishes
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">&#64;max_active</span></code> == 2,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TIME IN MSECS  EVENT
0              w0 starts and burns CPU
5              w0 sleeps
5              w1 starts and burns CPU
10             w1 sleeps
15             w0 wakes up and burns CPU
20             w0 finishes
20             w1 wakes up and finishes
20             w2 starts and burns CPU
25             w2 sleeps
35             w2 wakes up and finishes
</pre></div>
</div>
<p>Now, let’s assume w1 and w2 are queued to a different wq q1 which has
<code class="docutils literal notranslate"><span class="pre">WQ_CPU_INTENSIVE</span></code> set,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TIME IN MSECS  EVENT
0              w0 starts and burns CPU
5              w0 sleeps
5              w1 and w2 start and burn CPU
10             w1 sleeps
15             w2 sleeps
15             w0 wakes up and burns CPU
20             w0 finishes
20             w1 wakes up and finishes
25             w2 wakes up and finishes
</pre></div>
</div>
</section>
<section id="guidelines">
<h2>Guidelines<a class="headerlink" href="#guidelines" title="Link to this heading">¶</a></h2>
<ul>
<li><p>Do not forget to use <code class="docutils literal notranslate"><span class="pre">WQ_MEM_RECLAIM</span></code> if a wq may process work
items which are used during memory reclaim.  Each wq with
<code class="docutils literal notranslate"><span class="pre">WQ_MEM_RECLAIM</span></code> set has an execution context reserved for it.  If
there is dependency among multiple work items used during memory
reclaim, they should be queued to separate wq each with
<code class="docutils literal notranslate"><span class="pre">WQ_MEM_RECLAIM</span></code>.</p></li>
<li><p>Unless strict ordering is required, there is no need to use ST wq.</p></li>
<li><p>Unless there is a specific need, using 0 for &#64;max_active is
recommended.  In most use cases, concurrency level usually stays
well under the default limit.</p></li>
<li><p>A wq serves as a domain for forward progress guarantee
(<code class="docutils literal notranslate"><span class="pre">WQ_MEM_RECLAIM</span></code>, flush and work item attributes.  Work items
which are not involved in memory reclaim and don’t need to be
flushed as a part of a group of work items, and don’t require any
special attribute, can use one of the system wq.  There is no
difference in execution characteristics between using a dedicated wq
and a system wq.</p>
<p>Note: If something may generate more than &#64;max_active outstanding
work items (do stress test your producers), it may saturate a system
wq and potentially lead to deadlock. It should utilize its own
dedicated workqueue rather than the system wq.</p>
</li>
<li><p>Unless work items are expected to consume a huge amount of CPU
cycles, using a bound wq is usually beneficial due to the increased
level of locality in wq operations and work item execution.</p></li>
</ul>
</section>
<section id="affinity-scopes">
<h2>Affinity Scopes<a class="headerlink" href="#affinity-scopes" title="Link to this heading">¶</a></h2>
<p>An unbound workqueue groups CPUs according to its affinity scope to improve
cache locality. For example, if a workqueue is using the default affinity
scope of “cache”, it will group CPUs according to last level cache
boundaries. A work item queued on the workqueue will be assigned to a worker
on one of the CPUs which share the last level cache with the issuing CPU.
Once started, the worker may or may not be allowed to move outside the scope
depending on the <code class="docutils literal notranslate"><span class="pre">affinity_strict</span></code> setting of the scope.</p>
<p>Workqueue currently supports the following affinity scopes.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">default</span></code></dt><dd><p>Use the scope in module parameter <code class="docutils literal notranslate"><span class="pre">workqueue.default_affinity_scope</span></code>
which is always set to one of the scopes below.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu</span></code></dt><dd><p>CPUs are not grouped. A work item issued on one CPU is processed by a
worker on the same CPU. This makes unbound workqueues behave as per-cpu
workqueues without concurrency management.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">smt</span></code></dt><dd><p>CPUs are grouped according to SMT boundaries. This usually means that the
logical threads of each physical CPU core are grouped together.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache</span></code></dt><dd><p>CPUs are grouped according to cache boundaries. Which specific cache
boundary is used is determined by the arch code. L3 is used in a lot of
cases. This is the default affinity scope.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">numa</span></code></dt><dd><p>CPUs are grouped according to NUMA boundaries.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">system</span></code></dt><dd><p>All CPUs are put in the same group. Workqueue makes no effort to process a
work item on a CPU close to the issuing CPU.</p>
</dd>
</dl>
<p>The default affinity scope can be changed with the module parameter
<code class="docutils literal notranslate"><span class="pre">workqueue.default_affinity_scope</span></code> and a specific workqueue’s affinity
scope can be changed using <code class="docutils literal notranslate"><span class="pre">apply_workqueue_attrs()</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">WQ_SYSFS</span></code> is set, the workqueue will have the following affinity scope
related interface files under its <code class="docutils literal notranslate"><span class="pre">/sys/devices/virtual/workqueue/WQ_NAME/</span></code>
directory.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">affinity_scope</span></code></dt><dd><p>Read to see the current affinity scope. Write to change.</p>
<p>When default is the current scope, reading this file will also show the
current effective scope in parentheses, for example, <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">(cache)</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">affinity_strict</span></code></dt><dd><p>0 by default indicating that affinity scopes are not strict. When a work
item starts execution, workqueue makes a best-effort attempt to ensure
that the worker is inside its affinity scope, which is called
repatriation. Once started, the scheduler is free to move the worker
anywhere in the system as it sees fit. This enables benefiting from scope
locality while still being able to utilize other CPUs if necessary and
available.</p>
<p>If set to 1, all workers of the scope are guaranteed always to be in the
scope. This may be useful when crossing affinity scopes has other
implications, for example, in terms of power consumption or workload
isolation. Strict NUMA scope can also be used to match the workqueue
behavior of older kernels.</p>
</dd>
</dl>
</section>
<section id="affinity-scopes-and-performance">
<h2>Affinity Scopes and Performance<a class="headerlink" href="#affinity-scopes-and-performance" title="Link to this heading">¶</a></h2>
<p>It’d be ideal if an unbound workqueue’s behavior is optimal for vast
majority of use cases without further tuning. Unfortunately, in the current
kernel, there exists a pronounced trade-off between locality and utilization
necessitating explicit configurations when workqueues are heavily used.</p>
<p>Higher locality leads to higher efficiency where more work is performed for
the same number of consumed CPU cycles. However, higher locality may also
cause lower overall system utilization if the work items are not spread
enough across the affinity scopes by the issuers. The following performance
testing with dm-crypt clearly illustrates this trade-off.</p>
<p>The tests are run on a CPU with 12-cores/24-threads split across four L3
caches (AMD Ryzen 9 3900x). CPU clock boost is turned off for consistency.
<code class="docutils literal notranslate"><span class="pre">/dev/dm-0</span></code> is a dm-crypt device created on NVME SSD (Samsung 990 PRO) and
opened with <code class="docutils literal notranslate"><span class="pre">cryptsetup</span></code> with default settings.</p>
<section id="scenario-1-enough-issuers-and-work-spread-across-the-machine">
<h3>Scenario 1: Enough issuers and work spread across the machine<a class="headerlink" href="#scenario-1-enough-issuers-and-work-spread-across-the-machine" title="Link to this heading">¶</a></h3>
<p>The command used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ fio --filename=/dev/dm-0 --direct=1 --rw=randrw --bs=32k --ioengine=libaio \
  --iodepth=64 --runtime=60 --numjobs=24 --time_based --group_reporting \
  --name=iops-test-job --verify=sha512
</pre></div>
</div>
<p>There are 24 issuers, each issuing 64 IOs concurrently. <code class="docutils literal notranslate"><span class="pre">--verify=sha512</span></code>
makes <code class="docutils literal notranslate"><span class="pre">fio</span></code> generate and read back the content each time which makes
execution locality matter between the issuer and <code class="docutils literal notranslate"><span class="pre">kcryptd</span></code>. The following
are the read bandwidths and CPU utilizations depending on different affinity
scope settings on <code class="docutils literal notranslate"><span class="pre">kcryptd</span></code> measured over five runs. Bandwidths are in
MiBps, and CPU util in percents.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28.6%" />
<col style="width: 35.7%" />
<col style="width: 35.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Affinity</p></th>
<th class="head"><p>Bandwidth (MiBps)</p></th>
<th class="head"><p>CPU util (%)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>system</p></td>
<td><p>1159.40 ±1.34</p></td>
<td><p>99.31 ±0.02</p></td>
</tr>
<tr class="row-odd"><td><p>cache</p></td>
<td><p>1166.40 ±0.89</p></td>
<td><p>99.34 ±0.01</p></td>
</tr>
<tr class="row-even"><td><p>cache (strict)</p></td>
<td><p>1166.00 ±0.71</p></td>
<td><p>99.35 ±0.01</p></td>
</tr>
</tbody>
</table>
<p>With enough issuers spread across the system, there is no downside to
“cache”, strict or otherwise. All three configurations saturate the whole
machine but the cache-affine ones outperform by 0.6% thanks to improved
locality.</p>
</section>
<section id="scenario-2-fewer-issuers-enough-work-for-saturation">
<h3>Scenario 2: Fewer issuers, enough work for saturation<a class="headerlink" href="#scenario-2-fewer-issuers-enough-work-for-saturation" title="Link to this heading">¶</a></h3>
<p>The command used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ fio --filename=/dev/dm-0 --direct=1 --rw=randrw --bs=32k \
  --ioengine=libaio --iodepth=64 --runtime=60 --numjobs=8 \
  --time_based --group_reporting --name=iops-test-job --verify=sha512
</pre></div>
</div>
<p>The only difference from the previous scenario is <code class="docutils literal notranslate"><span class="pre">--numjobs=8</span></code>. There are
a third of the issuers but is still enough total work to saturate the
system.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28.6%" />
<col style="width: 35.7%" />
<col style="width: 35.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Affinity</p></th>
<th class="head"><p>Bandwidth (MiBps)</p></th>
<th class="head"><p>CPU util (%)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>system</p></td>
<td><p>1155.40 ±0.89</p></td>
<td><p>97.41 ±0.05</p></td>
</tr>
<tr class="row-odd"><td><p>cache</p></td>
<td><p>1154.40 ±1.14</p></td>
<td><p>96.15 ±0.09</p></td>
</tr>
<tr class="row-even"><td><p>cache (strict)</p></td>
<td><p>1112.00 ±4.64</p></td>
<td><p>93.26 ±0.35</p></td>
</tr>
</tbody>
</table>
<p>This is more than enough work to saturate the system. Both “system” and
“cache” are nearly saturating the machine but not fully. “cache” is using
less CPU but the better efficiency puts it at the same bandwidth as
“system”.</p>
<p>Eight issuers moving around over four L3 cache scope still allow “cache
(strict)” to mostly saturate the machine but the loss of work conservation
is now starting to hurt with 3.7% bandwidth loss.</p>
</section>
<section id="scenario-3-even-fewer-issuers-not-enough-work-to-saturate">
<h3>Scenario 3: Even fewer issuers, not enough work to saturate<a class="headerlink" href="#scenario-3-even-fewer-issuers-not-enough-work-to-saturate" title="Link to this heading">¶</a></h3>
<p>The command used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ fio --filename=/dev/dm-0 --direct=1 --rw=randrw --bs=32k \
  --ioengine=libaio --iodepth=64 --runtime=60 --numjobs=4 \
  --time_based --group_reporting --name=iops-test-job --verify=sha512
</pre></div>
</div>
<p>Again, the only difference is <code class="docutils literal notranslate"><span class="pre">--numjobs=4</span></code>. With the number of issuers
reduced to four, there now isn’t enough work to saturate the whole system
and the bandwidth becomes dependent on completion latencies.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28.6%" />
<col style="width: 35.7%" />
<col style="width: 35.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Affinity</p></th>
<th class="head"><p>Bandwidth (MiBps)</p></th>
<th class="head"><p>CPU util (%)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>system</p></td>
<td><p>993.60 ±1.82</p></td>
<td><p>75.49 ±0.06</p></td>
</tr>
<tr class="row-odd"><td><p>cache</p></td>
<td><p>973.40 ±1.52</p></td>
<td><p>74.90 ±0.07</p></td>
</tr>
<tr class="row-even"><td><p>cache (strict)</p></td>
<td><p>828.20 ±4.49</p></td>
<td><p>66.84 ±0.29</p></td>
</tr>
</tbody>
</table>
<p>Now, the tradeoff between locality and utilization is clearer. “cache” shows
2% bandwidth loss compared to “system” and “cache (struct)” whopping 20%.</p>
</section>
<section id="conclusion-and-recommendations">
<h3>Conclusion and Recommendations<a class="headerlink" href="#conclusion-and-recommendations" title="Link to this heading">¶</a></h3>
<p>In the above experiments, the efficiency advantage of the “cache” affinity
scope over “system” is, while consistent and noticeable, small. However, the
impact is dependent on the distances between the scopes and may be more
pronounced in processors with more complex topologies.</p>
<p>While the loss of work-conservation in certain scenarios hurts, it is a lot
better than “cache (strict)” and maximizing workqueue utilization is
unlikely to be the common case anyway. As such, “cache” is the default
affinity scope for unbound pools.</p>
<ul class="simple">
<li><p>As there is no one option which is great for most cases, workqueue usages
that may consume a significant amount of CPU are recommended to configure
the workqueues using <code class="docutils literal notranslate"><span class="pre">apply_workqueue_attrs()</span></code> and/or enable
<code class="docutils literal notranslate"><span class="pre">WQ_SYSFS</span></code>.</p></li>
<li><p>An unbound workqueue with strict “cpu” affinity scope behaves the same as
<code class="docutils literal notranslate"><span class="pre">WQ_CPU_INTENSIVE</span></code> per-cpu workqueue. There is no real advanage to the
latter and an unbound workqueue provides a lot more flexibility.</p></li>
<li><p>Affinity scopes are introduced in Linux v6.5. To emulate the previous
behavior, use strict “numa” affinity scope.</p></li>
<li><p>The loss of work-conservation in non-strict affinity scopes is likely
originating from the scheduler. There is no theoretical reason why the
kernel wouldn’t be able to do the right thing and maintain
work-conservation in most cases. As such, it is possible that future
scheduler improvements may make most of these tunables unnecessary.</p></li>
</ul>
</section>
</section>
<section id="examining-configuration">
<h2>Examining Configuration<a class="headerlink" href="#examining-configuration" title="Link to this heading">¶</a></h2>
<p>Use tools/workqueue/wq_dump.py to examine unbound CPU affinity
configuration, worker pools and how workqueues map to the pools:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ tools/workqueue/wq_dump.py
Affinity Scopes
===============
wq_unbound_cpumask=0000000f

CPU
  nr_pods  4
  pod_cpus [0]=00000001 [1]=00000002 [2]=00000004 [3]=00000008
  pod_node [0]=0 [1]=0 [2]=1 [3]=1
  cpu_pod  [0]=0 [1]=1 [2]=2 [3]=3

SMT
  nr_pods  4
  pod_cpus [0]=00000001 [1]=00000002 [2]=00000004 [3]=00000008
  pod_node [0]=0 [1]=0 [2]=1 [3]=1
  cpu_pod  [0]=0 [1]=1 [2]=2 [3]=3

CACHE (default)
  nr_pods  2
  pod_cpus [0]=00000003 [1]=0000000c
  pod_node [0]=0 [1]=1
  cpu_pod  [0]=0 [1]=0 [2]=1 [3]=1

NUMA
  nr_pods  2
  pod_cpus [0]=00000003 [1]=0000000c
  pod_node [0]=0 [1]=1
  cpu_pod  [0]=0 [1]=0 [2]=1 [3]=1

SYSTEM
  nr_pods  1
  pod_cpus [0]=0000000f
  pod_node [0]=-1
  cpu_pod  [0]=0 [1]=0 [2]=0 [3]=0

Worker Pools
============
pool[00] ref= 1 nice=  0 idle/workers=  4/  4 cpu=  0
pool[01] ref= 1 nice=-20 idle/workers=  2/  2 cpu=  0
pool[02] ref= 1 nice=  0 idle/workers=  4/  4 cpu=  1
pool[03] ref= 1 nice=-20 idle/workers=  2/  2 cpu=  1
pool[04] ref= 1 nice=  0 idle/workers=  4/  4 cpu=  2
pool[05] ref= 1 nice=-20 idle/workers=  2/  2 cpu=  2
pool[06] ref= 1 nice=  0 idle/workers=  3/  3 cpu=  3
pool[07] ref= 1 nice=-20 idle/workers=  2/  2 cpu=  3
pool[08] ref=42 nice=  0 idle/workers=  6/  6 cpus=0000000f
pool[09] ref=28 nice=  0 idle/workers=  3/  3 cpus=00000003
pool[10] ref=28 nice=  0 idle/workers= 17/ 17 cpus=0000000c
pool[11] ref= 1 nice=-20 idle/workers=  1/  1 cpus=0000000f
pool[12] ref= 2 nice=-20 idle/workers=  1/  1 cpus=00000003
pool[13] ref= 2 nice=-20 idle/workers=  1/  1 cpus=0000000c

Workqueue CPU -&gt; pool
=====================
[    workqueue \ CPU              0  1  2  3 dfl]
events                   percpu   0  2  4  6
events_highpri           percpu   1  3  5  7
events_long              percpu   0  2  4  6
events_unbound           unbound  9  9 10 10  8
events_freezable         percpu   0  2  4  6
events_power_efficient   percpu   0  2  4  6
events_freezable_pwr_ef  percpu   0  2  4  6
rcu_gp                   percpu   0  2  4  6
rcu_par_gp               percpu   0  2  4  6
slub_flushwq             percpu   0  2  4  6
netns                    ordered  8  8  8  8  8
...
</pre></div>
</div>
<p>See the command’s help message for more info.</p>
</section>
<section id="monitoring">
<h2>Monitoring<a class="headerlink" href="#monitoring" title="Link to this heading">¶</a></h2>
<p>Use tools/workqueue/wq_monitor.py to monitor workqueue operations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ tools/workqueue/wq_monitor.py events
                            total  infl  CPUtime  CPUhog CMW/RPR  mayday rescued
events                      18545     0      6.1       0       5       -       -
events_highpri                  8     0      0.0       0       0       -       -
events_long                     3     0      0.0       0       0       -       -
events_unbound              38306     0      0.1       -       7       -       -
events_freezable                0     0      0.0       0       0       -       -
events_power_efficient      29598     0      0.2       0       0       -       -
events_freezable_pwr_ef        10     0      0.0       0       0       -       -
sock_diag_events                0     0      0.0       0       0       -       -

                            total  infl  CPUtime  CPUhog CMW/RPR  mayday rescued
events                      18548     0      6.1       0       5       -       -
events_highpri                  8     0      0.0       0       0       -       -
events_long                     3     0      0.0       0       0       -       -
events_unbound              38322     0      0.1       -       7       -       -
events_freezable                0     0      0.0       0       0       -       -
events_power_efficient      29603     0      0.2       0       0       -       -
events_freezable_pwr_ef        10     0      0.0       0       0       -       -
sock_diag_events                0     0      0.0       0       0       -       -

...
</pre></div>
</div>
<p>See the command’s help message for more info.</p>
</section>
<section id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="Link to this heading">¶</a></h2>
<p>Because the work functions are executed by generic worker threads
there are a few tricks needed to shed some light on misbehaving
workqueue users.</p>
<p>Worker threads show up in the process list as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>root      5671  0.0  0.0      0     0 ?        S    12:07   0:00 [kworker/0:1]
root      5672  0.0  0.0      0     0 ?        S    12:07   0:00 [kworker/1:2]
root      5673  0.0  0.0      0     0 ?        S    12:12   0:00 [kworker/0:0]
root      5674  0.0  0.0      0     0 ?        S    12:13   0:00 [kworker/1:0]
</pre></div>
</div>
<p>If kworkers are going crazy (using too much cpu), there are two types
of possible problems:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Something being scheduled in rapid succession</p></li>
<li><p>A single work item that consumes lots of cpu cycles</p></li>
</ol>
</div></blockquote>
<p>The first one can be tracked using tracing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo workqueue:workqueue_queue_work &gt; /sys/kernel/tracing/set_event
$ cat /sys/kernel/tracing/trace_pipe &gt; out.txt
(wait a few secs)
^C
</pre></div>
</div>
<p>If something is busy looping on work queueing, it would be dominating
the output and the offender can be determined with the work item
function.</p>
<p>For the second type of problems it should be possible to just check
the stack trace of the offending worker thread.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /proc/THE_OFFENDING_KWORKER/stack
</pre></div>
</div>
<p>The work item’s function should be trivially visible in the stack
trace.</p>
</section>
<section id="non-reentrance-conditions">
<h2>Non-reentrance Conditions<a class="headerlink" href="#non-reentrance-conditions" title="Link to this heading">¶</a></h2>
<p>Workqueue guarantees that a work item cannot be re-entrant if the following
conditions hold after a work item gets queued:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The work function hasn’t been changed.</p></li>
<li><p>No one queues the work item to another workqueue.</p></li>
<li><p>The work item hasn’t been reinitiated.</p></li>
</ol>
</div></blockquote>
<p>In other words, if the above conditions hold, the work item is guaranteed to be
executed by at most one worker system-wide at any given time.</p>
<p>Note that requeuing the work item (to the same queue) in the self function
doesn’t break these conditions, so it’s safe to do. Otherwise, caution is
required when breaking the conditions inside a work function.</p>
</section>
<section id="kernel-inline-documentations-reference">
<h2>Kernel Inline Documentations Reference<a class="headerlink" href="#kernel-inline-documentations-reference" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.workqueue_attrs">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_attrs</span></span></span><a class="headerlink" href="#c.workqueue_attrs" title="Link to this definition">¶</a><br /></dt>
<dd><p>A struct for workqueue attributes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct workqueue_attrs {
    int nice;
    cpumask_var_t cpumask;
    cpumask_var_t __pod_cpumask;
    bool affn_strict;
    enum wq_affn_scope affn_scope;
    bool ordered;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">nice</span></code></dt><dd><p>nice level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpumask</span></code></dt><dd><p>allowed CPUs</p>
<p>Work items in this workqueue are affine to these CPUs and not allowed
to execute on other CPUs. A pool serving a workqueue must have the
same <strong>cpumask</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__pod_cpumask</span></code></dt><dd><p>internal attribute used to create per-pod pools</p>
<p>Internal use only.</p>
<p>Per-pod unbound worker pools are used to improve locality. Always a
subset of -&gt;cpumask. A workqueue can be associated with multiple
worker pools with disjoint <strong>__pod_cpumask</strong>’s. Whether the enforcement
of a pool’s <strong>__pod_cpumask</strong> is strict depends on <strong>affn_strict</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">affn_strict</span></code></dt><dd><p>affinity scope is strict</p>
<p>If clear, workqueue will make a best-effort attempt at starting the
worker inside <strong>__pod_cpumask</strong> but the scheduler is free to migrate it
outside.</p>
<p>If set, workers are only allowed to run inside <strong>__pod_cpumask</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">affn_scope</span></code></dt><dd><p>unbound CPU affinity scope</p>
<p>CPU pods are used to improve execution locality of unbound work
items. There are multiple pod types, one for each wq_affn_scope, and
every CPU in the system belongs to one pod in every pod type. CPUs
that belong to the same pod share the worker pool. For example,
selecting <code class="docutils literal notranslate"><span class="pre">WQ_AFFN_NUMA</span></code> makes the workqueue use a separate worker
pool for each NUMA node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ordered</span></code></dt><dd><p>work items must be executed one by one in queueing order</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This can be used to change attributes of an unbound workqueue.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.work_pending">
<span class="sig-name descname"><span class="n"><span class="pre">work_pending</span></span></span><a class="headerlink" href="#c.work_pending" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">work_pending</span> <span class="pre">(work)</span></code></p>
<blockquote>
<div><p>Find out whether a work item is currently pending</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>The work item in question</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.delayed_work_pending">
<span class="sig-name descname"><span class="n"><span class="pre">delayed_work_pending</span></span></span><a class="headerlink" href="#c.delayed_work_pending" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">delayed_work_pending</span> <span class="pre">(w)</span></code></p>
<blockquote>
<div><p>Find out whether a delayable work item is currently pending</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">w</span></code></dt><dd><p>The work item in question</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_workqueue">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_workqueue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_active</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_workqueue" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>printf format for the name of the workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>WQ_* flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_active</span></code></dt><dd><p>max in-flight work items, 0 for default</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>args for <strong>fmt</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a per-cpu workqueue, <strong>max_active</strong> limits the number of in-flight work
items for each CPU. e.g. <strong>max_active</strong> of 1 indicates that each CPU can be
executing at most one work item for the workqueue.</p>
<p>For unbound workqueues, <strong>max_active</strong> limits the number of in-flight work items
for the whole system. e.g. <strong>max_active</strong> of 16 indicates that there can be
at most 16 work items executing for the workqueue in the whole system.</p>
<p>As sharing the same active counter for an unbound workqueue across multiple
NUMA nodes can be expensive, <strong>max_active</strong> is distributed to each NUMA node
according to the proportion of the number of online CPUs and enforced
independently.</p>
<p>Depending on online CPU distribution, a node may end up with per-node
max_active which is significantly lower than <strong>max_active</strong>, which can lead to
deadlocks if the per-node concurrency limit is lower than the maximum number
of interdependent work items for the workqueue.</p>
<p>To guarantee forward progress regardless of online CPU distribution, the
concurrency limit on every node is guaranteed to be equal to or greater than
min_active which is set to min(<strong>max_active</strong>, <code class="docutils literal notranslate"><span class="pre">WQ_DFL_MIN_ACTIVE</span></code>). This means
that the sum of per-node max_active’s may be larger than <strong>max_active</strong>.</p>
<p>For detailed information on <code class="docutils literal notranslate"><span class="pre">WQ_*</span></code> flags, please refer to
<a class="reference internal" href="#"><span class="doc">Workqueue</span></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to the allocated workqueue on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_workqueue_lockdep_map">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_workqueue_lockdep_map</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_active</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.alloc_workqueue_lockdep_map" title="lockdep_map"><span class="n"><span class="pre">lockdep_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lockdep_map</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_workqueue_lockdep_map" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a workqueue with user-defined lockdep_map</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>printf format for the name of the workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>WQ_* flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_active</span></code></dt><dd><p>max in-flight work items, 0 for default</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lockdep_map</span> <span class="pre">*lockdep_map</span></code></dt><dd><p>user-defined lockdep_map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>args for <strong>fmt</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as alloc_workqueue but with the a user-define lockdep_map. Useful for
workqueues created with the same purpose and to avoid leaking a lockdep_map
on each workqueue creation.</p>
<p><strong>Return</strong></p>
<p>Pointer to the allocated workqueue on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.alloc_ordered_workqueue_lockdep_map">
<span class="sig-name descname"><span class="n"><span class="pre">alloc_ordered_workqueue_lockdep_map</span></span></span><a class="headerlink" href="#c.alloc_ordered_workqueue_lockdep_map" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">alloc_ordered_workqueue_lockdep_map</span> <span class="pre">(fmt,</span> <span class="pre">flags,</span> <span class="pre">lockdep_map,</span> <span class="pre">args...)</span></code></p>
<blockquote>
<div><p>allocate an ordered workqueue with user-defined lockdep_map</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>printf format for the name of the workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>WQ_* flags (only WQ_FREEZABLE and WQ_MEM_RECLAIM are meaningful)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lockdep_map</span></code></dt><dd><p>user-defined lockdep_map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args...</span></code></dt><dd><p>args for <strong>fmt</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as alloc_ordered_workqueue but with the a user-define lockdep_map.
Useful for workqueues created with the same purpose and to avoid leaking a
lockdep_map on each workqueue creation.</p>
<p><strong>Return</strong></p>
<p>Pointer to the allocated workqueue on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.alloc_ordered_workqueue">
<span class="sig-name descname"><span class="n"><span class="pre">alloc_ordered_workqueue</span></span></span><a class="headerlink" href="#c.alloc_ordered_workqueue" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">alloc_ordered_workqueue</span> <span class="pre">(fmt,</span> <span class="pre">flags,</span> <span class="pre">args...)</span></code></p>
<blockquote>
<div><p>allocate an ordered workqueue</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>printf format for the name of the workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>WQ_* flags (only WQ_FREEZABLE and WQ_MEM_RECLAIM are meaningful)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args...</span></code></dt><dd><p>args for <strong>fmt</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ordered workqueue.  An ordered workqueue executes at
most one work item at any given time in the queued order.  They are
implemented as unbound workqueues with <strong>max_active</strong> of one.</p>
<p><strong>Return</strong></p>
<p>Pointer to the allocated workqueue on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.queue_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">queue_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue work on a workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>work</strong> was already on a queue, <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
<p>We queue the work to the CPU on which it was submitted, but if the CPU dies
it can be processed by another CPU.</p>
<p>Memory-ordering properties:  If it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>, guarantees that all stores
preceding the call to <a class="reference internal" href="#c.queue_work" title="queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_work()</span></code></a> in the program order will be visible from
the CPU which will execute <strong>work</strong> by the time such work executes, e.g.,</p>
<p>{ x is initially 0 }</p>
<blockquote>
<div><p>CPU0                               CPU1</p>
<p>WRITE_ONCE(x, 1);                  [ <strong>work</strong> is being executed ]
r0 = queue_work(wq, work);           r1 = READ_ONCE(x);</p>
</div></blockquote>
<p>Forbids: r0 == true &amp;&amp; r1 == 0</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.queue_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">queue_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue work on a workqueue after delay</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>delayable work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queueing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Equivalent to <a class="reference internal" href="#c.queue_delayed_work_on" title="queue_delayed_work_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_delayed_work_on()</span></code></a> but tries to use the local CPU.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mod_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mod_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>modify delay of or queue a delayed work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queueing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mod_delayed_work_on" title="mod_delayed_work_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_delayed_work_on()</span></code></a> on local CPU.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.schedule_work_on">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">schedule_work_on</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_work_on" title="Link to this definition">¶</a><br /></dt>
<dd><p>put work task on a specific cpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>cpu to put the work task on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>job to be done</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This puts a job on a specific cpu</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.schedule_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">schedule_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>put work task in global workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>job to be done</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>work</strong> was already on the kernel-global workqueue and
<code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
<p>This puts a job in the kernel-global workqueue if it was not already
queued and leaves it in the same position on the kernel-global
workqueue otherwise.</p>
<p>Shares the same memory-ordering properties of <a class="reference internal" href="#c.queue_work" title="queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_work()</span></code></a>, cf. the
DocBook header of <a class="reference internal" href="#c.queue_work" title="queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_work()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.enable_and_queue_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">enable_and_queue_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_and_queue_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Enable and queue a work item on a specific workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>The target workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>The work item to be enabled and queued</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function combines the operations of <a class="reference internal" href="#c.enable_work" title="enable_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">enable_work()</span></code></a> and <a class="reference internal" href="#c.queue_work" title="queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_work()</span></code></a>,
providing a convenient way to enable and queue a work item in a single call.
It invokes <a class="reference internal" href="#c.enable_work" title="enable_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">enable_work()</span></code></a> on <strong>work</strong> and then queues it if the disable depth
reached 0. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the disable depth reached 0 and <strong>work</strong> is queued,
and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<p>Note that <strong>work</strong> is always queued when disable depth reaches zero. If the
desired behavior is queueing only if certain events took place while <strong>work</strong> is
disabled, the user should implement the necessary state tracking and perform
explicit conditional queueing after <a class="reference internal" href="#c.enable_work" title="enable_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">enable_work()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.schedule_delayed_work_on">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">schedule_delayed_work_on</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_delayed_work_on" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue work in global workqueue on CPU after delay</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>cpu to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>job to be done</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After waiting for a given time this puts a job in the kernel-global
workqueue on the specified CPU.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.schedule_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">schedule_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>put work task in global workqueue after delay</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>job to be done</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait or 0 for immediate execution</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After waiting for a given time this puts a job in the kernel-global
workqueue.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_pool">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_pool</span></span></span><a class="headerlink" href="#c.for_each_pool" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_pool</span> <span class="pre">(pool,</span> <span class="pre">pi)</span></code></p>
<blockquote>
<div><p>iterate through all worker_pools in the system</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pool</span></code></dt><dd><p>iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pi</span></code></dt><dd><p>integer used for iteration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called either with wq_pool_mutex held or RCU read
locked.  If the pool needs to be used beyond the locking in effect, the
caller is responsible for guaranteeing that the pool stays online.</p>
<p>The if/else clause exists only for the lockdep assertion and can be
ignored.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_pool_worker">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_pool_worker</span></span></span><a class="headerlink" href="#c.for_each_pool_worker" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_pool_worker</span> <span class="pre">(worker,</span> <span class="pre">pool)</span></code></p>
<blockquote>
<div><p>iterate through all workers of a worker_pool</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">worker</span></code></dt><dd><p>iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pool</span></code></dt><dd><p>worker_pool to iterate workers of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called with wq_pool_attach_mutex.</p>
<p>The if/else clause exists only for the lockdep assertion and can be
ignored.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_pwq">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_pwq</span></span></span><a class="headerlink" href="#c.for_each_pwq" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_pwq</span> <span class="pre">(pwq,</span> <span class="pre">wq)</span></code></p>
<blockquote>
<div><p>iterate through all pool_workqueues of the specified workqueue</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pwq</span></code></dt><dd><p>iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the target workqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called either with wq-&gt;mutex held or RCU read locked.
If the pwq needs to be used beyond the locking in effect, the caller is
responsible for guaranteeing that the pwq stays online.</p>
<p>The if/else clause exists only for the lockdep assertion and can be
ignored.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.worker_pool_assign_id">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker_pool_assign_id</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.worker_pool_assign_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate ID and assign it to <strong>pool</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the pool pointer of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if ID in [0, WORK_OFFQ_POOL_NONE) is allocated and assigned
successfully, -errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unbound_effective_cpumask">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cpumask</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">unbound_effective_cpumask</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unbound_effective_cpumask" title="Link to this definition">¶</a><br /></dt>
<dd><p>effective cpumask of an unbound workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>wq-&gt;unbound_attrs-&gt;cpumask</strong> contains the cpumask requested by the user which
is masked with wq_unbound_cpumask to determine the effective cpumask. The
default pwq is always mapped to the pool with the current effective cpumask.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_work_pool">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_work_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_work_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>return the worker_pool a given work was associated with</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>the work item of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pools are created and destroyed under wq_pool_mutex, and allows read
access under RCU read lock.  As such, this function should be
called under wq_pool_mutex or inside of a <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> region.</p>
<p>All fields of the returned pool are accessible as long as the above
mentioned locking is in effect.  If the returned pool needs to be used
beyond the critical section, the caller is responsible for ensuring the
returned pool is and stays online.</p>
<p><strong>Return</strong></p>
<p>The worker_pool <strong>work</strong> was last associated with.  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if none.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.worker_set_flags">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker_set_flags</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.worker_set_flags" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.worker_set_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>set worker flags and adjust nr_running accordingly</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>self</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set <strong>flags</strong> in <strong>worker-&gt;flags</strong> and adjust nr_running accordingly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.worker_clr_flags">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker_clr_flags</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.worker_clr_flags" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.worker_clr_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>clear worker flags and adjust nr_running accordingly</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>self</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>flags</strong> in <strong>worker-&gt;flags</strong> and adjust nr_running accordingly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.worker_enter_idle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker_enter_idle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.worker_enter_idle" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.worker_enter_idle" title="Link to this definition">¶</a><br /></dt>
<dd><p>enter idle state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker which is entering idle state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>worker</strong> is entering idle state.  Update stats and idle timer if
necessary.</p>
<p>LOCKING:
raw_spin_lock_irq(pool-&gt;lock).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.worker_leave_idle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker_leave_idle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.worker_leave_idle" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.worker_leave_idle" title="Link to this definition">¶</a><br /></dt>
<dd><p>leave idle state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker which is leaving idle state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>worker</strong> is leaving idle state.  Update stats.</p>
<p>LOCKING:
raw_spin_lock_irq(pool-&gt;lock).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_worker_executing_work">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_worker_executing_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_worker_executing_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>find worker which is executing a work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work to find worker for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a worker which is executing <strong>work</strong> on <strong>pool</strong> by searching
<strong>pool-&gt;busy_hash</strong> which is keyed by the address of <strong>work</strong>.  For a worker
to match, its current execution should match the address of <strong>work</strong> and
its work function.  This is to avoid unwanted dependency between
unrelated work executions through a work item being recycled while still
being executed.</p>
<p>This is a bit tricky.  A work item may be freed once its execution
starts and nothing prevents the freed area from being recycled for
another work item.  If the same work item address ends up being reused
before the original execution finishes, workqueue will identify the
recycled work item as currently executing and make it wait until the
current execution finishes, introducing an unwanted dependency.</p>
<p>This function checks the work item address and work function to avoid
false positives.  Note that this isn’t complete as one may construct a
work function which can introduce dependency onto itself through a
recycled work item.  Well, if somebody wants to shoot oneself in the
foot that badly, there’s only so much we can do, and if such deadlock
actually occurs, it should be easy to locate the culprit work function.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock).</p>
<p><strong>Return</strong></p>
<p>Pointer to worker which is executing <strong>work</strong> if found, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.move_linked_works">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">move_linked_works</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nextp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.move_linked_works" title="Link to this definition">¶</a><br /></dt>
<dd><p>move linked works to a list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>start of series of works to be scheduled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>target list to append <strong>work</strong> to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">**nextp</span></code></dt><dd><p>out parameter for nested worklist walking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule linked works starting from <strong>work</strong> to <strong>head</strong>. Work series to be
scheduled starts at <strong>work</strong> and includes any consecutive work with
WORK_STRUCT_LINKED set in its predecessor. See <a class="reference internal" href="#c.assign_work" title="assign_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">assign_work()</span></code></a> for details on
<strong>nextp</strong>.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.assign_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">assign_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.assign_work" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nextp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.assign_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>assign a work item and its linked work items to a worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work to assign</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to assign to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">**nextp</span></code></dt><dd><p>out parameter for nested worklist walking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assign <strong>work</strong> and its linked work items to <strong>worker</strong>. If <strong>work</strong> is already being
executed by another worker in the same pool, it’ll be punted there.</p>
<p>If <strong>nextp</strong> is not NULL, it’s updated to point to the next work of the last
scheduled work. This allows <a class="reference internal" href="#c.assign_work" title="assign_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">assign_work()</span></code></a> to be nested inside
<a class="reference internal" href="kernel-api.html#c.list_for_each_entry_safe" title="list_for_each_entry_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_safe()</span></code></a>.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>work</strong> was successfully assigned to <strong>worker</strong>. <code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>work</strong>
was punted to another worker already executing it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kick_pool">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kick_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kick_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>wake up an idle worker if necessary</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool to kick</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>pool</strong> may have pending work items. Wake up worker if necessary. Returns
whether a worker was woken up.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_worker_running">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_worker_running</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_worker_running" title="Link to this definition">¶</a><br /></dt>
<dd><p>a worker is running again</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>task waking up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called when a worker returns from schedule()</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_worker_sleeping">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_worker_sleeping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_worker_sleeping" title="Link to this definition">¶</a><br /></dt>
<dd><p>a worker is going to sleep</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>task going to sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from schedule() when a busy worker is
going to sleep.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_worker_tick">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_worker_tick</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_worker_tick" title="Link to this definition">¶</a><br /></dt>
<dd><p>a scheduler tick occurred while a kworker is running</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>task currently running</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from sched_tick(). We’re in the IRQ context and the current
worker’s fields which follow the ‘K’ locking rule can be accessed safely.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_worker_last_func">
<span class="n"><span class="pre">work_func_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_worker_last_func</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_worker_last_func" title="Link to this definition">¶</a><br /></dt>
<dd><p>retrieve worker’s last work function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>Task to retrieve last work function of.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the last function a worker executed. This is called from
the scheduler to get a worker’s last known identity.</p>
<p>This function is called during schedule() when a kworker is going
to sleep. It’s used by psi to identify aggregation workers during
dequeuing, to allow periodic aggregation to shut-off when that
worker is the last task in the system or cgroup to go to sleep.</p>
<p>As this function doesn’t involve any workqueue-related locking, it
only returns stable values when called from inside the scheduler’s
queuing and dequeuing paths, when <strong>task</strong>, which must be a kworker,
is guaranteed to not be processing any works.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(rq-&gt;lock)</p>
<p><strong>Return</strong></p>
<p>The last work function <code class="docutils literal notranslate"><span class="pre">current</span></code> executed as a worker, NULL if it
hasn’t executed any work yet.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_node_nr_active">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.wq_node_nr_active" title="wq_node_nr_active"><span class="n"><span class="pre">wq_node_nr_active</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">wq_node_nr_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_node_nr_active" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determine wq_node_nr_active to use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>NUMA node, can be <code class="docutils literal notranslate"><span class="pre">NUMA_NO_NODE</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine wq_node_nr_active to use for <strong>wq</strong> on <strong>node</strong>. Returns:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> for per-cpu workqueues as they don’t need to use shared nr_active.</p></li>
<li><p>node_nr_active[nr_node_ids] if <strong>node</strong> is <code class="docutils literal notranslate"><span class="pre">NUMA_NO_NODE</span></code>.</p></li>
<li><p>Otherwise, node_nr_active[<strong>node</strong>].</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_update_node_max_active">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_update_node_max_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">off_cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_update_node_max_active" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update per-node max_actives to use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">off_cpu</span></code></dt><dd><p>CPU that’s going down, -1 if a CPU is not going down</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update <strong>wq-&gt;node_nr_active**[]-&gt;max. **wq</strong> must be unbound. max_active is
distributed among nodes according to the proportions of numbers of online
cpus. The result is always between <strong>wq-&gt;min_active</strong> and max_active.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_pwq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_pwq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_pwq" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an extra reference on the specified pool_workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pool_workqueue to get</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain an extra reference on <strong>pwq</strong>.  The caller should guarantee that
<strong>pwq</strong> has positive refcnt and be holding the matching pool-&gt;lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_pwq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_pwq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_pwq" title="Link to this definition">¶</a><br /></dt>
<dd><p>put a pool_workqueue reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pool_workqueue to put</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop a reference of <strong>pwq</strong>.  If its refcnt reaches zero, schedule its
destruction.  The caller should be holding the matching pool-&gt;lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_pwq_unlocked">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_pwq_unlocked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_pwq_unlocked" title="Link to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#c.put_pwq" title="put_pwq"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_pwq()</span></code></a> with surrounding pool lock/unlock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pool_workqueue to put (can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.put_pwq" title="put_pwq"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_pwq()</span></code></a> with locking.  This function also allows <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <strong>pwq</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwq_tryinc_nr_active">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwq_tryinc_nr_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">fill</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwq_tryinc_nr_active" title="Link to this definition">¶</a><br /></dt>
<dd><p>Try to increment nr_active for a pwq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pool_workqueue of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fill</span></code></dt><dd><p>max_active may have increased, try to increase concurrency level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to increment nr_active for <strong>pwq</strong>. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if an nr_active count is
successfully obtained. <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwq_activate_first_inactive">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwq_activate_first_inactive</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">fill</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwq_activate_first_inactive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Activate the first inactive work item on a pwq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pool_workqueue of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fill</span></code></dt><dd><p>max_active may have increased, try to increase concurrency level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Activate the first inactive work item of <strong>pwq</strong> if available and allowed by
max_active limit.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if an inactive work item has been activated. <code class="docutils literal notranslate"><span class="pre">false</span></code> if no
inactive work item is found or max_active limit is reached.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unplug_oldest_pwq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unplug_oldest_pwq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unplug_oldest_pwq" title="Link to this definition">¶</a><br /></dt>
<dd><p>unplug the oldest pool_workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue_struct where its oldest pwq is to be unplugged</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should only be called for ordered workqueues where only the
oldest pwq is unplugged, the others are plugged to suspend execution to
ensure proper work item ordering:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dfl_pwq --------------+     [P] - plugged
                      |
                      v
pwqs -&gt; A -&gt; B [P] -&gt; C [P] (newest)
        |    |        |
        1    3        5
        |    |        |
        2    4        6
</pre></div>
</div>
<p>When the oldest pwq is drained and removed, this function should be called
to unplug the next oldest one to start its work item execution. Note that
pwq’s are linked into wq-&gt;pwqs with the oldest first, so the first one in
the list is the oldest.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.node_activate_pending_pwq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">node_activate_pending_pwq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.wq_node_nr_active" title="wq_node_nr_active"><span class="n"><span class="pre">wq_node_nr_active</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nna</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">caller_pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.node_activate_pending_pwq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Activate a pending pwq on a wq_node_nr_active</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wq_node_nr_active</span> <span class="pre">*nna</span></code></dt><dd><p>wq_node_nr_active to activate a pending pwq for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*caller_pool</span></code></dt><dd><p>worker_pool the caller is locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Activate a pwq in <strong>nna-&gt;pending_pwqs</strong>. Called with <strong>caller_pool</strong> locked.
<strong>caller_pool</strong> may be unlocked and relocked to lock other worker_pools.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwq_dec_nr_active">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwq_dec_nr_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwq_dec_nr_active" title="Link to this definition">¶</a><br /></dt>
<dd><p>Retire an active count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pool_workqueue of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement <strong>pwq</strong>’s nr_active and try to activate the first inactive work item.
For unbound workqueues, this function may temporarily drop <strong>pwq-&gt;pool-&gt;lock</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwq_dec_nr_in_flight">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwq_dec_nr_in_flight</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">work_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwq_dec_nr_in_flight" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrement pwq’s nr_in_flight</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pwq of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">work_data</span></code></dt><dd><p>work_data of work which left the queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A work either has completed or is removed from pending queue,
decrement nr_in_flight of its pwq and handle workqueue flushing.</p>
<p><strong>NOTE</strong></p>
<p>For unbound workqueues, this function may temporarily drop <strong>pwq-&gt;pool-&gt;lock</strong>
and thus should be called after all other state updates for the in-flight
work item is complete.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.try_to_grab_pending">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">try_to_grab_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">cflags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">irq_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_grab_pending" title="Link to this definition">¶</a><br /></dt>
<dd><p>steal work item from worklist and disable irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work item to steal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cflags</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">WORK_CANCEL_</span></code> flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*irq_flags</span></code></dt><dd><p>place to store irq state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to grab PENDING bit of <strong>work</strong>.  This function can handle <strong>work</strong> in any
stable state - idle, on timer or on worklist.</p>
<p>On successful return, &gt;= 0, irq is disabled and the caller is
responsible for releasing it using local_irq_restore(<strong>*irq_flags</strong>).</p>
<p>This function is safe to call from any context including IRQ handler.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>1</p></td>
<td><p>if <strong>work</strong> was pending and we successfully stole PENDING</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>if <strong>work</strong> was idle and we claimed PENDING</p></td>
</tr>
<tr class="row-odd"><td><p>-EAGAIN</p></td>
<td><p>if PENDING couldn’t be grabbed at the moment, safe to busy-retry</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><strong>Note</strong></p>
<p>On &gt;= 0 return, the caller owns <strong>work</strong>’s PENDING bit.  To avoid getting
interrupted while holding PENDING and <strong>work</strong> off queue, irq must be
disabled on entry.  This, combined with delayed_work-&gt;timer being
irqsafe, ensures that we return -EAGAIN for finite short period of time.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.work_grab_pending">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">work_grab_pending</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">cflags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">irq_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.work_grab_pending" title="Link to this definition">¶</a><br /></dt>
<dd><p>steal work item from worklist and disable irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work item to steal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cflags</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">WORK_CANCEL_</span></code> flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*irq_flags</span></code></dt><dd><p>place to store IRQ state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grab PENDING bit of <strong>work</strong>. <strong>work</strong> can be in any stable state - idle, on timer
or on worklist.</p>
<p>Can be called from any context. IRQ is disabled on return with IRQ state
stored in <strong>*irq_flags</strong>. The caller is responsible for re-enabling it using
local_irq_restore().</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>work</strong> was pending. <code class="docutils literal notranslate"><span class="pre">false</span></code> if idle.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.insert_work">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">insert_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">extra_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert a work into a pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pwq <strong>work</strong> belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>insertion point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">extra_flags</span></code></dt><dd><p>extra WORK_STRUCT_* flags to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert <strong>work</strong> which belongs to <strong>pwq</strong> after <strong>head</strong>.  <strong>extra_flags</strong> is or’d to
work_struct flags.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.queue_work_on">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">queue_work_on</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_work_on" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue work on specific cpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU number to execute work on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We queue the work to a specific CPU, the caller must ensure it
can’t go away.  Callers that fail to ensure that the specified
CPU cannot go away will execute on a randomly chosen CPU.
But note well that callers specifying a CPU that never has been
online will get a splat.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>work</strong> was already on a queue, <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.select_numa_node_cpu">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">select_numa_node_cpu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.select_numa_node_cpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Select a CPU based on NUMA node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>NUMA node ID that we want to select a CPU from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will attempt to find a “random” cpu available on a given
node. If there are no CPUs available on the given node it will return
WORK_CPU_UNBOUND indicating that we should just schedule to any
available CPU if we need to schedule this work.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.queue_work_node">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">queue_work_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_work_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue work on a “random” cpu for a given NUMA node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>NUMA node that we are targeting the work for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We queue the work to a “random” CPU within a given NUMA node. The basic
idea here is to provide a way to somehow associate work with a given
NUMA node.</p>
<p>This function will only make a best effort attempt at getting this onto
the right NUMA node. If no node is requested or the requested node is
offline then we just fall back to standard queue_work behavior.</p>
<p>Currently the “random” CPU ends up being the first available CPU in the
intersection of cpu_online_mask and the cpumask of the node, unless we
are running on the node. In that case we just use the current CPU.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>work</strong> was already on a queue, <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.queue_delayed_work_on">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">queue_delayed_work_on</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_delayed_work_on" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue work on specific CPU after delay</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU number to execute work on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queueing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We queue the delayed_work to a specific CPU, for non-zero delays the
caller must ensure it is online and can’t go away. Callers that fail
to ensure this, may get <strong>dwork-&gt;timer</strong> queued to an offlined CPU and
this will prevent queueing of <strong>dwork-&gt;work</strong> unless the offlined CPU
becomes online again.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>work</strong> was already on a queue, <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.  If
<strong>delay</strong> is zero and <strong>dwork</strong> is idle, it will be scheduled for immediate
execution.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mod_delayed_work_on">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mod_delayed_work_on</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">delay</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_delayed_work_on" title="Link to this definition">¶</a><br /></dt>
<dd><p>modify delay of or queue a delayed work on specific CPU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU number to execute work on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queueing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>dwork</strong> is idle, equivalent to <a class="reference internal" href="#c.queue_delayed_work_on" title="queue_delayed_work_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_delayed_work_on()</span></code></a>; otherwise,
modify <strong>dwork</strong>’s timer so that it expires after <strong>delay</strong>.  If <strong>delay</strong> is
zero, <strong>work</strong> is guaranteed to be scheduled immediately regardless of its
current state.</p>
<p>This function is safe to call from any context including IRQ handler.
See <a class="reference internal" href="#c.try_to_grab_pending" title="try_to_grab_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_to_grab_pending()</span></code></a> for details.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>dwork</strong> was idle and queued, <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dwork</strong> was
pending and its timer was modified.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.queue_rcu_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">queue_rcu_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_rcu_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue work after a RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_work</span> <span class="pre">*rwork</span></code></dt><dd><p>work to queue</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>rwork</strong> was already pending, <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.  Note
that a full RCU grace period is guaranteed only after a <code class="docutils literal notranslate"><span class="pre">true</span></code> return.
While <strong>rwork</strong> is guaranteed to be executed after a <code class="docutils literal notranslate"><span class="pre">false</span></code> return, the
execution may happen before a full RCU grace period has passed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.worker_attach_to_pool">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker_attach_to_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.worker_attach_to_pool" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.worker_attach_to_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>attach a worker to a pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to be attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the target pool</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attach <strong>worker</strong> to <strong>pool</strong>.  Once attached, the <code class="docutils literal notranslate"><span class="pre">WORKER_UNBOUND</span></code> flag and
cpu-binding of <strong>worker</strong> are kept coordinated with the pool across
cpu-[un]hotplugs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.worker_detach_from_pool">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker_detach_from_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.worker_detach_from_pool" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.worker_detach_from_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>detach a worker from its pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker which is attached to its pool</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo the attaching which had been done in <a class="reference internal" href="#c.worker_attach_to_pool" title="worker_attach_to_pool"><code class="xref c c-func docutils literal notranslate"><span class="pre">worker_attach_to_pool()</span></code></a>.  The
caller worker shouldn’t access to the pool after detached except it has
other reference to the pool.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.create_worker">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">create_worker</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.create_worker" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a new workqueue worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool the new worker will belong to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create and start a new worker which is attached to <strong>pool</strong>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.  Does GFP_KERNEL allocations.</p>
<p><strong>Return</strong></p>
<p>Pointer to the newly created worker.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_worker_dying">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_worker_dying</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.set_worker_dying" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_worker_dying" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tag a worker for destruction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to be destroyed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>transfer worker away from its pool-&gt;idle_list and into list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tag <strong>worker</strong> for destruction and adjust <strong>pool</strong> stats accordingly.  The worker
should be idle.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idle_worker_timeout">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idle_worker_timeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timer_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idle_worker_timeout" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if some idle workers can now be deleted.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*t</span></code></dt><dd><p>The pool’s idle_timer that just expired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The timer is armed in <a class="reference internal" href="#c.worker_enter_idle" title="worker_enter_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">worker_enter_idle()</span></code></a>. Note that it isn’t disarmed in
<a class="reference internal" href="#c.worker_leave_idle" title="worker_leave_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">worker_leave_idle()</span></code></a>, as a worker flicking between idle and active while its
pool is at the too_many_workers() tipping point would cause too much timer
housekeeping overhead. Since IDLE_WORKER_TIMEOUT is long enough, we just let
it expire and re-evaluate things from there.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idle_cull_fn">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idle_cull_fn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idle_cull_fn" title="Link to this definition">¶</a><br /></dt>
<dd><p>cull workers that have been idle for too long.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>the pool’s work for handling these idle workers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This goes through a pool’s idle workers and gets rid of those that have been
idle for at least IDLE_WORKER_TIMEOUT seconds.</p>
<p>We don’t want to disturb isolated CPUs because of a pcpu kworker being
culled, so this also resets worker affinity. This requires a sleepable
context, hence the split between timer callback and work item.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.maybe_create_worker">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">maybe_create_worker</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.maybe_create_worker" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a new worker if necessary</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool to create a new worker for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new worker for <strong>pool</strong> if necessary.  <strong>pool</strong> is guaranteed to
have at least one idle worker on return from this function.  If
creating a new worker takes longer than MAYDAY_INTERVAL, mayday is
sent to all rescuers with works scheduled on <strong>pool</strong> to resolve
possible allocation deadlock.</p>
<p>On return, need_to_create_worker() is guaranteed to be <code class="docutils literal notranslate"><span class="pre">false</span></code> and
may_start_working() <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>LOCKING:
raw_spin_lock_irq(pool-&gt;lock) which may be released and regrabbed
multiple times.  Does GFP_KERNEL allocations.  Called only from
manager.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.manage_workers">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">manage_workers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.manage_workers" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.manage_workers" title="Link to this definition">¶</a><br /></dt>
<dd><p>manage worker pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>self</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assume the manager role and manage the worker pool <strong>worker</strong> belongs
to.  At any given time, there can be only zero or one manager per
pool.  The exclusion is handled automatically by this function.</p>
<p>The caller can safely start processing works on false return.  On
true return, it’s guaranteed that need_to_create_worker() is false
and may_start_working() is true.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock) which may be released and regrabbed
multiple times.  Does GFP_KERNEL allocations.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if the pool doesn’t need management and the caller can safely
start processing works, <code class="docutils literal notranslate"><span class="pre">true</span></code> if management function was performed and
the conditions that the caller verified before calling the function may
no longer be true.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.process_one_work">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">process_one_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.process_one_work" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.process_one_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>process single work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>self</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work to process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Process <strong>work</strong>.  This function contains all the logics necessary to
process a single work including synchronization against and
interaction with other workers on the same cpu, queueing and
flushing.  As long as context requirement is met, any worker can
call this function to process a work.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock) which is released and regrabbed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.process_scheduled_works">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">process_scheduled_works</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.process_scheduled_works" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.process_scheduled_works" title="Link to this definition">¶</a><br /></dt>
<dd><p>process scheduled works</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>self</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Process all scheduled works.  Please note that the scheduled list
may change while processing a work, so this function repeatedly
fetches a work from the top and executes it.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock) which may be released and regrabbed
multiple times.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.worker_thread">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker_thread</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.worker_thread" title="Link to this definition">¶</a><br /></dt>
<dd><p>the worker thread function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*__worker</span></code></dt><dd><p>self</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The worker thread function.  All workers belong to a worker_pool -
either a per-cpu one or dynamic unbound one.  These workers process all
work items regardless of their specific target workqueue.  The only
exception is work items which belong to workqueues with a rescuer which
will be explained in <a class="reference internal" href="#c.rescuer_thread" title="rescuer_thread"><code class="xref c c-func docutils literal notranslate"><span class="pre">rescuer_thread()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rescuer_thread">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rescuer_thread</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__rescuer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rescuer_thread" title="Link to this definition">¶</a><br /></dt>
<dd><p>the rescuer thread function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*__rescuer</span></code></dt><dd><p>self</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Workqueue rescuer thread function.  There’s one rescuer for each
workqueue which has WQ_MEM_RECLAIM set.</p>
<p>Regular work processing on a pool may block trying to create a new
worker which uses GFP_KERNEL allocation which has slight chance of
developing into deadlock if some works currently on the same queue
need to be processed to satisfy the GFP_KERNEL allocation.  This is
the problem rescuer solves.</p>
<p>When such condition is possible, the pool summons rescuers of all
workqueues which have works queued on the pool and let them process
those works so that forward progress can be guaranteed.</p>
<p>This should happen rarely.</p>
<p><strong>Return</strong></p>
<p>0</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.check_flush_dependency">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">check_flush_dependency</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">target_wq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">target_work</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">from_cancel</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.check_flush_dependency" title="Link to this definition">¶</a><br /></dt>
<dd><p>check for flush dependency sanity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*target_wq</span></code></dt><dd><p>workqueue being flushed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*target_work</span></code></dt><dd><p>work item being flushed (NULL for workqueue flushes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">from_cancel</span></code></dt><dd><p>are we called from the work cancel path</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">current</span></code> is trying to flush the whole <strong>target_wq</strong> or <strong>target_work</strong> on it.
If this is not the cancel path (which implies work being flushed is either
already running, or will not be at all), check if <strong>target_wq</strong> doesn’t have
<code class="docutils literal notranslate"><span class="pre">WQ_MEM_RECLAIM</span></code> and verify that <code class="docutils literal notranslate"><span class="pre">current</span></code> is not reclaiming memory or running
on a workqueue which doesn’t have <code class="docutils literal notranslate"><span class="pre">WQ_MEM_RECLAIM</span></code> as that can break forward-
progress guarantee leading to a deadlock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.insert_wq_barrier">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">insert_wq_barrier</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pool_workqueue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">wq_barrier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">barr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">target</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.insert_wq_barrier" title="worker"><span class="n"><span class="pre">worker</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_wq_barrier" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert a barrier work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pool_workqueue</span> <span class="pre">*pwq</span></code></dt><dd><p>pwq to insert barrier into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wq_barrier</span> <span class="pre">*barr</span></code></dt><dd><p>wq_barrier to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*target</span></code></dt><dd><p>target work to attach <strong>barr</strong> to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker currently executing <strong>target</strong>, NULL if <strong>target</strong> is not executing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>barr</strong> is linked to <strong>target</strong> such that <strong>barr</strong> is completed only after
<strong>target</strong> finishes execution.  Please note that the ordering
guarantee is observed only with respect to <strong>target</strong> and on the local
cpu.</p>
<p>Currently, a queued barrier can’t be canceled.  This is because
<a class="reference internal" href="#c.try_to_grab_pending" title="try_to_grab_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_to_grab_pending()</span></code></a> can’t determine whether the work to be
grabbed is at the head of the queue and thus can’t clear LINKED
flag of the previous work while there must be a valid next work
after a work with LINKED flag set.</p>
<p>Note that when <strong>worker</strong> is non-NULL, <strong>target</strong> may be modified
underneath us, so we can’t reliably determine pwq from <strong>target</strong>.</p>
<p><strong>Context</strong></p>
<p>raw_spin_lock_irq(pool-&gt;lock).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.flush_workqueue_prep_pwqs">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flush_workqueue_prep_pwqs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flush_color</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">work_color</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.flush_workqueue_prep_pwqs" title="Link to this definition">¶</a><br /></dt>
<dd><p>prepare pwqs for workqueue flushing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue being flushed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flush_color</span></code></dt><dd><p>new flush color, &lt; 0 for no-op</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">work_color</span></code></dt><dd><p>new work color, &lt; 0 for no-op</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepare pwqs for workqueue flushing.</p>
<p>If <strong>flush_color</strong> is non-negative, flush_color on all pwqs should be
-1.  If no pwq has in-flight commands at the specified color, all
pwq-&gt;flush_color’s stay at -1 and <code class="docutils literal notranslate"><span class="pre">false</span></code> is returned.  If any pwq
has in flight commands, its pwq-&gt;flush_color is set to
<strong>flush_color</strong>, <strong>wq-&gt;nr_pwqs_to_flush</strong> is updated accordingly, pwq
wakeup logic is armed and <code class="docutils literal notranslate"><span class="pre">true</span></code> is returned.</p>
<p>The caller should have initialized <strong>wq-&gt;first_flusher</strong> prior to
calling this function with non-negative <strong>flush_color</strong>.  If
<strong>flush_color</strong> is negative, no flush color update is done and <code class="docutils literal notranslate"><span class="pre">false</span></code>
is returned.</p>
<p>If <strong>work_color</strong> is non-negative, all pwqs should have the same
work_color which is previous to <strong>work_color</strong> and all will be
advanced to <strong>work_color</strong>.</p>
<p><strong>Context</strong></p>
<p>mutex_lock(wq-&gt;mutex).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>flush_color</strong> &gt;= 0 and there’s something to flush.  <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__flush_workqueue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__flush_workqueue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__flush_workqueue" title="Link to this definition">¶</a><br /></dt>
<dd><p>ensure that any scheduled work has run to completion.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sleeps until all work items which were queued on entry
have finished execution, but it is not livelocked by new incoming ones.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drain_workqueue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drain_workqueue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drain_workqueue" title="Link to this definition">¶</a><br /></dt>
<dd><p>drain a workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue to drain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until the workqueue becomes empty.  While draining is in progress,
only chain queueing is allowed.  IOW, only currently pending or running
work items on <strong>wq</strong> can queue further work items on it.  <strong>wq</strong> is flushed
repeatedly until it becomes empty.  The number of flushing is determined
by the depth of chaining and should be relatively short.  Whine if it
takes too long.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.flush_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flush_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.flush_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for a work to finish executing the last queueing instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>the work to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until <strong>work</strong> has finished execution.  <strong>work</strong> is guaranteed to be idle
on return if it hasn’t been requeued since flush started.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <a class="reference internal" href="#c.flush_work" title="flush_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">flush_work()</span></code></a> waited for the work to finish execution,
<code class="docutils literal notranslate"><span class="pre">false</span></code> if it was already idle.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.flush_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flush_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.flush_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for a dwork to finish executing the last queueing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>the delayed work to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Delayed timer is cancelled and the pending work is queued for
immediate execution.  Like <a class="reference internal" href="#c.flush_work" title="flush_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">flush_work()</span></code></a>, this function only
considers the last queueing instance of <strong>dwork</strong>.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <a class="reference internal" href="#c.flush_work" title="flush_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">flush_work()</span></code></a> waited for the work to finish execution,
<code class="docutils literal notranslate"><span class="pre">false</span></code> if it was already idle.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.flush_rcu_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flush_rcu_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.flush_rcu_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for a rwork to finish executing the last queueing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_work</span> <span class="pre">*rwork</span></code></dt><dd><p>the rcu work to flush</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <a class="reference internal" href="#c.flush_rcu_work" title="flush_rcu_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">flush_rcu_work()</span></code></a> waited for the work to finish execution,
<code class="docutils literal notranslate"><span class="pre">false</span></code> if it was already idle.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cancel_work_sync">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cancel_work_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cancel_work_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>cancel a work and wait for it to finish</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>the work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cancel <strong>work</strong> and wait for its execution to finish. This function can be used
even if the work re-queues itself or migrates to another workqueue. On return
from this function, <strong>work</strong> is guaranteed to be not pending or executing on any
CPU as long as there aren’t racing enqueues.</p>
<p>cancel_work_sync(<code class="xref c c-type docutils literal notranslate"><span class="pre">delayed_work-&gt;work</span></code>) must not be used for delayed_work’s.
Use <a class="reference internal" href="#c.cancel_delayed_work_sync" title="cancel_delayed_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">cancel_delayed_work_sync()</span></code></a> instead.</p>
<p>Must be called from a sleepable context if <strong>work</strong> was last queued on a non-BH
workqueue. Can also be called from non-hardirq atomic contexts including BH
if <strong>work</strong> was last queued on a BH workqueue.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>work</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cancel_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cancel_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cancel_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>cancel a delayed work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>delayed_work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Kill off a pending delayed_work.</p>
<p>This function is safe to call from any context including IRQ handler.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dwork</strong> was pending and canceled; <code class="docutils literal notranslate"><span class="pre">false</span></code> if it wasn’t
pending.</p>
<p><strong>Note</strong></p>
<p>The work callback function may still be running on return, unless
it returns <code class="docutils literal notranslate"><span class="pre">true</span></code> and the work doesn’t re-arm itself.  Explicitly flush or
use <a class="reference internal" href="#c.cancel_delayed_work_sync" title="cancel_delayed_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">cancel_delayed_work_sync()</span></code></a> to wait on it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cancel_delayed_work_sync">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cancel_delayed_work_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cancel_delayed_work_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>cancel a delayed work and wait for it to finish</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>the delayed work cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <a class="reference internal" href="#c.cancel_work_sync" title="cancel_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">cancel_work_sync()</span></code></a> for delayed works.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dwork</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.disable_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">disable_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disable and cancel a work item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work item to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable <strong>work</strong> by incrementing its disable count and cancel it if currently
pending. As long as the disable count is non-zero, any attempt to queue <strong>work</strong>
will fail and return <code class="docutils literal notranslate"><span class="pre">false</span></code>. The maximum supported disable depth is 2 to the
power of <code class="docutils literal notranslate"><span class="pre">WORK_OFFQ_DISABLE_BITS</span></code>, currently 65536.</p>
<p>Can be called from any context. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>work</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.disable_work_sync">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">disable_work_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_work_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disable, cancel and drain a work item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work item to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.disable_work" title="disable_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_work()</span></code></a> but also wait for <strong>work</strong> to finish if currently
executing.</p>
<p>Must be called from a sleepable context if <strong>work</strong> was last queued on a non-BH
workqueue. Can also be called from non-hardirq atomic contexts including BH
if <strong>work</strong> was last queued on a BH workqueue.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>work</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.enable_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">enable_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Enable a work item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work item to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo disable_work[_sync]() by decrementing <strong>work</strong>’s disable count. <strong>work</strong> can
only be queued if its disable count is 0.</p>
<p>Can be called from any context. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the disable count reached 0.
Otherwise, <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.disable_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">disable_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disable and cancel a delayed work item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>delayed work item to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.disable_work" title="disable_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_work()</span></code></a> for delayed work items.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.disable_delayed_work_sync">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">disable_delayed_work_sync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_delayed_work_sync" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disable, cancel and drain a delayed work item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>delayed work item to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.disable_work_sync" title="disable_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_work_sync()</span></code></a> for delayed work items.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.enable_delayed_work">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">enable_delayed_work</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">delayed_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_delayed_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Enable a delayed work item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>delayed work item to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.enable_work" title="enable_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">enable_work()</span></code></a> for delayed work items.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.schedule_on_each_cpu">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">schedule_on_each_cpu</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">work_func_t</span></span><span class="w"> </span><span class="n"><span class="pre">func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_on_each_cpu" title="Link to this definition">¶</a><br /></dt>
<dd><p>execute a function synchronously on each online CPU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work_func_t</span> <span class="pre">func</span></code></dt><dd><p>the function to call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.schedule_on_each_cpu" title="schedule_on_each_cpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">schedule_on_each_cpu()</span></code></a> executes <strong>func</strong> on each online CPU using the
system workqueue and blocks until all CPUs have completed.
<a class="reference internal" href="#c.schedule_on_each_cpu" title="schedule_on_each_cpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">schedule_on_each_cpu()</span></code></a> is very slow.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.execute_in_process_context">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">execute_in_process_context</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">work_func_t</span></span><span class="w"> </span><span class="n"><span class="pre">fn</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">execute_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ew</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.execute_in_process_context" title="Link to this definition">¶</a><br /></dt>
<dd><p>reliably execute the routine with user context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work_func_t</span> <span class="pre">fn</span></code></dt><dd><p>the function to execute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">execute_work</span> <span class="pre">*ew</span></code></dt><dd><p>guaranteed storage for the execute work structure (must
be available when the work executes)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Executes the function immediately if process context is available,
otherwise schedules the function for delayed execution.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 - function was executed</dt><dd><p>1 - function was scheduled for execution</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.free_workqueue_attrs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_workqueue_attrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.workqueue_attrs" title="workqueue_attrs"><span class="n"><span class="pre">workqueue_attrs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.free_workqueue_attrs" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a workqueue_attrs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_attrs</span> <span class="pre">*attrs</span></code></dt><dd><p>workqueue_attrs to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo <a class="reference internal" href="#c.alloc_workqueue_attrs" title="alloc_workqueue_attrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_workqueue_attrs()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_workqueue_attrs">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.workqueue_attrs" title="workqueue_attrs"><span class="n"><span class="pre">workqueue_attrs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_workqueue_attrs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_workqueue_attrs" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a workqueue_attrs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new workqueue_attrs, initialize with default settings and
return it.</p>
<p><strong>Return</strong></p>
<p>The allocated new workqueue_attr on success. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.init_worker_pool">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">init_worker_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.init_worker_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a newly zalloc’d worker_pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>worker_pool to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a newly zalloc’d <strong>pool</strong>.  It also allocates <strong>pool-&gt;attrs</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.  Even on failure, all fields
inside <strong>pool</strong> proper are initialized and <a class="reference internal" href="#c.put_unbound_pool" title="put_unbound_pool"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_unbound_pool()</span></code></a> can be called
on <strong>pool</strong> safely to release it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_unbound_pool">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_unbound_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_unbound_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>put a worker_pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>worker_pool to put</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put <strong>pool</strong>.  If its refcnt reaches zero, it gets destroyed in RCU
safe manner.  <a class="reference internal" href="#c.get_unbound_pool" title="get_unbound_pool"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_unbound_pool()</span></code></a> calls this function on its failure path
and this function should be able to release pools which went through,
successfully or not, <a class="reference internal" href="#c.init_worker_pool" title="init_worker_pool"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_worker_pool()</span></code></a>.</p>
<p>Should be called with wq_pool_mutex held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_unbound_pool">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_unbound_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.workqueue_attrs" title="workqueue_attrs"><span class="n"><span class="pre">workqueue_attrs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_unbound_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a worker_pool with the specified attributes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">workqueue_attrs</span> <span class="pre">*attrs</span></code></dt><dd><p>the attributes of the worker_pool to get</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain a worker_pool which has the same attributes as <strong>attrs</strong>, bump the
reference count and return it.  If there already is a matching
worker_pool, it will be used; otherwise, this function attempts to
create a new one.</p>
<p>Should be called with wq_pool_mutex held.</p>
<p><strong>Return</strong></p>
<p>On success, a worker_pool with the same attributes as <strong>attrs</strong>.
On failure, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_calc_pod_cpumask">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_calc_pod_cpumask</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.workqueue_attrs" title="workqueue_attrs"><span class="n"><span class="pre">workqueue_attrs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_calc_pod_cpumask" title="Link to this definition">¶</a><br /></dt>
<dd><p>calculate a wq_attrs’ cpumask for a pod</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_attrs</span> <span class="pre">*attrs</span></code></dt><dd><p>the wq_attrs of the default pwq of the target workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the target CPU</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the cpumask a workqueue with <strong>attrs</strong> should use on <strong>pod</strong>.
The result is stored in <strong>attrs-&gt;__pod_cpumask</strong>.</p>
<p>If pod affinity is not enabled, <strong>attrs-&gt;cpumask</strong> is always used. If enabled
and <strong>pod</strong> has online CPUs requested by <strong>attrs</strong>, the returned cpumask is the
intersection of the possible CPUs of <strong>pod</strong> and <strong>attrs-&gt;cpumask</strong>.</p>
<p>The caller is responsible for ensuring that the cpumask of <strong>pod</strong> stays stable.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.apply_workqueue_attrs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">apply_workqueue_attrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.workqueue_attrs" title="workqueue_attrs"><span class="n"><span class="pre">workqueue_attrs</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.apply_workqueue_attrs" title="Link to this definition">¶</a><br /></dt>
<dd><p>apply new workqueue_attrs to an unbound workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>the target workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">workqueue_attrs</span> <span class="pre">*attrs</span></code></dt><dd><p>the workqueue_attrs to apply, allocated with <a class="reference internal" href="#c.alloc_workqueue_attrs" title="alloc_workqueue_attrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_workqueue_attrs()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply <strong>attrs</strong> to an unbound workqueue <strong>wq</strong>. Unless disabled, this function maps
a separate pwq to each CPU pod with possibles CPUs in <strong>attrs-&gt;cpumask</strong> so that
work items are affine to the pod it was issued on. Older pwqs are released as
in-flight work items finish. Note that a work item which repeatedly requeues
itself back-to-back will stay on its current pwq.</p>
<p>Performs GFP_KERNEL allocations.</p>
<p><strong>Return</strong></p>
<p>0 on success and -errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unbound_wq_update_pwq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unbound_wq_update_pwq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unbound_wq_update_pwq" title="Link to this definition">¶</a><br /></dt>
<dd><p>update a pwq slot for CPU hot[un]plug</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>the target workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the CPU to update the pwq slot for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is to be called from <code class="docutils literal notranslate"><span class="pre">CPU_DOWN_PREPARE</span></code>, <code class="docutils literal notranslate"><span class="pre">CPU_ONLINE</span></code> and
<code class="docutils literal notranslate"><span class="pre">CPU_DOWN_FAILED</span></code>.  <strong>cpu</strong> is in the same pod of the CPU being hot[un]plugged.</p>
<p>If pod affinity can’t be adjusted due to memory allocation failure, it falls
back to <strong>wq-&gt;dfl_pwq</strong> which may not be optimal but is always correct.</p>
<p>Note that when the last allowed CPU of a pod goes offline for a workqueue
with a cpumask spanning multiple pods, the workers which were already
executing the work items for the workqueue will lose their CPU affinity and
may execute on any CPU. This is similar to how per-cpu workqueues behave on
CPU_DOWN. If a workqueue user wants strict affinity, it’s the user’s
responsibility to flush the work item from CPU_DOWN_PREPARE.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wq_adjust_max_active">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wq_adjust_max_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_adjust_max_active" title="Link to this definition">¶</a><br /></dt>
<dd><p>update a wq’s max_active to the current setting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>target workqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>wq</strong> isn’t freezing, set <strong>wq-&gt;max_active</strong> to the saved_max_active and
activate inactive work items accordingly. If <strong>wq</strong> is freezing, clear
<strong>wq-&gt;max_active</strong> to zero.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.destroy_workqueue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">destroy_workqueue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.destroy_workqueue" title="Link to this definition">¶</a><br /></dt>
<dd><p>safely terminate a workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>target workqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Safely destroy a workqueue. All work currently pending will be done first.</p>
<p>This function does NOT guarantee that non-pending work that has been
submitted with <a class="reference internal" href="#c.queue_delayed_work" title="queue_delayed_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_delayed_work()</span></code></a> and similar functions will be done
before destroying the workqueue. The fundamental problem is that, currently,
the workqueue has no way of accessing non-pending delayed_work. delayed_work
is only linked on the timer-side. All delayed_work must, therefore, be
canceled before calling this function.</p>
<p>TODO: It would be better if the problem described above wouldn’t exist and
<a class="reference internal" href="#c.destroy_workqueue" title="destroy_workqueue"><code class="xref c c-func docutils literal notranslate"><span class="pre">destroy_workqueue()</span></code></a> would cleanly cancel all pending and non-pending
delayed_work.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_set_max_active">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_set_max_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_active</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_set_max_active" title="Link to this definition">¶</a><br /></dt>
<dd><p>adjust max_active of a workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>target workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_active</span></code></dt><dd><p>new max_active value.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set max_active of <strong>wq</strong> to <strong>max_active</strong>. See the <a class="reference internal" href="#c.alloc_workqueue" title="alloc_workqueue"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_workqueue()</span></code></a> function
comment.</p>
<p><strong>Context</strong></p>
<p>Don’t call from IRQ context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_set_min_active">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_set_min_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min_active</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_set_min_active" title="Link to this definition">¶</a><br /></dt>
<dd><p>adjust min_active of an unbound workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>target unbound workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_active</span></code></dt><dd><p>new min_active value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set min_active of an unbound workqueue. Unlike other types of workqueues, an
unbound workqueue is not guaranteed to be able to process max_active
interdependent work items. Instead, an unbound workqueue is guaranteed to be
able to process min_active number of interdependent work items which is
<code class="docutils literal notranslate"><span class="pre">WQ_DFL_MIN_ACTIVE</span></code> by default.</p>
<p>Use this function to adjust the min_active value between 0 and the current
max_active.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.current_work">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">current_work</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.current_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>retrieve <code class="docutils literal notranslate"><span class="pre">current</span></code> task’s work struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if <code class="docutils literal notranslate"><span class="pre">current</span></code> task is a workqueue worker and what it’s working on.
Useful to find out the context that the <code class="docutils literal notranslate"><span class="pre">current</span></code> task is running in.</p>
<p><strong>Return</strong></p>
<p>work struct if <code class="docutils literal notranslate"><span class="pre">current</span></code> task is a workqueue worker, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.current_is_workqueue_rescuer">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">current_is_workqueue_rescuer</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.current_is_workqueue_rescuer" title="Link to this definition">¶</a><br /></dt>
<dd><p>is <code class="docutils literal notranslate"><span class="pre">current</span></code> workqueue rescuer?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether <code class="docutils literal notranslate"><span class="pre">current</span></code> is a workqueue rescuer.  Can be used from
work functions to determine whether it’s being run off the rescuer task.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">current</span></code> is a workqueue rescuer. <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_congested">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_congested</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_congested" title="Link to this definition">¶</a><br /></dt>
<dd><p>test whether a workqueue is congested</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>target workqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test whether <strong>wq</strong>’s cpu workqueue for <strong>cpu</strong> is congested.  There is
no synchronization around this function and the test result is
unreliable and only useful as advisory hints or for debugging.</p>
<p>If <strong>cpu</strong> is WORK_CPU_UNBOUND, the test is performed on the local CPU.</p>
<p>With the exception of ordered workqueues, all workqueues have per-cpu
pool_workqueues, each with its own congested state. A workqueue being
congested on one CPU doesn’t mean that the workqueue is contested on any
other CPUs.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if congested, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.work_busy">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">work_busy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">work_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.work_busy" title="Link to this definition">¶</a><br /></dt>
<dd><p>test whether a work is currently pending or running</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>the work to be tested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test whether <strong>work</strong> is currently pending or running.  There is no
synchronization around this function and the test result is
unreliable and only useful as advisory hints or for debugging.</p>
<p><strong>Return</strong></p>
<p>OR’d bitmask of WORK_BUSY_* bits.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_worker_desc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_worker_desc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_worker_desc" title="Link to this definition">¶</a><br /></dt>
<dd><p>set description for the current work item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>printf-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be called by a running work function to describe what
the work item is about.  If the worker task gets dumped, this
information will be printed out together to help debugging.  The
description can be at most WORKER_DESC_LEN including the trailing ‘0’.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.print_worker_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">print_worker_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">log_lvl</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.print_worker_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>print out worker information and description</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*log_lvl</span></code></dt><dd><p>the log level to use when printing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>task</strong> is a worker and currently executing a work item, print out the
name of the workqueue being serviced and worker description set with
<a class="reference internal" href="#c.set_worker_desc" title="set_worker_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">set_worker_desc()</span></code></a> by the currently executing work item.</p>
<p>This function can be safely called on any task as long as the
task_struct itself is accessible.  While safe, this function isn’t
synchronized and may print out mixups or garbages of limited length.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.show_one_workqueue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">show_one_workqueue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.show_one_workqueue" title="Link to this definition">¶</a><br /></dt>
<dd><p>dump state of specified workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>workqueue whose state will be printed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.show_one_worker_pool">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">show_one_worker_pool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.show_one_worker_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>dump state of specified worker pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>worker pool whose state will be printed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.show_all_workqueues">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">show_all_workqueues</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.show_all_workqueues" title="Link to this definition">¶</a><br /></dt>
<dd><p>dump workqueue state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from a sysrq handler and prints out all busy workqueues and pools.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.show_freezable_workqueues">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">show_freezable_workqueues</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.show_freezable_workqueues" title="Link to this definition">¶</a><br /></dt>
<dd><p>dump freezable workqueue state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from try_to_freeze_tasks() and prints out all freezable workqueues
still busy.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rebind_workers">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rebind_workers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rebind_workers" title="Link to this definition">¶</a><br /></dt>
<dd><p>rebind all workers of a pool to the associated CPU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>pool of interest</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>pool-&gt;cpu</strong> is coming online.  Rebind all workers to the CPU.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.restore_unbound_workers_cpumask">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">restore_unbound_workers_cpumask</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">worker_pool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.restore_unbound_workers_cpumask" title="Link to this definition">¶</a><br /></dt>
<dd><p>restore cpumask of unbound workers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">worker_pool</span> <span class="pre">*pool</span></code></dt><dd><p>unbound pool of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the CPU which is coming up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An unbound pool may end up with a cpumask which doesn’t have any online
CPUs.  When a worker of such pool get scheduled, the scheduler resets
its cpus_allowed.  If <strong>cpu</strong> is in <strong>pool</strong>’s cpumask which didn’t have any
online CPU before, cpus_allowed of all its workers should be restored.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.work_on_cpu_key">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">work_on_cpu_key</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lock_class_key</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.work_on_cpu_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>run a function in thread context on a particular cpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the cpu to run on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">(*fn)(void</span> <span class="pre">*)</span></code></dt><dd><p>the function to run</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>the function arg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*key</span></code></dt><dd><p>The lock class key for lock debugging purposes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is up to the caller to ensure that the cpu doesn’t go offline.
The caller must not hold any locks which would prevent <strong>fn</strong> from completing.</p>
<p><strong>Return</strong></p>
<p>The value <strong>fn</strong> returns.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.work_on_cpu_safe_key">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">work_on_cpu_safe_key</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lock_class_key</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.work_on_cpu_safe_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>run a function in thread context on a particular cpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the cpu to run on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">(*fn)(void</span> <span class="pre">*)</span></code></dt><dd><p>the function to run</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>the function argument</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*key</span></code></dt><dd><p>The lock class key for lock debugging purposes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables CPU hotplug and calls work_on_cpu(). The caller must not hold
any locks which would prevent <strong>fn</strong> from completing.</p>
<p><strong>Return</strong></p>
<p>The value <strong>fn</strong> returns.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.freeze_workqueues_begin">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">freeze_workqueues_begin</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.freeze_workqueues_begin" title="Link to this definition">¶</a><br /></dt>
<dd><p>begin freezing workqueues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start freezing workqueues.  After this function returns, all freezable
workqueues will queue new works to their inactive_works list instead of
pool-&gt;worklist.</p>
<p><strong>Context</strong></p>
<p>Grabs and releases wq_pool_mutex, wq-&gt;mutex and pool-&gt;lock’s.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.freeze_workqueues_busy">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">freeze_workqueues_busy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.freeze_workqueues_busy" title="Link to this definition">¶</a><br /></dt>
<dd><p>are freezable workqueues still busy?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether freezing is complete.  This function must be called
between <a class="reference internal" href="#c.freeze_workqueues_begin" title="freeze_workqueues_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">freeze_workqueues_begin()</span></code></a> and <a class="reference internal" href="#c.thaw_workqueues" title="thaw_workqueues"><code class="xref c c-func docutils literal notranslate"><span class="pre">thaw_workqueues()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Grabs and releases wq_pool_mutex.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if some freezable workqueues are still busy.  <code class="docutils literal notranslate"><span class="pre">false</span></code> if freezing
is complete.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.thaw_workqueues">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thaw_workqueues</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thaw_workqueues" title="Link to this definition">¶</a><br /></dt>
<dd><p>thaw workqueues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Thaw workqueues.  Normal queueing is restored and all collected
frozen works are transferred to their respective pool worklists.</p>
<p><strong>Context</strong></p>
<p>Grabs and releases wq_pool_mutex, wq-&gt;mutex and pool-&gt;lock’s.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_unbound_exclude_cpumask">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_unbound_exclude_cpumask</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">cpumask_var_t</span></span><span class="w"> </span><span class="n"><span class="pre">exclude_cpumask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_unbound_exclude_cpumask" title="Link to this definition">¶</a><br /></dt>
<dd><p>Exclude given CPUs from unbound cpumask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cpumask_var_t</span> <span class="pre">exclude_cpumask</span></code></dt><dd><p>the cpumask to be excluded from wq_unbound_cpumask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be called from cpuset code to provide a set of isolated
CPUs that should be excluded from wq_unbound_cpumask.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_set_unbound_cpumask">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_set_unbound_cpumask</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">cpumask_var_t</span></span><span class="w"> </span><span class="n"><span class="pre">cpumask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_set_unbound_cpumask" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the low-level unbound cpumask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">cpumask_var_t</span> <span class="pre">cpumask</span></code></dt><dd><p>the cpumask to set</p>
<p>The low-level workqueues cpumask is a global cpumask that limits
the affinity of all unbound workqueues.  This function check the <strong>cpumask</strong>
and apply it to all unbound workqueues and updates all pwqs of them.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0       - Success</dt><dd><p>-EINVAL - Invalid <strong>cpumask</strong>
-ENOMEM - Failed to allocate memory for attrs or pwqs.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_sysfs_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_sysfs_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_sysfs_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>make a workqueue visible in sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>the workqueue to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expose <strong>wq</strong> in sysfs under /sys/bus/workqueue/devices.
alloc_workqueue*() automatically calls this function if WQ_SYSFS is set
which is the preferred method.</p>
<p>Workqueue user should use this function directly iff it wants to apply
workqueue_attrs before making the workqueue visible in sysfs; otherwise,
<a class="reference internal" href="#c.apply_workqueue_attrs" title="apply_workqueue_attrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">apply_workqueue_attrs()</span></code></a> may race against userland updating the
attributes.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_sysfs_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_sysfs_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_sysfs_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>undo <a class="reference internal" href="#c.workqueue_sysfs_register" title="workqueue_sysfs_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">workqueue_sysfs_register()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>the workqueue to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>wq</strong> is registered to sysfs by <a class="reference internal" href="#c.workqueue_sysfs_register" title="workqueue_sysfs_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">workqueue_sysfs_register()</span></code></a>, unregister.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_init_early">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_init_early</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_init_early" title="Link to this definition">¶</a><br /></dt>
<dd><p>early init for workqueue subsystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first step of three-staged workqueue subsystem initialization and
invoked as soon as the bare basics - memory allocation, cpumasks and idr are
up. It sets up all the data structures and system workqueues and allows early
boot code to create workqueues and queue/cancel work items. Actual work item
execution starts only after kthreads can be created and scheduled right
before early initcalls.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>bring workqueue subsystem fully online</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the second step of three-staged workqueue subsystem initialization
and invoked as soon as kthreads can be created and scheduled. Workqueues have
been created and work items queued on them, but there are no kworkers
executing the work items yet. Populate the worker pools with the initial
workers and enable future kworker creations.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.workqueue_init_topology">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">workqueue_init_topology</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_init_topology" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize CPU pods for unbound workqueues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the third step of three-staged workqueue subsystem initialization and
invoked after SMP and topology information are fully initialized. It
initializes the unbound CPU pods accordingly.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/workqueue.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>