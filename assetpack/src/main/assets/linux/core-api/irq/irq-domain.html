<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>The irq_domain Interrupt Number Mapping Library &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="IRQ-flags state tracing" href="irqflags-tracing.html" />
    <link rel="prev" title="SMP IRQ affinity" href="irq-affinity.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.16.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Core API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#concurrency-primitives">Concurrency primitives</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../refcount-vs-atomic.html">refcount_t API compared to atomic_t</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">IRQs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../padata.html">The padata parallel execution mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../RCU/index.html">RCU concepts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wrappers/memory-barriers.html">Linux kernel memory barriers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/core-api/irq/irq-domain.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../../translations/zh_CN/core-api/irq/irq-domain.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="the-irq-domain-interrupt-number-mapping-library">
<h1>The irq_domain Interrupt Number Mapping Library<a class="headerlink" href="#the-irq-domain-interrupt-number-mapping-library" title="Link to this heading">¶</a></h1>
<p>The current design of the Linux kernel uses a single large number
space where each separate IRQ source is assigned a unique number.
This is simple when there is only one interrupt controller. But in
systems with multiple interrupt controllers, the kernel must ensure
that each one gets assigned non-overlapping allocations of Linux
IRQ numbers.</p>
<p>The number of interrupt controllers registered as unique irqchips
shows a rising tendency. For example, subdrivers of different kinds
such as GPIO controllers avoid reimplementing identical callback
mechanisms as the IRQ core system by modelling their interrupt
handlers as irqchips. I.e. in effect cascading interrupt controllers.</p>
<p>So in the past, IRQ numbers could be chosen so that they match the
hardware IRQ line into the root interrupt controller (i.e. the
component actually firing the interrupt line to the CPU). Nowadays,
this number is just a number and the number loose all kind of
correspondence to hardware interrupt numbers.</p>
<p>For this reason, we need a mechanism to separate controller-local
interrupt numbers, called hardware IRQs, from Linux IRQ numbers.</p>
<p>The irq_alloc_desc*() and irq_free_desc*() APIs provide allocation of
IRQ numbers, but they don’t provide any support for reverse mapping of
the controller-local IRQ (hwirq) number into the Linux IRQ number
space.</p>
<p>The irq_domain library adds a mapping between hwirq and IRQ numbers on
top of the irq_alloc_desc*() API. An irq_domain to manage the mapping
is preferred over interrupt controller drivers open coding their own
reverse mapping scheme.</p>
<p>irq_domain also implements a translation from an abstract <a class="reference internal" href="#c.irq_fwspec" title="irq_fwspec"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">irq_fwspec</span></code></a> to hwirq numbers (Device Tree, non-DT firmware node, ACPI
GSI, and software node so far), and can be easily extended to support
other IRQ topology data sources. The implementation is performed
without any extra platform support code.</p>
<section id="irq-domain-usage">
<h2>irq_domain Usage<a class="headerlink" href="#irq-domain-usage" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#c.irq_domain" title="irq_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span></code></a> could be defined as an irq domain controller. That
is, it handles the mapping between hardware and virtual interrupt
numbers for a given interrupt domain. The domain structure is
generally created by the PIC code for a given PIC instance (though a
domain can cover more than one PIC if they have a flat number model).
It is the domain callbacks that are responsible for setting the
irq_chip on a given irq_desc after it has been mapped.</p>
<p>The host code and data structures use a fwnode_handle pointer to
identify the domain. In some cases, and in order to preserve source
code compatibility, this fwnode pointer is “upgraded” to a DT
device_node. For those firmware infrastructures that do not provide a
unique identifier for an interrupt controller, the irq_domain code
offers a fwnode allocator.</p>
<p>An interrupt controller driver creates and registers a <a class="reference internal" href="#c.irq_domain" title="irq_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span></code></a>
by calling one of the irq_domain_create_*() functions (each mapping
method has a different allocator function, more on that later). The
function will return a pointer to the <a class="reference internal" href="#c.irq_domain" title="irq_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span></code></a> on success. The
caller must provide the allocator function with a <a class="reference internal" href="#c.irq_domain_ops" title="irq_domain_ops"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain_ops</span></code></a>
pointer.</p>
<p>In most cases, the irq_domain will begin empty without any mappings
between hwirq and IRQ numbers.  Mappings are added to the irq_domain
by calling <a class="reference internal" href="#c.irq_create_mapping" title="irq_create_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_create_mapping()</span></code></a> which accepts the irq_domain and a
hwirq number as arguments. If a mapping for the hwirq doesn’t already
exist, <a class="reference internal" href="#c.irq_create_mapping" title="irq_create_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_create_mapping()</span></code></a> allocates a new Linux irq_desc, associates
it with the hwirq, and calls the <code class="xref c c-member docutils literal notranslate"><span class="pre">irq_domain_ops.map()</span></code>
callback. In there, the driver can perform any required hardware
setup.</p>
<p>Once a mapping has been established, it can be retrieved or used via a
variety of methods:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.irq_resolve_mapping" title="irq_resolve_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_resolve_mapping()</span></code></a> returns a pointer to the irq_desc structure
for a given domain and hwirq number, and NULL if there was no
mapping.</p></li>
<li><p><a class="reference internal" href="#c.irq_find_mapping" title="irq_find_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_find_mapping()</span></code></a> returns a Linux IRQ number for a given domain and
hwirq number, and 0 if there was no mapping</p></li>
<li><p><a class="reference internal" href="../genericirq.html#c.generic_handle_domain_irq" title="generic_handle_domain_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_handle_domain_irq()</span></code></a> handles an interrupt described by a
domain and a hwirq number</p></li>
</ul>
<p>Note that irq domain lookups must happen in contexts that are
compatible with a RCU read-side critical section.</p>
<p>The <a class="reference internal" href="#c.irq_create_mapping" title="irq_create_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_create_mapping()</span></code></a> function must be called <em>at least once</em>
before any call to <a class="reference internal" href="#c.irq_find_mapping" title="irq_find_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_find_mapping()</span></code></a>, lest the descriptor will not
be allocated.</p>
<p>If the driver has the Linux IRQ number or the irq_data pointer, and
needs to know the associated hwirq number (such as in the irq_chip
callbacks) then it can be directly obtained from
<code class="xref c c-member docutils literal notranslate"><span class="pre">irq_data.hwirq</span></code>.</p>
</section>
<section id="types-of-irq-domain-mappings">
<h2>Types of irq_domain Mappings<a class="headerlink" href="#types-of-irq-domain-mappings" title="Link to this heading">¶</a></h2>
<p>There are several mechanisms available for reverse mapping from hwirq
to Linux irq, and each mechanism uses a different allocation function.
Which reverse map type should be used depends on the use case.  Each
of the reverse map types are described below:</p>
<section id="linear">
<h3>Linear<a class="headerlink" href="#linear" title="Link to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>irq_domain_create_linear()
</pre></div>
</div>
<p>The linear reverse map maintains a fixed size table indexed by the
hwirq number.  When a hwirq is mapped, an irq_desc is allocated for
the hwirq, and the IRQ number is stored in the table.</p>
<p>The Linear map is a good choice when the maximum number of hwirqs is
fixed and a relatively small number (~ &lt; 256).  The advantages of this
map are fixed time lookup for IRQ numbers, and irq_descs are only
allocated for in-use IRQs.  The disadvantage is that the table must be
as large as the largest possible hwirq number.</p>
<p>The majority of drivers should use the Linear map.</p>
</section>
<section id="tree">
<h3>Tree<a class="headerlink" href="#tree" title="Link to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>irq_domain_create_tree()
</pre></div>
</div>
<p>The irq_domain maintains a radix tree map from hwirq numbers to Linux
IRQs.  When an hwirq is mapped, an irq_desc is allocated and the
hwirq is used as the lookup key for the radix tree.</p>
<p>The tree map is a good choice if the hwirq number can be very large
since it doesn’t need to allocate a table as large as the largest
hwirq number.  The disadvantage is that hwirq to IRQ number lookup is
dependent on how many entries are in the table.</p>
<p>Very few drivers should need this mapping.</p>
</section>
<section id="no-map">
<h3>No Map<a class="headerlink" href="#no-map" title="Link to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>irq_domain_create_nomap()
</pre></div>
</div>
<p>The No Map mapping is to be used when the hwirq number is
programmable in the hardware.  In this case it is best to program the
Linux IRQ number into the hardware itself so that no mapping is
required.  Calling <a class="reference internal" href="#c.irq_create_direct_mapping" title="irq_create_direct_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_create_direct_mapping()</span></code></a> will allocate a Linux
IRQ number and call the .map() callback so that driver can program the
Linux IRQ number into the hardware.</p>
<p>Most drivers cannot use this mapping, and it is now gated on the
CONFIG_IRQ_DOMAIN_NOMAP option. Please refrain from introducing new
users of this API.</p>
</section>
<section id="legacy">
<h3>Legacy<a class="headerlink" href="#legacy" title="Link to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>irq_domain_create_simple()
irq_domain_create_legacy()
</pre></div>
</div>
<p>The Legacy mapping is a special case for drivers that already have a
range of irq_descs allocated for the hwirqs.  It is used when the
driver cannot be immediately converted to use the linear mapping.  For
example, many embedded system board support files use a set of #defines
for IRQ numbers that are passed to <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> registrations.  In that
case the Linux IRQ numbers cannot be dynamically assigned and the legacy
mapping should be used.</p>
<p>As the name implies, the *_legacy() functions are deprecated and only
exist to ease the support of ancient platforms. No new users should be
added. Same goes for the *_simple() functions when their use results
in the legacy behaviour.</p>
<p>The legacy map assumes a contiguous range of IRQ numbers has already
been allocated for the controller and that the IRQ number can be
calculated by adding a fixed offset to the hwirq number, and
visa-versa.  The disadvantage is that it requires the interrupt
controller to manage IRQ allocations and it requires an irq_desc to be
allocated for every hwirq, even if it is unused.</p>
<p>The legacy map should only be used if fixed IRQ mappings must be
supported.  For example, ISA controllers would use the legacy map for
mapping Linux IRQs 0-15 so that existing ISA drivers get the correct IRQ
numbers.</p>
<p>Most users of legacy mappings should use <a class="reference internal" href="#c.irq_domain_create_simple" title="irq_domain_create_simple"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_domain_create_simple()</span></code></a>
which will use a legacy domain only if an IRQ range is supplied by the
system and will otherwise use a linear domain mapping. The semantics of
this call are such that if an IRQ range is specified then descriptors
will be allocated on-the-fly for it, and if no range is specified it
will fall through to <a class="reference internal" href="#c.irq_domain_create_linear" title="irq_domain_create_linear"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_domain_create_linear()</span></code></a> which means <em>no</em> irq
descriptors will be allocated.</p>
<p>A typical use case for simple domains is where an irqchip provider
is supporting both dynamic and static IRQ assignments.</p>
<p>In order to avoid ending up in a situation where a linear domain is
used and no descriptor gets allocated it is very important to make sure
that the driver using the simple domain call <a class="reference internal" href="#c.irq_create_mapping" title="irq_create_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_create_mapping()</span></code></a>
before any <a class="reference internal" href="#c.irq_find_mapping" title="irq_find_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_find_mapping()</span></code></a> since the latter will actually work
for the static IRQ assignment case.</p>
</section>
<section id="hierarchy-irq-domain">
<h3>Hierarchy IRQ Domain<a class="headerlink" href="#hierarchy-irq-domain" title="Link to this heading">¶</a></h3>
<p>On some architectures, there may be multiple interrupt controllers
involved in delivering an interrupt from the device to the target CPU.
Let’s look at a typical interrupt delivering path on x86 platforms:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device --&gt; IOAPIC -&gt; Interrupt remapping Controller -&gt; Local APIC -&gt; CPU
</pre></div>
</div>
<p>There are three interrupt controllers involved:</p>
<ol class="arabic simple">
<li><p>IOAPIC controller</p></li>
<li><p>Interrupt remapping controller</p></li>
<li><p>Local APIC controller</p></li>
</ol>
<p>To support such a hardware topology and make software architecture match
hardware architecture, an irq_domain data structure is built for each
interrupt controller and those irq_domains are organized into hierarchy.
When building irq_domain hierarchy, the irq_domain near to the device is
child and the irq_domain near to CPU is parent. So a hierarchy structure
as below will be built for the example above:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU Vector irq_domain (root irq_domain to manage CPU vectors)
        ^
        |
Interrupt Remapping irq_domain (manage irq_remapping entries)
        ^
        |
IOAPIC irq_domain (manage IOAPIC delivery entries/pins)
</pre></div>
</div>
<p>There are four major interfaces to use hierarchy irq_domain:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#c.irq_domain_alloc_irqs" title="irq_domain_alloc_irqs"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_domain_alloc_irqs()</span></code></a>: allocate IRQ descriptors and interrupt
controller related resources to deliver these interrupts.</p></li>
<li><p><a class="reference internal" href="#c.irq_domain_free_irqs" title="irq_domain_free_irqs"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_domain_free_irqs()</span></code></a>: free IRQ descriptors and interrupt controller
related resources associated with these interrupts.</p></li>
<li><p><a class="reference internal" href="#c.irq_domain_activate_irq" title="irq_domain_activate_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_domain_activate_irq()</span></code></a>: activate interrupt controller hardware to
deliver the interrupt.</p></li>
<li><p><a class="reference internal" href="#c.irq_domain_deactivate_irq" title="irq_domain_deactivate_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_domain_deactivate_irq()</span></code></a>: deactivate interrupt controller hardware
to stop delivering the interrupt.</p></li>
</ol>
<p>The following is needed to support hierarchy irq_domain:</p>
<ol class="arabic simple">
<li><p>The <code class="xref c c-member docutils literal notranslate"><span class="pre">parent</span></code> field in <a class="reference internal" href="#c.irq_domain" title="irq_domain"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span></code></a> is used to
maintain irq_domain hierarchy information.</p></li>
<li><p>The <code class="xref c c-member docutils literal notranslate"><span class="pre">parent_data</span></code> field in <a class="reference internal" href="../genericirq.html#c.irq_data" title="irq_data"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span></code></a> is used to
build hierarchy irq_data to match hierarchy irq_domains. The
irq_data is used to store irq_domain pointer and hardware irq
number.</p></li>
<li><p>The <code class="xref c c-member docutils literal notranslate"><span class="pre">alloc()</span></code>, <code class="xref c c-member docutils literal notranslate"><span class="pre">free()</span></code>, and other callbacks in
<a class="reference internal" href="#c.irq_domain_ops" title="irq_domain_ops"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain_ops</span></code></a> to support hierarchy irq_domain operations.</p></li>
</ol>
<p>With the support of hierarchy irq_domain and hierarchy irq_data ready,
an irq_domain structure is built for each interrupt controller, and an
irq_data structure is allocated for each irq_domain associated with an
IRQ.</p>
<p>For an interrupt controller driver to support hierarchy irq_domain, it
needs to:</p>
<ol class="arabic simple">
<li><p>Implement irq_domain_ops.alloc() and irq_domain_ops.free()</p></li>
<li><p>Optionally, implement irq_domain_ops.activate() and
irq_domain_ops.deactivate().</p></li>
<li><p>Optionally, implement an irq_chip to manage the interrupt controller
hardware.</p></li>
<li><p>There is no need to implement irq_domain_ops.map() and
irq_domain_ops.unmap(). They are unused with hierarchy irq_domain.</p></li>
</ol>
<p>Note the hierarchy irq_domain is in no way x86-specific, and is
heavily used to support other architectures, such as ARM, ARM64 etc.</p>
<section id="stacked-irq-chip">
<h4>Stacked irq_chip<a class="headerlink" href="#stacked-irq-chip" title="Link to this heading">¶</a></h4>
<p>Now, we could go one step further to support stacked (hierarchy)
irq_chip. That is, an irq_chip is associated with each irq_data along
the hierarchy. A child irq_chip may implement a required action by
itself or by cooperating with its parent irq_chip.</p>
<p>With stacked irq_chip, interrupt controller driver only needs to deal
with the hardware managed by itself and may ask for services from its
parent irq_chip when needed. So we could achieve a much cleaner
software architecture.</p>
</section>
</section>
</section>
<section id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="Link to this heading">¶</a></h2>
<p>Most of the internals of the IRQ subsystem are exposed in debugfs by
turning CONFIG_GENERIC_IRQ_DEBUGFS on.</p>
</section>
<section id="structures-and-public-functions-provided">
<h2>Structures and Public Functions Provided<a class="headerlink" href="#structures-and-public-functions-provided" title="Link to this heading">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the structures
and exported kernel API functions which are used for IRQ domains.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.irq_fwspec">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_fwspec</span></span></span><a class="headerlink" href="#c.irq_fwspec" title="Link to this definition">¶</a><br /></dt>
<dd><p>generic IRQ specifier structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_fwspec {
    struct fwnode_handle    *fwnode;
    int param_count;
    u32 param[IRQ_DOMAIN_IRQ_SPEC_PARAMS];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>Pointer to a firmware-specific descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param_count</span></code></dt><dd><p>Number of device-specific parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>Device-specific parameters</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure, directly modeled after of_phandle_args, is used to
pass a device-specific description of an interrupt.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.irq_domain_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_ops</span></span></span><a class="headerlink" href="#c.irq_domain_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>Methods for irq_domain objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_domain_ops {
    int (*match)(struct irq_domain *d, struct device_node *node, enum irq_domain_bus_token bus_token);
    int (*select)(struct irq_domain *d, struct irq_fwspec *fwspec, enum irq_domain_bus_token bus_token);
    int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);
    void (*unmap)(struct irq_domain *d, unsigned int virq);
    int (*xlate)(struct irq_domain *d, struct device_node *node,const u32 *intspec, unsigned int intsize, unsigned long *out_hwirq, unsigned int *out_type);
#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY;
    int (*alloc)(struct irq_domain *d, unsigned int virq, unsigned int nr_irqs, void *arg);
    void (*free)(struct irq_domain *d, unsigned int virq, unsigned int nr_irqs);
    int (*activate)(struct irq_domain *d, struct irq_data *irqd, bool reserve);
    void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
    int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec, unsigned long *out_hwirq, unsigned int *out_type);
#endif;
#ifdef CONFIG_GENERIC_IRQ_DEBUGFS;
    void (*debug_show)(struct seq_file *m, struct irq_domain *d, struct irq_data *irqd, int ind);
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">match</span></code></dt><dd><p>Match an interrupt controller device node to a domain, returns
1 on a match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">select</span></code></dt><dd><p>Match an interrupt controller fw specification. It is more generic
than <strong>match</strong> as it receives a complete <a class="reference internal" href="#c.irq_fwspec" title="irq_fwspec"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_fwspec</span></code></a>. Therefore,
<strong>select</strong> is preferred if provided. Returns 1 on a match.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>Create or update a mapping between a virtual irq number and a hw
irq number. This is called only once for a given mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unmap</span></code></dt><dd><p>Dispose of such a mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xlate</span></code></dt><dd><p>Given a device tree node and interrupt specifier, decode
the hardware irq number and linux irq type value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alloc</span></code></dt><dd><p>Allocate <strong>nr_irqs</strong> interrupts starting from <strong>virq</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt><dd><p>Free <strong>nr_irqs</strong> interrupts starting from <strong>virq</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">activate</span></code></dt><dd><p>Activate one interrupt in HW (<strong>irqd</strong>). If <strong>reserve</strong> is set, only
reserve the vector. If unset, assign the vector (called from
<a class="reference internal" href="../genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deactivate</span></code></dt><dd><p>Disarm one interrupt (<strong>irqd</strong>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">translate</span></code></dt><dd><p>Given <strong>fwspec</strong>, decode the hardware irq number (<strong>out_hwirq</strong>) and
linux irq type value (<strong>out_type</strong>). This is a generalised <strong>xlate</strong>
(over <a class="reference internal" href="#c.irq_fwspec" title="irq_fwspec"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_fwspec</span></code></a>) and is preferred if provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debug_show</span></code></dt><dd><p>For domains to show specific data for an interrupt in debugfs.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Functions below are provided by the driver and called whenever a new mapping
is created or an old mapping is disposed. The driver can then proceed to
whatever internal data structures management is required. It also needs
to setup the irq_desc when returning from map().</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.irq_domain">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain</span></span></span><a class="headerlink" href="#c.irq_domain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Hardware interrupt number translation object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_domain {
    struct list_head                link;
    const char                      *name;
    const struct irq_domain_ops     *ops;
    void *host_data;
    unsigned int                    flags;
    unsigned int                    mapcount;
    struct mutex                    mutex;
    struct irq_domain               *root;
    struct fwnode_handle            *fwnode;
    enum irq_domain_bus_token       bus_token;
    struct irq_domain_chip_generic  *gc;
    struct device                   *dev;
    struct device                   *pm_dev;
#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY;
    struct irq_domain               *parent;
#endif;
#ifdef CONFIG_GENERIC_MSI_IRQ;
    const struct msi_parent_ops     *msi_parent_ops;
#endif;
    void (*exit)(struct irq_domain *d);
    irq_hw_number_t hwirq_max;
    unsigned int                    revmap_size;
    struct radix_tree_root          revmap_tree;
    struct irq_data __rcu           *revmap[] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt><dd><p>Element in global irq_domain list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of interrupt domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Pointer to irq_domain methods</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">host_data</span></code></dt><dd><p>Private data pointer for use by owner.  Not touched by irq_domain
core code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Per irq_domain flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mapcount</span></code></dt><dd><p>The number of mapped interrupts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>Domain lock, hierarchical domains use root domain’s lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">root</span></code></dt><dd><p>Pointer to root domain, or containing structure if non-hierarchical</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>Pointer to firmware node associated with the irq_domain. Pretty easy
to swap it for the of_node via the irq_domain_get_of_node accessor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_token</span></code></dt><dd><p><strong>fwnode</strong>’s device_node might be used for several irq domains. But
in connection with <strong>bus_token</strong>, the pair shall be unique in a
system.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gc</span></code></dt><dd><p>Pointer to a list of generic chips. There is a helper function for
setting up one or more generic chips for interrupt controllers
drivers using the generic chip library which uses this pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Pointer to the device which instantiated the irqdomain
With per device irq domains this is not necessarily the same
as <strong>pm_dev</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm_dev</span></code></dt><dd><p>Pointer to a device that can be utilized for power management
purposes related to the irq domain.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>Pointer to parent irq_domain to support hierarchy irq_domains</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msi_parent_ops</span></code></dt><dd><p>Pointer to MSI parent domain methods for per device domain init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exit</span></code></dt><dd><p>Function called when the domain is destroyed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwirq_max</span></code></dt><dd><p>Top limit for the HW irq number. Especially to avoid
conflicts/failures with reserved HW irqs. Can be ~0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">revmap_size</span></code></dt><dd><p>Size of the linear map table <strong>revmap</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">revmap_tree</span></code></dt><dd><p>Radix map tree for hwirqs that don’t fit in the linear map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">revmap</span></code></dt><dd><p>Linear table of irq_data pointers</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Optional elements:
Revmap data, used internally by the irq domain code:</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.irq_domain_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_info</span></span></span><a class="headerlink" href="#c.irq_domain_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Domain information structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct irq_domain_info {
    struct fwnode_handle                    *fwnode;
    unsigned int                            domain_flags;
    unsigned int                            size;
    irq_hw_number_t hwirq_max;
    int direct_max;
    unsigned int                            hwirq_base;
    unsigned int                            virq_base;
    enum irq_domain_bus_token               bus_token;
    const char                              *name_suffix;
    const struct irq_domain_ops             *ops;
    void *host_data;
#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY;
    struct irq_domain                       *parent;
#endif;
    struct irq_domain_chip_generic_info     *dgc_info;
    int (*init)(struct irq_domain *d);
    void (*exit)(struct irq_domain *d);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>firmware node for the interrupt controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain_flags</span></code></dt><dd><p>Additional flags to add to the domain flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of linear map; 0 for radix mapping only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwirq_max</span></code></dt><dd><p>Maximum number of interrupts supported by controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direct_max</span></code></dt><dd><p>Maximum value of direct maps;
Use ~0 for no limit; 0 for no direct mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwirq_base</span></code></dt><dd><p>The first hardware interrupt number (legacy domains only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">virq_base</span></code></dt><dd><p>The first Linux interrupt number for legacy domains to
immediately associate the interrupts after domain creation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_token</span></code></dt><dd><p>Domain bus token</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_suffix</span></code></dt><dd><p>Optional name suffix to avoid collisions when multiple
domains are added using same fwnode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Domain operation callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">host_data</span></code></dt><dd><p>Controller private data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>Pointer to the parent irq domain used in a hierarchy domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dgc_info</span></code></dt><dd><p>Geneneric chip information structure pointer used to
create generic chips for the domain if not NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init</span></code></dt><dd><p>Function called when the domain is created.
Allow to do some additional domain initialisation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exit</span></code></dt><dd><p>Function called when the domain is destroyed.
Allow to do some additional cleanup operation.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_create_linear">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_create_linear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain_ops" title="irq_domain_ops"><span class="n"><span class="pre">irq_domain_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">host_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_create_linear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate and register a linear revmap irq_domain.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>pointer to interrupt controller’s FW node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>Number of interrupts in the domain.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_domain_ops</span> <span class="pre">*ops</span></code></dt><dd><p>map/unmap domain callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*host_data</span></code></dt><dd><p>Controller private data pointer</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Newly created irq_domain</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_create_mapping">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_create_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="n"><span class="pre">hwirq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_create_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Map a hardware interrupt into linux irq space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain owning this hardware interrupt or NULL for default domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>hardware irq number in that domain space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only one mapping per hardware interrupt is permitted.</p>
<p>If the sense/trigger is to be specified, set_irq_type() should be called
on the number returned from that call.</p>
<p><strong>Return</strong></p>
<p>Linux irq number or 0 on error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_resolve_mapping">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">irq_desc</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">irq_resolve_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="n"><span class="pre">hwirq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_resolve_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find a linux irq from a hw irq number.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain owning this hardware interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>hardware irq number in that domain space</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Interrupt descriptor</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_find_mapping">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_find_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="n"><span class="pre">hwirq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_find_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find a linux irq from a hw irq number.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain owning this hardware interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>hardware irq number in that domain space</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Linux irq number or 0 if not found</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_create_hierarchy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_create_hierarchy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain_ops" title="irq_domain_ops"><span class="n"><span class="pre">irq_domain_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">host_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_create_hierarchy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add a irqdomain into the hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*parent</span></code></dt><dd><p>Parent irq domain to associate with the new domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>Irq domain flags associated to the domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>Size of the domain. See below</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>Optional fwnode of the interrupt controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_domain_ops</span> <span class="pre">*ops</span></code></dt><dd><p>Pointer to the interrupt domain callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*host_data</span></code></dt><dd><p>Controller private data pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>size</strong> is 0 a tree domain is created, otherwise a linear domain.</p>
<p>If successful the parent is associated to the new domain and the
domain flags are set.</p>
<p><strong>Return</strong></p>
<p>A pointer to IRQ domain, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_alloc_irqs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_alloc_irqs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_irqs</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_alloc_irqs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate IRQs from domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain to allocate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_irqs</span></code></dt><dd><p>number of IRQs to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>NUMA node id for memory allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>domain specific argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.__irq_domain_alloc_irqs" title="__irq_domain_alloc_irqs"><code class="xref c c-func docutils literal notranslate"><span class="pre">__irq_domain_alloc_irqs()</span></code></a>’ documentation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__irq_domain_alloc_fwnode">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__irq_domain_alloc_fwnode</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">phys_addr_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pa</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__irq_domain_alloc_fwnode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate a fwnode_handle suitable for identifying an irq domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>Type of irqchip_fwnode. See linux/irqdomain.h</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>Optional user provided id if name != NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Optional user provided domain name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">*pa</span></code></dt><dd><p>Optional user-provided physical address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a struct irqchip_fwid, and return a pointer to the embedded
fwnode_handle (or NULL on failure).</p>
<p><strong>Note</strong></p>
<p>The types IRQCHIP_FWNODE_NAMED and IRQCHIP_FWNODE_NAMED_ID are
solely to transport name information to irqdomain creation code. The
node is not stored. For other types the pointer is kept in the irq
domain struct.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_free_fwnode">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_free_fwnode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_free_fwnode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free a non-OF-backed fwnode_handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>fwnode_handle to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free a fwnode_handle allocated with irq_domain_alloc_fwnode.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_instantiate">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_instantiate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain_info" title="irq_domain_info"><span class="n"><span class="pre">irq_domain_info</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_instantiate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Instantiate a new irq domain data structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_domain_info</span> <span class="pre">*info</span></code></dt><dd><p>Domain information pointer pointing to the information for this domain</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the instantiated irq domain or an ERR_PTR value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove an irq domain.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used to remove an irq domain. The caller must ensure
that all mappings within the domain have been disposed of prior to
use, depending on the revmap type.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_create_simple">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_create_simple</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">first_irq</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain_ops" title="irq_domain_ops"><span class="n"><span class="pre">irq_domain_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">host_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_create_simple" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register an irq_domain and optionally map a range of irqs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>firmware node for the interrupt controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>total number of irqs in mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">first_irq</span></code></dt><dd><p>first number of irq block assigned to the domain,
pass zero to assign irqs on-the-fly. If first_irq is non-zero, then
pre-map all of the irqs in the domain to virqs starting at first_irq.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_domain_ops</span> <span class="pre">*ops</span></code></dt><dd><p>domain callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*host_data</span></code></dt><dd><p>Controller private data pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an irq_domain, and optionally if first_irq is positive then also
allocate irq_descs and map all of the hwirqs to virqs starting at first_irq.</p>
<p>This is intended to implement the expected behaviour for most
interrupt controllers. If device tree is used, then first_irq will be 0 and
irqs get mapped dynamically on the fly. However, if the controller requires
static virq assignments (non-DT boot) then it will set that up correctly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_find_matching_fwspec">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">irq_find_matching_fwspec</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_fwspec" title="irq_fwspec"><span class="n"><span class="pre">irq_fwspec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwspec</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">irq_domain_bus_token</span></span><span class="w"> </span><span class="n"><span class="pre">bus_token</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_find_matching_fwspec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Locates a domain for a given fwspec</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_fwspec</span> <span class="pre">*fwspec</span></code></dt><dd><p>FW specifier for an interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">irq_domain_bus_token</span> <span class="pre">bus_token</span></code></dt><dd><p>domain-specific data</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_set_default_domain">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_set_default_domain</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_default_domain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set a “default” irq domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>default domain pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For convenience, it’s possible to set a “default” domain that will be used
whenever NULL is passed to <a class="reference internal" href="#c.irq_create_mapping" title="irq_create_mapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_create_mapping()</span></code></a>. It makes life easier for
platforms that want to manipulate a few hard coded interrupt numbers that
aren’t properly represented in the device-tree.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_get_default_domain">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">irq_get_default_domain</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_default_domain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Retrieve the “default” irq domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the default domain, if any.</p>
<p><strong>Description</strong></p>
<p>Modern code should never use this. This should only be used on
systems that cannot implement a firmware-&gt;fwnode mapping (which
both DT and ACPI provide).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_create_direct_mapping">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_create_direct_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_create_direct_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate an irq for direct mapping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain to allocate the irq for or NULL for default domain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used for irq controllers which can choose the hardware
interrupt numbers they generate. In such a case it’s simplest to use
the linux irq as the hardware interrupt number. It still uses the linear
or radix tree to store the mapping, but the irq controller can optimize
the revmap path by using the hwirq directly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_create_mapping_affinity">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_create_mapping_affinity</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="n"><span class="pre">hwirq</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../genericirq.html#c.irq_affinity_desc" title="irq_affinity_desc"><span class="n"><span class="pre">irq_affinity_desc</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">affinity</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_create_mapping_affinity" title="Link to this definition">¶</a><br /></dt>
<dd><p>Map a hardware interrupt into linux irq space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain owning this hardware interrupt or NULL for default domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>hardware irq number in that domain space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_affinity_desc</span> <span class="pre">*affinity</span></code></dt><dd><p>irq affinity</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only one mapping per hardware interrupt is permitted. Returns a linux
irq number.
If the sense/trigger is to be specified, set_irq_type() should be called
on the number returned from that call.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_dispose_mapping">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_dispose_mapping</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_dispose_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unmap an interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>linux irq number of the interrupt to unmap</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__irq_resolve_mapping">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">irq_desc</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__irq_resolve_mapping</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="n"><span class="pre">hwirq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">irq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__irq_resolve_mapping" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find a linux irq from a hw irq number.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain owning this hardware interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>hardware irq number in that domain space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*irq</span></code></dt><dd><p>optional pointer to return the Linux irq if required</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the interrupt descriptor.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_xlate_onecell">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_xlate_onecell</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctrlr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">intspec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">intsize</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_hwirq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_xlate_onecell" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic xlate for direct one cell bindings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>Interrupt domain involved in the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*ctrlr</span></code></dt><dd><p>The device tree node for the device whose interrupt is translated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*intspec</span></code></dt><dd><p>The interrupt specifier data from the device tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">intsize</span></code></dt><dd><p>The number of entries in <strong>intspec</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*out_hwirq</span></code></dt><dd><p>Pointer to storage for the hardware interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*out_type</span></code></dt><dd><p>Pointer to storage for the interrupt type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device Tree IRQ specifier translation function which works with one cell
bindings where the cell value maps directly to the hwirq number.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_xlate_twocell">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_xlate_twocell</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctrlr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">intspec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">intsize</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_hwirq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_xlate_twocell" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic xlate for direct two cell bindings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>Interrupt domain involved in the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*ctrlr</span></code></dt><dd><p>The device tree node for the device whose interrupt is translated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*intspec</span></code></dt><dd><p>The interrupt specifier data from the device tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">intsize</span></code></dt><dd><p>The number of entries in <strong>intspec</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">*out_hwirq</span></code></dt><dd><p>Pointer to storage for the hardware interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*out_type</span></code></dt><dd><p>Pointer to storage for the interrupt type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device Tree IRQ specifier translation function which works with two cell
bindings where the cell values map directly to the hwirq number
and linux irq flags.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_xlate_twothreecell">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_xlate_twothreecell</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctrlr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">intspec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">intsize</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_hwirq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_xlate_twothreecell" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic xlate for direct two or three cell bindings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>Interrupt domain involved in the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*ctrlr</span></code></dt><dd><p>The device tree node for the device whose interrupt is translated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*intspec</span></code></dt><dd><p>The interrupt specifier data from the device tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">intsize</span></code></dt><dd><p>The number of entries in <strong>intspec</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">*out_hwirq</span></code></dt><dd><p>Pointer to storage for the hardware interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*out_type</span></code></dt><dd><p>Pointer to storage for the interrupt type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device Tree interrupt specifier translation function for two or three
cell bindings, where the cell values map directly to the hardware
interrupt number and the type specifier.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_xlate_onetwocell">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_xlate_onetwocell</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctrlr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">intspec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">intsize</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_hwirq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_xlate_onetwocell" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic xlate for one or two cell bindings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>Interrupt domain involved in the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*ctrlr</span></code></dt><dd><p>The device tree node for the device whose interrupt is translated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*intspec</span></code></dt><dd><p>The interrupt specifier data from the device tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">intsize</span></code></dt><dd><p>The number of entries in <strong>intspec</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*out_hwirq</span></code></dt><dd><p>Pointer to storage for the hardware interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*out_type</span></code></dt><dd><p>Pointer to storage for the interrupt type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device Tree IRQ specifier translation function which works with either one
or two cell bindings where the cell values map directly to the hwirq number
and linux irq flags.</p>
<p><strong>Note</strong></p>
<p>don’t use this function unless your interrupt controller explicitly
supports both one and two cell bindings.  For the majority of controllers
the _onecell() or _twocell() variants above should be used.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_translate_onecell">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_translate_onecell</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_fwspec" title="irq_fwspec"><span class="n"><span class="pre">irq_fwspec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwspec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_hwirq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_translate_onecell" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic translate for direct one cell bindings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>Interrupt domain involved in the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_fwspec</span> <span class="pre">*fwspec</span></code></dt><dd><p>The firmware interrupt specifier to translate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*out_hwirq</span></code></dt><dd><p>Pointer to storage for the hardware interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*out_type</span></code></dt><dd><p>Pointer to storage for the interrupt type</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_translate_twocell">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_translate_twocell</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_fwspec" title="irq_fwspec"><span class="n"><span class="pre">irq_fwspec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwspec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_hwirq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_translate_twocell" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic translate for direct two cell bindings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>Interrupt domain involved in the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_fwspec</span> <span class="pre">*fwspec</span></code></dt><dd><p>The firmware interrupt specifier to translate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*out_hwirq</span></code></dt><dd><p>Pointer to storage for the hardware interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*out_type</span></code></dt><dd><p>Pointer to storage for the interrupt type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device Tree IRQ specifier translation function which works with two cell
bindings where the cell values map directly to the hwirq number
and linux irq flags.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_translate_twothreecell">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_translate_twothreecell</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_fwspec" title="irq_fwspec"><span class="n"><span class="pre">irq_fwspec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwspec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_hwirq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_translate_twothreecell" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generic translate for direct two or three cell bindings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>Interrupt domain involved in the translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_fwspec</span> <span class="pre">*fwspec</span></code></dt><dd><p>The firmware interrupt specifier to translate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*out_hwirq</span></code></dt><dd><p>Pointer to storage for the hardware interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*out_type</span></code></dt><dd><p>Pointer to storage for the interrupt type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Firmware interrupt specifier translation function for two or three cell
specifications, where the parameter values map directly to the hardware
interrupt number and the type specifier.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_reset_irq_data">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_reset_irq_data</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain_reset_irq_data" title="irq_data"><span class="n"><span class="pre">irq_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">irq_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_reset_irq_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear hwirq, chip and chip_data in <strong>irq_data</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*irq_data</span></code></dt><dd><p>The pointer to irq_data</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_disconnect_hierarchy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_disconnect_hierarchy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_disconnect_hierarchy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Mark the first unused level of a hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>IRQ domain from which the hierarchy is to be disconnected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>IRQ number where the hierarchy is to be trimmed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks the <strong>virq</strong> level belonging to <strong>domain</strong> as disconnected.
Returns -EINVAL if <strong>virq</strong> doesn’t have a valid irq_data pointing
to <strong>domain</strong>.</p>
<p>Its only use is to be able to trim levels of hierarchy that do not
have any real meaning for this interrupt, and that the driver marks
as such from its .alloc() callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_get_irq_data">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../genericirq.html#c.irq_data" title="irq_data"><span class="n"><span class="pre">irq_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_get_irq_data</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_get_irq_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get irq_data associated with <strong>virq</strong> and <strong>domain</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>IRQ number to get irq_data</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_set_hwirq_and_chip">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_set_hwirq_and_chip</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="n"><span class="pre">hwirq</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../genericirq.html#c.irq_chip" title="irq_chip"><span class="n"><span class="pre">irq_chip</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chip</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chip_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_set_hwirq_and_chip" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set hwirq and irqchip of <strong>virq</strong> at <strong>domain</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>Interrupt domain to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>IRQ number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>The hwirq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The associated interrupt chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*chip_data</span></code></dt><dd><p>The associated chip data</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_set_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_set_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span>, <span class="n"><span class="pre">irq_hw_number_t</span></span><span class="w"> </span><span class="n"><span class="pre">hwirq</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../genericirq.html#c.irq_chip" title="irq_chip"><span class="n"><span class="pre">irq_chip</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chip</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chip_data</span></span>, <span class="n"><span class="pre">irq_flow_handler_t</span></span><span class="w"> </span><span class="n"><span class="pre">handler</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handler_data</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handler_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_set_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the complete data for a <strong>virq</strong> in <strong>domain</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>Interrupt domain to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>IRQ number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>The hardware interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The associated interrupt chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*chip_data</span></code></dt><dd><p>The associated interrupt chip data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_flow_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>The interrupt flow handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*handler_data</span></code></dt><dd><p>The interrupt flow handler data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*handler_name</span></code></dt><dd><p>The interrupt handler name</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_free_irqs_common">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_free_irqs_common</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_irqs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_free_irqs_common" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear irq_data and free the parent</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>Interrupt domain to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>IRQ number to start with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_irqs</span></code></dt><dd><p>The number of irqs to free</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__irq_domain_alloc_irqs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__irq_domain_alloc_irqs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq_base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_irqs</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">realloc</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../genericirq.html#c.irq_affinity_desc" title="irq_affinity_desc"><span class="n"><span class="pre">irq_affinity_desc</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">affinity</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__irq_domain_alloc_irqs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate IRQs from domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>domain to allocate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq_base</span></code></dt><dd><p>allocate specified IRQ number if irq_base &gt;= 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_irqs</span></code></dt><dd><p>number of IRQs to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>NUMA node id for memory allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>domain specific argument</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">realloc</span></code></dt><dd><p>IRQ descriptors have already been allocated if true</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_affinity_desc</span> <span class="pre">*affinity</span></code></dt><dd><p>Optional irq affinity mask for multiqueue devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate IRQ numbers and initialized all data structures to support
hierarchy IRQ domains.
Parameter <strong>realloc</strong> is mainly to support legacy IRQs.
Returns error code or allocated IRQ number</p>
<p>The whole process to setup an IRQ has been split into two steps.
The first step, <a class="reference internal" href="#c.__irq_domain_alloc_irqs" title="__irq_domain_alloc_irqs"><code class="xref c c-func docutils literal notranslate"><span class="pre">__irq_domain_alloc_irqs()</span></code></a>, is to allocate IRQ
descriptor and required hardware resources. The second step,
<a class="reference internal" href="#c.irq_domain_activate_irq" title="irq_domain_activate_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_domain_activate_irq()</span></code></a>, is to program the hardware with preallocated
resources. In this way, it’s easier to rollback when failing to
allocate resources.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_push_irq">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_push_irq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_push_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Push a domain in to the top of a hierarchy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>Domain to push.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>Irq to push the domain in to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>Passed to the irq_domain_ops alloc() function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For an already existing irqdomain hierarchy, as might be obtained
via a call to pci_enable_msix(), add an additional domain to the
head of the processing chain.  Must be called before <a class="reference internal" href="../genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a>
has been called.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_pop_irq">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_pop_irq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_pop_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove a domain from the top of a hierarchy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>Domain to remove.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>Irq to remove the domain from.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo the effects of a call to <a class="reference internal" href="#c.irq_domain_push_irq" title="irq_domain_push_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_domain_push_irq()</span></code></a>.  Must be
called either before <a class="reference internal" href="../genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> or after <a class="reference internal" href="../genericirq.html#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_alloc_irqs_parent">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_alloc_irqs_parent</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq_base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_irqs</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_alloc_irqs_parent" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate interrupts from parent domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>Domain below which interrupts must be allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq_base</span></code></dt><dd><p>Base IRQ number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_irqs</span></code></dt><dd><p>Number of IRQs to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>Allocation data (arch/domain specific)</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_free_irqs_parent">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_free_irqs_parent</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq_base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_irqs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_free_irqs_parent" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free interrupts from parent domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>Domain below which interrupts must be freed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq_base</span></code></dt><dd><p>Base IRQ number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_irqs</span></code></dt><dd><p>Number of IRQs to free</p>
</dd>
</dl>
</div>
</section>
<section id="internal-functions-provided">
<h2>Internal Functions Provided<a class="headerlink" href="#internal-functions-provided" title="Link to this heading">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the internal
functions.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_free_irqs_top">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_free_irqs_top</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain" title="irq_domain"><span class="n"><span class="pre">irq_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_irqs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_free_irqs_top" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear handler and handler data, clear irqdata and free parent</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>Interrupt domain to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>IRQ number to start with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_irqs</span></code></dt><dd><p>The number of irqs to free</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_free_irqs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_free_irqs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">virq</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_irqs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_free_irqs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free IRQ number and associated data structures</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">virq</span></code></dt><dd><p>base IRQ number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_irqs</span></code></dt><dd><p>number of IRQs to free</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_activate_irq">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_activate_irq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain_activate_irq" title="irq_data"><span class="n"><span class="pre">irq_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">irq_data</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">reserve</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_activate_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Call domain_ops-&gt;activate recursively to activate interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*irq_data</span></code></dt><dd><p>Outermost irq_data associated with interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">reserve</span></code></dt><dd><p>If set only reserve an interrupt vector instead of assigning one</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the second step to call domain_ops-&gt;activate to program interrupt
controllers, so the interrupt could actually get delivered.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.irq_domain_deactivate_irq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">irq_domain_deactivate_irq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.irq_domain_deactivate_irq" title="irq_data"><span class="n"><span class="pre">irq_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">irq_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_domain_deactivate_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Call domain_ops-&gt;deactivate recursively to deactivate interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*irq_data</span></code></dt><dd><p>outermost irq_data associated with interrupt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It calls domain_ops-&gt;deactivate to program interrupt controllers to disable
interrupt delivery.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/core-api/irq/irq-domain.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>