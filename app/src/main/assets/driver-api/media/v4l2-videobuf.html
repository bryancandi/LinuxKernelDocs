
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>2.16. Videobuf Framework &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.17. V4L2 videobuf2 functions and data structures" href="v4l2-videobuf2.html" />
    <link rel="prev" title="2.15. V4L2 Controls" href="v4l2-controls.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.5.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver implementer's API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization (dma-buf)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer's API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer's Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas' 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer's Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="maintainer-entry-profile.html">1. Media Subsystem Profile</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="v4l2-core.html">2. Video4Linux devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html">3. Digital TV (DVB) devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">4. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">5. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">6. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="tx-rx.html">7. Pixel data transmitter and receiver drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="camera-sensor.html">8. Writing camera sensor drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers/index.html">9. Media driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - &quot;Virtual Function I/O&quot; </a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-pci-device-specific-driver-acceptance.html">Acceptance criteria for vfio-pci device specific driver variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../virtio/index.html">Virtio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Kernel subsystem documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  sbar.scrollTop = currents[currents.length - 1].offsetTop;
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/media/v4l2-videobuf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="videobuf-framework">
<span id="vb-framework"></span><h1><span class="section-number">2.16. </span>Videobuf Framework<a class="headerlink" href="#videobuf-framework" title="Permalink to this heading">¶</a></h1>
<p>Author: Jonathan Corbet &lt;<a class="reference external" href="mailto:corbet&#37;&#52;&#48;lwn&#46;net">corbet<span>&#64;</span>lwn<span>&#46;</span>net</a>&gt;</p>
<p>Current as of 2.6.33</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The videobuf framework was deprecated in favor of videobuf2. Shouldn't
be used on new drivers.</p>
</div>
<section id="introduction">
<h2><span class="section-number">2.16.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>The videobuf layer functions as a sort of glue layer between a V4L2 driver
and user space.  It handles the allocation and management of buffers for
the storage of video frames.  There is a set of functions which can be used
to implement many of the standard POSIX I/O system calls, including read(),
poll(), and, happily, mmap().  Another set of functions can be used to
implement the bulk of the V4L2 ioctl() calls related to streaming I/O,
including buffer allocation, queueing and dequeueing, and streaming
control.  Using videobuf imposes a few design decisions on the driver
author, but the payback comes in the form of reduced code in the driver and
a consistent implementation of the V4L2 user-space API.</p>
</section>
<section id="buffer-types">
<h2><span class="section-number">2.16.2. </span>Buffer types<a class="headerlink" href="#buffer-types" title="Permalink to this heading">¶</a></h2>
<p>Not all video devices use the same kind of buffers.  In fact, there are (at
least) three common variations:</p>
<blockquote>
<div><ul class="simple">
<li><p>Buffers which are scattered in both the physical and (kernel) virtual
address spaces.  (Almost) all user-space buffers are like this, but it
makes great sense to allocate kernel-space buffers this way as well when
it is possible.  Unfortunately, it is not always possible; working with
this kind of buffer normally requires hardware which can do
scatter/gather DMA operations.</p></li>
<li><p>Buffers which are physically scattered, but which are virtually
contiguous; buffers allocated with <a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>, in other words.  These
buffers are just as hard to use for DMA operations, but they can be
useful in situations where DMA is not available but virtually-contiguous
buffers are convenient.</p></li>
<li><p>Buffers which are physically contiguous.  Allocation of this kind of
buffer can be unreliable on fragmented systems, but simpler DMA
controllers cannot deal with anything else.</p></li>
</ul>
</div></blockquote>
<p>Videobuf can work with all three types of buffers, but the driver author
must pick one at the outset and design the driver around that decision.</p>
<p>[It's worth noting that there's a fourth kind of buffer: &quot;overlay&quot; buffers
which are located within the system's video memory.  The overlay
functionality is considered to be deprecated for most use, but it still
shows up occasionally in system-on-chip drivers where the performance
benefits merit the use of this technique.  Overlay buffers can be handled
as a form of scattered buffer, but there are very few implementations in
the kernel and a description of this technique is currently beyond the
scope of this document.]</p>
</section>
<section id="data-structures-callbacks-and-initialization">
<h2><span class="section-number">2.16.3. </span>Data structures, callbacks, and initialization<a class="headerlink" href="#data-structures-callbacks-and-initialization" title="Permalink to this heading">¶</a></h2>
<p>Depending on which type of buffers are being used, the driver should
include one of the following files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;media/videobuf-dma-sg.h&gt;           /* Physically scattered */
&lt;media/videobuf-vmalloc.h&gt;          /* vmalloc() buffers    */
&lt;media/videobuf-dma-contig.h&gt;       /* Physically contiguous */
</pre></div>
</div>
<p>The driver's data structure describing a V4L2 device should include a
struct videobuf_queue instance for the management of the buffer queue,
along with a list_head for the queue of available buffers.  There will also
need to be an interrupt-safe spinlock which is used to protect (at least)
the queue.</p>
<p>The next step is to write four simple callbacks to help videobuf deal with
the management of buffers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct videobuf_queue_ops {
    int (*buf_setup)(struct videobuf_queue *q,
                     unsigned int *count, unsigned int *size);
    int (*buf_prepare)(struct videobuf_queue *q,
                       struct videobuf_buffer *vb,
                       enum v4l2_field field);
    void (*buf_queue)(struct videobuf_queue *q,
                      struct videobuf_buffer *vb);
    void (*buf_release)(struct videobuf_queue *q,
                        struct videobuf_buffer *vb);
};
</pre></div>
</div>
<p>buf_setup() is called early in the I/O process, when streaming is being
initiated; its purpose is to tell videobuf about the I/O stream.  The count
parameter will be a suggested number of buffers to use; the driver should
check it for rationality and adjust it if need be.  As a practical rule, a
minimum of two buffers are needed for proper streaming, and there is
usually a maximum (which cannot exceed 32) which makes sense for each
device.  The size parameter should be set to the expected (maximum) size
for each frame of data.</p>
<p>Each buffer (in the form of a struct videobuf_buffer pointer) will be
passed to buf_prepare(), which should set the buffer's size, width, height,
and field fields properly.  If the buffer's state field is
VIDEOBUF_NEEDS_INIT, the driver should pass it to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int videobuf_iolock(struct videobuf_queue* q, struct videobuf_buffer *vb,
                    struct v4l2_framebuffer *fbuf);
</pre></div>
</div>
<p>Among other things, this call will usually allocate memory for the buffer.
Finally, the buf_prepare() function should set the buffer's state to
VIDEOBUF_PREPARED.</p>
<p>When a buffer is queued for I/O, it is passed to buf_queue(), which should
put it onto the driver's list of available buffers and set its state to
VIDEOBUF_QUEUED.  Note that this function is called with the queue spinlock
held; if it tries to acquire it as well things will come to a screeching
halt.  Yes, this is the voice of experience.  Note also that videobuf may
wait on the first buffer in the queue; placing other buffers in front of it
could again gum up the works.  So use <a class="reference internal" href="../../core-api/kernel-api.html#c.list_add_tail" title="list_add_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_tail()</span></code></a> to enqueue buffers.</p>
<p>Finally, buf_release() is called when a buffer is no longer intended to be
used.  The driver should ensure that there is no I/O active on the buffer,
then pass it to the appropriate free routine(s):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Scatter/gather drivers */
int videobuf_dma_unmap(struct videobuf_queue *q,
                       struct videobuf_dmabuf *dma);
int videobuf_dma_free(struct videobuf_dmabuf *dma);

/* vmalloc drivers */
void videobuf_vmalloc_free (struct videobuf_buffer *buf);

/* Contiguous drivers */
void videobuf_dma_contig_free(struct videobuf_queue *q,
                              struct videobuf_buffer *buf);
</pre></div>
</div>
<p>One way to ensure that a buffer is no longer under I/O is to pass it to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int videobuf_waiton(struct videobuf_buffer *vb, int non_blocking, int intr);
</pre></div>
</div>
<p>Here, vb is the buffer, non_blocking indicates whether non-blocking I/O
should be used (it should be zero in the buf_release() case), and intr
controls whether an interruptible wait is used.</p>
</section>
<section id="file-operations">
<h2><span class="section-number">2.16.4. </span>File operations<a class="headerlink" href="#file-operations" title="Permalink to this heading">¶</a></h2>
<p>At this point, much of the work is done; much of the rest is slipping
videobuf calls into the implementation of the other driver callbacks.  The
first step is in the open() function, which must initialize the
videobuf queue.  The function to use depends on the type of buffer used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void videobuf_queue_sg_init(struct videobuf_queue *q,
                            struct videobuf_queue_ops *ops,
                            struct device *dev,
                            spinlock_t *irqlock,
                            enum v4l2_buf_type type,
                            enum v4l2_field field,
                            unsigned int msize,
                            void *priv);

void videobuf_queue_vmalloc_init(struct videobuf_queue *q,
                            struct videobuf_queue_ops *ops,
                            struct device *dev,
                            spinlock_t *irqlock,
                            enum v4l2_buf_type type,
                            enum v4l2_field field,
                            unsigned int msize,
                            void *priv);

void videobuf_queue_dma_contig_init(struct videobuf_queue *q,
                                   struct videobuf_queue_ops *ops,
                                   struct device *dev,
                                   spinlock_t *irqlock,
                                   enum v4l2_buf_type type,
                                   enum v4l2_field field,
                                   unsigned int msize,
                                   void *priv);
</pre></div>
</div>
<p>In each case, the parameters are the same: q is the queue structure for the
device, ops is the set of callbacks as described above, dev is the device
structure for this video device, irqlock is an interrupt-safe spinlock to
protect access to the data structures, type is the buffer type used by the
device (cameras will use V4L2_BUF_TYPE_VIDEO_CAPTURE, for example), field
describes which field is being captured (often V4L2_FIELD_NONE for
progressive devices), msize is the size of any containing structure used
around struct videobuf_buffer, and priv is a private data pointer which
shows up in the priv_data field of struct videobuf_queue.  Note that these
are void functions which, evidently, are immune to failure.</p>
<p>V4L2 capture drivers can be written to support either of two APIs: the
read() system call and the rather more complicated streaming mechanism.  As
a general rule, it is necessary to support both to ensure that all
applications have a chance of working with the device.  Videobuf makes it
easy to do that with the same code.  To implement read(), the driver need
only make a call to one of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ssize_t videobuf_read_one(struct videobuf_queue *q,
                          char __user *data, size_t count,
                          loff_t *ppos, int nonblocking);

ssize_t videobuf_read_stream(struct videobuf_queue *q,
                             char __user *data, size_t count,
                             loff_t *ppos, int vbihack, int nonblocking);
</pre></div>
</div>
<p>Either one of these functions will read frame data into data, returning the
amount actually read; the difference is that videobuf_read_one() will only
read a single frame, while videobuf_read_stream() will read multiple frames
if they are needed to satisfy the count requested by the application.  A
typical driver read() implementation will start the capture engine, call
one of the above functions, then stop the engine before returning (though a
smarter implementation might leave the engine running for a little while in
anticipation of another read() call happening in the near future).</p>
<p>The poll() function can usually be implemented with a direct call to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned int videobuf_poll_stream(struct file *file,
                                  struct videobuf_queue *q,
                                  poll_table *wait);
</pre></div>
</div>
<p>Note that the actual wait queue eventually used will be the one associated
with the first available buffer.</p>
<p>When streaming I/O is done to kernel-space buffers, the driver must support
the mmap() system call to enable user space to access the data.  In many
V4L2 drivers, the often-complex mmap() implementation simplifies to a
single call to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int videobuf_mmap_mapper(struct videobuf_queue *q,
                         struct vm_area_struct *vma);
</pre></div>
</div>
<p>Everything else is handled by the videobuf code.</p>
<p>The release() function requires two separate videobuf calls:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void videobuf_stop(struct videobuf_queue *q);
int videobuf_mmap_free(struct videobuf_queue *q);
</pre></div>
</div>
<p>The call to videobuf_stop() terminates any I/O in progress - though it is
still up to the driver to stop the capture engine.  The call to
videobuf_mmap_free() will ensure that all buffers have been unmapped; if
so, they will all be passed to the buf_release() callback.  If buffers
remain mapped, videobuf_mmap_free() returns an error code instead.  The
purpose is clearly to cause the closing of the file descriptor to fail if
buffers are still mapped, but every driver in the 2.6.32 kernel cheerfully
ignores its return value.</p>
</section>
<section id="ioctl-operations">
<h2><span class="section-number">2.16.5. </span>ioctl() operations<a class="headerlink" href="#ioctl-operations" title="Permalink to this heading">¶</a></h2>
<p>The V4L2 API includes a very long list of driver callbacks to respond to
the many ioctl() commands made available to user space.  A number of these
- those associated with streaming I/O - turn almost directly into videobuf
calls.  The relevant helper functions are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int videobuf_reqbufs(struct videobuf_queue *q,
                     struct v4l2_requestbuffers *req);
int videobuf_querybuf(struct videobuf_queue *q, struct v4l2_buffer *b);
int videobuf_qbuf(struct videobuf_queue *q, struct v4l2_buffer *b);
int videobuf_dqbuf(struct videobuf_queue *q, struct v4l2_buffer *b,
                   int nonblocking);
int videobuf_streamon(struct videobuf_queue *q);
int videobuf_streamoff(struct videobuf_queue *q);
</pre></div>
</div>
<p>So, for example, a VIDIOC_REQBUFS call turns into a call to the driver's
vidioc_reqbufs() callback which, in turn, usually only needs to locate the
proper struct videobuf_queue pointer and pass it to videobuf_reqbufs().
These support functions can replace a great deal of buffer management
boilerplate in a lot of V4L2 drivers.</p>
<p>The vidioc_streamon() and vidioc_streamoff() functions will be a bit more
complex, of course, since they will also need to deal with starting and
stopping the capture engine.</p>
</section>
<section id="buffer-allocation">
<h2><span class="section-number">2.16.6. </span>Buffer allocation<a class="headerlink" href="#buffer-allocation" title="Permalink to this heading">¶</a></h2>
<p>Thus far, we have talked about buffers, but have not looked at how they are
allocated.  The scatter/gather case is the most complex on this front.  For
allocation, the driver can leave buffer allocation entirely up to the
videobuf layer; in this case, buffers will be allocated as anonymous
user-space pages and will be very scattered indeed.  If the application is
using user-space buffers, no allocation is needed; the videobuf layer will
take care of calling get_user_pages() and filling in the scatterlist array.</p>
<p>If the driver needs to do its own memory allocation, it should be done in
the vidioc_reqbufs() function, <em>after</em> calling videobuf_reqbufs().  The
first step is a call to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct videobuf_dmabuf *videobuf_to_dma(struct videobuf_buffer *buf);
</pre></div>
</div>
<p>The returned videobuf_dmabuf structure (defined in
&lt;media/videobuf-dma-sg.h&gt;) includes a couple of relevant fields:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct scatterlist  *sglist;
int                 sglen;
</pre></div>
</div>
<p>The driver must allocate an appropriately-sized scatterlist array and
populate it with pointers to the pieces of the allocated buffer; sglen
should be set to the length of the array.</p>
<p>Drivers using the <a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a> method need not (and cannot) concern themselves
with buffer allocation at all; videobuf will handle those details.  The
same is normally true of contiguous-DMA drivers as well; videobuf will
allocate the buffers (with dma_alloc_coherent()) when it sees fit.  That
means that these drivers may be trying to do high-order allocations at any
time, an operation which is not always guaranteed to work.  Some drivers
play tricks by allocating DMA space at system boot time; videobuf does not
currently play well with those drivers.</p>
<p>As of 2.6.31, contiguous-DMA drivers can work with a user-supplied buffer,
as long as that buffer is physically contiguous.  Normal user-space
allocations will not meet that criterion, but buffers obtained from other
kernel drivers, or those contained within huge pages, will work with these
drivers.</p>
</section>
<section id="filling-the-buffers">
<h2><span class="section-number">2.16.7. </span>Filling the buffers<a class="headerlink" href="#filling-the-buffers" title="Permalink to this heading">¶</a></h2>
<p>The final part of a videobuf implementation has no direct callback - it's
the portion of the code which actually puts frame data into the buffers,
usually in response to interrupts from the device.  For all types of
drivers, this process works approximately as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>Obtain the next available buffer and make sure that somebody is actually
waiting for it.</p></li>
<li><p>Get a pointer to the memory and put video data there.</p></li>
<li><p>Mark the buffer as done and wake up the process waiting for it.</p></li>
</ul>
</div></blockquote>
<p>Step (1) above is done by looking at the driver-managed list_head structure
- the one which is filled in the buf_queue() callback.  Because starting
the engine and enqueueing buffers are done in separate steps, it's possible
for the engine to be running without any buffers available - in the
<a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a> case especially.  So the driver should be prepared for the list
to be empty.  It is equally possible that nobody is yet interested in the
buffer; the driver should not remove it from the list or fill it until a
process is waiting on it.  That test can be done by examining the buffer's
done field (a wait_queue_head_t structure) with <a class="reference internal" href="../basics.html#c.waitqueue_active" title="waitqueue_active"><code class="xref c c-func docutils literal notranslate"><span class="pre">waitqueue_active()</span></code></a>.</p>
<p>A buffer's state should be set to VIDEOBUF_ACTIVE before being mapped for
DMA; that ensures that the videobuf layer will not try to do anything with
it while the device is transferring data.</p>
<p>For scatter/gather drivers, the needed memory pointers will be found in the
scatterlist structure described above.  Drivers using the <a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a> method
can get a memory pointer with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void *videobuf_to_vmalloc(struct videobuf_buffer *buf);
</pre></div>
</div>
<p>For contiguous DMA drivers, the function to use is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dma_addr_t videobuf_to_dma_contig(struct videobuf_buffer *buf);
</pre></div>
</div>
<p>The contiguous DMA API goes out of its way to hide the kernel-space address
of the DMA buffer from drivers.</p>
<p>The final step is to set the size field of the relevant videobuf_buffer
structure to the actual size of the captured image, set state to
VIDEOBUF_DONE, then call wake_up() on the done queue.  At this point, the
buffer is owned by the videobuf layer and the driver should not touch it
again.</p>
<p>Developers who are interested in more information can go into the relevant
header files; there are a few low-level functions declared there which have
not been talked about here.  Note also that all of these calls are exported
GPL-only, so they will not be available to non-GPL kernel modules.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/media/v4l2-videobuf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>