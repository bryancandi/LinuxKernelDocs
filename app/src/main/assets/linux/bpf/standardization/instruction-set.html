<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>1 BPF Instruction Set Architecture (ISA) &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=3918102e" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="1 BPF ABI Recommended Conventions and Guidelines v1.0" href="abi.html" />
    <link rel="prev" title="BPF Standardization" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.12.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cpu-freq/index.html">CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../fpga/index.html">FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../pcmcia/index.html">PCMCIA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../watchdog/index.html">Watchdog Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../virt/index.html">Virtualization Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hwmon/index.html">Hardware Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../accel/index.html">Compute Accelerators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../crypto/index.html">Crypto API</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">BPF Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../PCI/index.html">PCI Bus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../peci/index.html">PECI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../wmi/index.html">WMI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tee/index.html">TEE Subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/bpf/standardization/instruction-set.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<nav class="contents" id="contents" role="doc-toc">
<p class="topic-title">Contents</p>
<ul class="auto-toc simple">
<li><p><a class="reference internal" href="#bpf-instruction-set-architecture-isa" id="id13"><span class="sectnum">1 </span>BPF Instruction Set Architecture (ISA)</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#documentation-conventions" id="id14"><span class="sectnum">1.1 </span>Documentation conventions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#types" id="id15"><span class="sectnum">1.1.1 </span>Types</a></p></li>
<li><p><a class="reference internal" href="#functions" id="id16"><span class="sectnum">1.1.2 </span>Functions</a></p></li>
<li><p><a class="reference internal" href="#definitions" id="id17"><span class="sectnum">1.1.3 </span>Definitions</a></p></li>
<li><p><a class="reference internal" href="#conformance-groups" id="id18"><span class="sectnum">1.1.4 </span>Conformance groups</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#instruction-encoding" id="id19"><span class="sectnum">1.2 </span>Instruction encoding</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#basic-instruction-encoding" id="id20"><span class="sectnum">1.2.1 </span>Basic instruction encoding</a></p></li>
<li><p><a class="reference internal" href="#wide-instruction-encoding" id="id21"><span class="sectnum">1.2.2 </span>Wide instruction encoding</a></p></li>
<li><p><a class="reference internal" href="#instruction-classes" id="id22"><span class="sectnum">1.2.3 </span>Instruction classes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#arithmetic-and-jump-instructions" id="id23"><span class="sectnum">1.3 </span>Arithmetic and jump instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#arithmetic-instructions" id="id24"><span class="sectnum">1.3.1 </span>Arithmetic instructions</a></p></li>
<li><p><a class="reference internal" href="#byte-swap-instructions" id="id25"><span class="sectnum">1.3.2 </span>Byte swap instructions</a></p></li>
<li><p><a class="reference internal" href="#jump-instructions" id="id26"><span class="sectnum">1.3.3 </span>Jump instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#helper-functions" id="id27"><span class="sectnum">1.3.3.1 </span>Helper functions</a></p></li>
<li><p><a class="reference internal" href="#program-local-functions" id="id28"><span class="sectnum">1.3.3.2 </span>Program-local functions</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#load-and-store-instructions" id="id29"><span class="sectnum">1.4 </span>Load and store instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#regular-load-and-store-operations" id="id30"><span class="sectnum">1.4.1 </span>Regular load and store operations</a></p></li>
<li><p><a class="reference internal" href="#sign-extension-load-operations" id="id31"><span class="sectnum">1.4.2 </span>Sign-extension load operations</a></p></li>
<li><p><a class="reference internal" href="#atomic-operations" id="id32"><span class="sectnum">1.4.3 </span>Atomic operations</a></p></li>
<li><p><a class="reference internal" href="#bit-immediate-instructions" id="id33"><span class="sectnum">1.4.4 </span>64-bit immediate instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#maps" id="id34"><span class="sectnum">1.4.4.1 </span>Maps</a></p></li>
<li><p><a class="reference internal" href="#platform-variables" id="id35"><span class="sectnum">1.4.4.2 </span>Platform Variables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#legacy-bpf-packet-access-instructions" id="id36"><span class="sectnum">1.4.5 </span>Legacy BPF Packet access instructions</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="bpf-instruction-set-architecture-isa">
<h1><a class="toc-backref" href="#id13" role="doc-backlink"><span class="sectnum">1 </span>BPF Instruction Set Architecture (ISA)</a><a class="headerlink" href="#bpf-instruction-set-architecture-isa" title="Link to this heading">¶</a></h1>
<p>eBPF, also commonly
referred to as BPF, is a technology with origins in the Linux kernel
that can run untrusted programs in a privileged context such as an
operating system kernel. This document specifies the BPF instruction
set architecture (ISA).</p>
<p>As a historical note, BPF originally stood for Berkeley Packet Filter,
but now that it can do so much more than packet filtering, the acronym
no longer makes sense. BPF is now considered a standalone term that
does not stand for anything.  The original BPF is sometimes referred to
as cBPF (classic BPF) to distinguish it from the now widely deployed
eBPF (extended BPF).</p>
<section id="documentation-conventions">
<h2><a class="toc-backref" href="#id14" role="doc-backlink"><span class="sectnum">1.1 </span>Documentation conventions</a><a class="headerlink" href="#documentation-conventions" title="Link to this heading">¶</a></h2>
<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in
BCP 14 <a class="reference external" href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>
<a class="reference external" href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>
when, and only when, they appear in all capitals, as shown here.</p>
<p>For brevity and consistency, this document refers to families
of types using a shorthand syntax and refers to several expository,
mnemonic functions when describing the semantics of instructions.
The range of valid values for those types and the semantics of those
functions are defined in the following subsections.</p>
<section id="types">
<h3><a class="toc-backref" href="#id15" role="doc-backlink"><span class="sectnum">1.1.1 </span>Types</a><a class="headerlink" href="#types" title="Link to this heading">¶</a></h3>
<p>This document refers to integer types with the notation <cite>SN</cite> to specify
a type’s signedness (<cite>S</cite>) and bit width (<cite>N</cite>), respectively.</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Meaning of signedness notation</span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>S</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>u</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-odd"><td><p>s</p></td>
<td><p>signed</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Meaning of bit-width notation</span><a class="headerlink" href="#id2" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>N</p></th>
<th class="head"><p>Bit width</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>8</p></td>
<td><p>8 bits</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>16 bits</p></td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td><p>32 bits</p></td>
</tr>
<tr class="row-odd"><td><p>64</p></td>
<td><p>64 bits</p></td>
</tr>
<tr class="row-even"><td><p>128</p></td>
<td><p>128 bits</p></td>
</tr>
</tbody>
</table>
<p>For example, <cite>u32</cite> is a type whose valid values are all the 32-bit unsigned
numbers and <cite>s16</cite> is a type whose valid values are all the 16-bit signed
numbers.</p>
</section>
<section id="functions">
<h3><a class="toc-backref" href="#id16" role="doc-backlink"><span class="sectnum">1.1.2 </span>Functions</a><a class="headerlink" href="#functions" title="Link to this heading">¶</a></h3>
<p>The following byteswap functions are direction-agnostic.  That is,
the same function is used for conversion in either direction discussed
below.</p>
<ul class="simple">
<li><p>be16: Takes an unsigned 16-bit number and converts it between
host byte order and big-endian
(<a class="reference external" href="https://www.rfc-editor.org/ien/ien137.txt">IEN137</a>) byte order.</p></li>
<li><p>be32: Takes an unsigned 32-bit number and converts it between
host byte order and big-endian byte order.</p></li>
<li><p>be64: Takes an unsigned 64-bit number and converts it between
host byte order and big-endian byte order.</p></li>
<li><p>bswap16: Takes an unsigned 16-bit number in either big- or little-endian
format and returns the equivalent number with the same bit width but
opposite endianness.</p></li>
<li><p>bswap32: Takes an unsigned 32-bit number in either big- or little-endian
format and returns the equivalent number with the same bit width but
opposite endianness.</p></li>
<li><p>bswap64: Takes an unsigned 64-bit number in either big- or little-endian
format and returns the equivalent number with the same bit width but
opposite endianness.</p></li>
<li><p>le16: Takes an unsigned 16-bit number and converts it between
host byte order and little-endian byte order.</p></li>
<li><p>le32: Takes an unsigned 32-bit number and converts it between
host byte order and little-endian byte order.</p></li>
<li><p>le64: Takes an unsigned 64-bit number and converts it between
host byte order and little-endian byte order.</p></li>
</ul>
</section>
<section id="definitions">
<h3><a class="toc-backref" href="#id17" role="doc-backlink"><span class="sectnum">1.1.3 </span>Definitions</a><a class="headerlink" href="#definitions" title="Link to this heading">¶</a></h3>
<dl class="simple glossary">
<dt id="term-Sign-Extend">Sign Extend<a class="headerlink" href="#term-Sign-Extend" title="Link to this term">¶</a></dt><dd><p>To <cite>sign extend an</cite> <code class="docutils literal notranslate"><span class="pre">X</span></code> <cite>-bit number, A, to a</cite> <code class="docutils literal notranslate"><span class="pre">Y</span></code> <cite>-bit number, B  ,</cite> means to</p>
<ol class="arabic simple">
<li><p>Copy all <code class="docutils literal notranslate"><span class="pre">X</span></code> bits from <cite>A</cite> to the lower <code class="docutils literal notranslate"><span class="pre">X</span></code> bits of <cite>B</cite>.</p></li>
<li><p>Set the value of the remaining <code class="docutils literal notranslate"><span class="pre">Y</span></code> - <code class="docutils literal notranslate"><span class="pre">X</span></code> bits of <cite>B</cite> to the value of
the  most-significant bit of <cite>A</cite>.</p></li>
</ol>
</dd>
</dl>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>Sign extend an 8-bit number <code class="docutils literal notranslate"><span class="pre">A</span></code> to a 16-bit number <code class="docutils literal notranslate"><span class="pre">B</span></code> on a big-endian platform:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A:          10000110
B: 11111111 10000110
</pre></div>
</div>
</div>
</section>
<section id="conformance-groups">
<h3><a class="toc-backref" href="#id18" role="doc-backlink"><span class="sectnum">1.1.4 </span>Conformance groups</a><a class="headerlink" href="#conformance-groups" title="Link to this heading">¶</a></h3>
<p>An implementation does not need to support all instructions specified in this
document (e.g., deprecated instructions).  Instead, a number of conformance
groups are specified.  An implementation MUST support the base32 conformance
group and MAY support additional conformance groups, where supporting a
conformance group means it MUST support all instructions in that conformance
group.</p>
<p>The use of named conformance groups enables interoperability between a runtime
that executes instructions, and tools such as compilers that generate
instructions for the runtime.  Thus, capability discovery in terms of
conformance groups might be done manually by users or automatically by tools.</p>
<p>Each conformance group has a short ASCII label (e.g., “base32”) that
corresponds to a set of instructions that are mandatory.  That is, each
instruction has one or more conformance groups of which it is a member.</p>
<p>This document defines the following conformance groups:</p>
<ul class="simple">
<li><p>base32: includes all instructions defined in this
specification unless otherwise noted.</p></li>
<li><p>base64: includes base32, plus instructions explicitly noted
as being in the base64 conformance group.</p></li>
<li><p>atomic32: includes 32-bit atomic operation instructions (see <a class="reference internal" href="#atomic-operations">Atomic operations</a>).</p></li>
<li><p>atomic64: includes atomic32, plus 64-bit atomic operation instructions.</p></li>
<li><p>divmul32: includes 32-bit division, multiplication, and modulo instructions.</p></li>
<li><p>divmul64: includes divmul32, plus 64-bit division, multiplication,
and modulo instructions.</p></li>
<li><p>packet: deprecated packet access instructions.</p></li>
</ul>
</section>
</section>
<section id="instruction-encoding">
<h2><a class="toc-backref" href="#id19" role="doc-backlink"><span class="sectnum">1.2 </span>Instruction encoding</a><a class="headerlink" href="#instruction-encoding" title="Link to this heading">¶</a></h2>
<p>BPF has two instruction encodings:</p>
<ul class="simple">
<li><p>the basic instruction encoding, which uses 64 bits to encode an instruction</p></li>
<li><p>the wide instruction encoding, which appends a second 64 bits
after the basic instruction for a total of 128 bits.</p></li>
</ul>
<section id="basic-instruction-encoding">
<h3><a class="toc-backref" href="#id20" role="doc-backlink"><span class="sectnum">1.2.1 </span>Basic instruction encoding</a><a class="headerlink" href="#basic-instruction-encoding" title="Link to this heading">¶</a></h3>
<p>A basic instruction is encoded as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    opcode     |     regs      |            offset             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              imm                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<dl>
<dt><strong>opcode</strong></dt><dd><p>operation to perform, encoded as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-+-+-+-+-+-+-+-+
|specific |class|
+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<dl class="simple">
<dt><strong>specific</strong></dt><dd><p>The format of these bits varies by instruction class</p>
</dd>
<dt><strong>class</strong></dt><dd><p>The instruction class (see <a class="reference internal" href="#instruction-classes">Instruction classes</a>)</p>
</dd>
</dl>
</dd>
<dt><strong>regs</strong></dt><dd><p>The source and destination register numbers, encoded as follows
on a little-endian host:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-+-+-+-+-+-+-+-+
|src_reg|dst_reg|
+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<p>and as follows on a big-endian host:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-+-+-+-+-+-+-+-+
|dst_reg|src_reg|
+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<dl class="simple">
<dt><strong>src_reg</strong></dt><dd><p>the source register number (0-10), except where otherwise specified
(<a class="reference internal" href="#bit-immediate-instructions">64-bit immediate instructions</a> reuse this field for other purposes)</p>
</dd>
<dt><strong>dst_reg</strong></dt><dd><p>destination register number (0-10), unless otherwise specified
(future instructions might reuse this field for other purposes)</p>
</dd>
</dl>
</dd>
<dt><strong>offset</strong></dt><dd><p>signed integer offset used with pointer arithmetic, except where
otherwise specified (some arithmetic instructions reuse this field
for other purposes)</p>
</dd>
<dt><strong>imm</strong></dt><dd><p>signed integer immediate value</p>
</dd>
</dl>
<p>Note that the contents of multi-byte fields (‘offset’ and ‘imm’) are
stored using big-endian byte ordering on big-endian hosts and
little-endian byte ordering on little-endian hosts.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>opcode                  offset imm          assembly
       src_reg dst_reg
07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // little
       dst_reg src_reg
07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // big
</pre></div>
</div>
<p>Note that most instructions do not use all of the fields.
Unused fields SHALL be cleared to zero.</p>
</section>
<section id="wide-instruction-encoding">
<h3><a class="toc-backref" href="#id21" role="doc-backlink"><span class="sectnum">1.2.2 </span>Wide instruction encoding</a><a class="headerlink" href="#wide-instruction-encoding" title="Link to this heading">¶</a></h3>
<p>Some instructions are defined to use the wide instruction encoding,
which uses two 32-bit immediate values.  The 64 bits following
the basic instruction format contain a pseudo instruction
with ‘opcode’, ‘dst_reg’, ‘src_reg’, and ‘offset’ all set to zero.</p>
<p>This is depicted in the following figure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    opcode     |     regs      |            offset             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              imm                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           reserved                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           next_imm                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<dl class="simple">
<dt><strong>opcode</strong></dt><dd><p>operation to perform, encoded as explained above</p>
</dd>
<dt><strong>regs</strong></dt><dd><p>The source and destination register numbers (unless otherwise
specified), encoded as explained above</p>
</dd>
<dt><strong>offset</strong></dt><dd><p>signed integer offset used with pointer arithmetic, unless
otherwise specified</p>
</dd>
<dt><strong>imm</strong></dt><dd><p>signed integer immediate value</p>
</dd>
<dt><strong>reserved</strong></dt><dd><p>unused, set to zero</p>
</dd>
<dt><strong>next_imm</strong></dt><dd><p>second signed integer immediate value</p>
</dd>
</dl>
</section>
<section id="instruction-classes">
<h3><a class="toc-backref" href="#id22" role="doc-backlink"><span class="sectnum">1.2.3 </span>Instruction classes</a><a class="headerlink" href="#instruction-classes" title="Link to this heading">¶</a></h3>
<p>The three least significant bits of the ‘opcode’ field store the instruction class:</p>
<table class="docutils align-default" id="id3">
<caption><span class="caption-text">Instruction class</span><a class="headerlink" href="#id3" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>class</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
<th class="head"><p>reference</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>LD</p></td>
<td><p>0x0</p></td>
<td><p>non-standard load operations</p></td>
<td><p><a class="reference internal" href="#load-and-store-instructions">Load and store instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>LDX</p></td>
<td><p>0x1</p></td>
<td><p>load into register operations</p></td>
<td><p><a class="reference internal" href="#load-and-store-instructions">Load and store instructions</a></p></td>
</tr>
<tr class="row-even"><td><p>ST</p></td>
<td><p>0x2</p></td>
<td><p>store from immediate operations</p></td>
<td><p><a class="reference internal" href="#load-and-store-instructions">Load and store instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>STX</p></td>
<td><p>0x3</p></td>
<td><p>store from register operations</p></td>
<td><p><a class="reference internal" href="#load-and-store-instructions">Load and store instructions</a></p></td>
</tr>
<tr class="row-even"><td><p>ALU</p></td>
<td><p>0x4</p></td>
<td><p>32-bit arithmetic operations</p></td>
<td><p><a class="reference internal" href="#arithmetic-and-jump-instructions">Arithmetic and jump instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>JMP</p></td>
<td><p>0x5</p></td>
<td><p>64-bit jump operations</p></td>
<td><p><a class="reference internal" href="#arithmetic-and-jump-instructions">Arithmetic and jump instructions</a></p></td>
</tr>
<tr class="row-even"><td><p>JMP32</p></td>
<td><p>0x6</p></td>
<td><p>32-bit jump operations</p></td>
<td><p><a class="reference internal" href="#arithmetic-and-jump-instructions">Arithmetic and jump instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>ALU64</p></td>
<td><p>0x7</p></td>
<td><p>64-bit arithmetic operations</p></td>
<td><p><a class="reference internal" href="#arithmetic-and-jump-instructions">Arithmetic and jump instructions</a></p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="arithmetic-and-jump-instructions">
<h2><a class="toc-backref" href="#id23" role="doc-backlink"><span class="sectnum">1.3 </span>Arithmetic and jump instructions</a><a class="headerlink" href="#arithmetic-and-jump-instructions" title="Link to this heading">¶</a></h2>
<p>For arithmetic and jump instructions (<code class="docutils literal notranslate"><span class="pre">ALU</span></code>, <code class="docutils literal notranslate"><span class="pre">ALU64</span></code>, <code class="docutils literal notranslate"><span class="pre">JMP</span></code> and
<code class="docutils literal notranslate"><span class="pre">JMP32</span></code>), the 8-bit ‘opcode’ field is divided into three parts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-+-+-+-+-+-+-+-+
|  code |s|class|
+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<dl>
<dt><strong>code</strong></dt><dd><p>the operation code, whose meaning varies by instruction class</p>
</dd>
<dt><strong>s (source)</strong></dt><dd><p>the source operand location, which unless otherwise specified is one of:</p>
<table class="docutils align-default" id="id4">
<caption><span class="caption-text">Source operand location</span><a class="headerlink" href="#id4" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>source</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>K</p></td>
<td><p>0</p></td>
<td><p>use 32-bit ‘imm’ value as source operand</p></td>
</tr>
<tr class="row-odd"><td><p>X</p></td>
<td><p>1</p></td>
<td><p>use ‘src_reg’ register value as source operand</p></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>instruction class</strong></dt><dd><p>the instruction class (see <a class="reference internal" href="#instruction-classes">Instruction classes</a>)</p>
</dd>
</dl>
<section id="arithmetic-instructions">
<h3><a class="toc-backref" href="#id24" role="doc-backlink"><span class="sectnum">1.3.1 </span>Arithmetic instructions</a><a class="headerlink" href="#arithmetic-instructions" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ALU</span></code> uses 32-bit wide operands while <code class="docutils literal notranslate"><span class="pre">ALU64</span></code> uses 64-bit wide operands for
otherwise identical operations. <code class="docutils literal notranslate"><span class="pre">ALU64</span></code> instructions belong to the
base64 conformance group unless noted otherwise.
The ‘code’ field encodes the operation as below, where ‘src’ refers to the
the source operand and ‘dst’ refers to the value of the destination
register.</p>
<table class="docutils align-default" id="id5">
<caption><span class="caption-text">Arithmetic instructions</span><a class="headerlink" href="#id5" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>name</p></th>
<th class="head"><p>code</p></th>
<th class="head"><p>offset</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ADD</p></td>
<td><p>0x0</p></td>
<td><p>0</p></td>
<td><p>dst += src</p></td>
</tr>
<tr class="row-odd"><td><p>SUB</p></td>
<td><p>0x1</p></td>
<td><p>0</p></td>
<td><p>dst -= src</p></td>
</tr>
<tr class="row-even"><td><p>MUL</p></td>
<td><p>0x2</p></td>
<td><p>0</p></td>
<td><p>dst *= src</p></td>
</tr>
<tr class="row-odd"><td><p>DIV</p></td>
<td><p>0x3</p></td>
<td><p>0</p></td>
<td><p>dst = (src != 0) ? (dst / src) : 0</p></td>
</tr>
<tr class="row-even"><td><p>SDIV</p></td>
<td><p>0x3</p></td>
<td><p>1</p></td>
<td><p>dst = (src != 0) ? (dst s/ src) : 0</p></td>
</tr>
<tr class="row-odd"><td><p>OR</p></td>
<td><p>0x4</p></td>
<td><p>0</p></td>
<td><p>dst |= src</p></td>
</tr>
<tr class="row-even"><td><p>AND</p></td>
<td><p>0x5</p></td>
<td><p>0</p></td>
<td><p>dst &amp;= src</p></td>
</tr>
<tr class="row-odd"><td><p>LSH</p></td>
<td><p>0x6</p></td>
<td><p>0</p></td>
<td><p>dst &lt;&lt;= (src &amp; mask)</p></td>
</tr>
<tr class="row-even"><td><p>RSH</p></td>
<td><p>0x7</p></td>
<td><p>0</p></td>
<td><p>dst &gt;&gt;= (src &amp; mask)</p></td>
</tr>
<tr class="row-odd"><td><p>NEG</p></td>
<td><p>0x8</p></td>
<td><p>0</p></td>
<td><p>dst = -dst</p></td>
</tr>
<tr class="row-even"><td><p>MOD</p></td>
<td><p>0x9</p></td>
<td><p>0</p></td>
<td><p>dst = (src != 0) ? (dst % src) : dst</p></td>
</tr>
<tr class="row-odd"><td><p>SMOD</p></td>
<td><p>0x9</p></td>
<td><p>1</p></td>
<td><p>dst = (src != 0) ? (dst s% src) : dst</p></td>
</tr>
<tr class="row-even"><td><p>XOR</p></td>
<td><p>0xa</p></td>
<td><p>0</p></td>
<td><p>dst ^= src</p></td>
</tr>
<tr class="row-odd"><td><p>MOV</p></td>
<td><p>0xb</p></td>
<td><p>0</p></td>
<td><p>dst = src</p></td>
</tr>
<tr class="row-even"><td><p>MOVSX</p></td>
<td><p>0xb</p></td>
<td><p>8/16/32</p></td>
<td><p>dst = (s8,s16,s32)src</p></td>
</tr>
<tr class="row-odd"><td><p>ARSH</p></td>
<td><p>0xc</p></td>
<td><p>0</p></td>
<td><p><a class="reference internal" href="#term-Sign-Extend"><span class="xref std std-term">sign extending</span></a> dst &gt;&gt;= (src &amp; mask)</p></td>
</tr>
<tr class="row-even"><td><p>END</p></td>
<td><p>0xd</p></td>
<td><p>0</p></td>
<td><p>byte swap operations (see <a class="reference internal" href="#byte-swap-instructions">Byte swap instructions</a> below)</p></td>
</tr>
</tbody>
</table>
<p>Underflow and overflow are allowed during arithmetic operations, meaning
the 64-bit or 32-bit value will wrap. If BPF program execution would
result in division by zero, the destination register is instead set to zero.
If execution would result in modulo by zero, for <code class="docutils literal notranslate"><span class="pre">ALU64</span></code> the value of
the destination register is unchanged whereas for <code class="docutils literal notranslate"><span class="pre">ALU</span></code> the upper
32 bits of the destination register are zeroed.</p>
<p><code class="docutils literal notranslate"><span class="pre">{ADD,</span> <span class="pre">X,</span> <span class="pre">ALU}</span></code>, where ‘code’ = <code class="docutils literal notranslate"><span class="pre">ADD</span></code>, ‘source’ = <code class="docutils literal notranslate"><span class="pre">X</span></code>, and ‘class’ = <code class="docutils literal notranslate"><span class="pre">ALU</span></code>, means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = (u32) ((u32) dst + (u32) src)
</pre></div>
</div>
<p>where ‘(u32)’ indicates that the upper 32 bits are zeroed.</p>
<p><code class="docutils literal notranslate"><span class="pre">{ADD,</span> <span class="pre">X,</span> <span class="pre">ALU64}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = dst + src
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{XOR,</span> <span class="pre">K,</span> <span class="pre">ALU}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = (u32) dst ^ (u32) imm
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{XOR,</span> <span class="pre">K,</span> <span class="pre">ALU64}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = dst ^ imm
</pre></div>
</div>
<p>Note that most arithmetic instructions have ‘offset’ set to 0. Only three instructions
(<code class="docutils literal notranslate"><span class="pre">SDIV</span></code>, <code class="docutils literal notranslate"><span class="pre">SMOD</span></code>, <code class="docutils literal notranslate"><span class="pre">MOVSX</span></code>) have a non-zero ‘offset’.</p>
<p>Division, multiplication, and modulo operations for <code class="docutils literal notranslate"><span class="pre">ALU</span></code> are part
of the “divmul32” conformance group, and division, multiplication, and
modulo operations for <code class="docutils literal notranslate"><span class="pre">ALU64</span></code> are part of the “divmul64” conformance
group.
The division and modulo operations support both unsigned and signed flavors.</p>
<p>For unsigned operations (<code class="docutils literal notranslate"><span class="pre">DIV</span></code> and <code class="docutils literal notranslate"><span class="pre">MOD</span></code>), for <code class="docutils literal notranslate"><span class="pre">ALU</span></code>,
‘imm’ is interpreted as a 32-bit unsigned value. For <code class="docutils literal notranslate"><span class="pre">ALU64</span></code>,
‘imm’ is first <a class="reference internal" href="#term-Sign-Extend"><span class="xref std std-term">sign extended</span></a> from 32 to 64 bits, and then
interpreted as a 64-bit unsigned value.</p>
<p>For signed operations (<code class="docutils literal notranslate"><span class="pre">SDIV</span></code> and <code class="docutils literal notranslate"><span class="pre">SMOD</span></code>), for <code class="docutils literal notranslate"><span class="pre">ALU</span></code>,
‘imm’ is interpreted as a 32-bit signed value. For <code class="docutils literal notranslate"><span class="pre">ALU64</span></code>, ‘imm’
is first <a class="reference internal" href="#term-Sign-Extend"><span class="xref std std-term">sign extended</span></a> from 32 to 64 bits, and then
interpreted as a 64-bit signed value.</p>
<p>Note that there are varying definitions of the signed modulo operation
when the dividend or divisor are negative, where implementations often
vary by language such that Python, Ruby, etc.  differ from C, Go, Java,
etc. This specification requires that signed modulo MUST use truncated division
(where -13 % 3 == -1) as implemented in C, Go, etc.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>a % n = a - n * trunc(a / n)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MOVSX</span></code> instruction does a move operation with sign extension.
<code class="docutils literal notranslate"><span class="pre">{MOVSX,</span> <span class="pre">X,</span> <span class="pre">ALU}</span></code> <a class="reference internal" href="#term-Sign-Extend"><span class="xref std std-term">sign extends</span></a> 8-bit and 16-bit operands into
32-bit operands, and zeroes the remaining upper 32 bits.
<code class="docutils literal notranslate"><span class="pre">{MOVSX,</span> <span class="pre">X,</span> <span class="pre">ALU64}</span></code> <a class="reference internal" href="#term-Sign-Extend"><span class="xref std std-term">sign extends</span></a> 8-bit, 16-bit, and 32-bit
operands into 64-bit operands.  Unlike other arithmetic instructions,
<code class="docutils literal notranslate"><span class="pre">MOVSX</span></code> is only defined for register source operands (<code class="docutils literal notranslate"><span class="pre">X</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">{MOV,</span> <span class="pre">K,</span> <span class="pre">ALU64}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = (s64)imm
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{MOV,</span> <span class="pre">X,</span> <span class="pre">ALU}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = (u32)src
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{MOVSX,</span> <span class="pre">X,</span> <span class="pre">ALU}</span></code> with ‘offset’ 8 means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = (u32)(s32)(s8)src
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">NEG</span></code> instruction is only defined when the source bit is clear
(<code class="docutils literal notranslate"><span class="pre">K</span></code>).</p>
<p>Shift operations use a mask of 0x3F (63) for 64-bit operations and 0x1F (31)
for 32-bit operations.</p>
</section>
<section id="byte-swap-instructions">
<h3><a class="toc-backref" href="#id25" role="doc-backlink"><span class="sectnum">1.3.2 </span>Byte swap instructions</a><a class="headerlink" href="#byte-swap-instructions" title="Link to this heading">¶</a></h3>
<p>The byte swap instructions use instruction classes of <code class="docutils literal notranslate"><span class="pre">ALU</span></code> and <code class="docutils literal notranslate"><span class="pre">ALU64</span></code>
and a 4-bit ‘code’ field of <code class="docutils literal notranslate"><span class="pre">END</span></code>.</p>
<p>The byte swap instructions operate on the destination register
only and do not use a separate source register or immediate value.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">ALU</span></code>, the 1-bit source operand field in the opcode is used to
select what byte order the operation converts from or to. For
<code class="docutils literal notranslate"><span class="pre">ALU64</span></code>, the 1-bit source operand field in the opcode is reserved
and MUST be set to 0.</p>
<table class="docutils align-default" id="id6">
<caption><span class="caption-text">Byte swap instructions</span><a class="headerlink" href="#id6" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>class</p></th>
<th class="head"><p>source</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ALU</p></td>
<td><p>LE</p></td>
<td><p>0</p></td>
<td><p>convert between host byte order and little endian</p></td>
</tr>
<tr class="row-odd"><td><p>ALU</p></td>
<td><p>BE</p></td>
<td><p>1</p></td>
<td><p>convert between host byte order and big endian</p></td>
</tr>
<tr class="row-even"><td><p>ALU64</p></td>
<td><p>Reserved</p></td>
<td><p>0</p></td>
<td><p>do byte swap unconditionally</p></td>
</tr>
</tbody>
</table>
<p>The ‘imm’ field encodes the width of the swap operations.  The following widths
are supported: 16, 32 and 64.  Width 64 operations belong to the base64
conformance group and other swap operations belong to the base32
conformance group.</p>
<p>Examples:</p>
<p><code class="docutils literal notranslate"><span class="pre">{END,</span> <span class="pre">LE,</span> <span class="pre">ALU}</span></code> with ‘imm’ = 16/32/64 means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = le16(dst)
dst = le32(dst)
dst = le64(dst)
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{END,</span> <span class="pre">BE,</span> <span class="pre">ALU}</span></code> with ‘imm’ = 16/32/64 means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = be16(dst)
dst = be32(dst)
dst = be64(dst)
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{END,</span> <span class="pre">TO,</span> <span class="pre">ALU64}</span></code> with ‘imm’ = 16/32/64 means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = bswap16(dst)
dst = bswap32(dst)
dst = bswap64(dst)
</pre></div>
</div>
</section>
<section id="jump-instructions">
<h3><a class="toc-backref" href="#id26" role="doc-backlink"><span class="sectnum">1.3.3 </span>Jump instructions</a><a class="headerlink" href="#jump-instructions" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">JMP32</span></code> uses 32-bit wide operands and indicates the base32
conformance group, while <code class="docutils literal notranslate"><span class="pre">JMP</span></code> uses 64-bit wide operands for
otherwise identical operations, and indicates the base64 conformance
group unless otherwise specified.
The ‘code’ field encodes the operation as below:</p>
<table class="docutils align-default" id="id7">
<caption><span class="caption-text">Jump instructions</span><a class="headerlink" href="#id7" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>code</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>src_reg</p></th>
<th class="head"><p>description</p></th>
<th class="head"><p>notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>JA</p></td>
<td><p>0x0</p></td>
<td><p>0x0</p></td>
<td><p>PC += offset</p></td>
<td><p>{JA, K, JMP} only</p></td>
</tr>
<tr class="row-odd"><td><p>JA</p></td>
<td><p>0x0</p></td>
<td><p>0x0</p></td>
<td><p>PC += imm</p></td>
<td><p>{JA, K, JMP32} only</p></td>
</tr>
<tr class="row-even"><td><p>JEQ</p></td>
<td><p>0x1</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst == src</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>JGT</p></td>
<td><p>0x2</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &gt; src</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-even"><td><p>JGE</p></td>
<td><p>0x3</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &gt;= src</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-odd"><td><p>JSET</p></td>
<td><p>0x4</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &amp; src</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>JNE</p></td>
<td><p>0x5</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst != src</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>JSGT</p></td>
<td><p>0x6</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &gt; src</p></td>
<td><p>signed</p></td>
</tr>
<tr class="row-even"><td><p>JSGE</p></td>
<td><p>0x7</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &gt;= src</p></td>
<td><p>signed</p></td>
</tr>
<tr class="row-odd"><td><p>CALL</p></td>
<td><p>0x8</p></td>
<td><p>0x0</p></td>
<td><p>call helper function by static ID</p></td>
<td><p>{CALL, K, JMP} only, see <a class="reference internal" href="#helper-functions">Helper functions</a></p></td>
</tr>
<tr class="row-even"><td><p>CALL</p></td>
<td><p>0x8</p></td>
<td><p>0x1</p></td>
<td><p>call PC += imm</p></td>
<td><p>{CALL, K, JMP} only, see <a class="reference internal" href="#program-local-functions">Program-local functions</a></p></td>
</tr>
<tr class="row-odd"><td><p>CALL</p></td>
<td><p>0x8</p></td>
<td><p>0x2</p></td>
<td><p>call helper function by BTF ID</p></td>
<td><p>{CALL, K, JMP} only, see <a class="reference internal" href="#helper-functions">Helper functions</a></p></td>
</tr>
<tr class="row-even"><td><p>EXIT</p></td>
<td><p>0x9</p></td>
<td><p>0x0</p></td>
<td><p>return</p></td>
<td><p>{CALL, K, JMP} only</p></td>
</tr>
<tr class="row-odd"><td><p>JLT</p></td>
<td><p>0xa</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &lt; src</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-even"><td><p>JLE</p></td>
<td><p>0xb</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &lt;= src</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-odd"><td><p>JSLT</p></td>
<td><p>0xc</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &lt; src</p></td>
<td><p>signed</p></td>
</tr>
<tr class="row-even"><td><p>JSLE</p></td>
<td><p>0xd</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &lt;= src</p></td>
<td><p>signed</p></td>
</tr>
</tbody>
</table>
<p>where ‘PC’ denotes the program counter, and the offset to increment by
is in units of 64-bit instructions relative to the instruction following
the jump instruction.  Thus ‘PC += 1’ skips execution of the next
instruction if it’s a basic instruction or results in undefined behavior
if the next instruction is a 128-bit wide instruction.</p>
<p>Example:</p>
<p><code class="docutils literal notranslate"><span class="pre">{JSGE,</span> <span class="pre">X,</span> <span class="pre">JMP32}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (s32)dst s&gt;= (s32)src goto +offset
</pre></div>
</div>
<p>where ‘s&gt;=’ indicates a signed ‘&gt;=’ comparison.</p>
<p><code class="docutils literal notranslate"><span class="pre">{JLE,</span> <span class="pre">K,</span> <span class="pre">JMP}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if dst &lt;= (u64)(s64)imm goto +offset
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{JA,</span> <span class="pre">K,</span> <span class="pre">JMP32}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gotol +imm
</pre></div>
</div>
<p>where ‘imm’ means the branch offset comes from the ‘imm’ field.</p>
<p>Note that there are two flavors of <code class="docutils literal notranslate"><span class="pre">JA</span></code> instructions. The
<code class="docutils literal notranslate"><span class="pre">JMP</span></code> class permits a 16-bit jump offset specified by the ‘offset’
field, whereas the <code class="docutils literal notranslate"><span class="pre">JMP32</span></code> class permits a 32-bit jump offset
specified by the ‘imm’ field. A &gt; 16-bit conditional jump may be
converted to a &lt; 16-bit conditional jump plus a 32-bit unconditional
jump.</p>
<p>All <code class="docutils literal notranslate"><span class="pre">CALL</span></code> and <code class="docutils literal notranslate"><span class="pre">JA</span></code> instructions belong to the
base32 conformance group.</p>
<section id="helper-functions">
<h4><a class="toc-backref" href="#id27" role="doc-backlink"><span class="sectnum">1.3.3.1 </span>Helper functions</a><a class="headerlink" href="#helper-functions" title="Link to this heading">¶</a></h4>
<p>Helper functions are a concept whereby BPF programs can call into a
set of function calls exposed by the underlying platform.</p>
<p>Historically, each helper function was identified by a static ID
encoded in the ‘imm’ field.  Further documentation of helper functions
is outside the scope of this document and standardization is left for
future work, but use is widely deployed and more information can be
found in platform-specific documentation (e.g., Linux kernel documentation).</p>
<p>Platforms that support the BPF Type Format (BTF) support identifying
a helper function by a BTF ID encoded in the ‘imm’ field, where the BTF ID
identifies the helper name and type.  Further documentation of BTF
is outside the scope of this document and standardization is left for
future work, but use is widely deployed and more information can be
found in platform-specific documentation (e.g., Linux kernel documentation).</p>
</section>
<section id="program-local-functions">
<h4><a class="toc-backref" href="#id28" role="doc-backlink"><span class="sectnum">1.3.3.2 </span>Program-local functions</a><a class="headerlink" href="#program-local-functions" title="Link to this heading">¶</a></h4>
<p>Program-local functions are functions exposed by the same BPF program as the
caller, and are referenced by offset from the instruction following the call
instruction, similar to <code class="docutils literal notranslate"><span class="pre">JA</span></code>.  The offset is encoded in the ‘imm’ field of
the call instruction. An <code class="docutils literal notranslate"><span class="pre">EXIT</span></code> within the program-local function will
return to the caller.</p>
</section>
</section>
</section>
<section id="load-and-store-instructions">
<h2><a class="toc-backref" href="#id29" role="doc-backlink"><span class="sectnum">1.4 </span>Load and store instructions</a><a class="headerlink" href="#load-and-store-instructions" title="Link to this heading">¶</a></h2>
<p>For load and store instructions (<code class="docutils literal notranslate"><span class="pre">LD</span></code>, <code class="docutils literal notranslate"><span class="pre">LDX</span></code>, <code class="docutils literal notranslate"><span class="pre">ST</span></code>, and <code class="docutils literal notranslate"><span class="pre">STX</span></code>), the
8-bit ‘opcode’ field is divided as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+-+-+-+-+-+-+-+-+
|mode |sz |class|
+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<dl>
<dt><strong>mode</strong></dt><dd><p>The mode modifier is one of:</p>
<table class="docutils align-default" id="id8">
<caption><span class="caption-text">Mode modifier</span><a class="headerlink" href="#id8" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>mode modifier</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
<th class="head"><p>reference</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IMM</p></td>
<td><p>0</p></td>
<td><p>64-bit immediate instructions</p></td>
<td><p><a class="reference internal" href="#bit-immediate-instructions">64-bit immediate instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>ABS</p></td>
<td><p>1</p></td>
<td><p>legacy BPF packet access (absolute)</p></td>
<td><p><a class="reference internal" href="#legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</a></p></td>
</tr>
<tr class="row-even"><td><p>IND</p></td>
<td><p>2</p></td>
<td><p>legacy BPF packet access (indirect)</p></td>
<td><p><a class="reference internal" href="#legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>MEM</p></td>
<td><p>3</p></td>
<td><p>regular load and store operations</p></td>
<td><p><a class="reference internal" href="#regular-load-and-store-operations">Regular load and store operations</a></p></td>
</tr>
<tr class="row-even"><td><p>MEMSX</p></td>
<td><p>4</p></td>
<td><p>sign-extension load operations</p></td>
<td><p><a class="reference internal" href="#sign-extension-load-operations">Sign-extension load operations</a></p></td>
</tr>
<tr class="row-odd"><td><p>ATOMIC</p></td>
<td><p>6</p></td>
<td><p>atomic operations</p></td>
<td><p><a class="reference internal" href="#atomic-operations">Atomic operations</a></p></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>sz (size)</strong></dt><dd><p>The size modifier is one of:</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">Size modifier</span><a class="headerlink" href="#id9" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>size</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>W</p></td>
<td><p>0</p></td>
<td><p>word        (4 bytes)</p></td>
</tr>
<tr class="row-odd"><td><p>H</p></td>
<td><p>1</p></td>
<td><p>half word   (2 bytes)</p></td>
</tr>
<tr class="row-even"><td><p>B</p></td>
<td><p>2</p></td>
<td><p>byte</p></td>
</tr>
<tr class="row-odd"><td><p>DW</p></td>
<td><p>3</p></td>
<td><p>double word (8 bytes)</p></td>
</tr>
</tbody>
</table>
<p>Instructions using <code class="docutils literal notranslate"><span class="pre">DW</span></code> belong to the base64 conformance group.</p>
</dd>
<dt><strong>class</strong></dt><dd><p>The instruction class (see <a class="reference internal" href="#instruction-classes">Instruction classes</a>)</p>
</dd>
</dl>
<section id="regular-load-and-store-operations">
<h3><a class="toc-backref" href="#id30" role="doc-backlink"><span class="sectnum">1.4.1 </span>Regular load and store operations</a><a class="headerlink" href="#regular-load-and-store-operations" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MEM</span></code> mode modifier is used to encode regular load and store
instructions that transfer data between a register and memory.</p>
<p><code class="docutils literal notranslate"><span class="pre">{MEM,</span> <span class="pre">&lt;size&gt;,</span> <span class="pre">STX}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*(size *) (dst + offset) = src
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{MEM,</span> <span class="pre">&lt;size&gt;,</span> <span class="pre">ST}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*(size *) (dst + offset) = imm
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{MEM,</span> <span class="pre">&lt;size&gt;,</span> <span class="pre">LDX}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = *(unsigned size *) (src + offset)
</pre></div>
</div>
<p>Where ‘&lt;size&gt;’ is one of: <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">H</span></code>, <code class="docutils literal notranslate"><span class="pre">W</span></code>, or <code class="docutils literal notranslate"><span class="pre">DW</span></code>, and
‘unsigned size’ is one of: u8, u16, u32, or u64.</p>
</section>
<section id="sign-extension-load-operations">
<h3><a class="toc-backref" href="#id31" role="doc-backlink"><span class="sectnum">1.4.2 </span>Sign-extension load operations</a><a class="headerlink" href="#sign-extension-load-operations" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MEMSX</span></code> mode modifier is used to encode <a class="reference internal" href="#term-Sign-Extend"><span class="xref std std-term">sign-extension</span></a> load
instructions that transfer data between a register and memory.</p>
<p><code class="docutils literal notranslate"><span class="pre">{MEMSX,</span> <span class="pre">&lt;size&gt;,</span> <span class="pre">LDX}</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = *(signed size *) (src + offset)
</pre></div>
</div>
<p>Where ‘&lt;size&gt;’ is one of: <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">H</span></code>, or <code class="docutils literal notranslate"><span class="pre">W</span></code>, and
‘signed size’ is one of: s8, s16, or s32.</p>
</section>
<section id="atomic-operations">
<h3><a class="toc-backref" href="#id32" role="doc-backlink"><span class="sectnum">1.4.3 </span>Atomic operations</a><a class="headerlink" href="#atomic-operations" title="Link to this heading">¶</a></h3>
<p>Atomic operations are operations that operate on memory and can not be
interrupted or corrupted by other access to the same memory region
by other BPF programs or means outside of this specification.</p>
<p>All atomic operations supported by BPF are encoded as store operations
that use the <code class="docutils literal notranslate"><span class="pre">ATOMIC</span></code> mode modifier as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{ATOMIC,</span> <span class="pre">W,</span> <span class="pre">STX}</span></code> for 32-bit operations, which are
part of the “atomic32” conformance group.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{ATOMIC,</span> <span class="pre">DW,</span> <span class="pre">STX}</span></code> for 64-bit operations, which are
part of the “atomic64” conformance group.</p></li>
<li><p>8-bit and 16-bit wide atomic operations are not supported.</p></li>
</ul>
<p>The ‘imm’ field is used to encode the actual atomic operation.
Simple atomic operation use a subset of the values defined to encode
arithmetic operations in the ‘imm’ field to encode the atomic operation:</p>
<table class="docutils align-default" id="id10">
<caption><span class="caption-text">Simple atomic operations</span><a class="headerlink" href="#id10" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>imm</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ADD</p></td>
<td><p>0x00</p></td>
<td><p>atomic add</p></td>
</tr>
<tr class="row-odd"><td><p>OR</p></td>
<td><p>0x40</p></td>
<td><p>atomic or</p></td>
</tr>
<tr class="row-even"><td><p>AND</p></td>
<td><p>0x50</p></td>
<td><p>atomic and</p></td>
</tr>
<tr class="row-odd"><td><p>XOR</p></td>
<td><p>0xa0</p></td>
<td><p>atomic xor</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">{ATOMIC,</span> <span class="pre">W,</span> <span class="pre">STX}</span></code> with ‘imm’ = ADD means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*(u32 *)(dst + offset) += src
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">{ATOMIC,</span> <span class="pre">DW,</span> <span class="pre">STX}</span></code> with ‘imm’ = ADD means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*(u64 *)(dst + offset) += src
</pre></div>
</div>
<p>In addition to the simple atomic operations, there also is a modifier and
two complex atomic operations:</p>
<table class="docutils align-default" id="id11">
<caption><span class="caption-text">Complex atomic operations</span><a class="headerlink" href="#id11" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>imm</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>FETCH</p></td>
<td><p>0x01</p></td>
<td><p>modifier: return old value</p></td>
</tr>
<tr class="row-odd"><td><p>XCHG</p></td>
<td><p>0xe0 | FETCH</p></td>
<td><p>atomic exchange</p></td>
</tr>
<tr class="row-even"><td><p>CMPXCHG</p></td>
<td><p>0xf0 | FETCH</p></td>
<td><p>atomic compare and exchange</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">FETCH</span></code> modifier is optional for simple atomic operations, and
always set for the complex atomic operations.  If the <code class="docutils literal notranslate"><span class="pre">FETCH</span></code> flag
is set, then the operation also overwrites <code class="docutils literal notranslate"><span class="pre">src</span></code> with the value that
was in memory before it was modified.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">XCHG</span></code> operation atomically exchanges <code class="docutils literal notranslate"><span class="pre">src</span></code> with the value
addressed by <code class="docutils literal notranslate"><span class="pre">dst</span> <span class="pre">+</span> <span class="pre">offset</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">CMPXCHG</span></code> operation atomically compares the value addressed by
<code class="docutils literal notranslate"><span class="pre">dst</span> <span class="pre">+</span> <span class="pre">offset</span></code> with <code class="docutils literal notranslate"><span class="pre">R0</span></code>. If they match, the value addressed by
<code class="docutils literal notranslate"><span class="pre">dst</span> <span class="pre">+</span> <span class="pre">offset</span></code> is replaced with <code class="docutils literal notranslate"><span class="pre">src</span></code>. In either case, the
value that was at <code class="docutils literal notranslate"><span class="pre">dst</span> <span class="pre">+</span> <span class="pre">offset</span></code> before the operation is zero-extended
and loaded back to <code class="docutils literal notranslate"><span class="pre">R0</span></code>.</p>
</section>
<section id="bit-immediate-instructions">
<h3><a class="toc-backref" href="#id33" role="doc-backlink"><span class="sectnum">1.4.4 </span>64-bit immediate instructions</a><a class="headerlink" href="#bit-immediate-instructions" title="Link to this heading">¶</a></h3>
<p>Instructions with the <code class="docutils literal notranslate"><span class="pre">IMM</span></code> ‘mode’ modifier use the wide instruction
encoding defined in <a class="reference internal" href="#instruction-encoding">Instruction encoding</a>, and use the ‘src_reg’ field of the
basic instruction to hold an opcode subtype.</p>
<p>The following table defines a set of <code class="docutils literal notranslate"><span class="pre">{IMM,</span> <span class="pre">DW,</span> <span class="pre">LD}</span></code> instructions
with opcode subtypes in the ‘src_reg’ field, using new terms such as “map”
defined further below:</p>
<table class="docutils align-default" id="id12">
<caption><span class="caption-text">64-bit immediate instructions</span><a class="headerlink" href="#id12" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>src_reg</p></th>
<th class="head"><p>pseudocode</p></th>
<th class="head"><p>imm type</p></th>
<th class="head"><p>dst type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>dst = (next_imm &lt;&lt; 32) | imm</p></td>
<td><p>integer</p></td>
<td><p>integer</p></td>
</tr>
<tr class="row-odd"><td><p>0x1</p></td>
<td><p>dst = map_by_fd(imm)</p></td>
<td><p>map fd</p></td>
<td><p>map</p></td>
</tr>
<tr class="row-even"><td><p>0x2</p></td>
<td><p>dst = map_val(map_by_fd(imm)) + next_imm</p></td>
<td><p>map fd</p></td>
<td><p>data address</p></td>
</tr>
<tr class="row-odd"><td><p>0x3</p></td>
<td><p>dst = var_addr(imm)</p></td>
<td><p>variable id</p></td>
<td><p>data address</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>dst = code_addr(imm)</p></td>
<td><p>integer</p></td>
<td><p>code address</p></td>
</tr>
<tr class="row-odd"><td><p>0x5</p></td>
<td><p>dst = map_by_idx(imm)</p></td>
<td><p>map index</p></td>
<td><p>map</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>dst = map_val(map_by_idx(imm)) + next_imm</p></td>
<td><p>map index</p></td>
<td><p>data address</p></td>
</tr>
</tbody>
</table>
<p>where</p>
<ul class="simple">
<li><p>map_by_fd(imm) means to convert a 32-bit file descriptor into an address of a map (see <a class="reference internal" href="#maps">Maps</a>)</p></li>
<li><p>map_by_idx(imm) means to convert a 32-bit index into an address of a map</p></li>
<li><p>map_val(map) gets the address of the first value in a given map</p></li>
<li><p>var_addr(imm) gets the address of a platform variable (see <a class="reference internal" href="#platform-variables">Platform Variables</a>) with a given id</p></li>
<li><p>code_addr(imm) gets the address of the instruction at a specified relative offset in number of (64-bit) instructions</p></li>
<li><p>the ‘imm type’ can be used by disassemblers for display</p></li>
<li><p>the ‘dst type’ can be used for verification and JIT compilation purposes</p></li>
</ul>
<section id="maps">
<h4><a class="toc-backref" href="#id34" role="doc-backlink"><span class="sectnum">1.4.4.1 </span>Maps</a><a class="headerlink" href="#maps" title="Link to this heading">¶</a></h4>
<p>Maps are shared memory regions accessible by BPF programs on some platforms.
A map can have various semantics as defined in a separate document, and may or
may not have a single contiguous memory region, but the ‘map_val(map)’ is
currently only defined for maps that do have a single contiguous memory region.</p>
<p>Each map can have a file descriptor (fd) if supported by the platform, where
‘map_by_fd(imm)’ means to get the map with the specified file descriptor. Each
BPF program can also be defined to use a set of maps associated with the
program at load time, and ‘map_by_idx(imm)’ means to get the map with the given
index in the set associated with the BPF program containing the instruction.</p>
</section>
<section id="platform-variables">
<h4><a class="toc-backref" href="#id35" role="doc-backlink"><span class="sectnum">1.4.4.2 </span>Platform Variables</a><a class="headerlink" href="#platform-variables" title="Link to this heading">¶</a></h4>
<p>Platform variables are memory regions, identified by integer ids, exposed by
the runtime and accessible by BPF programs on some platforms.  The
‘var_addr(imm)’ operation means to get the address of the memory region
identified by the given id.</p>
</section>
</section>
<section id="legacy-bpf-packet-access-instructions">
<h3><a class="toc-backref" href="#id36" role="doc-backlink"><span class="sectnum">1.4.5 </span>Legacy BPF Packet access instructions</a><a class="headerlink" href="#legacy-bpf-packet-access-instructions" title="Link to this heading">¶</a></h3>
<p>BPF previously introduced special instructions for access to packet data that were
carried over from classic BPF. These instructions used an instruction
class of <code class="docutils literal notranslate"><span class="pre">LD</span></code>, a size modifier of <code class="docutils literal notranslate"><span class="pre">W</span></code>, <code class="docutils literal notranslate"><span class="pre">H</span></code>, or <code class="docutils literal notranslate"><span class="pre">B</span></code>, and a
mode modifier of <code class="docutils literal notranslate"><span class="pre">ABS</span></code> or <code class="docutils literal notranslate"><span class="pre">IND</span></code>.  The ‘dst_reg’ and ‘offset’ fields were
set to zero, and ‘src_reg’ was set to zero for <code class="docutils literal notranslate"><span class="pre">ABS</span></code>.  However, these
instructions are deprecated and SHOULD no longer be used.  All legacy packet
access instructions belong to the “packet” conformance group.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../../_sources/bpf/standardization/instruction-set.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>