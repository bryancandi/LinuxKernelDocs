
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>1 eBPF Instruction Set Specification, v1.0 &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="eBPF verifier" href="verifier.html" />
    <link rel="prev" title="BPF Documentation" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.5.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Kernel subsystem documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpu-freq/index.html">CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../networking/index.html">Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pcmcia/index.html">PCMCIA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../watchdog/index.html">Watchdog Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../virt/index.html">Virtualization Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hwmon/index.html">Hardware Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accel/index.html">Compute Accelerators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">BPF Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PCI/index.html">PCI Bus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l3"><a class="reference internal" href="../peci/index.html">PECI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi/index.html">WMI Subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  sbar.scrollTop = currents[currents.length - 1].offsetTop;
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/bpf/instruction-set.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <nav class="contents" id="contents" role="doc-toc">
<p class="topic-title">Contents</p>
<ul class="auto-toc simple">
<li><p><a class="reference internal" href="#ebpf-instruction-set-specification-v1-0" id="id1"><span class="sectnum">1 </span>eBPF Instruction Set Specification, v1.0</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#documentation-conventions" id="id2"><span class="sectnum">1.1 </span>Documentation conventions</a></p></li>
<li><p><a class="reference internal" href="#registers-and-calling-convention" id="id3"><span class="sectnum">1.2 </span>Registers and calling convention</a></p></li>
<li><p><a class="reference internal" href="#instruction-encoding" id="id4"><span class="sectnum">1.3 </span>Instruction encoding</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#instruction-classes" id="id5"><span class="sectnum">1.3.1 </span>Instruction classes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#arithmetic-and-jump-instructions" id="id6"><span class="sectnum">1.4 </span>Arithmetic and jump instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#arithmetic-instructions" id="id7"><span class="sectnum">1.4.1 </span>Arithmetic instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#byte-swap-instructions" id="id8"><span class="sectnum">1.4.1.1 </span>Byte swap instructions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#jump-instructions" id="id9"><span class="sectnum">1.4.2 </span>Jump instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#helper-functions" id="id10"><span class="sectnum">1.4.2.1 </span>Helper functions</a></p></li>
<li><p><a class="reference internal" href="#program-local-functions" id="id11"><span class="sectnum">1.4.2.2 </span>Program-local functions</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#load-and-store-instructions" id="id12"><span class="sectnum">1.5 </span>Load and store instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#regular-load-and-store-operations" id="id13"><span class="sectnum">1.5.1 </span>Regular load and store operations</a></p></li>
<li><p><a class="reference internal" href="#atomic-operations" id="id14"><span class="sectnum">1.5.2 </span>Atomic operations</a></p></li>
<li><p><a class="reference internal" href="#bit-immediate-instructions" id="id15"><span class="sectnum">1.5.3 </span>64-bit immediate instructions</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#maps" id="id16"><span class="sectnum">1.5.3.1 </span>Maps</a></p></li>
<li><p><a class="reference internal" href="#platform-variables" id="id17"><span class="sectnum">1.5.3.2 </span>Platform Variables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#legacy-bpf-packet-access-instructions" id="id18"><span class="sectnum">1.5.4 </span>Legacy BPF Packet access instructions</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="ebpf-instruction-set-specification-v1-0">
<h1><a class="toc-backref" href="#id1" role="doc-backlink"><span class="sectnum">1 </span>eBPF Instruction Set Specification, v1.0</a><a class="headerlink" href="#ebpf-instruction-set-specification-v1-0" title="Permalink to this heading">¶</a></h1>
<p>This document specifies version 1.0 of the eBPF instruction set.</p>
<section id="documentation-conventions">
<h2><a class="toc-backref" href="#id2" role="doc-backlink"><span class="sectnum">1.1 </span>Documentation conventions</a><a class="headerlink" href="#documentation-conventions" title="Permalink to this heading">¶</a></h2>
<p>For brevity, this document uses the type notion &quot;u64&quot;, &quot;u32&quot;, etc.
to mean an unsigned integer whose width is the specified number of bits,
and &quot;s32&quot;, etc. to mean a signed integer of the specified number of bits.</p>
</section>
<section id="registers-and-calling-convention">
<h2><a class="toc-backref" href="#id3" role="doc-backlink"><span class="sectnum">1.2 </span>Registers and calling convention</a><a class="headerlink" href="#registers-and-calling-convention" title="Permalink to this heading">¶</a></h2>
<p>eBPF has 10 general purpose registers and a read-only frame pointer register,
all of which are 64-bits wide.</p>
<p>The eBPF calling convention is defined as:</p>
<ul class="simple">
<li><p>R0: return value from function calls, and exit value for eBPF programs</p></li>
<li><p>R1 - R5: arguments for function calls</p></li>
<li><p>R6 - R9: callee saved registers that function calls will preserve</p></li>
<li><p>R10: read-only frame pointer to access stack</p></li>
</ul>
<p>R0 - R5 are scratch registers and eBPF programs needs to spill/fill them if
necessary across calls.</p>
</section>
<section id="instruction-encoding">
<h2><a class="toc-backref" href="#id4" role="doc-backlink"><span class="sectnum">1.3 </span>Instruction encoding</a><a class="headerlink" href="#instruction-encoding" title="Permalink to this heading">¶</a></h2>
<p>eBPF has two instruction encodings:</p>
<ul class="simple">
<li><p>the basic instruction encoding, which uses 64 bits to encode an instruction</p></li>
<li><p>the wide instruction encoding, which appends a second 64-bit immediate (i.e.,
constant) value after the basic instruction for a total of 128 bits.</p></li>
</ul>
<p>The fields conforming an encoded basic instruction are stored in the
following order:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>opcode:8 src_reg:4 dst_reg:4 offset:16 imm:32 // In little-endian BPF.
opcode:8 dst_reg:4 src_reg:4 offset:16 imm:32 // In big-endian BPF.
</pre></div>
</div>
<dl class="simple">
<dt><strong>imm</strong></dt><dd><p>signed integer immediate value</p>
</dd>
<dt><strong>offset</strong></dt><dd><p>signed integer offset used with pointer arithmetic</p>
</dd>
<dt><strong>src_reg</strong></dt><dd><p>the source register number (0-10), except where otherwise specified
(<a class="reference internal" href="#bit-immediate-instructions">64-bit immediate instructions</a> reuse this field for other purposes)</p>
</dd>
<dt><strong>dst_reg</strong></dt><dd><p>destination register number (0-10)</p>
</dd>
<dt><strong>opcode</strong></dt><dd><p>operation to perform</p>
</dd>
</dl>
<p>Note that the contents of multi-byte fields ('imm' and 'offset') are
stored using big-endian byte ordering in big-endian BPF and
little-endian byte ordering in little-endian BPF.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>opcode                  offset imm          assembly
       src_reg dst_reg
07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // little
       dst_reg src_reg
07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // big
</pre></div>
</div>
<p>Note that most instructions do not use all of the fields.
Unused fields shall be cleared to zero.</p>
<p>As discussed below in <a class="reference internal" href="#bit-immediate-instructions">64-bit immediate instructions</a>, a 64-bit immediate
instruction uses a 64-bit immediate value that is constructed as follows.
The 64 bits following the basic instruction contain a pseudo instruction
using the same format but with opcode, dst_reg, src_reg, and offset all set to zero,
and imm containing the high 32 bits of the immediate value.</p>
<p>This is depicted in the following figure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      basic_instruction
.-----------------------------.
|                             |
code:8 regs:8 offset:16 imm:32 unused:32 imm:32
                               |              |
                               &#39;--------------&#39;
                              pseudo instruction
</pre></div>
</div>
<p>Thus the 64-bit immediate value is constructed as follows:</p>
<blockquote>
<div><p>imm64 = (next_imm &lt;&lt; 32) | imm</p>
</div></blockquote>
<p>where 'next_imm' refers to the imm value of the pseudo instruction
following the basic instruction.  The unused bytes in the pseudo
instruction are reserved and shall be cleared to zero.</p>
<section id="instruction-classes">
<h3><a class="toc-backref" href="#id5" role="doc-backlink"><span class="sectnum">1.3.1 </span>Instruction classes</a><a class="headerlink" href="#instruction-classes" title="Permalink to this heading">¶</a></h3>
<p>The three LSB bits of the 'opcode' field store the instruction class:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>class</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
<th class="head"><p>reference</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_LD</p></td>
<td><p>0x00</p></td>
<td><p>non-standard load operations</p></td>
<td><p><a class="reference internal" href="#load-and-store-instructions">Load and store instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>BPF_LDX</p></td>
<td><p>0x01</p></td>
<td><p>load into register operations</p></td>
<td><p><a class="reference internal" href="#load-and-store-instructions">Load and store instructions</a></p></td>
</tr>
<tr class="row-even"><td><p>BPF_ST</p></td>
<td><p>0x02</p></td>
<td><p>store from immediate operations</p></td>
<td><p><a class="reference internal" href="#load-and-store-instructions">Load and store instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>BPF_STX</p></td>
<td><p>0x03</p></td>
<td><p>store from register operations</p></td>
<td><p><a class="reference internal" href="#load-and-store-instructions">Load and store instructions</a></p></td>
</tr>
<tr class="row-even"><td><p>BPF_ALU</p></td>
<td><p>0x04</p></td>
<td><p>32-bit arithmetic operations</p></td>
<td><p><a class="reference internal" href="#arithmetic-and-jump-instructions">Arithmetic and jump instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>BPF_JMP</p></td>
<td><p>0x05</p></td>
<td><p>64-bit jump operations</p></td>
<td><p><a class="reference internal" href="#arithmetic-and-jump-instructions">Arithmetic and jump instructions</a></p></td>
</tr>
<tr class="row-even"><td><p>BPF_JMP32</p></td>
<td><p>0x06</p></td>
<td><p>32-bit jump operations</p></td>
<td><p><a class="reference internal" href="#arithmetic-and-jump-instructions">Arithmetic and jump instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>BPF_ALU64</p></td>
<td><p>0x07</p></td>
<td><p>64-bit arithmetic operations</p></td>
<td><p><a class="reference internal" href="#arithmetic-and-jump-instructions">Arithmetic and jump instructions</a></p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="arithmetic-and-jump-instructions">
<h2><a class="toc-backref" href="#id6" role="doc-backlink"><span class="sectnum">1.4 </span>Arithmetic and jump instructions</a><a class="headerlink" href="#arithmetic-and-jump-instructions" title="Permalink to this heading">¶</a></h2>
<p>For arithmetic and jump instructions (<code class="docutils literal notranslate"><span class="pre">BPF_ALU</span></code>, <code class="docutils literal notranslate"><span class="pre">BPF_ALU64</span></code>, <code class="docutils literal notranslate"><span class="pre">BPF_JMP</span></code> and
<code class="docutils literal notranslate"><span class="pre">BPF_JMP32</span></code>), the 8-bit 'opcode' field is divided into three parts:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>4 bits (MSB)</p></th>
<th class="head"><p>1 bit</p></th>
<th class="head"><p>3 bits (LSB)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>code</p></td>
<td><p>source</p></td>
<td><p>instruction class</p></td>
</tr>
</tbody>
</table>
<dl>
<dt><strong>code</strong></dt><dd><p>the operation code, whose meaning varies by instruction class</p>
</dd>
<dt><strong>source</strong></dt><dd><p>the source operand location, which unless otherwise specified is one of:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>source</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_K</p></td>
<td><p>0x00</p></td>
<td><p>use 32-bit 'imm' value as source operand</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_X</p></td>
<td><p>0x08</p></td>
<td><p>use 'src_reg' register value as source operand</p></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>instruction class</strong></dt><dd><p>the instruction class (see <a class="reference internal" href="#instruction-classes">Instruction classes</a>)</p>
</dd>
</dl>
<section id="arithmetic-instructions">
<h3><a class="toc-backref" href="#id7" role="doc-backlink"><span class="sectnum">1.4.1 </span>Arithmetic instructions</a><a class="headerlink" href="#arithmetic-instructions" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">BPF_ALU</span></code> uses 32-bit wide operands while <code class="docutils literal notranslate"><span class="pre">BPF_ALU64</span></code> uses 64-bit wide operands for
otherwise identical operations.
The 'code' field encodes the operation as below, where 'src' and 'dst' refer
to the values of the source and destination registers, respectively.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>code</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_ADD</p></td>
<td><p>0x00</p></td>
<td><p>dst += src</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_SUB</p></td>
<td><p>0x10</p></td>
<td><p>dst -= src</p></td>
</tr>
<tr class="row-even"><td><p>BPF_MUL</p></td>
<td><p>0x20</p></td>
<td><p>dst *= src</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_DIV</p></td>
<td><p>0x30</p></td>
<td><p>dst = (src != 0) ? (dst / src) : 0</p></td>
</tr>
<tr class="row-even"><td><p>BPF_OR</p></td>
<td><p>0x40</p></td>
<td><p>dst |= src</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_AND</p></td>
<td><p>0x50</p></td>
<td><p>dst &amp;= src</p></td>
</tr>
<tr class="row-even"><td><p>BPF_LSH</p></td>
<td><p>0x60</p></td>
<td><p>dst &lt;&lt;= (src &amp; mask)</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_RSH</p></td>
<td><p>0x70</p></td>
<td><p>dst &gt;&gt;= (src &amp; mask)</p></td>
</tr>
<tr class="row-even"><td><p>BPF_NEG</p></td>
<td><p>0x80</p></td>
<td><p>dst = ~src</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_MOD</p></td>
<td><p>0x90</p></td>
<td><p>dst = (src != 0) ? (dst % src) : dst</p></td>
</tr>
<tr class="row-even"><td><p>BPF_XOR</p></td>
<td><p>0xa0</p></td>
<td><p>dst ^= src</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_MOV</p></td>
<td><p>0xb0</p></td>
<td><p>dst = src</p></td>
</tr>
<tr class="row-even"><td><p>BPF_ARSH</p></td>
<td><p>0xc0</p></td>
<td><p>sign extending dst &gt;&gt;= (src &amp; mask)</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_END</p></td>
<td><p>0xd0</p></td>
<td><p>byte swap operations (see <a class="reference internal" href="#byte-swap-instructions">Byte swap instructions</a> below)</p></td>
</tr>
</tbody>
</table>
<p>Underflow and overflow are allowed during arithmetic operations, meaning
the 64-bit or 32-bit value will wrap. If eBPF program execution would
result in division by zero, the destination register is instead set to zero.
If execution would result in modulo by zero, for <code class="docutils literal notranslate"><span class="pre">BPF_ALU64</span></code> the value of
the destination register is unchanged whereas for <code class="docutils literal notranslate"><span class="pre">BPF_ALU</span></code> the upper
32 bits of the destination register are zeroed.</p>
<p><code class="docutils literal notranslate"><span class="pre">BPF_ADD</span> <span class="pre">|</span> <span class="pre">BPF_X</span> <span class="pre">|</span> <span class="pre">BPF_ALU</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = (u32) ((u32) dst + (u32) src)
</pre></div>
</div>
<p>where '(u32)' indicates that the upper 32 bits are zeroed.</p>
<p><code class="docutils literal notranslate"><span class="pre">BPF_ADD</span> <span class="pre">|</span> <span class="pre">BPF_X</span> <span class="pre">|</span> <span class="pre">BPF_ALU64</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = dst + src
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BPF_XOR</span> <span class="pre">|</span> <span class="pre">BPF_K</span> <span class="pre">|</span> <span class="pre">BPF_ALU</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = (u32) dst ^ (u32) imm32
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BPF_XOR</span> <span class="pre">|</span> <span class="pre">BPF_K</span> <span class="pre">|</span> <span class="pre">BPF_ALU64</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = dst ^ imm32
</pre></div>
</div>
<p>Also note that the division and modulo operations are unsigned. Thus, for
<code class="docutils literal notranslate"><span class="pre">BPF_ALU</span></code>, 'imm' is first interpreted as an unsigned 32-bit value, whereas
for <code class="docutils literal notranslate"><span class="pre">BPF_ALU64</span></code>, 'imm' is first sign extended to 64 bits and the result
interpreted as an unsigned 64-bit value. There are no instructions for
signed division or modulo.</p>
<p>Shift operations use a mask of 0x3F (63) for 64-bit operations and 0x1F (31)
for 32-bit operations.</p>
<section id="byte-swap-instructions">
<h4><a class="toc-backref" href="#id8" role="doc-backlink"><span class="sectnum">1.4.1.1 </span>Byte swap instructions</a><a class="headerlink" href="#byte-swap-instructions" title="Permalink to this heading">¶</a></h4>
<p>The byte swap instructions use an instruction class of <code class="docutils literal notranslate"><span class="pre">BPF_ALU</span></code> and a 4-bit
'code' field of <code class="docutils literal notranslate"><span class="pre">BPF_END</span></code>.</p>
<p>The byte swap instructions operate on the destination register
only and do not use a separate source register or immediate value.</p>
<p>The 1-bit source operand field in the opcode is used to select what byte
order the operation convert from or to:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>source</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_TO_LE</p></td>
<td><p>0x00</p></td>
<td><p>convert between host byte order and little endian</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_TO_BE</p></td>
<td><p>0x08</p></td>
<td><p>convert between host byte order and big endian</p></td>
</tr>
</tbody>
</table>
<p>The 'imm' field encodes the width of the swap operations.  The following widths
are supported: 16, 32 and 64.</p>
<p>Examples:</p>
<p><code class="docutils literal notranslate"><span class="pre">BPF_ALU</span> <span class="pre">|</span> <span class="pre">BPF_TO_LE</span> <span class="pre">|</span> <span class="pre">BPF_END</span></code> with imm = 16 means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = htole16(dst)
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BPF_ALU</span> <span class="pre">|</span> <span class="pre">BPF_TO_BE</span> <span class="pre">|</span> <span class="pre">BPF_END</span></code> with imm = 64 means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = htobe64(dst)
</pre></div>
</div>
</section>
</section>
<section id="jump-instructions">
<h3><a class="toc-backref" href="#id9" role="doc-backlink"><span class="sectnum">1.4.2 </span>Jump instructions</a><a class="headerlink" href="#jump-instructions" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">BPF_JMP32</span></code> uses 32-bit wide operands while <code class="docutils literal notranslate"><span class="pre">BPF_JMP</span></code> uses 64-bit wide operands for
otherwise identical operations.
The 'code' field encodes the operation as below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>code</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>src</p></th>
<th class="head"><p>description</p></th>
<th class="head"><p>notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_JA</p></td>
<td><p>0x0</p></td>
<td><p>0x0</p></td>
<td><p>PC += offset</p></td>
<td><p>BPF_JMP only</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_JEQ</p></td>
<td><p>0x1</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst == src</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>BPF_JGT</p></td>
<td><p>0x2</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &gt; src</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_JGE</p></td>
<td><p>0x3</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &gt;= src</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-even"><td><p>BPF_JSET</p></td>
<td><p>0x4</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &amp; src</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>BPF_JNE</p></td>
<td><p>0x5</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst != src</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>BPF_JSGT</p></td>
<td><p>0x6</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &gt; src</p></td>
<td><p>signed</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_JSGE</p></td>
<td><p>0x7</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &gt;= src</p></td>
<td><p>signed</p></td>
</tr>
<tr class="row-even"><td><p>BPF_CALL</p></td>
<td><p>0x8</p></td>
<td><p>0x0</p></td>
<td><p>call helper function by address</p></td>
<td><p>see <a class="reference internal" href="#helper-functions">Helper functions</a></p></td>
</tr>
<tr class="row-odd"><td><p>BPF_CALL</p></td>
<td><p>0x8</p></td>
<td><p>0x1</p></td>
<td><p>call PC += offset</p></td>
<td><p>see <a class="reference internal" href="#program-local-functions">Program-local functions</a></p></td>
</tr>
<tr class="row-even"><td><p>BPF_CALL</p></td>
<td><p>0x8</p></td>
<td><p>0x2</p></td>
<td><p>call helper function by BTF ID</p></td>
<td><p>see <a class="reference internal" href="#helper-functions">Helper functions</a></p></td>
</tr>
<tr class="row-odd"><td><p>BPF_EXIT</p></td>
<td><p>0x9</p></td>
<td><p>0x0</p></td>
<td><p>return</p></td>
<td><p>BPF_JMP only</p></td>
</tr>
<tr class="row-even"><td><p>BPF_JLT</p></td>
<td><p>0xa</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &lt; src</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_JLE</p></td>
<td><p>0xb</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &lt;= src</p></td>
<td><p>unsigned</p></td>
</tr>
<tr class="row-even"><td><p>BPF_JSLT</p></td>
<td><p>0xc</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &lt; src</p></td>
<td><p>signed</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_JSLE</p></td>
<td><p>0xd</p></td>
<td><p>any</p></td>
<td><p>PC += offset if dst &lt;= src</p></td>
<td><p>signed</p></td>
</tr>
</tbody>
</table>
<p>The eBPF program needs to store the return value into register R0 before doing a
<code class="docutils literal notranslate"><span class="pre">BPF_EXIT</span></code>.</p>
<p>Example:</p>
<p><code class="docutils literal notranslate"><span class="pre">BPF_JSGE</span> <span class="pre">|</span> <span class="pre">BPF_X</span> <span class="pre">|</span> <span class="pre">BPF_JMP32</span></code> (0x7e) means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (s32)dst s&gt;= (s32)src goto +offset
</pre></div>
</div>
<p>where 's&gt;=' indicates a signed '&gt;=' comparison.</p>
<section id="helper-functions">
<h4><a class="toc-backref" href="#id10" role="doc-backlink"><span class="sectnum">1.4.2.1 </span>Helper functions</a><a class="headerlink" href="#helper-functions" title="Permalink to this heading">¶</a></h4>
<p>Helper functions are a concept whereby BPF programs can call into a
set of function calls exposed by the underlying platform.</p>
<p>Historically, each helper function was identified by an address
encoded in the imm field.  The available helper functions may differ
for each program type, but address values are unique across all program types.</p>
<p>Platforms that support the BPF Type Format (BTF) support identifying
a helper function by a BTF ID encoded in the imm field, where the BTF ID
identifies the helper name and type.</p>
</section>
<section id="program-local-functions">
<h4><a class="toc-backref" href="#id11" role="doc-backlink"><span class="sectnum">1.4.2.2 </span>Program-local functions</a><a class="headerlink" href="#program-local-functions" title="Permalink to this heading">¶</a></h4>
<p>Program-local functions are functions exposed by the same BPF program as the
caller, and are referenced by offset from the call instruction, similar to
<code class="docutils literal notranslate"><span class="pre">BPF_JA</span></code>.  A <code class="docutils literal notranslate"><span class="pre">BPF_EXIT</span></code> within the program-local function will return to
the caller.</p>
</section>
</section>
</section>
<section id="load-and-store-instructions">
<h2><a class="toc-backref" href="#id12" role="doc-backlink"><span class="sectnum">1.5 </span>Load and store instructions</a><a class="headerlink" href="#load-and-store-instructions" title="Permalink to this heading">¶</a></h2>
<p>For load and store instructions (<code class="docutils literal notranslate"><span class="pre">BPF_LD</span></code>, <code class="docutils literal notranslate"><span class="pre">BPF_LDX</span></code>, <code class="docutils literal notranslate"><span class="pre">BPF_ST</span></code>, and <code class="docutils literal notranslate"><span class="pre">BPF_STX</span></code>), the
8-bit 'opcode' field is divided as:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>3 bits (MSB)</p></th>
<th class="head"><p>2 bits</p></th>
<th class="head"><p>3 bits (LSB)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>mode</p></td>
<td><p>size</p></td>
<td><p>instruction class</p></td>
</tr>
</tbody>
</table>
<p>The mode modifier is one of:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>mode modifier</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
<th class="head"><p>reference</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_IMM</p></td>
<td><p>0x00</p></td>
<td><p>64-bit immediate instructions</p></td>
<td><p><a class="reference internal" href="#bit-immediate-instructions">64-bit immediate instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>BPF_ABS</p></td>
<td><p>0x20</p></td>
<td><p>legacy BPF packet access (absolute)</p></td>
<td><p><a class="reference internal" href="#legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</a></p></td>
</tr>
<tr class="row-even"><td><p>BPF_IND</p></td>
<td><p>0x40</p></td>
<td><p>legacy BPF packet access (indirect)</p></td>
<td><p><a class="reference internal" href="#legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</a></p></td>
</tr>
<tr class="row-odd"><td><p>BPF_MEM</p></td>
<td><p>0x60</p></td>
<td><p>regular load and store operations</p></td>
<td><p><a class="reference internal" href="#regular-load-and-store-operations">Regular load and store operations</a></p></td>
</tr>
<tr class="row-even"><td><p>BPF_ATOMIC</p></td>
<td><p>0xc0</p></td>
<td><p>atomic operations</p></td>
<td><p><a class="reference internal" href="#atomic-operations">Atomic operations</a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The size modifier is one of:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>size modifier</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_W</p></td>
<td><p>0x00</p></td>
<td><p>word        (4 bytes)</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_H</p></td>
<td><p>0x08</p></td>
<td><p>half word   (2 bytes)</p></td>
</tr>
<tr class="row-even"><td><p>BPF_B</p></td>
<td><p>0x10</p></td>
<td><p>byte</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_DW</p></td>
<td><p>0x18</p></td>
<td><p>double word (8 bytes)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<section id="regular-load-and-store-operations">
<h3><a class="toc-backref" href="#id13" role="doc-backlink"><span class="sectnum">1.5.1 </span>Regular load and store operations</a><a class="headerlink" href="#regular-load-and-store-operations" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">BPF_MEM</span></code> mode modifier is used to encode regular load and store
instructions that transfer data between a register and memory.</p>
<p><code class="docutils literal notranslate"><span class="pre">BPF_MEM</span> <span class="pre">|</span> <span class="pre">&lt;size&gt;</span> <span class="pre">|</span> <span class="pre">BPF_STX</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*(size *) (dst + offset) = src
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BPF_MEM</span> <span class="pre">|</span> <span class="pre">&lt;size&gt;</span> <span class="pre">|</span> <span class="pre">BPF_ST</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*(size *) (dst + offset) = imm32
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BPF_MEM</span> <span class="pre">|</span> <span class="pre">&lt;size&gt;</span> <span class="pre">|</span> <span class="pre">BPF_LDX</span></code> means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dst = *(size *) (src + offset)
</pre></div>
</div>
<p>Where size is one of: <code class="docutils literal notranslate"><span class="pre">BPF_B</span></code>, <code class="docutils literal notranslate"><span class="pre">BPF_H</span></code>, <code class="docutils literal notranslate"><span class="pre">BPF_W</span></code>, or <code class="docutils literal notranslate"><span class="pre">BPF_DW</span></code>.</p>
</section>
<section id="atomic-operations">
<h3><a class="toc-backref" href="#id14" role="doc-backlink"><span class="sectnum">1.5.2 </span>Atomic operations</a><a class="headerlink" href="#atomic-operations" title="Permalink to this heading">¶</a></h3>
<p>Atomic operations are operations that operate on memory and can not be
interrupted or corrupted by other access to the same memory region
by other eBPF programs or means outside of this specification.</p>
<p>All atomic operations supported by eBPF are encoded as store operations
that use the <code class="docutils literal notranslate"><span class="pre">BPF_ATOMIC</span></code> mode modifier as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BPF_ATOMIC</span> <span class="pre">|</span> <span class="pre">BPF_W</span> <span class="pre">|</span> <span class="pre">BPF_STX</span></code> for 32-bit operations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BPF_ATOMIC</span> <span class="pre">|</span> <span class="pre">BPF_DW</span> <span class="pre">|</span> <span class="pre">BPF_STX</span></code> for 64-bit operations</p></li>
<li><p>8-bit and 16-bit wide atomic operations are not supported.</p></li>
</ul>
<p>The 'imm' field is used to encode the actual atomic operation.
Simple atomic operation use a subset of the values defined to encode
arithmetic operations in the 'imm' field to encode the atomic operation:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>imm</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_ADD</p></td>
<td><p>0x00</p></td>
<td><p>atomic add</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_OR</p></td>
<td><p>0x40</p></td>
<td><p>atomic or</p></td>
</tr>
<tr class="row-even"><td><p>BPF_AND</p></td>
<td><p>0x50</p></td>
<td><p>atomic and</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_XOR</p></td>
<td><p>0xa0</p></td>
<td><p>atomic xor</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">BPF_ATOMIC</span> <span class="pre">|</span> <span class="pre">BPF_W</span>&#160; <span class="pre">|</span> <span class="pre">BPF_STX</span></code> with 'imm' = BPF_ADD means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*(u32 *)(dst + offset) += src
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BPF_ATOMIC</span> <span class="pre">|</span> <span class="pre">BPF_DW</span> <span class="pre">|</span> <span class="pre">BPF_STX</span></code> with 'imm' = BPF ADD means:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*(u64 *)(dst + offset) += src
</pre></div>
</div>
<p>In addition to the simple atomic operations, there also is a modifier and
two complex atomic operations:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>imm</p></th>
<th class="head"><p>value</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_FETCH</p></td>
<td><p>0x01</p></td>
<td><p>modifier: return old value</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_XCHG</p></td>
<td><p>0xe0 | BPF_FETCH</p></td>
<td><p>atomic exchange</p></td>
</tr>
<tr class="row-even"><td><p>BPF_CMPXCHG</p></td>
<td><p>0xf0 | BPF_FETCH</p></td>
<td><p>atomic compare and exchange</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">BPF_FETCH</span></code> modifier is optional for simple atomic operations, and
always set for the complex atomic operations.  If the <code class="docutils literal notranslate"><span class="pre">BPF_FETCH</span></code> flag
is set, then the operation also overwrites <code class="docutils literal notranslate"><span class="pre">src</span></code> with the value that
was in memory before it was modified.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BPF_XCHG</span></code> operation atomically exchanges <code class="docutils literal notranslate"><span class="pre">src</span></code> with the value
addressed by <code class="docutils literal notranslate"><span class="pre">dst</span> <span class="pre">+</span> <span class="pre">offset</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BPF_CMPXCHG</span></code> operation atomically compares the value addressed by
<code class="docutils literal notranslate"><span class="pre">dst</span> <span class="pre">+</span> <span class="pre">offset</span></code> with <code class="docutils literal notranslate"><span class="pre">R0</span></code>. If they match, the value addressed by
<code class="docutils literal notranslate"><span class="pre">dst</span> <span class="pre">+</span> <span class="pre">offset</span></code> is replaced with <code class="docutils literal notranslate"><span class="pre">src</span></code>. In either case, the
value that was at <code class="docutils literal notranslate"><span class="pre">dst</span> <span class="pre">+</span> <span class="pre">offset</span></code> before the operation is zero-extended
and loaded back to <code class="docutils literal notranslate"><span class="pre">R0</span></code>.</p>
</section>
<section id="bit-immediate-instructions">
<h3><a class="toc-backref" href="#id15" role="doc-backlink"><span class="sectnum">1.5.3 </span>64-bit immediate instructions</a><a class="headerlink" href="#bit-immediate-instructions" title="Permalink to this heading">¶</a></h3>
<p>Instructions with the <code class="docutils literal notranslate"><span class="pre">BPF_IMM</span></code> 'mode' modifier use the wide instruction
encoding defined in <a class="reference internal" href="#instruction-encoding">Instruction encoding</a>, and use the 'src' field of the
basic instruction to hold an opcode subtype.</p>
<p>The following table defines a set of <code class="docutils literal notranslate"><span class="pre">BPF_IMM</span> <span class="pre">|</span> <span class="pre">BPF_DW</span> <span class="pre">|</span> <span class="pre">BPF_LD</span></code> instructions
with opcode subtypes in the 'src' field, using new terms such as &quot;map&quot;
defined further below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>opcode construction</p></th>
<th class="head"><p>opcode</p></th>
<th class="head"><p>src</p></th>
<th class="head"><p>pseudocode</p></th>
<th class="head"><p>imm type</p></th>
<th class="head"><p>dst type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPF_IMM | BPF_DW | BPF_LD</p></td>
<td><p>0x18</p></td>
<td><p>0x0</p></td>
<td><p>dst = imm64</p></td>
<td><p>integer</p></td>
<td><p>integer</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_IMM | BPF_DW | BPF_LD</p></td>
<td><p>0x18</p></td>
<td><p>0x1</p></td>
<td><p>dst = map_by_fd(imm)</p></td>
<td><p>map fd</p></td>
<td><p>map</p></td>
</tr>
<tr class="row-even"><td><p>BPF_IMM | BPF_DW | BPF_LD</p></td>
<td><p>0x18</p></td>
<td><p>0x2</p></td>
<td><p>dst = map_val(map_by_fd(imm)) + next_imm</p></td>
<td><p>map fd</p></td>
<td><p>data pointer</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_IMM | BPF_DW | BPF_LD</p></td>
<td><p>0x18</p></td>
<td><p>0x3</p></td>
<td><p>dst = var_addr(imm)</p></td>
<td><p>variable id</p></td>
<td><p>data pointer</p></td>
</tr>
<tr class="row-even"><td><p>BPF_IMM | BPF_DW | BPF_LD</p></td>
<td><p>0x18</p></td>
<td><p>0x4</p></td>
<td><p>dst = code_addr(imm)</p></td>
<td><p>integer</p></td>
<td><p>code pointer</p></td>
</tr>
<tr class="row-odd"><td><p>BPF_IMM | BPF_DW | BPF_LD</p></td>
<td><p>0x18</p></td>
<td><p>0x5</p></td>
<td><p>dst = map_by_idx(imm)</p></td>
<td><p>map index</p></td>
<td><p>map</p></td>
</tr>
<tr class="row-even"><td><p>BPF_IMM | BPF_DW | BPF_LD</p></td>
<td><p>0x18</p></td>
<td><p>0x6</p></td>
<td><p>dst = map_val(map_by_idx(imm)) + next_imm</p></td>
<td><p>map index</p></td>
<td><p>data pointer</p></td>
</tr>
</tbody>
</table>
<p>where</p>
<ul class="simple">
<li><p>map_by_fd(imm) means to convert a 32-bit file descriptor into an address of a map (see <a class="reference internal" href="#maps">Maps</a>)</p></li>
<li><p>map_by_idx(imm) means to convert a 32-bit index into an address of a map</p></li>
<li><p>map_val(map) gets the address of the first value in a given map</p></li>
<li><p>var_addr(imm) gets the address of a platform variable (see <a class="reference internal" href="#platform-variables">Platform Variables</a>) with a given id</p></li>
<li><p>code_addr(imm) gets the address of the instruction at a specified relative offset in number of (64-bit) instructions</p></li>
<li><p>the 'imm type' can be used by disassemblers for display</p></li>
<li><p>the 'dst type' can be used for verification and JIT compilation purposes</p></li>
</ul>
<section id="maps">
<h4><a class="toc-backref" href="#id16" role="doc-backlink"><span class="sectnum">1.5.3.1 </span>Maps</a><a class="headerlink" href="#maps" title="Permalink to this heading">¶</a></h4>
<p>Maps are shared memory regions accessible by eBPF programs on some platforms.
A map can have various semantics as defined in a separate document, and may or
may not have a single contiguous memory region, but the 'map_val(map)' is
currently only defined for maps that do have a single contiguous memory region.</p>
<p>Each map can have a file descriptor (fd) if supported by the platform, where
'map_by_fd(imm)' means to get the map with the specified file descriptor. Each
BPF program can also be defined to use a set of maps associated with the
program at load time, and 'map_by_idx(imm)' means to get the map with the given
index in the set associated with the BPF program containing the instruction.</p>
</section>
<section id="platform-variables">
<h4><a class="toc-backref" href="#id17" role="doc-backlink"><span class="sectnum">1.5.3.2 </span>Platform Variables</a><a class="headerlink" href="#platform-variables" title="Permalink to this heading">¶</a></h4>
<p>Platform variables are memory regions, identified by integer ids, exposed by
the runtime and accessible by BPF programs on some platforms.  The
'var_addr(imm)' operation means to get the address of the memory region
identified by the given id.</p>
</section>
</section>
<section id="legacy-bpf-packet-access-instructions">
<h3><a class="toc-backref" href="#id18" role="doc-backlink"><span class="sectnum">1.5.4 </span>Legacy BPF Packet access instructions</a><a class="headerlink" href="#legacy-bpf-packet-access-instructions" title="Permalink to this heading">¶</a></h3>
<p>eBPF previously introduced special instructions for access to packet data that were
carried over from classic BPF. However, these instructions are
deprecated and should no longer be used.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/bpf/instruction-set.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>