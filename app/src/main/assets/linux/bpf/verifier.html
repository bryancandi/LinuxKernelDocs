
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>eBPF verifier &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="libbpf" href="libbpf/index.html" />
    <link rel="prev" title="BPF Documentation" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.6.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Kernel subsystem documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpu-freq/index.html">CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pcmcia/index.html">PCMCIA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../watchdog/index.html">Watchdog Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../virt/index.html">Virtualization Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hwmon/index.html">Hardware Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accel/index.html">Compute Accelerators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto API</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">BPF Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PCI/index.html">PCI Bus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../peci/index.html">PECI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi/index.html">WMI Subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  sbar.scrollTop = currents[currents.length - 1].offsetTop;
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/bpf/verifier.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="ebpf-verifier">
<h1>eBPF verifier<a class="headerlink" href="#ebpf-verifier" title="Permalink to this heading">¶</a></h1>
<p>The safety of the eBPF program is determined in two steps.</p>
<p>First step does DAG check to disallow loops and other CFG validation.
In particular it will detect programs that have unreachable instructions.
(though classic BPF checker allows them)</p>
<p>Second step starts from the first insn and descends all possible paths.
It simulates execution of every insn and observes the state change of
registers and stack.</p>
<p>At the start of the program the register R1 contains a pointer to context
and has type PTR_TO_CTX.
If verifier sees an insn that does R2=R1, then R2 has now type
PTR_TO_CTX as well and can be used on the right hand side of expression.
If R1=PTR_TO_CTX and insn is R2=R1+R1, then R2=SCALAR_VALUE,
since addition of two valid pointers makes invalid pointer.
(In 'secure' mode verifier will reject any type of pointer arithmetic to make
sure that kernel addresses don't leak to unprivileged users)</p>
<p>If register was never written to, it's not readable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bpf_mov R0 = R2
bpf_exit
</pre></div>
</div>
<p>will be rejected, since R2 is unreadable at the start of the program.</p>
<p>After kernel function call, R1-R5 are reset to unreadable and
R0 has a return type of the function.</p>
<p>Since R6-R9 are callee saved, their state is preserved across the call.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bpf_mov R6 = 1
bpf_call foo
bpf_mov R0 = R6
bpf_exit
</pre></div>
</div>
<p>is a correct program. If there was R1 instead of R6, it would have
been rejected.</p>
<p>load/store instructions are allowed only with registers of valid types, which
are PTR_TO_CTX, PTR_TO_MAP, PTR_TO_STACK. They are bounds and alignment checked.
For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bpf_mov R1 = 1
bpf_mov R2 = 2
bpf_xadd *(u32 *)(R1 + 3) += R2
bpf_exit
</pre></div>
</div>
<p>will be rejected, since R1 doesn't have a valid pointer type at the time of
execution of instruction bpf_xadd.</p>
<p>At the start R1 type is PTR_TO_CTX (a pointer to generic <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_context</span></code>)
A callback is used to customize verifier to restrict eBPF program access to only
certain fields within ctx structure with specified size and alignment.</p>
<p>For example, the following insn:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bpf_ld R0 = *(u32 *)(R6 + 8)
</pre></div>
</div>
<p>intends to load a word from address R6 + 8 and store it into R0
If R6=PTR_TO_CTX, via is_valid_access() callback the verifier will know
that offset 8 of size 4 bytes can be accessed for reading, otherwise
the verifier will reject the program.
If R6=PTR_TO_STACK, then access should be aligned and be within
stack bounds, which are [-MAX_BPF_STACK, 0). In this example offset is 8,
so it will fail verification, since it's out of bounds.</p>
<p>The verifier will allow eBPF program to read data from stack only after
it wrote into it.</p>
<p>Classic BPF verifier does similar check with M[0-15] memory slots.
For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bpf_ld R0 = *(u32 *)(R10 - 4)
bpf_exit
</pre></div>
</div>
<p>is invalid program.
Though R10 is correct read-only register and has type PTR_TO_STACK
and R10 - 4 is within stack bounds, there were no stores into that location.</p>
<p>Pointer register spill/fill is tracked as well, since four (R6-R9)
callee saved registers may not be enough for some programs.</p>
<p>Allowed function calls are customized with bpf_verifier_ops-&gt;get_func_proto()
The eBPF verifier will check that registers match argument constraints.
After the call register R0 will be set to return type of the function.</p>
<p>Function calls is a main mechanism to extend functionality of eBPF programs.
Socket filters may let programs to call one set of functions, whereas tracing
filters may allow completely different set.</p>
<p>If a function made accessible to eBPF program, it needs to be thought through
from safety point of view. The verifier will guarantee that the function is
called with valid arguments.</p>
<p>seccomp vs socket filters have different security restrictions for classic BPF.
Seccomp solves this by two stage verifier: classic BPF verifier is followed
by seccomp verifier. In case of eBPF one configurable verifier is shared for
all use cases.</p>
<p>See details of eBPF verifier in kernel/bpf/verifier.c</p>
<section id="register-value-tracking">
<h2>Register value tracking<a class="headerlink" href="#register-value-tracking" title="Permalink to this heading">¶</a></h2>
<p>In order to determine the safety of an eBPF program, the verifier must track
the range of possible values in each register and also in each stack slot.
This is done with <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_reg_state</span></code>, defined in include/linux/
bpf_verifier.h, which unifies tracking of scalar and pointer values.  Each
register state has a type, which is either NOT_INIT (the register has not been
written to), SCALAR_VALUE (some value which is not usable as a pointer), or a
pointer type.  The types of pointers describe their base, as follows:</p>
<blockquote>
<div><dl class="simple">
<dt>PTR_TO_CTX</dt><dd><p>Pointer to bpf_context.</p>
</dd>
<dt>CONST_PTR_TO_MAP</dt><dd><p>Pointer to struct bpf_map.  &quot;Const&quot; because arithmetic
on these pointers is forbidden.</p>
</dd>
<dt>PTR_TO_MAP_VALUE</dt><dd><p>Pointer to the value stored in a map element.</p>
</dd>
<dt>PTR_TO_MAP_VALUE_OR_NULL</dt><dd><p>Either a pointer to a map value, or NULL; map accesses
(see <a class="reference internal" href="maps.html"><span class="doc">BPF maps</span></a>) return this type, which becomes a
PTR_TO_MAP_VALUE when checked != NULL. Arithmetic on
these pointers is forbidden.</p>
</dd>
<dt>PTR_TO_STACK</dt><dd><p>Frame pointer.</p>
</dd>
<dt>PTR_TO_PACKET</dt><dd><p>skb-&gt;data.</p>
</dd>
<dt>PTR_TO_PACKET_END</dt><dd><p>skb-&gt;data + headlen; arithmetic forbidden.</p>
</dd>
<dt>PTR_TO_SOCKET</dt><dd><p>Pointer to struct bpf_sock_ops, implicitly refcounted.</p>
</dd>
<dt>PTR_TO_SOCKET_OR_NULL</dt><dd><p>Either a pointer to a socket, or NULL; socket lookup
returns this type, which becomes a PTR_TO_SOCKET when
checked != NULL. PTR_TO_SOCKET is reference-counted,
so programs must release the reference through the
socket release function before the end of the program.
Arithmetic on these pointers is forbidden.</p>
</dd>
</dl>
</div></blockquote>
<p>However, a pointer may be offset from this base (as a result of pointer
arithmetic), and this is tracked in two parts: the 'fixed offset' and 'variable
offset'.  The former is used when an exactly-known value (e.g. an immediate
operand) is added to a pointer, while the latter is used for values which are
not exactly known.  The variable offset is also used in SCALAR_VALUEs, to track
the range of possible values in the register.</p>
<p>The verifier's knowledge about the variable offset consists of:</p>
<ul class="simple">
<li><p>minimum and maximum values as unsigned</p></li>
<li><p>minimum and maximum values as signed</p></li>
<li><p>knowledge of the values of individual bits, in the form of a 'tnum': a u64
'mask' and a u64 'value'.  1s in the mask represent bits whose value is unknown;
1s in the value represent bits known to be 1.  Bits known to be 0 have 0 in both
mask and value; no bit should ever be 1 in both.  For example, if a byte is read
into a register from memory, the register's top 56 bits are known zero, while
the low 8 are unknown - which is represented as the tnum (0x0; 0xff).  If we
then OR this with 0x40, we get (0x40; 0xbf), then if we add 1 we get (0x0;
0x1ff), because of potential carries.</p></li>
</ul>
<p>Besides arithmetic, the register state can also be updated by conditional
branches.  For instance, if a SCALAR_VALUE is compared &gt; 8, in the 'true' branch
it will have a umin_value (unsigned minimum value) of 9, whereas in the 'false'
branch it will have a umax_value of 8.  A signed compare (with BPF_JSGT or
BPF_JSGE) would instead update the signed minimum/maximum values.  Information
from the signed and unsigned bounds can be combined; for instance if a value is
first tested &lt; 8 and then tested s&gt; 4, the verifier will conclude that the value
is also &gt; 4 and s&lt; 8, since the bounds prevent crossing the sign boundary.</p>
<p>PTR_TO_PACKETs with a variable offset part have an 'id', which is common to all
pointers sharing that same variable offset.  This is important for packet range
checks: after adding a variable to a packet pointer register A, if you then copy
it to another register B and then add a constant 4 to A, both registers will
share the same 'id' but the A will have a fixed offset of +4.  Then if A is
bounds-checked and found to be less than a PTR_TO_PACKET_END, the register B is
now known to have a safe range of at least 4 bytes.  See 'Direct packet access',
below, for more on PTR_TO_PACKET ranges.</p>
<p>The 'id' field is also used on PTR_TO_MAP_VALUE_OR_NULL, common to all copies of
the pointer returned from a map lookup.  This means that when one copy is
checked and found to be non-NULL, all copies can become PTR_TO_MAP_VALUEs.
As well as range-checking, the tracked information is also used for enforcing
alignment of pointer accesses.  For instance, on most systems the packet pointer
is 2 bytes after a 4-byte alignment.  If a program adds 14 bytes to that to jump
over the Ethernet header, then reads IHL and adds (IHL * 4), the resulting
pointer will have a variable offset known to be 4n+2 for some n, so adding the 2
bytes (NET_IP_ALIGN) gives a 4-byte alignment and so word-sized accesses through
that pointer are safe.
The 'id' field is also used on PTR_TO_SOCKET and PTR_TO_SOCKET_OR_NULL, common
to all copies of the pointer returned from a socket lookup. This has similar
behaviour to the handling for PTR_TO_MAP_VALUE_OR_NULL-&gt;PTR_TO_MAP_VALUE, but
it also handles reference tracking for the pointer. PTR_TO_SOCKET implicitly
represents a reference to the corresponding <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span></code>. To ensure that the
reference is not leaked, it is imperative to NULL-check the reference and in
the non-NULL case, and pass the valid reference to the socket release function.</p>
</section>
<section id="direct-packet-access">
<h2>Direct packet access<a class="headerlink" href="#direct-packet-access" title="Permalink to this heading">¶</a></h2>
<p>In cls_bpf and act_bpf programs the verifier allows direct access to the packet
data via skb-&gt;data and skb-&gt;data_end pointers.
Ex:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1:  r4 = *(u32 *)(r1 +80)  /* load skb-&gt;data_end */
2:  r3 = *(u32 *)(r1 +76)  /* load skb-&gt;data */
3:  r5 = r3
4:  r5 += 14
5:  if r5 &gt; r4 goto pc+16
R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp
6:  r0 = *(u16 *)(r3 +12) /* access 12 and 13 bytes of the packet */
</pre></div>
</div>
<p>this 2byte load from the packet is safe to do, since the program author
did check <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(skb-&gt;data</span> <span class="pre">+</span> <span class="pre">14</span> <span class="pre">&gt;</span> <span class="pre">skb-&gt;data_end)</span> <span class="pre">goto</span> <span class="pre">err</span></code> at insn #5 which
means that in the fall-through case the register R3 (which points to skb-&gt;data)
has at least 14 directly accessible bytes. The verifier marks it
as R3=pkt(id=0,off=0,r=14).
id=0 means that no additional variables were added to the register.
off=0 means that no additional constants were added.
r=14 is the range of safe access which means that bytes [R3, R3 + 14) are ok.
Note that R5 is marked as R5=pkt(id=0,off=14,r=14). It also points
to the packet data, but constant 14 was added to the register, so
it now points to <code class="docutils literal notranslate"><span class="pre">skb-&gt;data</span> <span class="pre">+</span> <span class="pre">14</span></code> and accessible range is [R5, R5 + 14 - 14)
which is zero bytes.</p>
<p>More complex packet access may look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>R0=inv1 R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp
6:  r0 = *(u8 *)(r3 +7) /* load 7th byte from the packet */
7:  r4 = *(u8 *)(r3 +12)
8:  r4 *= 14
9:  r3 = *(u32 *)(r1 +76) /* load skb-&gt;data */
10:  r3 += r4
11:  r2 = r1
12:  r2 &lt;&lt;= 48
13:  r2 &gt;&gt;= 48
14:  r3 += r2
15:  r2 = r3
16:  r2 += 8
17:  r1 = *(u32 *)(r1 +80) /* load skb-&gt;data_end */
18:  if r2 &gt; r1 goto pc+2
R0=inv(id=0,umax_value=255,var_off=(0x0; 0xff)) R1=pkt_end R2=pkt(id=2,off=8,r=8) R3=pkt(id=2,off=0,r=8) R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe)) R5=pkt(id=0,off=14,r=14) R10=fp
19:  r1 = *(u8 *)(r3 +4)
</pre></div>
</div>
<p>The state of the register R3 is R3=pkt(id=2,off=0,r=8)
id=2 means that two <code class="docutils literal notranslate"><span class="pre">r3</span> <span class="pre">+=</span> <span class="pre">rX</span></code> instructions were seen, so r3 points to some
offset within a packet and since the program author did
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(r3</span> <span class="pre">+</span> <span class="pre">8</span> <span class="pre">&gt;</span> <span class="pre">r1)</span> <span class="pre">goto</span> <span class="pre">err</span></code> at insn #18, the safe range is [R3, R3 + 8).
The verifier only allows 'add'/'sub' operations on packet registers. Any other
operation will set the register state to 'SCALAR_VALUE' and it won't be
available for direct packet access.</p>
<p>Operation <code class="docutils literal notranslate"><span class="pre">r3</span> <span class="pre">+=</span> <span class="pre">rX</span></code> may overflow and become less than original skb-&gt;data,
therefore the verifier has to prevent that.  So when it sees <code class="docutils literal notranslate"><span class="pre">r3</span> <span class="pre">+=</span> <span class="pre">rX</span></code>
instruction and rX is more than 16-bit value, any subsequent bounds-check of r3
against skb-&gt;data_end will not give us 'range' information, so attempts to read
through the pointer will give &quot;invalid access to packet&quot; error.</p>
<p>Ex. after insn <code class="docutils literal notranslate"><span class="pre">r4</span> <span class="pre">=</span> <span class="pre">*(u8</span> <span class="pre">*)(r3</span> <span class="pre">+12)</span></code> (insn #7 above) the state of r4 is
R4=inv(id=0,umax_value=255,var_off=(0x0; 0xff)) which means that upper 56 bits
of the register are guaranteed to be zero, and nothing is known about the lower
8 bits. After insn <code class="docutils literal notranslate"><span class="pre">r4</span> <span class="pre">*=</span> <span class="pre">14</span></code> the state becomes
R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe)), since multiplying an 8-bit
value by constant 14 will keep upper 52 bits as zero, also the least significant
bit will be zero as 14 is even.  Similarly <code class="docutils literal notranslate"><span class="pre">r2</span> <span class="pre">&gt;&gt;=</span> <span class="pre">48</span></code> will make
R2=inv(id=0,umax_value=65535,var_off=(0x0; 0xffff)), since the shift is not sign
extending.  This logic is implemented in adjust_reg_min_max_vals() function,
which calls adjust_ptr_min_max_vals() for adding pointer to scalar (or vice
versa) and adjust_scalar_min_max_vals() for operations on two scalars.</p>
<p>The end result is that bpf program author can access packet directly
using normal C code as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void *data = (void *)(long)skb-&gt;data;
void *data_end = (void *)(long)skb-&gt;data_end;
struct eth_hdr *eth = data;
struct iphdr *iph = data + sizeof(*eth);
struct udphdr *udp = data + sizeof(*eth) + sizeof(*iph);

if (data + sizeof(*eth) + sizeof(*iph) + sizeof(*udp) &gt; data_end)
        return 0;
if (eth-&gt;h_proto != htons(ETH_P_IP))
        return 0;
if (iph-&gt;protocol != IPPROTO_UDP || iph-&gt;ihl != 5)
        return 0;
if (udp-&gt;dest == 53 || udp-&gt;source == 9)
        ...;
</pre></div>
</div>
<p>which makes such programs easier to write comparing to LD_ABS insn
and significantly faster.</p>
</section>
<section id="pruning">
<h2>Pruning<a class="headerlink" href="#pruning" title="Permalink to this heading">¶</a></h2>
<p>The verifier does not actually walk all possible paths through the program.  For
each new branch to analyse, the verifier looks at all the states it's previously
been in when at this instruction.  If any of them contain the current state as a
subset, the branch is 'pruned' - that is, the fact that the previous state was
accepted implies the current state would be as well.  For instance, if in the
previous state, r1 held a packet-pointer, and in the current state, r1 holds a
packet-pointer with a range as long or longer and at least as strict an
alignment, then r1 is safe.  Similarly, if r2 was NOT_INIT before then it can't
have been used by any path from that point, so any value in r2 (including
another NOT_INIT) is safe.  The implementation is in the function regsafe().
Pruning considers not only the registers but also the stack (and any spilled
registers it may hold).  They must all be safe for the branch to be pruned.
This is implemented in states_equal().</p>
<p>Some technical details about state pruning implementation could be found below.</p>
<section id="register-liveness-tracking">
<h3>Register liveness tracking<a class="headerlink" href="#register-liveness-tracking" title="Permalink to this heading">¶</a></h3>
<p>In order to make state pruning effective, liveness state is tracked for each
register and stack slot. The basic idea is to track which registers and stack
slots are actually used during subseqeuent execution of the program, until
program exit is reached. Registers and stack slots that were never used could be
removed from the cached state thus making more states equivalent to a cached
state. This could be illustrated by the following program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: call bpf_get_prandom_u32()
1: r1 = 0
2: if r0 == 0 goto +1
3: r0 = 1
--- checkpoint ---
4: r0 = r1
5: exit
</pre></div>
</div>
<p>Suppose that a state cache entry is created at instruction #4 (such entries are
also called &quot;checkpoints&quot; in the text below). The verifier could reach the
instruction with one of two possible register states:</p>
<ul class="simple">
<li><p>r0 = 1, r1 = 0</p></li>
<li><p>r0 = 0, r1 = 0</p></li>
</ul>
<p>However, only the value of register <code class="docutils literal notranslate"><span class="pre">r1</span></code> is important to successfully finish
verification. The goal of the liveness tracking algorithm is to spot this fact
and figure out that both states are actually equivalent.</p>
<section id="data-structures">
<h4>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this heading">¶</a></h4>
<p>Liveness is tracked using the following data structures:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum bpf_reg_liveness {
      REG_LIVE_NONE = 0,
      REG_LIVE_READ32 = 0x1,
      REG_LIVE_READ64 = 0x2,
      REG_LIVE_READ = REG_LIVE_READ32 | REG_LIVE_READ64,
      REG_LIVE_WRITTEN = 0x4,
      REG_LIVE_DONE = 0x8,
};

struct bpf_reg_state {
      ...
      struct bpf_reg_state *parent;
      ...
      enum bpf_reg_liveness live;
      ...
};

struct bpf_stack_state {
      struct bpf_reg_state spilled_ptr;
      ...
};

struct bpf_func_state {
      struct bpf_reg_state regs[MAX_BPF_REG];
      ...
      struct bpf_stack_state *stack;
}

struct bpf_verifier_state {
      struct bpf_func_state *frame[MAX_CALL_FRAMES];
      struct bpf_verifier_state *parent;
      ...
}
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">REG_LIVE_NONE</span></code> is an initial value assigned to <code class="docutils literal notranslate"><span class="pre">-&gt;live</span></code> fields upon new
verifier state creation;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REG_LIVE_WRITTEN</span></code> means that the value of the register (or stack slot) is
defined by some instruction verified between this verifier state's parent and
verifier state itself;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REG_LIVE_READ{32,64}</span></code> means that the value of the register (or stack slot)
is read by a some child state of this verifier state;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REG_LIVE_DONE</span></code> is a marker used by <code class="docutils literal notranslate"><span class="pre">clean_verifier_state()</span></code> to avoid
processing same verifier state multiple times and for some sanity checks;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-&gt;live</span></code> field values are formed by combining <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">bpf_reg_liveness</span></code>
values using bitwise or.</p></li>
</ul>
</section>
<section id="register-parentage-chains">
<h4>Register parentage chains<a class="headerlink" href="#register-parentage-chains" title="Permalink to this heading">¶</a></h4>
<p>In order to propagate information between parent and child states, a <em>register
parentage chain</em> is established. Each register or stack slot is linked to a
corresponding register or stack slot in its parent state via a <code class="docutils literal notranslate"><span class="pre">-&gt;parent</span></code>
pointer. This link is established upon state creation in <code class="docutils literal notranslate"><span class="pre">is_state_visited()</span></code>
and might be modified by <code class="docutils literal notranslate"><span class="pre">set_callee_state()</span></code> called from
<code class="docutils literal notranslate"><span class="pre">__check_func_call()</span></code>.</p>
<p>The rules for correspondence between registers / stack slots are as follows:</p>
<ul class="simple">
<li><p>For the current stack frame, registers and stack slots of the new state are
linked to the registers and stack slots of the parent state with the same
indices.</p></li>
<li><p>For the outer stack frames, only caller saved registers (r6-r9) and stack
slots are linked to the registers and stack slots of the parent state with the
same indices.</p></li>
<li><p>When function call is processed a new <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_func_state</span></code> instance is
allocated, it encapsulates a new set of registers and stack slots. For this
new frame, parent links for r6-r9 and stack slots are set to nil, parent links
for r1-r5 are set to match caller r1-r5 parent links.</p></li>
</ul>
<p>This could be illustrated by the following diagram (arrows stand for
<code class="docutils literal notranslate"><span class="pre">-&gt;parent</span></code> pointers):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    ...                    ; Frame #0, some instructions
--- checkpoint #0 ---
1 : r6 = 42                ; Frame #0
--- checkpoint #1 ---
2 : call foo()             ; Frame #0
    ...                    ; Frame #1, instructions from foo()
--- checkpoint #2 ---
    ...                    ; Frame #1, instructions from foo()
--- checkpoint #3 ---
    exit                   ; Frame #1, return from foo()
3 : r1 = r6                ; Frame #0  &lt;- current state

           +-------------------------------+-------------------------------+
           |           Frame #0            |           Frame #1            |
Checkpoint +-------------------------------+-------------------------------+
#0         | r0 | r1-r5 | r6-r9 | fp-8 ... |
           +-------------------------------+
              ^    ^       ^       ^
              |    |       |       |
Checkpoint +-------------------------------+
#1         | r0 | r1-r5 | r6-r9 | fp-8 ... |
           +-------------------------------+
                   ^       ^       ^
                   |_______|_______|_______________
                           |       |               |
             nil  nil      |       |               |      nil     nil
              |    |       |       |               |       |       |
Checkpoint +-------------------------------+-------------------------------+
#2         | r0 | r1-r5 | r6-r9 | fp-8 ... | r0 | r1-r5 | r6-r9 | fp-8 ... |
           +-------------------------------+-------------------------------+
                           ^       ^               ^       ^       ^
             nil  nil      |       |               |       |       |
              |    |       |       |               |       |       |
Checkpoint +-------------------------------+-------------------------------+
#3         | r0 | r1-r5 | r6-r9 | fp-8 ... | r0 | r1-r5 | r6-r9 | fp-8 ... |
           +-------------------------------+-------------------------------+
                           ^       ^
             nil  nil      |       |
              |    |       |       |
Current    +-------------------------------+
state      | r0 | r1-r5 | r6-r9 | fp-8 ... |
           +-------------------------------+
                           \
                             r6 read mark is propagated via these links
                             all the way up to checkpoint #1.
                             The checkpoint #1 contains a write mark for r6
                             because of instruction (1), thus read propagation
                             does not reach checkpoint #0 (see section below).
</pre></div>
</div>
</section>
<section id="liveness-marks-tracking">
<h4>Liveness marks tracking<a class="headerlink" href="#liveness-marks-tracking" title="Permalink to this heading">¶</a></h4>
<p>For each processed instruction, the verifier tracks read and written registers
and stack slots. The main idea of the algorithm is that read marks propagate
back along the state parentage chain until they hit a write mark, which 'screens
off' earlier states from the read. The information about reads is propagated by
function <code class="docutils literal notranslate"><span class="pre">mark_reg_read()</span></code> which could be summarized as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mark_reg_read(struct bpf_reg_state *state, ...):
    parent = state-&gt;parent
    while parent:
        if state-&gt;live &amp; REG_LIVE_WRITTEN:
            break
        if parent-&gt;live &amp; REG_LIVE_READ64:
            break
        parent-&gt;live |= REG_LIVE_READ64
        state = parent
        parent = state-&gt;parent
</pre></div>
</div>
<p>Notes:</p>
<ul class="simple">
<li><p>The read marks are applied to the <strong>parent</strong> state while write marks are
applied to the <strong>current</strong> state. The write mark on a register or stack slot
means that it is updated by some instruction in the straight-line code leading
from the parent state to the current state.</p></li>
<li><p>Details about REG_LIVE_READ32 are omitted.</p></li>
<li><p>Function <code class="docutils literal notranslate"><span class="pre">propagate_liveness()</span></code> (see section <a class="reference internal" href="#read-marks-for-cache-hits"><span class="std std-ref">Read marks propagation for cache hits</span></a>)
might override the first parent link. Please refer to the comments in the
<code class="docutils literal notranslate"><span class="pre">propagate_liveness()</span></code> and <code class="docutils literal notranslate"><span class="pre">mark_reg_read()</span></code> source code for further
details.</p></li>
</ul>
<p>Because stack writes could have different sizes <code class="docutils literal notranslate"><span class="pre">REG_LIVE_WRITTEN</span></code> marks are
applied conservatively: stack slots are marked as written only if write size
corresponds to the size of the register, e.g. see function <code class="docutils literal notranslate"><span class="pre">save_register_state()</span></code>.</p>
<p>Consider the following example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (*u64)(r10 - 8) = 0   ; define 8 bytes of fp-8
--- checkpoint #0 ---
1: (*u32)(r10 - 8) = 1   ; redefine lower 4 bytes
2: r1 = (*u32)(r10 - 8)  ; read lower 4 bytes defined at (1)
3: r2 = (*u32)(r10 - 4)  ; read upper 4 bytes defined at (0)
</pre></div>
</div>
<p>As stated above, the write at (1) does not count as <code class="docutils literal notranslate"><span class="pre">REG_LIVE_WRITTEN</span></code>. Should
it be otherwise, the algorithm above wouldn't be able to propagate the read mark
from (3) to checkpoint #0.</p>
<p>Once the <code class="docutils literal notranslate"><span class="pre">BPF_EXIT</span></code> instruction is reached <code class="docutils literal notranslate"><span class="pre">update_branch_counts()</span></code> is
called to update the <code class="docutils literal notranslate"><span class="pre">-&gt;branches</span></code> counter for each verifier state in a chain
of parent verifier states. When the <code class="docutils literal notranslate"><span class="pre">-&gt;branches</span></code> counter reaches zero the
verifier state becomes a valid entry in a set of cached verifier states.</p>
<p>Each entry of the verifier states cache is post-processed by a function
<code class="docutils literal notranslate"><span class="pre">clean_live_states()</span></code>. This function marks all registers and stack slots
without <code class="docutils literal notranslate"><span class="pre">REG_LIVE_READ{32,64}</span></code> marks as <code class="docutils literal notranslate"><span class="pre">NOT_INIT</span></code> or <code class="docutils literal notranslate"><span class="pre">STACK_INVALID</span></code>.
Registers/stack slots marked in this way are ignored in function <code class="docutils literal notranslate"><span class="pre">stacksafe()</span></code>
called from <code class="docutils literal notranslate"><span class="pre">states_equal()</span></code> when a state cache entry is considered for
equivalence with a current state.</p>
<p>Now it is possible to explain how the example from the beginning of the section
works:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: call bpf_get_prandom_u32()
1: r1 = 0
2: if r0 == 0 goto +1
3: r0 = 1
--- checkpoint[0] ---
4: r0 = r1
5: exit
</pre></div>
</div>
<ul class="simple">
<li><p>At instruction #2 branching point is reached and state <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">r0</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">r1</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">pc</span> <span class="pre">==</span> <span class="pre">4</span> <span class="pre">}</span></code>
is pushed to states processing queue (pc stands for program counter).</p></li>
<li><p>At instruction #4:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">checkpoint[0]</span></code> states cache entry is created: <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">r0</span> <span class="pre">==</span> <span class="pre">1,</span> <span class="pre">r1</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">pc</span> <span class="pre">==</span> <span class="pre">4</span> <span class="pre">}</span></code>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">checkpoint[0].r0</span></code> is marked as written;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">checkpoint[0].r1</span></code> is marked as read;</p></li>
</ul>
</li>
<li><p>At instruction #5 exit is reached and <code class="docutils literal notranslate"><span class="pre">checkpoint[0]</span></code> can now be processed
by <code class="docutils literal notranslate"><span class="pre">clean_live_states()</span></code>. After this processing <code class="docutils literal notranslate"><span class="pre">checkpoint[0].r0</span></code> has a
read mark and all other registers and stack slots are marked as <code class="docutils literal notranslate"><span class="pre">NOT_INIT</span></code>
or <code class="docutils literal notranslate"><span class="pre">STACK_INVALID</span></code></p></li>
<li><p>The state <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">r0</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">r1</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">pc</span> <span class="pre">==</span> <span class="pre">4</span> <span class="pre">}</span></code> is popped from the states queue
and is compared against a cached state <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">r1</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">pc</span> <span class="pre">==</span> <span class="pre">4</span> <span class="pre">}</span></code>, the states
are considered equivalent.</p></li>
</ul>
</section>
<section id="read-marks-propagation-for-cache-hits">
<span id="read-marks-for-cache-hits"></span><h4>Read marks propagation for cache hits<a class="headerlink" href="#read-marks-propagation-for-cache-hits" title="Permalink to this heading">¶</a></h4>
<p>Another point is the handling of read marks when a previously verified state is
found in the states cache. Upon cache hit verifier must behave in the same way
as if the current state was verified to the program exit. This means that all
read marks, present on registers and stack slots of the cached state, must be
propagated over the parentage chain of the current state. Example below shows
why this is important. Function <code class="docutils literal notranslate"><span class="pre">propagate_liveness()</span></code> handles this case.</p>
<p>Consider the following state parentage chain (S is a starting state, A-E are
derived states, -&gt; arrows show which state is derived from which):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>               r1 read
        &lt;-------------                A[r1] == 0
                                      C[r1] == 0
  S ---&gt; A ---&gt; B ---&gt; exit           E[r1] == 1
  |
  ` ---&gt; C ---&gt; D
  |
  ` ---&gt; E      ^
                |___   suppose all these
         ^           states are at insn #Y
         |
  suppose all these
states are at insn #X
</pre></div>
</div>
<ul class="simple">
<li><p>Chain of states <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">-&gt;</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">exit</span></code> is verified first.</p></li>
<li><p>While <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">exit</span></code> is verified, register <code class="docutils literal notranslate"><span class="pre">r1</span></code> is read and this read mark is
propagated up to state <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
<li><p>When chain of states <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">D</span></code> is verified the state <code class="docutils literal notranslate"><span class="pre">D</span></code> turns out to be
equivalent to state <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p></li>
<li><p>The read mark for <code class="docutils literal notranslate"><span class="pre">r1</span></code> has to be propagated to state <code class="docutils literal notranslate"><span class="pre">C</span></code>, otherwise state
<code class="docutils literal notranslate"><span class="pre">C</span></code> might get mistakenly marked as equivalent to state <code class="docutils literal notranslate"><span class="pre">E</span></code> even though
values for register <code class="docutils literal notranslate"><span class="pre">r1</span></code> differ between <code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">E</span></code>.</p></li>
</ul>
</section>
</section>
</section>
<section id="understanding-ebpf-verifier-messages">
<h2>Understanding eBPF verifier messages<a class="headerlink" href="#understanding-ebpf-verifier-messages" title="Permalink to this heading">¶</a></h2>
<p>The following are few examples of invalid eBPF programs and verifier error
messages as seen in the log:</p>
<p>Program with unreachable instructions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct bpf_insn prog[] = {
BPF_EXIT_INSN(),
BPF_EXIT_INSN(),
};
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unreachable insn 1
</pre></div>
</div>
<p>Program that reads uninitialized register:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_MOV64_REG(BPF_REG_0, BPF_REG_2),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (bf) r0 = r2
R2 !read_ok
</pre></div>
</div>
<p>Program that doesn't initialize R0 before exiting:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_MOV64_REG(BPF_REG_2, BPF_REG_1),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (bf) r2 = r1
1: (95) exit
R0 !read_ok
</pre></div>
</div>
<p>Program that accesses stack out of bounds:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_ST_MEM(BPF_DW, BPF_REG_10, 8, 0),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (7a) *(u64 *)(r10 +8) = 0
invalid stack off=8 size=8
</pre></div>
</div>
<p>Program that doesn't initialize stack before passing its address into function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
BPF_LD_MAP_FD(BPF_REG_1, 0),
BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (bf) r2 = r10
1: (07) r2 += -8
2: (b7) r1 = 0x0
3: (85) call 1
invalid indirect read from stack off -8+0 size 8
</pre></div>
</div>
<p>Program that uses invalid map_fd=0 while calling to map_lookup_elem() function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
BPF_LD_MAP_FD(BPF_REG_1, 0),
BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (7a) *(u64 *)(r10 -8) = 0
1: (bf) r2 = r10
2: (07) r2 += -8
3: (b7) r1 = 0x0
4: (85) call 1
fd 0 is not pointing to valid bpf_map
</pre></div>
</div>
<p>Program that doesn't check return value of map_lookup_elem() before accessing
map element:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
BPF_LD_MAP_FD(BPF_REG_1, 0),
BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (7a) *(u64 *)(r10 -8) = 0
1: (bf) r2 = r10
2: (07) r2 += -8
3: (b7) r1 = 0x0
4: (85) call 1
5: (7a) *(u64 *)(r0 +0) = 0
R0 invalid mem access &#39;map_value_or_null&#39;
</pre></div>
</div>
<p>Program that correctly checks map_lookup_elem() returned value for NULL, but
accesses the memory with incorrect alignment:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
BPF_LD_MAP_FD(BPF_REG_1, 0),
BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 1),
BPF_ST_MEM(BPF_DW, BPF_REG_0, 4, 0),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (7a) *(u64 *)(r10 -8) = 0
1: (bf) r2 = r10
2: (07) r2 += -8
3: (b7) r1 = 1
4: (85) call 1
5: (15) if r0 == 0x0 goto pc+1
 R0=map_ptr R10=fp
6: (7a) *(u64 *)(r0 +4) = 0
misaligned access off 4 size 8
</pre></div>
</div>
<p>Program that correctly checks map_lookup_elem() returned value for NULL and
accesses memory with correct alignment in one side of 'if' branch, but fails
to do so in the other side of 'if' branch:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
BPF_LD_MAP_FD(BPF_REG_1, 0),
BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),
BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),
BPF_EXIT_INSN(),
BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 1),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (7a) *(u64 *)(r10 -8) = 0
1: (bf) r2 = r10
2: (07) r2 += -8
3: (b7) r1 = 1
4: (85) call 1
5: (15) if r0 == 0x0 goto pc+2
 R0=map_ptr R10=fp
6: (7a) *(u64 *)(r0 +0) = 0
7: (95) exit

from 5 to 8: R0=imm0 R10=fp
8: (7a) *(u64 *)(r0 +0) = 1
R0 invalid mem access &#39;imm&#39;
</pre></div>
</div>
<p>Program that performs a socket lookup then sets the pointer to NULL without
checking it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_MOV64_IMM(BPF_REG_2, 0),
BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, -8),
BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
BPF_MOV64_IMM(BPF_REG_3, 4),
BPF_MOV64_IMM(BPF_REG_4, 0),
BPF_MOV64_IMM(BPF_REG_5, 0),
BPF_EMIT_CALL(BPF_FUNC_sk_lookup_tcp),
BPF_MOV64_IMM(BPF_REG_0, 0),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (b7) r2 = 0
1: (63) *(u32 *)(r10 -8) = r2
2: (bf) r2 = r10
3: (07) r2 += -8
4: (b7) r3 = 4
5: (b7) r4 = 0
6: (b7) r5 = 0
7: (85) call bpf_sk_lookup_tcp#65
8: (b7) r0 = 0
9: (95) exit
Unreleased reference id=1, alloc_insn=7
</pre></div>
</div>
<p>Program that performs a socket lookup but does not NULL-check the returned
value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BPF_MOV64_IMM(BPF_REG_2, 0),
BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, -8),
BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
BPF_MOV64_IMM(BPF_REG_3, 4),
BPF_MOV64_IMM(BPF_REG_4, 0),
BPF_MOV64_IMM(BPF_REG_5, 0),
BPF_EMIT_CALL(BPF_FUNC_sk_lookup_tcp),
BPF_EXIT_INSN(),
</pre></div>
</div>
<p>Error:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0: (b7) r2 = 0
1: (63) *(u32 *)(r10 -8) = r2
2: (bf) r2 = r10
3: (07) r2 += -8
4: (b7) r3 = 4
5: (b7) r4 = 0
6: (b7) r5 = 0
7: (85) call bpf_sk_lookup_tcp#65
8: (95) exit
Unreleased reference id=1, alloc_insn=7
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/bpf/verifier.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>