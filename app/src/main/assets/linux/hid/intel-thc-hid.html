<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Intel Touch Host Controller (THC) &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="AMD Sensor Fusion Hub" href="amd-sfh-hid.html" />
    <link rel="prev" title="Intel Integrated Sensor Hub (ISH)" href="intel-ish-hid.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.14.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../input/index.html">Input Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpu/index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/hid/intel-thc-hid.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="intel-touch-host-controller-thc">
<h1>Intel Touch Host Controller (THC)<a class="headerlink" href="#intel-touch-host-controller-thc" title="Link to this heading">¶</a></h1>
<p>Touch Host Controller is the name of the IP block in PCH that interface with Touch Devices (ex:
touchscreen, touchpad etc.). It is comprised of 3 key functional blocks:</p>
<ul class="simple">
<li><p>A natively half-duplex Quad I/O capable SPI master</p></li>
<li><p>Low latency I2C interface to support HIDI2C compliant devices</p></li>
<li><p>A HW sequencer with RW DMA capability to system memory</p></li>
</ul>
<p>It has a single root space IOSF Primary interface that supports transactions to/from touch devices.
Host driver configures and controls the touch devices over THC interface. THC provides high
bandwidth DMA services to the touch driver and transfers the HID report to host system main memory.</p>
<p>Hardware sequencer within the THC is responsible for transferring (via DMA) data from touch devices
into system memory. A ring buffer is used to avoid data loss due to asynchronous nature of data
consumption (by host) in relation to data production (by touch device via DMA).</p>
<p>Unlike other common SPI/I2C controllers, THC handles the HID device data interrupt and reset
signals directly.</p>
<section id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<section id="thc-software-hardware-stack">
<h3>1.1 THC software/hardware stack<a class="headerlink" href="#thc-software-hardware-stack" title="Link to this heading">¶</a></h3>
<p>Below diagram illustrates the high-level architecture of THC software/hardware stack, which is fully
capable of supporting HIDSPI/HIDI2C protocol in Linux OS.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> ----------------------------------------------
|      +-----------------------------------+   |
|      |           Input Device            |   |
|      +-----------------------------------+   |
|      +-----------------------------------+   |
|      |       HID Multi-touch Driver      |   |
|      +-----------------------------------+   |
|      +-----------------------------------+   |
|      |             HID Core              |   |
|      +-----------------------------------+   |
|      +-----------------------------------+   |
|      |    THC QuickSPI/QuickI2C Driver   |   |
|      +-----------------------------------+   |
|      +-----------------------------------+   |
|      |      THC Hardware Driver          |   |
|      +-----------------------------------+   |
|      +----------------+ +----------------+   |
|  SW  | PCI Bus Driver | | ACPI Resource  |   |
|      +----------------+ +----------------+   |
 ----------------------------------------------
 ----------------------------------------------
|      +-----------------------------------+   |
|  HW  |              PCI Bus              |   |
|      +-----------------------------------+   |
|      +-----------------------------------+   |
|      |           THC Controller          |   |
|      +-----------------------------------+   |
|      +-----------------------------------+   |
|      |              Touch IC             |   |
|      +-----------------------------------+   |
 ----------------------------------------------
</pre></div>
</div>
<p>Touch IC (TIC), also as known as the Touch devices (touchscreen or touchpad). The discrete analog
components that sense and transfer either discrete touch data or heatmap data in the form of HID
reports over the SPI/I2C bus to the THC Controller on the host.</p>
<p>THC Host Controller, which is a PCI device HBA (host bus adapter), integrated into the PCH, that
serves as a bridge between the Touch ICs and the host.</p>
<p>THC Hardware Driver, provides THC hardware operation APIs for above QuickSPI/QuickI2C driver, it
accesses THC MMIO registers to configure and control THC hardware.</p>
<p>THC QuickSPI/QuickI2C driver, also as known as HIDSPI/HIDI2C driver, is registered as a HID
low-level driver that manages the THC Controller and implements HIDSPI/HIDI2C protocol.</p>
</section>
<section id="thc-hardware-diagram">
<h3>1.2 THC hardware diagram<a class="headerlink" href="#thc-hardware-diagram" title="Link to this heading">¶</a></h3>
<p>Below diagram shows THC hardware components:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                     ---------------------------------
                    |          THC Controller         |
                    |  +---------------------------+  |
                    |  |     PCI Config Space      |  |
                    |  +---------------------------+  |
                    |  +---------------------------+  |
                    |  +       MMIO Registers      |  |
                    |  +---------------------------+  |
+---------------+   |  +------------+ +------------+  |
| System Memory +---+--+      DMA   | |   PIO      |  |
+---------------+   |  +------------+ +------------+  |
                    |  +---------------------------+  |
                    |  |       HW Sequencer        |  |
                    |  +---------------------------+  |
                    |  +------------+ +------------+  |
                    |  |  SPI/I2C   | |    GPIO    |  |
                    |  | Controller | | Controller |  |
                    |  +------------+ +------------+  |
                     ---------------------------------
</pre></div>
</div>
<p>As THC is exposed as a PCI devices, so it has standard PCI config space registers for PCI
enumeration and configuration.</p>
<p>MMIO Registers, which provide registers access for driver to configure and control THC hardware,
the registers include several categories: Interrupt status and control, DMA configure,
PIO (Programmed I/O, defined in section 3.2) status and control, SPI bus configure, I2C subIP
status and control, reset status and control...</p>
<p>THC provides two ways for driver to communicate with external Touch ICs: PIO and DMA.
PIO can let driver manually write/read data to/from Touch ICs, instead, THC DMA can
automatically write/read data without driver involved.</p>
<p>HW Sequencer includes THC major logic, it gets instruction from MMIO registers to control
SPI bus and I2C bus to finish a bus data transaction, it also can automatically handle
Touch ICs interrupt and start DMA receive/send data from/to Touch ICs according to interrupt
type. That means THC HW Sequencer understands HIDSPI/HIDI2C transfer protocol, and handle
the communication without driver involved, what driver needs to do is just configure the THC
properly, and prepare the formatted data packet or handle received data packet.</p>
<p>As THC supports HIDSPI/HIDI2C protocols, it has SPI controller and I2C subIP in it to expose
SPI bus and I2C bus. THC also integrates a GPIO controller to provide interrupt line support
and reset line support.</p>
</section>
</section>
<section id="thc-hardware-interface">
<h2>2. THC Hardware Interface<a class="headerlink" href="#thc-hardware-interface" title="Link to this heading">¶</a></h2>
<section id="host-interface">
<h3>2.1 Host Interface<a class="headerlink" href="#host-interface" title="Link to this heading">¶</a></h3>
<p>THC is exposed as “PCI Digitizer device” to the host. The PCI product and device IDs are
changed from different generations of processors. So the source code which enumerates drivers
needs to update from generation to generation.</p>
</section>
<section id="device-interface">
<h3>2.2 Device Interface<a class="headerlink" href="#device-interface" title="Link to this heading">¶</a></h3>
<p>THC supports two types of bus for Touch IC connection: Enhanced SPI bus and I2C bus.</p>
<section id="spi-port">
<h4>2.2.1 SPI Port<a class="headerlink" href="#spi-port" title="Link to this heading">¶</a></h4>
<p>When PORT_TYPE = 00b in MMIO registers, THC uses SPI interfaces to communicate with external
Touch IC. THC enhanced SPI Bus supports different SPI modes: standard Single IO mode,
Dual IO mode and Quad IO mode.</p>
<p>In Single IO mode, THC drives MOSI line to send data to Touch ICs, and receives data from Touch
ICs data from MISO line. In Dual IO mode, THC drivers MOSI and MISO both for data sending, and
also receives the data on both line. In Quad IO mode, there are other two lines (IO2 and IO3)
are added, THC drives MOSI (IO0), MISO (IO1), IO2 and IO3 at the same time for data sending, and
also receives the data on those 4 lines. Driver needs to configure THC in different mode by
setting different opcode.</p>
<p>Beside IO mode, driver also needs to configure SPI bus speed. THC supports up to 42MHz SPI clock
on Intel Lunar Lake platform.</p>
<p>For THC sending data to Touch IC, the data flow on SPI bus:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>| --------------------THC sends---------------------------------|
&lt;8Bits OPCode&gt;&lt;24Bits Slave Address&gt;&lt;Data&gt;&lt;Data&gt;&lt;Data&gt;...........
</pre></div>
</div>
<p>For THC receiving data from Touch IC, the data flow on SPI bus:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>| ---------THC Sends---------------||-----Touch IC sends--------|
&lt;8Bits OPCode&gt;&lt;24Bits Slave Address&gt;&lt;Data&gt;&lt;Data&gt;&lt;Data&gt;...........
</pre></div>
</div>
</section>
<section id="i2c-port">
<h4>2.2.2 I2C Port<a class="headerlink" href="#i2c-port" title="Link to this heading">¶</a></h4>
<p>THC also integrates I2C controller in it, it’s called I2C SubSystem. When PORT_TYPE = 01, THC
is configured to I2C mode. Comparing to SPI mode which can be configured through MMIO registers
directly, THC needs to use PIO read (by setting SubIP read opcode) to I2C subIP APB registers’
value and use PIO write (by setting SubIP write opcode) to do a write operation.</p>
</section>
<section id="gpio-interface">
<h4>2.2.3 GPIO interface<a class="headerlink" href="#gpio-interface" title="Link to this heading">¶</a></h4>
<p>THC also includes two GPIO pins, one for interrupt and the other for device reset control.</p>
<p>Interrupt line can be configured to either level triggerred or edge triggerred by setting MMIO
Control register.</p>
<p>Reset line is controlled by BIOS (or EFI) through ACPI _RST method, driver needs to call this
device ACPI _RST method to reset touch IC during initialization.</p>
</section>
</section>
</section>
<section id="high-level-concept">
<h2>3. High level concept<a class="headerlink" href="#high-level-concept" title="Link to this heading">¶</a></h2>
<section id="opcode">
<h3>3.1 Opcode<a class="headerlink" href="#opcode" title="Link to this heading">¶</a></h3>
<p>Opcode (operation code) is used to tell THC or Touch IC what the operation will be, such as PIO
read or PIO write.</p>
<p>When THC is configured to SPI mode, opcodes are used for determining the read/write IO mode.
There are some OPCode examples for SPI IO mode:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>opcode</p></th>
<th class="head"><p>Corresponding SPI command</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0B</p></td>
<td><p>Read Single I/O</p></td>
</tr>
<tr class="row-odd"><td><p>0x02</p></td>
<td><p>Write Single I/O</p></td>
</tr>
<tr class="row-even"><td><p>0xBB</p></td>
<td><p>Read Dual I/O</p></td>
</tr>
<tr class="row-odd"><td><p>0xB2</p></td>
<td><p>Write Dual I/O</p></td>
</tr>
<tr class="row-even"><td><p>0xEB</p></td>
<td><p>Read Quad I/O</p></td>
</tr>
<tr class="row-odd"><td><p>0xE2</p></td>
<td><p>Write Quad I/O</p></td>
</tr>
</tbody>
</table>
<p>In general, different touch IC has different OPCode definition. According to HIDSPI
protocol whitepaper, those OPCodes are defined in device ACPI table, and driver needs to
query those information through OS ACPI APIs during driver initialization, then configures
THC MMIO OPCode registers with correct setting.</p>
<p>When THC is working in I2C mode, opcodes are used to tell THC what’s the next PIO type:
I2C SubIP APB register read, I2C SubIP APB register write, I2C touch IC device read,
I2C touch IC device write, I2C touch IC device write followed by read.</p>
<p>Here are the THC pre-defined opcodes for I2C mode:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>opcode</p></th>
<th class="head"><p>Corresponding I2C command</p></th>
<th class="head"><p>Address</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x12</p></td>
<td><p>Read I2C SubIP APB internal registers</p></td>
<td><p>0h - FFh</p></td>
</tr>
<tr class="row-odd"><td><p>0x13</p></td>
<td><p>Write I2C SubIP APB internal registers</p></td>
<td><p>0h - FFh</p></td>
</tr>
<tr class="row-even"><td><p>0x14</p></td>
<td><p>Read external Touch IC through I2C bus</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>0x18</p></td>
<td><p>Write external Touch IC through I2C bus</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>0x1C</p></td>
<td><p>Write then read external Touch IC through I2C bus</p></td>
<td><p>N/A</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pio">
<h3>3.2 PIO<a class="headerlink" href="#pio" title="Link to this heading">¶</a></h3>
<p>THC provides a programmed I/O (PIO) access interface for the driver to access the touch IC’s
configuration registers, or access I2C subIP’s configuration registers. To use PIO to perform
I/O operations, driver should pre-program PIO control registers and PIO data registers and kick
off the sequencing cycle. THC uses different PIO opcodes to distinguish different PIO
operations (PIO read/write/write followed by read).</p>
<p>If there is a Sequencing Cycle In Progress and an attempt is made to program any of the control,
address, or data register the cycle is blocked and a sequence error will be encountered.</p>
<p>A status bit indicates when the cycle has completed allowing the driver to know when read results
can be checked and/or when to initiate a new command. If enabled, the cycle done assertion can
interrupt driver with an interrupt.</p>
<p>Because THC only has 16 FIFO registers for PIO, so all the data transfer through PIO shouldn’t
exceed 64 bytes.</p>
<p>As DMA needs max packet size for transferring configuration, and the max packet size information
always in HID device descriptor which needs THC driver to read it out from HID Device (Touch IC).
So PIO typical use case is, before DMA initialization, write RESET command (PIO write), read
RESET response (PIO read or PIO write followed by read), write Power ON command (PIO write), read
device descriptor (PIO read).</p>
<p>For how to issue a PIO operation, here is the steps which driver needs follow:</p>
<ul class="simple">
<li><p>Program read/write data size in THC_SS_BC.</p></li>
<li><p>Program I/O target address in THC_SW_SEQ_DATA0_ADDR.</p></li>
<li><p>If write, program the write data in THC_SW_SEQ_DATA0..THC_SW_SEQ_DATAn.</p></li>
<li><p>Program the PIO opcode in THC_SS_CMD.</p></li>
<li><p>Set TSSGO = 1 to start the PIO write sequence.</p></li>
<li><p>If THC_SS_CD_IE = 1, SW will receives a MSI when the PIO is completed.</p></li>
<li><p>If read, read out the data in THC_SW_SEQ_DATA0..THC_SW_SEQ_DATAn.</p></li>
</ul>
</section>
<section id="dma">
<h3>3.3 DMA<a class="headerlink" href="#dma" title="Link to this heading">¶</a></h3>
<p>THC has 4 DMA channels: Read DMA1, Read DMA2, Write DMA and Software DMA.</p>
<section id="read-dma-channel">
<h4>3.3.1 Read DMA Channel<a class="headerlink" href="#read-dma-channel" title="Link to this heading">¶</a></h4>
<p>THC has two Read DMA engines: 1st RxDMA (RxDMA1) and 2nd RxDMA (RxDMA2). RxDMA1 is reserved for
raw data mode. RxDMA2 is used for HID data mode and it is the RxDMA engine currently driver uses
for HID input report data retrieval.</p>
<p>RxDMA’s typical use case is auto receiving the data from Touch IC. Once RxDMA is enabled by
software, THC will start auto-handling receiving logic.</p>
<p>For SPI mode, THC RxDMA sequence is: when Touch IC triggers a interrupt to THC, THC reads out
report header to identify what’s the report type, and what’s the report length, according to
above information, THC reads out report body to internal FIFO and start RxDMA coping the data
to system memory. After that, THC update interrupt cause register with report type, and update
RxDMA PRD table read pointer, then trigger a MSI interrupt to notify driver RxDMA finishing
data receiving.</p>
<p>For I2C mode, THC RxDMA’s behavior is a little bit different, because of HIDI2C protocol difference
with HIDSPI protocol, RxDMA only be used to receive input report. The sequence is, when Touch IC
triggers a interrupt to THC, THC first reads out 2 bytes from input report address to determine the
packet length, then use this packet length to start a DMA reading from input report address for
input report data. After that, THC update RxDMA PRD table read pointer, then trigger a MSI interrupt
to notify driver input report data is ready in system memory.</p>
<p>All above sequence is hardware automatically handled, all driver needs to do is configure RxDMA and
waiting for interrupt ready then read out the data from system memory.</p>
</section>
<section id="software-dma-channel">
<h4>3.3.2 Software DMA channel<a class="headerlink" href="#software-dma-channel" title="Link to this heading">¶</a></h4>
<p>THC supports a software triggerred RxDMA mode to read the touch data from touch IC. This SW RxDMA
is the 3rd THC RxDMA engine with the similar functionalities as the existing two RxDMAs, the only
difference is this SW RxDMA is triggerred by software, and RxDMA2 is triggerred by external Touch IC
interrupt. It gives a flexiblity to software driver to use RxDMA read Touch IC data in any time.</p>
<p>Before software starts a SW RxDMA, it shall stop the 1st and 2nd RxDMA, clear PRD read/write pointer
and quiesce the device interrupt (THC_DEVINT_QUIESCE_HW_STS = 1), other operations are the same with
RxDMA.</p>
</section>
<section id="write-dma-channel">
<h4>3.3.3 Write DMA Channel<a class="headerlink" href="#write-dma-channel" title="Link to this heading">¶</a></h4>
<p>THC has one write DMA engine, which can be used for sending data to Touch IC automatically.
According to HIDSPI and HIDI2C protocol, every time only one command can be sent to touch IC, and
before last command is completely handled, next command cannot be sent, THC write DMA engine only
supports single PRD table.</p>
<p>What driver needs to do is, preparing PRD table and DMA buffer, then copy data to DMA buffer and
update PRD table with buffer address and buffer length, then start write DMA. THC will
automatically send the data to touch IC, and trigger a DMA completion interrupt once transferring
is done.</p>
</section>
</section>
<section id="prd">
<h3>3.4 PRD<a class="headerlink" href="#prd" title="Link to this heading">¶</a></h3>
<p>Physical Region Descriptor (PRD) provides the memory mapping description for THC DMAs.</p>
<section id="prd-table-and-entry">
<h4>3.4.1 PRD table and entry<a class="headerlink" href="#prd-table-and-entry" title="Link to this heading">¶</a></h4>
<p>In order to improve physical DMA memory usage, modern drivers trend to allocate a virtually
contiguous, but physically fragmented buffer of memory for each data buffer. Linux OS also
provide SGL (scatter gather list) APIs to support this usage.</p>
<p>THC uses PRD table (physical region descriptor) to support the corresponding OS kernel
SGL that describes the virtual to physical buffer mapping.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> ------------------------      --------------       --------------
| PRD table base address +----+ PRD table #1 +-----+ PRD Entry #1 |
 ------------------------      --------------       --------------
                                                    --------------
                                                   | PRD Entry #2 |
                                                    --------------
                                                    --------------
                                                   | PRD Entry #n |
                                                    --------------
</pre></div>
</div>
<p>The read DMA engine supports multiple PRD tables held within a circular buffer that allow the THC
to support multiple data buffers from the Touch IC. This allows host SW to arm the Read DMA engine
with multiple buffers, allowing the Touch IC to send multiple data frames to the THC without SW
interaction. This capability is required when the CPU processes touch frames slower than the
Touch IC can send them.</p>
<p>To simplify the design, SW assumes worst-case memory fragmentation. Therefore,each PRD table shall
contain the same number of PRD entries, allowing for a global register (per Touch IC) to hold the
number of PRD-entries per PRD table.</p>
<p>SW allocates up to 128 PRD tables per Read DMA engine as specified in the THC_M_PRT_RPRD_CNTRL.PCD
register field. The number of PRD tables should equal the number of data buffers.</p>
<p>Max OS memory fragmentation will be at a 4KB boundary, thus to address 1MB of virtually contiguous
memory 256 PRD entries are required for a single PRD Table. SW writes the number of PRD entries
for each PRD table in the THC_M_PRT_RPRD_CNTRL.PTEC register field. The PRD entry’s length must be
multiple of 4KB except for the last entry in a PRD table.</p>
<p>SW allocates all the data buffers and PRD tables only once at host initialization.</p>
</section>
<section id="prd-write-pointer-and-read-pointer">
<h4>3.4.2 PRD Write pointer and read pointer<a class="headerlink" href="#prd-write-pointer-and-read-pointer" title="Link to this heading">¶</a></h4>
<p>As PRD tables are organized as a Circular Buffer (CB), a read pointer and a write pointer for a CB
are needed.</p>
<p>DMA HW consumes the PRD tables in the CB, one PRD entry at a time until the EOP bit is found set
in a PRD entry. At this point HW increments the PRD read pointer. Thus, the read pointer points
to the PRD which the DMA engine is currently processing. This pointer rolls over once the circular
buffer’s depth has been traversed with bit[7] the Rollover bit. E.g. if the DMA CB depth is equal
to 4 entries (0011b), then the read pointers will follow this pattern (HW is required to honor
this behavior): 00h 01h 02h 03h 80h 81h 82h 83h 00h 01h ...</p>
<p>The write pointer is updated by SW. The write pointer points to location in the DMA CB, where the
next PRD table is going to be stored. SW needs to ensure that this pointer rolls over once the
circular buffer’s depth has been traversed with Bit[7] as the rollover bit. E.g. if the DMA CB
depth is equal to 5 entries (0100b), then the write pointers will follow this pattern (SW is
required to honor this behavior): 00h 01h 02h 03h 04h 80h 81h 82h 83h 84h 00h 01h ..</p>
</section>
<section id="prd-descriptor-structure">
<h4>3.4.3 PRD descriptor structure<a class="headerlink" href="#prd-descriptor-structure" title="Link to this heading">¶</a></h4>
<p>Intel THC uses PRD entry descriptor for every PRD entry. Every PRD entry descriptor occupies
128 bits memories:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>struct field</p></th>
<th class="head"><p>bit(s)</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>dest_addr</p></td>
<td><p>53..0</p></td>
<td><p>destination memory address, as every entry
is 4KB, ignore lowest 10 bits of address.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved1</p></td>
<td><p>54..62</p></td>
<td><p>reserved</p></td>
</tr>
<tr class="row-even"><td><p>int_on_completion</p></td>
<td><p>63</p></td>
<td><p>completion interrupt enable bit, if this bit
set it means THC will trigger a completion
interrupt. This bit is set by SW driver.</p></td>
</tr>
<tr class="row-odd"><td><p>len</p></td>
<td><p>87..64</p></td>
<td><p>how many bytes of data in this entry.</p></td>
</tr>
<tr class="row-even"><td><p>end_of_prd</p></td>
<td><p>88</p></td>
<td><p>end of PRD table bit, if this bit is set,
it means this entry is last entry in this PRD
table. This bit is set by SW driver.</p></td>
</tr>
<tr class="row-odd"><td><p>hw_status</p></td>
<td><p>90..89</p></td>
<td><p>HW status bits</p></td>
</tr>
<tr class="row-even"><td><p>reserved2</p></td>
<td><p>127..91</p></td>
<td><p>reserved</p></td>
</tr>
</tbody>
</table>
<p>And one PRD table can include up to 256 PRD entries, as every entries is 4K bytes, so every
PRD table can describe 1M bytes memory.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">thc_prd_table</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">struct</span><span class="w"> </span><span class="nc">thc_prd_entry</span><span class="w"> </span><span class="n">entries</span><span class="p">[</span><span class="n">PRD_ENTRIES_NUM</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In general, every PRD table means one HID touch data packet. Every DMA engine can support
up to 128 PRD tables (except write DMA, write DMA only has one PRD table). SW driver is responsible
to get max packet length from touch IC, and use this max packet length to create PRD entries for
each PRD table.</p>
</section>
</section>
</section>
<section id="hidspi-support-quickspi">
<h2>4. HIDSPI support (QuickSPI)<a class="headerlink" href="#hidspi-support-quickspi" title="Link to this heading">¶</a></h2>
<p>Intel THC is total compatible with HIDSPI protocol, THC HW sequenser can accelerate HIDSPI
protocol transferring.</p>
<section id="reset-flow">
<h3>4.1 Reset Flow<a class="headerlink" href="#reset-flow" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Call ACPI _RST method to reset Touch IC device.</p></li>
<li><p>Read the reset response from TIC through PIO read.</p></li>
<li><p>Issue a command to retrieve device descriptor from Touch IC through PIO write.</p></li>
<li><p>Read the device descriptor from Touch IC through PIO read.</p></li>
<li><p>If the device descriptor is valid, allocate DMA buffers and configure all DMA channels.</p></li>
<li><p>Issue a command to retrieve report descriptor from Touch IC through DMA.</p></li>
</ul>
</section>
<section id="input-report-data-flow">
<h3>4.2 Input Report Data Flow<a class="headerlink" href="#input-report-data-flow" title="Link to this heading">¶</a></h3>
<p>Basic Flow:</p>
<ul class="simple">
<li><p>Touch IC interrupts the THC Controller using an in-band THC interrupt.</p></li>
<li><p>THC Sequencer reads the input report header by transmitting read approval as a signal
to the Touch IC to prepare for host to read from the device.</p></li>
<li><p>THC Sequencer executes a Input Report Body Read operation corresponding to the value
reflected in “Input Report Length” field of the Input Report Header.</p></li>
<li><p>THC DMA engine begins fetching data from the THC Sequencer and writes to host memory
at PRD entry 0 for the current CB PRD table entry. This process continues until the
THC Sequencer signals all data has been read or the THC DMA Read Engine reaches the
end of it’s last PRD entry (or both).</p></li>
<li><p>The THC Sequencer checks for the “Last Fragment Flag” bit in the Input Report Header.
If it is clear, the THC Sequencer enters an idle state.</p></li>
<li><p>If the “Last Fragment Flag” bit is enabled the THC Sequencer enters End-of-Frame Processing.</p></li>
</ul>
<p>THC Sequencer End of Frame Processing:</p>
<ul class="simple">
<li><p>THC DMA engine increments the read pointer of the Read PRD CB, sets EOF interrupt status
in RxDMA2 register (THC_M_PRT_READ_DMA_INT_STS_2).</p></li>
<li><p>If THC EOF interrupt is enabled by the driver in the control register (THC_M_PRT_READ_DMA_CNTRL_2),
generates interrupt to software.</p></li>
</ul>
<p>Sequence of steps to read data from RX DMA buffer:</p>
<ul class="simple">
<li><p>THC QuickSPI driver checks CB write Ptr and CB read Ptr to identify if any data frame in DMA
circular buffers.</p></li>
<li><p>THC QuickSPI driver gets first unprocessed PRD table.</p></li>
<li><p>THC QuickSPI driver scans all PRD entries in this PRD table to calculate the total frame size.</p></li>
<li><p>THC QuickSPI driver copies all frame data out.</p></li>
<li><p>THC QuickSPI driver checks the data type according to input report body, and calls related
callbacks to process the data.</p></li>
<li><p>THC QuickSPI driver updates write Ptr.</p></li>
</ul>
</section>
<section id="output-report-data-flow">
<h3>4.3 Output Report Data Flow<a class="headerlink" href="#output-report-data-flow" title="Link to this heading">¶</a></h3>
<p>Generic Output Report Flow:</p>
<ul class="simple">
<li><p>HID core calls raw_request callback with a request to THC QuickSPI driver.</p></li>
<li><p>THC QuickSPI Driver converts request provided data into the output report packet and copies it
to THC’s write DMA buffer.</p></li>
<li><p>Start TxDMA to complete the write operation.</p></li>
</ul>
</section>
</section>
<section id="hidi2c-support-quicki2c">
<h2>5. HIDI2C support (QuickI2C)<a class="headerlink" href="#hidi2c-support-quicki2c" title="Link to this heading">¶</a></h2>
<section id="id1">
<h3>5.1 Reset Flow<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Read device descriptor from Touch IC device through PIO write followed by read.</p></li>
<li><p>If the device descriptor is valid, allocate DMA buffers and configure all DMA channels.</p></li>
<li><p>Use PIO or TxDMA to write a SET_POWER request to TIC’s command register, and check if the
write operation is successfully completed.</p></li>
<li><p>Use PIO or TxDMA to write a RESET request to TIC’s command register. If the write operation
is successfully completed, wait for reset response from TIC.</p></li>
<li><p>Use SWDMA to read report descriptor through TIC’s report descriptor register.</p></li>
</ul>
</section>
<section id="id2">
<h3>5.2 Input Report Data Flow<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<p>Basic Flow:</p>
<ul class="simple">
<li><p>Touch IC asserts the interrupt indicating that it has an interrupt to send to HOST.
THC Sequencer issues a READ request over the I2C bus. The HIDI2C device returns the
first 2 bytes from the HIDI2C device which contains the length of the received data.</p></li>
<li><p>THC Sequencer continues the Read operation as per the size of data indicated in the
length field.</p></li>
<li><p>THC DMA engine begins fetching data from the THC Sequencer and writes to host memory
at PRD entry 0 for the current CB PRD table entry. THC writes 2Bytes for length field
plus the remaining data to RxDMA buffer. This process continues until the THC Sequencer
signals all data has been read or the THC DMA Read Engine reaches the end of it’s last
PRD entry (or both).</p></li>
<li><p>THC Sequencer enters End-of-Input Report Processing.</p></li>
<li><p>If the device has no more input reports to send to the host, it de-asserts the interrupt
line. For any additional input reports, device keeps the interrupt line asserted and
steps 1 through 4 in the flow are repeated.</p></li>
</ul>
<p>THC Sequencer End of Input Report Processing:</p>
<ul class="simple">
<li><p>THC DMA engine increments the read pointer of the Read PRD CB, sets EOF interrupt status
in RxDMA 2 register (THC_M_PRT_READ_DMA_INT_STS_2).</p></li>
<li><p>If THC EOF interrupt is enabled by the driver in the control register
(THC_M_PRT_READ_DMA_CNTRL_2), generates interrupt to software.</p></li>
</ul>
<p>Sequence of steps to read data from RX DMA buffer:</p>
<ul class="simple">
<li><p>THC QuickI2C driver checks CB write Ptr and CB read Ptr to identify if any data frame in DMA
circular buffers.</p></li>
<li><p>THC QuickI2C driver gets first unprocessed PRD table.</p></li>
<li><p>THC QuickI2C driver scans all PRD entries in this PRD table to calculate the total frame size.</p></li>
<li><p>THC QuickI2C driver copies all frame data out.</p></li>
<li><p>THC QuickI2C driver call hid_input_report to send the input report content to HID core, which
includes Report ID + Report Data Content (remove the length field from the original report
data).</p></li>
<li><p>THC QuickI2C driver updates write Ptr.</p></li>
</ul>
</section>
<section id="id3">
<h3>5.3 Output Report Data Flow<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h3>
<p>Generic Output Report Flow:</p>
<ul class="simple">
<li><p>HID core call THC QuickI2C raw_request callback.</p></li>
<li><p>THC QuickI2C uses PIO or TXDMA to write a SET_REPORT request to TIC’s command register. Report
type in SET_REPORT should be set to Output.</p></li>
<li><p>THC QuickI2C programs TxDMA buffer with TX Data to be written to TIC’s data register. The first
2 bytes should indicate the length of the report followed by the report contents including
Report ID.</p></li>
</ul>
</section>
</section>
<section id="thc-debugging">
<h2>6. THC Debugging<a class="headerlink" href="#thc-debugging" title="Link to this heading">¶</a></h2>
<p>To debug THC, event tracing mechanism is used. To enable debug logs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 1 &gt; /sys/kernel/debug/tracing/events/intel_thc/enable
cat /sys/kernel/debug/tracing/trace
</pre></div>
</div>
</section>
<section id="reference">
<h2>7. Reference<a class="headerlink" href="#reference" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>HIDSPI: <a class="reference external" href="https://download.microsoft.com/download/c/a/0/ca07aef3-3e10-4022-b1e9-c98cea99465d/HidSpiProtocolSpec.pdf">https://download.microsoft.com/download/c/a/0/ca07aef3-3e10-4022-b1e9-c98cea99465d/HidSpiProtocolSpec.pdf</a></p></li>
<li><p>HIDI2C: <a class="reference external" href="https://download.microsoft.com/download/7/d/d/7dd44bb7-2a7a-4505-ac1c-7227d3d96d5b/hid-over-i2c-protocol-spec-v1-0.docx">https://download.microsoft.com/download/7/d/d/7dd44bb7-2a7a-4505-ac1c-7227d3d96d5b/hid-over-i2c-protocol-spec-v1-0.docx</a></p></li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/hid/intel-thc-hid.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>