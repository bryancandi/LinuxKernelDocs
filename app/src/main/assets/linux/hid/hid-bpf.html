<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>HID-BPF &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="UHID - User-space I/O driver support for HID subsystem" href="uhid.html" />
    <link rel="prev" title="HID I/O Transport Drivers" href="hid-transport.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.9.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../input/index.html">Input Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpu/index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/hid/hid-bpf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="hid-bpf">
<h1>HID-BPF<a class="headerlink" href="#hid-bpf" title="Link to this heading">¶</a></h1>
<p>HID is a standard protocol for input devices but some devices may require
custom tweaks, traditionally done with a kernel driver fix. Using the eBPF
capabilities instead speeds up development and adds new capabilities to the
existing HID interfaces.</p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#when-and-why-to-use-hid-bpf" id="id1">When (and why) to use HID-BPF</a></p>
<ul>
<li><p><a class="reference internal" href="#dead-zone-of-a-joystick" id="id2">Dead zone of a joystick</a></p></li>
<li><p><a class="reference internal" href="#simple-fixup-of-report-descriptor" id="id3">Simple fixup of report descriptor</a></p></li>
<li><p><a class="reference internal" href="#add-a-new-feature-that-requires-a-new-kernel-api" id="id4">Add a new feature that requires a new kernel API</a></p></li>
<li><p><a class="reference internal" href="#morph-a-device-into-something-else-and-control-that-from-userspace" id="id5">Morph a device into something else and control that from userspace</a></p></li>
<li><p><a class="reference internal" href="#firewall" id="id6">Firewall</a></p></li>
<li><p><a class="reference internal" href="#tracing" id="id7">Tracing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#high-level-view-of-hid-bpf" id="id8">High-level view of HID-BPF</a></p></li>
<li><p><a class="reference internal" href="#available-types-of-programs" id="id9">Available types of programs</a></p></li>
<li><p><a class="reference internal" href="#developer-api" id="id10">Developer API:</a></p>
<ul>
<li><p><a class="reference internal" href="#user-api-data-structures-available-in-programs" id="id11">User API data structures available in programs:</a></p></li>
<li><p><a class="reference internal" href="#available-tracing-functions-to-attach-a-hid-bpf-program" id="id12">Available tracing functions to attach a HID-BPF program:</a></p></li>
<li><p><a class="reference internal" href="#available-api-that-can-be-used-in-all-hid-bpf-programs" id="id13">Available API that can be used in all HID-BPF programs:</a></p></li>
<li><p><a class="reference internal" href="#available-api-that-can-be-used-in-syscall-hid-bpf-programs" id="id14">Available API that can be used in syscall HID-BPF programs:</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#general-overview-of-a-hid-bpf-program" id="id15">General overview of a HID-BPF program</a></p>
<ul>
<li><p><a class="reference internal" href="#accessing-the-data-attached-to-the-context" id="id16">Accessing the data attached to the context</a></p></li>
<li><p><a class="reference internal" href="#effect-of-a-hid-bpf-program" id="id17">Effect of a HID-BPF program</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#attaching-a-bpf-program-to-a-device" id="id18">Attaching a bpf program to a device</a></p></li>
<li><p><a class="reference internal" href="#an-almost-complete-example-of-a-bpf-enhanced-hid-device" id="id19">An (almost) complete example of a BPF enhanced HID device</a></p>
<ul>
<li><p><a class="reference internal" href="#filtering-events" id="id20">Filtering events</a></p></li>
<li><p><a class="reference internal" href="#controlling-the-device" id="id21">Controlling the device</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="when-and-why-to-use-hid-bpf">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">When (and why) to use HID-BPF</a><a class="headerlink" href="#when-and-why-to-use-hid-bpf" title="Link to this heading">¶</a></h2>
<p>There are several use cases when using HID-BPF is better
than standard kernel driver fix:</p>
<section id="dead-zone-of-a-joystick">
<h3><a class="toc-backref" href="#id2" role="doc-backlink">Dead zone of a joystick</a><a class="headerlink" href="#dead-zone-of-a-joystick" title="Link to this heading">¶</a></h3>
<p>Assuming you have a joystick that is getting older, it is common to see it
wobbling around its neutral point. This is usually filtered at the application
level by adding a <em>dead zone</em> for this specific axis.</p>
<p>With HID-BPF, we can apply this filtering in the kernel directly so userspace
does not get woken up when nothing else is happening on the input controller.</p>
<p>Of course, given that this dead zone is specific to an individual device, we
can not create a generic fix for all of the same joysticks. Adding a custom
kernel API for this (e.g. by adding a sysfs entry) does not guarantee this new
kernel API will be broadly adopted and maintained.</p>
<p>HID-BPF allows the userspace program to load the program itself, ensuring we
only load the custom API when we have a user.</p>
</section>
<section id="simple-fixup-of-report-descriptor">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Simple fixup of report descriptor</a><a class="headerlink" href="#simple-fixup-of-report-descriptor" title="Link to this heading">¶</a></h3>
<p>In the HID tree, half of the drivers only fix one key or one byte
in the report descriptor. These fixes all require a kernel patch and the
subsequent shepherding into a release, a long and painful process for users.</p>
<p>We can reduce this burden by providing an eBPF program instead. Once such a
program  has been verified by the user, we can embed the source code into the
kernel tree and ship the eBPF program and load it directly instead of loading
a specific kernel module for it.</p>
<p>Note: distribution of eBPF programs and their inclusion in the kernel is not
yet fully implemented</p>
</section>
<section id="add-a-new-feature-that-requires-a-new-kernel-api">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Add a new feature that requires a new kernel API</a><a class="headerlink" href="#add-a-new-feature-that-requires-a-new-kernel-api" title="Link to this heading">¶</a></h3>
<p>An example for such a feature are the Universal Stylus Interface (USI) pens.
Basically, USI pens require a new kernel API because there are new
channels of communication that our HID and input stack do not support.
Instead of using hidraw or creating new sysfs entries or ioctls, we can rely
on eBPF to have the kernel API controlled by the consumer and to not
impact the performances by waking up userspace every time there is an
event.</p>
</section>
<section id="morph-a-device-into-something-else-and-control-that-from-userspace">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Morph a device into something else and control that from userspace</a><a class="headerlink" href="#morph-a-device-into-something-else-and-control-that-from-userspace" title="Link to this heading">¶</a></h3>
<p>The kernel has a relatively static mapping of HID items to evdev bits.
It cannot decide to dynamically transform a given device into something else
as it does not have the required context and any such transformation cannot be
undone (or even discovered) by userspace.</p>
<p>However, some devices are useless with that static way of defining devices. For
example, the Microsoft Surface Dial is a pushbutton with haptic feedback that
is barely usable as of today.</p>
<p>With eBPF, userspace can morph that device into a mouse, and convert the dial
events into wheel events. Also, the userspace program can set/unset the haptic
feedback depending on the context. For example, if a menu is visible on the
screen we likely need to have a haptic click every 15 degrees. But when
scrolling in a web page the user experience is better when the device emits
events at the highest resolution.</p>
</section>
<section id="firewall">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Firewall</a><a class="headerlink" href="#firewall" title="Link to this heading">¶</a></h3>
<p>What if we want to prevent other users to access a specific feature of a
device? (think a possibly broken firmware update entry point)</p>
<p>With eBPF, we can intercept any HID command emitted to the device and
validate it or not.</p>
<p>This also allows to sync the state between the userspace and the
kernel/bpf program because we can intercept any incoming command.</p>
</section>
<section id="tracing">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Tracing</a><a class="headerlink" href="#tracing" title="Link to this heading">¶</a></h3>
<p>The last usage is tracing events and all the fun we can do we BPF to summarize
and analyze events.</p>
<p>Right now, tracing relies on hidraw. It works well except for a couple
of issues:</p>
<ol class="arabic simple">
<li><p>if the driver doesn’t export a hidraw node, we can’t trace anything
(eBPF will be a “god-mode” there, so this may raise some eyebrows)</p></li>
<li><p>hidraw doesn’t catch other processes’ requests to the device, which
means that we have cases where we need to add printks to the kernel
to understand what is happening.</p></li>
</ol>
</section>
</section>
<section id="high-level-view-of-hid-bpf">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">High-level view of HID-BPF</a><a class="headerlink" href="#high-level-view-of-hid-bpf" title="Link to this heading">¶</a></h2>
<p>The main idea behind HID-BPF is that it works at an array of bytes level.
Thus, all of the parsing of the HID report and the HID report descriptor
must be implemented in the userspace component that loads the eBPF
program.</p>
<p>For example, in the dead zone joystick from above, knowing which fields
in the data stream needs to be set to <code class="docutils literal notranslate"><span class="pre">0</span></code> needs to be computed by userspace.</p>
<p>A corollary of this is that HID-BPF doesn’t know about the other subsystems
available in the kernel. <em>You can not directly emit input event through the
input API from eBPF</em>.</p>
<p>When a BPF program needs to emit input events, it needs to talk with the HID
protocol, and rely on the HID kernel processing to translate the HID data into
input events.</p>
</section>
<section id="available-types-of-programs">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Available types of programs</a><a class="headerlink" href="#available-types-of-programs" title="Link to this heading">¶</a></h2>
<p>HID-BPF is built “on top” of BPF, meaning that we use tracing method to
declare our programs.</p>
<p>HID-BPF has the following attachment types available:</p>
<ol class="arabic simple">
<li><p>event processing/filtering with <code class="docutils literal notranslate"><span class="pre">SEC(&quot;fmod_ret/hid_bpf_device_event&quot;)</span></code> in libbpf</p></li>
<li><p>actions coming from userspace with <code class="docutils literal notranslate"><span class="pre">SEC(&quot;syscall&quot;)</span></code> in libbpf</p></li>
<li><p>change of the report descriptor with <code class="docutils literal notranslate"><span class="pre">SEC(&quot;fmod_ret/hid_bpf_rdesc_fixup&quot;)</span></code> in libbpf</p></li>
</ol>
<p>A <code class="docutils literal notranslate"><span class="pre">hid_bpf_device_event</span></code> is calling a BPF program when an event is received from
the device. Thus we are in IRQ context and can act on the data or notify userspace.
And given that we are in IRQ context, we can not talk back to the device.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">syscall</span></code> means that userspace called the syscall <code class="docutils literal notranslate"><span class="pre">BPF_PROG_RUN</span></code> facility.
This time, we can do any operations allowed by HID-BPF, and talking to the device is
allowed.</p>
<p>Last, <code class="docutils literal notranslate"><span class="pre">hid_bpf_rdesc_fixup</span></code> is different from the others as there can be only one
BPF program of this type. This is called on <code class="docutils literal notranslate"><span class="pre">probe</span></code> from the driver and allows to
change the report descriptor from the BPF program. Once a <code class="docutils literal notranslate"><span class="pre">hid_bpf_rdesc_fixup</span></code>
program has been loaded, it is not possible to overwrite it unless the program which
inserted it allows us by pinning the program and closing all of its fds pointing to it.</p>
</section>
<section id="developer-api">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Developer API:</a><a class="headerlink" href="#developer-api" title="Link to this heading">¶</a></h2>
<section id="user-api-data-structures-available-in-programs">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">User API data structures available in programs:</a><a class="headerlink" href="#user-api-data-structures-available-in-programs" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.hid_bpf_ctx">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_ctx</span></span></span><a class="headerlink" href="#c.hid_bpf_ctx" title="Link to this definition">¶</a><br /></dt>
<dd><p>User accessible data for all HID programs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hid_bpf_ctx {
    __u32 index;
    const struct hid_device *hid;
    __u32 allocated_size;
    enum hid_report_type report_type;
    union {
        __s32 retval;
        __s32 size;
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>program index in the jump table. No special meaning (a smaller index
doesn’t mean the program will be executed before another program with
a bigger index).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hid</span></code></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_device</span></code> representing the device itself</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allocated_size</span></code></dt><dd><p>Allocated size of data.</p>
<p>This is how much memory is available and can be requested
by the HID program.
Note that for <code class="docutils literal notranslate"><span class="pre">HID_BPF_RDESC_FIXUP</span></code>, that memory is set to
<code class="docutils literal notranslate"><span class="pre">4096</span></code> (4 KB)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">report_type</span></code></dt><dd><p>used for <code class="docutils literal notranslate"><span class="pre">hid_bpf_device_event()</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">retval</span></code></dt><dd><p>Return value of the previous program.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Valid data in the data field.</p>
<p>Programs can get the available valid size in data by fetching this field.
Programs can also change this value by returning a positive number in the
program.
To discard the event, return a negative error code.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> must always be less or equal than <code class="docutils literal notranslate"><span class="pre">allocated_size</span></code> (it is enforced
once all BPF programs have been run).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">data</span></code> is not directly accessible from the context. We need to issue
a call to <code class="docutils literal notranslate"><span class="pre">hid_bpf_get_data()</span></code> in order to get a pointer to that field.</p>
<p>All of these fields are currently read-only.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.hid_bpf_attach_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_attach_flags</span></span></span><a class="headerlink" href="#c.hid_bpf_attach_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>flags used when attaching a HIF-BPF program</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">HID_BPF_FLAG_NONE</span></code></dt><dd><p>no specific flag is used, the kernel choses where to
insert the program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HID_BPF_FLAG_INSERT_HEAD</span></code></dt><dd><p>insert the given program before any other program
currently attached to the device. This doesn’t
guarantee that this program will always be first</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HID_BPF_FLAG_MAX</span></code></dt><dd><p>sentinel value, not to be used by the callers</p>
</dd>
</dl>
</div>
</section>
<section id="available-tracing-functions-to-attach-a-hid-bpf-program">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Available tracing functions to attach a HID-BPF program:</a><a class="headerlink" href="#available-tracing-functions-to-attach-a-hid-bpf-program" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_device_event">
<span class="pre">noinline</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_device_event</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_device_event" title="Link to this definition">¶</a><br /></dt>
<dd><p>Called whenever an event is coming in from the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>The HID-BPF context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>return</strong> <code class="docutils literal notranslate"><span class="pre">0</span></code> on success and keep processing; a positive value to change the
incoming size buffer; a negative error code to interrupt the processing
of this event</p>
<p>Declare an <code class="docutils literal notranslate"><span class="pre">fmod_ret</span></code> tracing bpf program to this function and attach this
program through <a class="reference internal" href="#c.hid_bpf_attach_prog" title="hid_bpf_attach_prog"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_attach_prog()</span></code></a> to have this helper called for
any incoming event from the device itself.</p>
<p>The function is called while on IRQ context, so we can not sleep.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_rdesc_fixup">
<span class="pre">noinline</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_rdesc_fixup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_rdesc_fixup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Called when the probe function parses the report descriptor of the HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>The HID-BPF context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>return</strong> 0 on success and keep processing; a positive value to change the
incoming size buffer; a negative error code to interrupt the processing
of this event</p>
<p>Declare an <code class="docutils literal notranslate"><span class="pre">fmod_ret</span></code> tracing bpf program to this function and attach this
program through <a class="reference internal" href="#c.hid_bpf_attach_prog" title="hid_bpf_attach_prog"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_attach_prog()</span></code></a> to have this helper called before any
parsing of the report descriptor by HID.</p>
</div>
</section>
<section id="available-api-that-can-be-used-in-all-hid-bpf-programs">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Available API that can be used in all HID-BPF programs:</a><a class="headerlink" href="#available-api-that-can-be-used-in-all-hid-bpf-programs" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_get_data">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="n"><span class="pre">__u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_get_data</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">rdwr_buf_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_get_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the kernel memory pointer associated with the context <strong>ctx</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>The HID-BPF context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>The offset within the memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">size_t</span> <span class="pre">rdwr_buf_size</span></code></dt><dd><p>the const size of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>returns</strong> <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error, an <code class="docutils literal notranslate"><span class="pre">__u8</span></code> memory pointer on success</p>
</div>
</section>
<section id="available-api-that-can-be-used-in-syscall-hid-bpf-programs">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Available API that can be used in syscall HID-BPF programs:</a><a class="headerlink" href="#available-api-that-can-be-used-in-syscall-hid-bpf-programs" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_attach_prog">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_attach_prog</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">hid_id</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">prog_fd</span></span>, <span class="n"><span class="pre">__u32</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_attach_prog" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attach the given <strong>prog_fd</strong> to the given HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hid_id</span></code></dt><dd><p>the system unique identifier of the HID device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">prog_fd</span></code></dt><dd><p>an fd in the user process representing the program to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u32</span> <span class="pre">flags</span></code></dt><dd><p>any logical OR combination of <a class="reference internal" href="#c.hid_bpf_attach_flags" title="hid_bpf_attach_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_bpf_attach_flags</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>returns</strong> an fd of a bpf_link object on success (&gt; <code class="docutils literal notranslate"><span class="pre">0</span></code>), an error code otherwise.
Closing this fd will detach the program from the HID device (unless the bpf_link
is pinned to the BPF file system).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_allocate_context">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_allocate_context</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">hid_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_allocate_context" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate a context to the given HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hid_id</span></code></dt><dd><p>the system unique identifier of the HID device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>returns</strong> A pointer to <a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span></code></a> on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_release_context">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_release_context</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_release_context" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release the previously allocated context <strong>ctx</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the HID-BPF context to release</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hid_bpf_hw_request">
<span class="pre">__bpf_kfunc</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hid_bpf_hw_request</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.hid_bpf_ctx" title="hid_bpf_ctx"><span class="n"><span class="pre">hid_bpf_ctx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">__u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">buf__sz</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hid_report_type</span></span><span class="w"> </span><span class="n"><span class="pre">rtype</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">hid_class_request</span></span><span class="w"> </span><span class="n"><span class="pre">reqtype</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hid_bpf_hw_request" title="Link to this definition">¶</a><br /></dt>
<dd><p>Communicate with a HID device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the HID-BPF context previously allocated in <a class="reference internal" href="#c.hid_bpf_allocate_context" title="hid_bpf_allocate_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_allocate_context()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">*buf</span></code></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">PTR_TO_MEM</span></code> buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buf__sz</span></code></dt><dd><p>the size of the data to transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_report_type</span> <span class="pre">rtype</span></code></dt><dd><p>the type of the report (<code class="docutils literal notranslate"><span class="pre">HID_INPUT_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_FEATURE_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_OUTPUT_REPORT</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_class_request</span> <span class="pre">reqtype</span></code></dt><dd><p>the type of the request (<code class="docutils literal notranslate"><span class="pre">HID_REQ_GET_REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">HID_REQ_SET_REPORT</span></code>, ...)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>returns</strong> <code class="docutils literal notranslate"><span class="pre">0</span></code> on success, a negative error code otherwise.</p>
</div>
</section>
</section>
<section id="general-overview-of-a-hid-bpf-program">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">General overview of a HID-BPF program</a><a class="headerlink" href="#general-overview-of-a-hid-bpf-program" title="Link to this heading">¶</a></h2>
<section id="accessing-the-data-attached-to-the-context">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Accessing the data attached to the context</a><a class="headerlink" href="#accessing-the-data-attached-to-the-context" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_bpf_ctx</span></code> doesn’t export the <code class="docutils literal notranslate"><span class="pre">data</span></code> fields directly and to access
it, a bpf program needs to first call <a class="reference internal" href="#c.hid_bpf_get_data" title="hid_bpf_get_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_get_data()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">offset</span></code> can be any integer, but <code class="docutils literal notranslate"><span class="pre">size</span></code> needs to be constant, known at compile
time.</p>
<p>This allows the following:</p>
<ol class="arabic">
<li><p>for a given device, if we know that the report length will always be of a certain value,
we can request the <code class="docutils literal notranslate"><span class="pre">data</span></code> pointer to point at the full report length.</p>
<p>The kernel will ensure we are using a correct size and offset and eBPF will ensure
the code will not attempt to read or write outside of the boundaries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u8 *data = hid_bpf_get_data(ctx, 0 /* offset */, 256 /* size */);

if (!data)
    return 0; /* ensure data is correct, now the verifier knows we
               * have 256 bytes available */

bpf_printk(&quot;hello world: %02x %02x %02x&quot;, data[0], data[128], data[255]);
</pre></div>
</div>
</li>
<li><p>if the report length is variable, but we know the value of <code class="docutils literal notranslate"><span class="pre">X</span></code> is always a 16-bit
integer, we can then have a pointer to that value only:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u16 *x = hid_bpf_get_data(ctx, offset, sizeof(*x));

if (!x)
    return 0; /* something went wrong */

*x += 1; /* increment X by one */
</pre></div>
</div>
</li>
</ol>
</section>
<section id="effect-of-a-hid-bpf-program">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Effect of a HID-BPF program</a><a class="headerlink" href="#effect-of-a-hid-bpf-program" title="Link to this heading">¶</a></h3>
<p>For all HID-BPF attachment types except for <a class="reference internal" href="#c.hid_bpf_rdesc_fixup" title="hid_bpf_rdesc_fixup"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_rdesc_fixup()</span></code></a>, several eBPF
programs can be attached to the same device.</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">HID_BPF_FLAG_INSERT_HEAD</span></code> is added to the flags while attaching the
program, the new program is appended at the end of the list.
<code class="docutils literal notranslate"><span class="pre">HID_BPF_FLAG_INSERT_HEAD</span></code> will insert the new program at the beginning of the
list which is useful for e.g. tracing where we need to get the unprocessed events
from the device.</p>
<p>Note that if there are multiple programs using the <code class="docutils literal notranslate"><span class="pre">HID_BPF_FLAG_INSERT_HEAD</span></code> flag,
only the most recently loaded one is actually the first in the list.</p>
<section id="sec-fmod-ret-hid-bpf-device-event">
<h4><code class="docutils literal notranslate"><span class="pre">SEC(&quot;fmod_ret/hid_bpf_device_event&quot;)</span></code><a class="headerlink" href="#sec-fmod-ret-hid-bpf-device-event" title="Link to this heading">¶</a></h4>
<p>Whenever a matching event is raised, the eBPF programs are called one after the other
and are working on the same data buffer.</p>
<p>If a program changes the data associated with the context, the next one will see
the modified data but it will have <em>no</em> idea of what the original data was.</p>
<p>Once all the programs are run and return <code class="docutils literal notranslate"><span class="pre">0</span></code> or a positive value, the rest of the
HID stack will work on the modified data, with the <code class="docutils literal notranslate"><span class="pre">size</span></code> field of the last hid_bpf_ctx
being the new size of the input stream of data.</p>
<p>A BPF program returning a negative error discards the event, i.e. this event will not be
processed by the HID stack. Clients (hidraw, input, LEDs) will <strong>not</strong> see this event.</p>
</section>
<section id="sec-syscall">
<h4><code class="docutils literal notranslate"><span class="pre">SEC(&quot;syscall&quot;)</span></code><a class="headerlink" href="#sec-syscall" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">syscall</span></code> are not attached to a given device. To tell which device we are working
with, userspace needs to refer to the device by its unique system id (the last 4 numbers
in the sysfs path: <code class="docutils literal notranslate"><span class="pre">/sys/bus/hid/devices/xxxx:yyyy:zzzz:0000</span></code>).</p>
<p>To retrieve a context associated with the device, the program must call
<a class="reference internal" href="#c.hid_bpf_allocate_context" title="hid_bpf_allocate_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_allocate_context()</span></code></a> and must release it with <a class="reference internal" href="#c.hid_bpf_release_context" title="hid_bpf_release_context"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_release_context()</span></code></a>
before returning.
Once the context is retrieved, one can also request a pointer to kernel memory with
<a class="reference internal" href="#c.hid_bpf_get_data" title="hid_bpf_get_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">hid_bpf_get_data()</span></code></a>. This memory is big enough to support all input/output/feature
reports of the given device.</p>
</section>
<section id="sec-fmod-ret-hid-bpf-rdesc-fixup">
<h4><code class="docutils literal notranslate"><span class="pre">SEC(&quot;fmod_ret/hid_bpf_rdesc_fixup&quot;)</span></code><a class="headerlink" href="#sec-fmod-ret-hid-bpf-rdesc-fixup" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">hid_bpf_rdesc_fixup</span></code> program works in a similar manner to
<code class="docutils literal notranslate"><span class="pre">.report_fixup</span></code> of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hid_driver</span></code>.</p>
<p>When the device is probed, the kernel sets the data buffer of the context with the
content of the report descriptor. The memory associated with that buffer is
<code class="docutils literal notranslate"><span class="pre">HID_MAX_DESCRIPTOR_SIZE</span></code> (currently 4kB).</p>
<p>The eBPF program can modify the data buffer at-will and the kernel uses the
modified content and size as the report descriptor.</p>
<p>Whenever a <code class="docutils literal notranslate"><span class="pre">SEC(&quot;fmod_ret/hid_bpf_rdesc_fixup&quot;)</span></code> program is attached (if no
program was attached before), the kernel immediately disconnects the HID device
and does a reprobe.</p>
<p>In the same way, when the <code class="docutils literal notranslate"><span class="pre">SEC(&quot;fmod_ret/hid_bpf_rdesc_fixup&quot;)</span></code> program is
detached, the kernel issues a disconnect on the device.</p>
<p>There is no <code class="docutils literal notranslate"><span class="pre">detach</span></code> facility in HID-BPF. Detaching a program happens when
all the user space file descriptors pointing at a program are closed.
Thus, if we need to replace a report descriptor fixup, some cooperation is
required from the owner of the original report descriptor fixup.
The previous owner will likely pin the program in the bpffs, and we can then
replace it through normal bpf operations.</p>
</section>
</section>
</section>
<section id="attaching-a-bpf-program-to-a-device">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Attaching a bpf program to a device</a><a class="headerlink" href="#attaching-a-bpf-program-to-a-device" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">libbpf</span></code> does not export any helper to attach a HID-BPF program.
Users need to use a dedicated <code class="docutils literal notranslate"><span class="pre">syscall</span></code> program which will call
<code class="docutils literal notranslate"><span class="pre">hid_bpf_attach_prog(hid_id,</span> <span class="pre">program_fd,</span> <span class="pre">flags)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">hid_id</span></code> is the unique system ID of the HID device (the last 4 numbers in the
sysfs path: <code class="docutils literal notranslate"><span class="pre">/sys/bus/hid/devices/xxxx:yyyy:zzzz:0000</span></code>)</p>
<p><code class="docutils literal notranslate"><span class="pre">progam_fd</span></code> is the opened file descriptor of the program to attach.</p>
<p><code class="docutils literal notranslate"><span class="pre">flags</span></code> is of type <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hid_bpf_attach_flags</span></code>.</p>
<p>We can not rely on hidraw to bind a BPF program to a HID device. hidraw is an
artefact of the processing of the HID device, and is not stable. Some drivers
even disable it, so that removes the tracing capabilities on those devices
(where it is interesting to get the non-hidraw traces).</p>
<p>On the other hand, the <code class="docutils literal notranslate"><span class="pre">hid_id</span></code> is stable for the entire life of the HID device,
even if we change its report descriptor.</p>
<p>Given that hidraw is not stable when the device disconnects/reconnects, we recommend
accessing the current report descriptor of the device through the sysfs.
This is available at <code class="docutils literal notranslate"><span class="pre">/sys/bus/hid/devices/BUS:VID:PID.000N/report_descriptor</span></code> as a
binary stream.</p>
<p>Parsing the report descriptor is the responsibility of the BPF programmer or the userspace
component that loads the eBPF program.</p>
</section>
<section id="an-almost-complete-example-of-a-bpf-enhanced-hid-device">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">An (almost) complete example of a BPF enhanced HID device</a><a class="headerlink" href="#an-almost-complete-example-of-a-bpf-enhanced-hid-device" title="Link to this heading">¶</a></h2>
<p><em>Foreword: for most parts, this could be implemented as a kernel driver</em></p>
<p>Let’s imagine we have a new tablet device that has some haptic capabilities
to simulate the surface the user is scratching on. This device would also have
a specific 3 positions switch to toggle between <em>pencil on paper</em>, <em>cray on a wall</em>
and <em>brush on a painting canvas</em>. To make things even better, we can control the
physical position of the switch through a feature report.</p>
<p>And of course, the switch is relying on some userspace component to control the
haptic feature of the device itself.</p>
<section id="filtering-events">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Filtering events</a><a class="headerlink" href="#filtering-events" title="Link to this heading">¶</a></h3>
<p>The first step consists in filtering events from the device. Given that the switch
position is actually reported in the flow of the pen events, using hidraw to implement
that filtering would mean that we wake up userspace for every single event.</p>
<p>This is OK for libinput, but having an external library that is just interested in
one byte in the report is less than ideal.</p>
<p>For that, we can create a basic skeleton for our BPF program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &quot;vmlinux.h&quot;
#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;

/* HID programs need to be GPL */
char _license[] SEC(&quot;license&quot;) = &quot;GPL&quot;;

/* HID-BPF kfunc API definitions */
extern __u8 *hid_bpf_get_data(struct hid_bpf_ctx *ctx,
                            unsigned int offset,
                            const size_t __sz) __ksym;
extern int hid_bpf_attach_prog(unsigned int hid_id, int prog_fd, u32 flags) __ksym;

struct {
      __uint(type, BPF_MAP_TYPE_RINGBUF);
      __uint(max_entries, 4096 * 64);
} ringbuf SEC(&quot;.maps&quot;);

struct attach_prog_args {
      int prog_fd;
      unsigned int hid;
      unsigned int flags;
      int retval;
};

SEC(&quot;syscall&quot;)
int attach_prog(struct attach_prog_args *ctx)
{
      ctx-&gt;retval = hid_bpf_attach_prog(ctx-&gt;hid,
                                        ctx-&gt;prog_fd,
                                        ctx-&gt;flags);
      return 0;
}

__u8 current_value = 0;

SEC(&quot;?fmod_ret/hid_bpf_device_event&quot;)
int BPF_PROG(filter_switch, struct hid_bpf_ctx *hid_ctx)
{
      __u8 *data = hid_bpf_get_data(hid_ctx, 0 /* offset */, 192 /* size */);
      __u8 *buf;

      if (!data)
              return 0; /* EPERM check */

      if (current_value != data[152]) {
              buf = bpf_ringbuf_reserve(&amp;ringbuf, 1, 0);
              if (!buf)
                      return 0;

              *buf = data[152];

              bpf_ringbuf_commit(buf, 0);

              current_value = data[152];
      }

      return 0;
}
</pre></div>
</div>
<p>To attach <code class="docutils literal notranslate"><span class="pre">filter_switch</span></code>, userspace needs to call the <code class="docutils literal notranslate"><span class="pre">attach_prog</span></code> syscall
program first:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int attach_filter(struct hid *hid_skel, int hid_id)
{
      int err, prog_fd;
      int ret = -1;
      struct attach_prog_args args = {
              .hid = hid_id,
      };
      DECLARE_LIBBPF_OPTS(bpf_test_run_opts, tattrs,
              .ctx_in = &amp;args,
              .ctx_size_in = sizeof(args),
      );

      args.prog_fd = bpf_program__fd(hid_skel-&gt;progs.filter_switch);

      prog_fd = bpf_program__fd(hid_skel-&gt;progs.attach_prog);

      err = bpf_prog_test_run_opts(prog_fd, &amp;tattrs);
      if (err)
              return err;

      return args.retval; /* the fd of the created bpf_link */
}
</pre></div>
</div>
<p>Our userspace program can now listen to notifications on the ring buffer, and
is awaken only when the value changes.</p>
<p>When the userspace program doesn’t need to listen to events anymore, it can just
close the returned fd from <code class="xref c c-func docutils literal notranslate"><span class="pre">attach_filter()</span></code>, which will tell the kernel to
detach the program from the HID device.</p>
<p>Of course, in other use cases, the userspace program can also pin the fd to the
BPF filesystem through a call to <code class="xref c c-func docutils literal notranslate"><span class="pre">bpf_obj_pin()</span></code>, as with any bpf_link.</p>
</section>
<section id="controlling-the-device">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Controlling the device</a><a class="headerlink" href="#controlling-the-device" title="Link to this heading">¶</a></h3>
<p>To be able to change the haptic feedback from the tablet, the userspace program
needs to emit a feature report on the device itself.</p>
<p>Instead of using hidraw for that, we can create a <code class="docutils literal notranslate"><span class="pre">SEC(&quot;syscall&quot;)</span></code> program
that talks to the device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* some more HID-BPF kfunc API definitions */
extern struct hid_bpf_ctx *hid_bpf_allocate_context(unsigned int hid_id) __ksym;
extern void hid_bpf_release_context(struct hid_bpf_ctx *ctx) __ksym;
extern int hid_bpf_hw_request(struct hid_bpf_ctx *ctx,
                            __u8* data,
                            size_t len,
                            enum hid_report_type type,
                            enum hid_class_request reqtype) __ksym;


struct hid_send_haptics_args {
      /* data needs to come at offset 0 so we can do a memcpy into it */
      __u8 data[10];
      unsigned int hid;
};

SEC(&quot;syscall&quot;)
int send_haptic(struct hid_send_haptics_args *args)
{
      struct hid_bpf_ctx *ctx;
      int ret = 0;

      ctx = hid_bpf_allocate_context(args-&gt;hid);
      if (!ctx)
              return 0; /* EPERM check */

      ret = hid_bpf_hw_request(ctx,
                               args-&gt;data,
                               10,
                               HID_FEATURE_REPORT,
                               HID_REQ_SET_REPORT);

      hid_bpf_release_context(ctx);

      return ret;
}
</pre></div>
</div>
<p>And then userspace needs to call that program directly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int set_haptic(struct hid *hid_skel, int hid_id, __u8 haptic_value)
{
      int err, prog_fd;
      int ret = -1;
      struct hid_send_haptics_args args = {
              .hid = hid_id,
      };
      DECLARE_LIBBPF_OPTS(bpf_test_run_opts, tattrs,
              .ctx_in = &amp;args,
              .ctx_size_in = sizeof(args),
      );

      args.data[0] = 0x02; /* report ID of the feature on our device */
      args.data[1] = haptic_value;

      prog_fd = bpf_program__fd(hid_skel-&gt;progs.set_haptic);

      err = bpf_prog_test_run_opts(prog_fd, &amp;tattrs);
      return err;
}
</pre></div>
</div>
<p>Now our userspace program is aware of the haptic state and can control it. The
program could make this state further available to other userspace programs
(e.g. via a DBus API).</p>
<p>The interesting bit here is that we did not created a new kernel API for this.
Which means that if there is a bug in our implementation, we can change the
interface with the kernel at-will, because the userspace application is
responsible for its own usage.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/hid/hid-bpf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>