<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>KCOV: code coverage for fuzzing &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Using gcov with the Linux kernel" href="gcov.html" />
    <link rel="prev" title="Sparse" href="sparse.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.10.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Development tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="checkpatch.html">Checkpatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="coccinelle.html">Coccinelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="sparse.html">Sparse</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">KCOV: code coverage for fuzzing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coverage-collection">Coverage collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comparison-operands-collection">Comparison operands collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#remote-coverage-collection">Remote coverage collection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gcov.html">Using gcov with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="kasan.html">Kernel Address Sanitizer (KASAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="kmsan.html">Kernel Memory Sanitizer (KMSAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ubsan.html">Undefined Behavior Sanitizer - UBSAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="kmemleak.html">Kernel Memory Leak Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="kcsan.html">Kernel Concurrency Sanitizer (KCSAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="kfence.html">Kernel Electric-Fence (KFENCE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="gdb-kernel-debugging.html">Debugging kernel and modules via gdb</a></li>
<li class="toctree-l2"><a class="reference internal" href="kgdb.html">Using kgdb, kdb and the kernel debugger internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="kselftest.html">Linux Kernel Selftests</a></li>
<li class="toctree-l2"><a class="reference internal" href="kunit/index.html">KUnit - Linux Kernel Unit Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="ktap.html">The Kernel Test Anything Protocol (KTAP), version 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="checkuapi.html">UAPI Checker</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/dev-tools/kcov.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../translations/zh_CN/dev-tools/kcov.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="kcov-code-coverage-for-fuzzing">
<h1>KCOV: code coverage for fuzzing<a class="headerlink" href="#kcov-code-coverage-for-fuzzing" title="Link to this heading">¶</a></h1>
<p>KCOV collects and exposes kernel code coverage information in a form suitable
for coverage-guided fuzzing. Coverage data of a running kernel is exported via
the <code class="docutils literal notranslate"><span class="pre">kcov</span></code> debugfs file. Coverage collection is enabled on a task basis, and
thus KCOV can capture precise coverage of a single system call.</p>
<p>Note that KCOV does not aim to collect as much coverage as possible. It aims
to collect more or less stable coverage that is a function of syscall inputs.
To achieve this goal, it does not collect coverage in soft/hard interrupts
(unless remove coverage collection is enabled, see below) and from some
inherently non-deterministic parts of the kernel (e.g. scheduler, locking).</p>
<p>Besides collecting code coverage, KCOV can also collect comparison operands.
See the “Comparison operands collection” section for details.</p>
<p>Besides collecting coverage data from syscall handlers, KCOV can also collect
coverage for annotated parts of the kernel executing in background kernel
tasks or soft interrupts. See the “Remote coverage collection” section for
details.</p>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Link to this heading">¶</a></h2>
<p>KCOV relies on compiler instrumentation and requires GCC 6.1.0 or later
or any Clang version supported by the kernel.</p>
<p>Collecting comparison operands is supported with GCC 8+ or with Clang.</p>
<p>To enable KCOV, configure the kernel with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KCOV=y
</pre></div>
</div>
<p>To enable comparison operands collection, set:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KCOV_ENABLE_COMPARISONS=y
</pre></div>
</div>
<p>Coverage data only becomes accessible once debugfs has been mounted:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t debugfs none /sys/kernel/debug
</pre></div>
</div>
</section>
<section id="coverage-collection">
<h2>Coverage collection<a class="headerlink" href="#coverage-collection" title="Link to this heading">¶</a></h2>
<p>The following program demonstrates how to use KCOV to collect coverage for a
single syscall from within a test program:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/stat.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/ioctl.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/mman.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fcntl.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/types.h&gt;</span>

<span class="cp">#define KCOV_INIT_TRACE                     _IOR(&#39;c&#39;, 1, unsigned long)</span>
<span class="cp">#define KCOV_ENABLE                 _IO(&#39;c&#39;, 100)</span>
<span class="cp">#define KCOV_DISABLE                        _IO(&#39;c&#39;, 101)</span>
<span class="cp">#define COVER_SIZE                  (64&lt;&lt;10)</span>

<span class="cp">#define KCOV_TRACE_PC  0</span>
<span class="cp">#define KCOV_TRACE_CMP 1</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">cover</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* A single fd descriptor allows coverage collection on a single</span>
<span class="cm">     * thread.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/sys/kernel/debug/kcov&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;open&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Setup trace mode and trace size. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_INIT_TRACE</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Mmap buffer shared between kernel- and user-space. */</span>
<span class="w">    </span><span class="n">cover</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">),</span>
<span class="w">                                 </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">cover</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mmap&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Enable coverage collection on the current thread. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_ENABLE</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_TRACE_PC</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Reset coverage from the tail of the ioctl() call. */</span>
<span class="w">    </span><span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cover</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Call the target syscall call. */</span>
<span class="w">    </span><span class="n">read</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Read number of PCs collected. */</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cover</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cover</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="cm">/* Disable coverage collection for the current thread. After this call</span>
<span class="cm">     * coverage can be enabled for a different thread.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_DISABLE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Free resources. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">munmap</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;munmap&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After piping through <code class="docutils literal notranslate"><span class="pre">addr2line</span></code> the output of the program looks as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SyS_read
fs/read_write.c:562
__fdget_pos
fs/file.c:774
__fget_light
fs/file.c:746
__fget_light
fs/file.c:750
__fget_light
fs/file.c:760
__fdget_pos
fs/file.c:784
SyS_read
fs/read_write.c:562
</pre></div>
</div>
<p>If a program needs to collect coverage from several threads (independently),
it needs to open <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/kcov</span></code> in each thread separately.</p>
<p>The interface is fine-grained to allow efficient forking of test processes.
That is, a parent process opens <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/kcov</span></code>, enables trace mode,
mmaps coverage buffer, and then forks child processes in a loop. The child
processes only need to enable coverage (it gets disabled automatically when
a thread exits).</p>
</section>
<section id="comparison-operands-collection">
<h2>Comparison operands collection<a class="headerlink" href="#comparison-operands-collection" title="Link to this heading">¶</a></h2>
<p>Comparison operands collection is similar to coverage collection:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Same includes and defines as above. */</span>

<span class="cm">/* Number of 64-bit words per record. */</span>
<span class="cp">#define KCOV_WORDS_PER_CMP 4</span>

<span class="cm">/*</span>
<span class="cm"> * The format for the types of collected comparisons.</span>
<span class="cm"> *</span>
<span class="cm"> * Bit 0 shows whether one of the arguments is a compile-time constant.</span>
<span class="cm"> * Bits 1 &amp; 2 contain log2 of the argument size, up to 8 bytes.</span>
<span class="cm"> */</span>

<span class="cp">#define KCOV_CMP_CONST          (1 &lt;&lt; 0)</span>
<span class="cp">#define KCOV_CMP_SIZE(n)        ((n) &lt;&lt; 1)</span>
<span class="cp">#define KCOV_CMP_MASK           KCOV_CMP_SIZE(3)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">cover</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="n">is_const</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/sys/kernel/debug/kcov&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;open&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_INIT_TRACE</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    * Note that the buffer pointer is of type uint64_t*, because all</span>
<span class="cm">    * the comparison operands are promoted to uint64_t.</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="n">cover</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">),</span>
<span class="w">                                 </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">cover</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mmap&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Note KCOV_TRACE_CMP instead of KCOV_TRACE_PC. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_ENABLE</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_TRACE_CMP</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cover</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
<span class="w">    </span><span class="n">read</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Read number of comparisons collected. */</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cover</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>

<span class="w">            </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cover</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">KCOV_WORDS_PER_CMP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="cm">/* arg1 and arg2 - operands of the comparison. */</span>
<span class="w">            </span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cover</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">KCOV_WORDS_PER_CMP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">            </span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cover</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">KCOV_WORDS_PER_CMP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="w">            </span><span class="cm">/* ip - caller address. */</span>
<span class="w">            </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cover</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">KCOV_WORDS_PER_CMP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span>
<span class="w">            </span><span class="cm">/* size of the operands. */</span>
<span class="w">            </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">((</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">KCOV_CMP_MASK</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="cm">/* is_const - true if either operand is a compile-time constant.*/</span>
<span class="w">            </span><span class="n">is_const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">KCOV_CMP_CONST</span><span class="p">;</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ip: 0x%lx type: 0x%lx, arg1: 0x%lx, arg2: 0x%lx, &quot;</span>
<span class="w">                    </span><span class="s">&quot;size: %lu, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">            </span><span class="n">is_const</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;const&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;non-const&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_DISABLE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Free resources. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">munmap</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;munmap&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the KCOV modes (collection of code coverage or comparison operands)
are mutually exclusive.</p>
</section>
<section id="remote-coverage-collection">
<h2>Remote coverage collection<a class="headerlink" href="#remote-coverage-collection" title="Link to this heading">¶</a></h2>
<p>Besides collecting coverage data from handlers of syscalls issued from a
userspace process, KCOV can also collect coverage for parts of the kernel
executing in other contexts - so-called “remote” coverage.</p>
<p>Using KCOV to collect remote coverage requires:</p>
<ol class="arabic simple">
<li><p>Modifying kernel code to annotate the code section from where coverage
should be collected with <code class="docutils literal notranslate"><span class="pre">kcov_remote_start</span></code> and <code class="docutils literal notranslate"><span class="pre">kcov_remote_stop</span></code>.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">KCOV_REMOTE_ENABLE</span></code> instead of <code class="docutils literal notranslate"><span class="pre">KCOV_ENABLE</span></code> in the userspace
process that collects coverage.</p></li>
</ol>
<p>Both <code class="docutils literal notranslate"><span class="pre">kcov_remote_start</span></code> and <code class="docutils literal notranslate"><span class="pre">kcov_remote_stop</span></code> annotations and the
<code class="docutils literal notranslate"><span class="pre">KCOV_REMOTE_ENABLE</span></code> ioctl accept handles that identify particular coverage
collection sections. The way a handle is used depends on the context where the
matching code section executes.</p>
<p>KCOV supports collecting remote coverage from the following contexts:</p>
<ol class="arabic simple">
<li><p>Global kernel background tasks. These are the tasks that are spawned during
kernel boot in a limited number of instances (e.g. one USB <code class="docutils literal notranslate"><span class="pre">hub_event</span></code>
worker is spawned per one USB HCD).</p></li>
<li><p>Local kernel background tasks. These are spawned when a userspace process
interacts with some kernel interface and are usually killed when the process
exits (e.g. vhost workers).</p></li>
<li><p>Soft interrupts.</p></li>
</ol>
<p>For #1 and #3, a unique global handle must be chosen and passed to the
corresponding <code class="docutils literal notranslate"><span class="pre">kcov_remote_start</span></code> call. Then a userspace process must pass
this handle to <code class="docutils literal notranslate"><span class="pre">KCOV_REMOTE_ENABLE</span></code> in the <code class="docutils literal notranslate"><span class="pre">handles</span></code> array field of the
<code class="docutils literal notranslate"><span class="pre">kcov_remote_arg</span></code> struct. This will attach the used KCOV device to the code
section referenced by this handle. Multiple global handles identifying
different code sections can be passed at once.</p>
<p>For #2, the userspace process instead must pass a non-zero handle through the
<code class="docutils literal notranslate"><span class="pre">common_handle</span></code> field of the <code class="docutils literal notranslate"><span class="pre">kcov_remote_arg</span></code> struct. This common handle
gets saved to the <code class="docutils literal notranslate"><span class="pre">kcov_handle</span></code> field in the current <code class="docutils literal notranslate"><span class="pre">task_struct</span></code> and
needs to be passed to the newly spawned local tasks via custom kernel code
modifications. Those tasks should in turn use the passed handle in their
<code class="docutils literal notranslate"><span class="pre">kcov_remote_start</span></code> and <code class="docutils literal notranslate"><span class="pre">kcov_remote_stop</span></code> annotations.</p>
<p>KCOV follows a predefined format for both global and common handles. Each
handle is a <code class="docutils literal notranslate"><span class="pre">u64</span></code> integer. Currently, only the one top and the lower 4 bytes
are used. Bytes 4-7 are reserved and must be zero.</p>
<p>For global handles, the top byte of the handle denotes the id of a subsystem
this handle belongs to. For example, KCOV uses <code class="docutils literal notranslate"><span class="pre">1</span></code> as the USB subsystem id.
The lower 4 bytes of a global handle denote the id of a task instance within
that subsystem. For example, each <code class="docutils literal notranslate"><span class="pre">hub_event</span></code> worker uses the USB bus number
as the task instance id.</p>
<p>For common handles, a reserved value <code class="docutils literal notranslate"><span class="pre">0</span></code> is used as a subsystem id, as such
handles don’t belong to a particular subsystem. The lower 4 bytes of a common
handle identify a collective instance of all local tasks spawned by the
userspace process that passed a common handle to <code class="docutils literal notranslate"><span class="pre">KCOV_REMOTE_ENABLE</span></code>.</p>
<p>In practice, any value can be used for common handle instance id if coverage
is only collected from a single userspace process on the system. However, if
common handles are used by multiple processes, unique instance ids must be
used for each process. One option is to use the process id as the common
handle instance id.</p>
<p>The following program demonstrates using KCOV to collect coverage from both
local tasks spawned by the process and the global task that handles USB bus #1:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Same includes and defines as above. */</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">kcov_remote_arg</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__u32</span><span class="w">           </span><span class="n">trace_mode</span><span class="p">;</span>
<span class="w">    </span><span class="n">__u32</span><span class="w">           </span><span class="n">area_size</span><span class="p">;</span>
<span class="w">    </span><span class="n">__u32</span><span class="w">           </span><span class="n">num_handles</span><span class="p">;</span>
<span class="w">    </span><span class="n">__aligned_u64</span><span class="w">   </span><span class="n">common_handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">__aligned_u64</span><span class="w">   </span><span class="n">handles</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define KCOV_INIT_TRACE                     _IOR(&#39;c&#39;, 1, unsigned long)</span>
<span class="cp">#define KCOV_DISABLE                        _IO(&#39;c&#39;, 101)</span>
<span class="cp">#define KCOV_REMOTE_ENABLE          _IOW(&#39;c&#39;, 102, struct kcov_remote_arg)</span>

<span class="cp">#define COVER_SIZE  (64 &lt;&lt; 10)</span>

<span class="cp">#define KCOV_TRACE_PC       0</span>

<span class="cp">#define KCOV_SUBSYSTEM_COMMON       (0x00ull &lt;&lt; 56)</span>
<span class="cp">#define KCOV_SUBSYSTEM_USB  (0x01ull &lt;&lt; 56)</span>

<span class="cp">#define KCOV_SUBSYSTEM_MASK (0xffull &lt;&lt; 56)</span>
<span class="cp">#define KCOV_INSTANCE_MASK  (0xffffffffull)</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">__u64</span><span class="w"> </span><span class="nf">kcov_remote_handle</span><span class="p">(</span><span class="n">__u64</span><span class="w"> </span><span class="n">subsys</span><span class="p">,</span><span class="w"> </span><span class="n">__u64</span><span class="w"> </span><span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">subsys</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">KCOV_SUBSYSTEM_MASK</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">inst</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">KCOV_INSTANCE_MASK</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">subsys</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">inst</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define KCOV_COMMON_ID      0x42</span>
<span class="cp">#define KCOV_USB_BUS_NUM    1</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">cover</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kcov_remote_arg</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">;</span>

<span class="w">    </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;/sys/kernel/debug/kcov&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;open&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_INIT_TRACE</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">cover</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">),</span>
<span class="w">                                 </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_SHARED</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">cover</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mmap&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Enable coverage collection via common handle and from USB bus #1. */</span>
<span class="w">    </span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;calloc&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">trace_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KCOV_TRACE_PC</span><span class="p">;</span>
<span class="w">    </span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">area_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">num_handles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">common_handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kcov_remote_handle</span><span class="p">(</span><span class="n">KCOV_SUBSYSTEM_COMMON</span><span class="p">,</span>
<span class="w">                                                    </span><span class="n">KCOV_COMMON_ID</span><span class="p">);</span>
<span class="w">    </span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">handles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kcov_remote_handle</span><span class="p">(</span><span class="n">KCOV_SUBSYSTEM_USB</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">KCOV_USB_BUS_NUM</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_REMOTE_ENABLE</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">free</span><span class="p">(</span><span class="n">arg</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Here the user needs to trigger execution of a kernel code section</span>
<span class="cm">     * that is either annotated with the common handle, or to trigger some</span>
<span class="cm">     * activity on USB bus #1.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cover</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cover</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">KCOV_DISABLE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;ioctl&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">munmap</span><span class="p">(</span><span class="n">cover</span><span class="p">,</span><span class="w"> </span><span class="n">COVER_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;munmap&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">))</span>
<span class="w">            </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/dev-tools/kcov.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>