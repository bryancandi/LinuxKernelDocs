<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Kernel Electric-Fence (KFENCE) &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Debugging kernel and modules via gdb" href="gdb-kernel-debugging.html" />
    <link rel="prev" title="Kernel Concurrency Sanitizer (KCSAN)" href="kcsan.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.13.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Development tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="checkpatch.html">Checkpatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="clang-format.html">clang-format</a></li>
<li class="toctree-l2"><a class="reference internal" href="coccinelle.html">Coccinelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="sparse.html">Sparse</a></li>
<li class="toctree-l2"><a class="reference internal" href="kcov.html">KCOV: code coverage for fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="gcov.html">Using gcov with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="kasan.html">Kernel Address Sanitizer (KASAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="kmsan.html">Kernel Memory Sanitizer (KMSAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ubsan.html">Undefined Behavior Sanitizer - UBSAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="kmemleak.html">Kernel Memory Leak Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="kcsan.html">Kernel Concurrency Sanitizer (KCSAN)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Kernel Electric-Fence (KFENCE)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-details">Implementation Details</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interface">Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#related-tools">Related Tools</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gdb-kernel-debugging.html">Debugging kernel and modules via gdb</a></li>
<li class="toctree-l2"><a class="reference internal" href="kgdb.html">Using kgdb, kdb and the kernel debugger internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="kselftest.html">Linux Kernel Selftests</a></li>
<li class="toctree-l2"><a class="reference internal" href="kunit/index.html">KUnit - Linux Kernel Unit Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="ktap.html">The Kernel Test Anything Protocol (KTAP), version 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="checkuapi.html">UAPI Checker</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio-sloppy-logic-analyzer.html">Linux Kernel GPIO based sloppy logic analyzer</a></li>
<li class="toctree-l2"><a class="reference internal" href="autofdo.html">Using AutoFDO with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="propeller.html">Using Propeller with the Linux kernel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/dev-tools/kfence.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="kernel-electric-fence-kfence">
<h1>Kernel Electric-Fence (KFENCE)<a class="headerlink" href="#kernel-electric-fence-kfence" title="Link to this heading">¶</a></h1>
<p>Kernel Electric-Fence (KFENCE) is a low-overhead sampling-based memory safety
error detector. KFENCE detects heap out-of-bounds access, use-after-free, and
invalid-free errors.</p>
<p>KFENCE is designed to be enabled in production kernels, and has near zero
performance overhead. Compared to KASAN, KFENCE trades performance for
precision. The main motivation behind KFENCE’s design, is that with enough
total uptime KFENCE will detect bugs in code paths not typically exercised by
non-production test workloads. One way to quickly achieve a large enough total
uptime is when the tool is deployed across a large fleet of machines.</p>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h2>
<p>To enable KFENCE, configure the kernel with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KFENCE=y
</pre></div>
</div>
<p>To build a kernel with KFENCE support, but disabled by default (to enable, set
<code class="docutils literal notranslate"><span class="pre">kfence.sample_interval</span></code> to non-zero value), configure the kernel with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KFENCE=y
CONFIG_KFENCE_SAMPLE_INTERVAL=0
</pre></div>
</div>
<p>KFENCE provides several other configuration options to customize behaviour (see
the respective help text in <code class="docutils literal notranslate"><span class="pre">lib/Kconfig.kfence</span></code> for more info).</p>
<section id="tuning-performance">
<h3>Tuning performance<a class="headerlink" href="#tuning-performance" title="Link to this heading">¶</a></h3>
<p>The most important parameter is KFENCE’s sample interval, which can be set via
the kernel boot parameter <code class="docutils literal notranslate"><span class="pre">kfence.sample_interval</span></code> in milliseconds. The
sample interval determines the frequency with which heap allocations will be
guarded by KFENCE. The default is configurable via the Kconfig option
<code class="docutils literal notranslate"><span class="pre">CONFIG_KFENCE_SAMPLE_INTERVAL</span></code>. Setting <code class="docutils literal notranslate"><span class="pre">kfence.sample_interval=0</span></code>
disables KFENCE.</p>
<p>The sample interval controls a timer that sets up KFENCE allocations. By
default, to keep the real sample interval predictable, the normal timer also
causes CPU wake-ups when the system is completely idle. This may be undesirable
on power-constrained systems. The boot parameter <code class="docutils literal notranslate"><span class="pre">kfence.deferrable=1</span></code>
instead switches to a “deferrable” timer which does not force CPU wake-ups on
idle systems, at the risk of unpredictable sample intervals. The default is
configurable via the Kconfig option <code class="docutils literal notranslate"><span class="pre">CONFIG_KFENCE_DEFERRABLE</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The KUnit test suite is very likely to fail when using a deferrable timer
since it currently causes very unpredictable sample intervals.</p>
</div>
<p>By default KFENCE will only sample 1 heap allocation within each sample
interval. <em>Burst mode</em> allows to sample successive heap allocations, where the
kernel boot parameter <code class="docutils literal notranslate"><span class="pre">kfence.burst</span></code> can be set to a non-zero value which
denotes the <em>additional</em> successive allocations within a sample interval;
setting <code class="docutils literal notranslate"><span class="pre">kfence.burst=N</span></code> means that <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">N</span></code> successive allocations are
attempted through KFENCE for each sample interval.</p>
<p>The KFENCE memory pool is of fixed size, and if the pool is exhausted, no
further KFENCE allocations occur. With <code class="docutils literal notranslate"><span class="pre">CONFIG_KFENCE_NUM_OBJECTS</span></code> (default
255), the number of available guarded objects can be controlled. Each object
requires 2 pages, one for the object itself and the other one used as a guard
page; object pages are interleaved with guard pages, and every object page is
therefore surrounded by two guard pages.</p>
<p>The total memory dedicated to the KFENCE memory pool can be computed as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>( #objects + 1 ) * 2 * PAGE_SIZE
</pre></div>
</div>
<p>Using the default config, and assuming a page size of 4 KiB, results in
dedicating 2 MiB to the KFENCE memory pool.</p>
<p>Note: On architectures that support huge pages, KFENCE will ensure that the
pool is using pages of size <code class="docutils literal notranslate"><span class="pre">PAGE_SIZE</span></code>. This will result in additional page
tables being allocated.</p>
</section>
<section id="error-reports">
<h3>Error reports<a class="headerlink" href="#error-reports" title="Link to this heading">¶</a></h3>
<p>A typical out-of-bounds access looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: out-of-bounds read in test_out_of_bounds_read+0xa6/0x234

Out-of-bounds read at 0xffff8c3f2e291fff (1B left of kfence-#72):
 test_out_of_bounds_read+0xa6/0x234
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

kfence-#72: 0xffff8c3f2e292000-0xffff8c3f2e29201f, size=32, cache=kmalloc-32

allocated by task 484 on cpu 0 at 32.919330s:
 test_alloc+0xfe/0x738
 test_out_of_bounds_read+0x9b/0x234
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

CPU: 0 PID: 484 Comm: kunit_try_catch Not tainted 5.13.0-rc3+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
==================================================================
</pre></div>
</div>
<p>The header of the report provides a short summary of the function involved in
the access. It is followed by more detailed information about the access and
its origin. Note that, real kernel addresses are only shown when using the
kernel command line option <code class="docutils literal notranslate"><span class="pre">no_hash_pointers</span></code>.</p>
<p>Use-after-free accesses are reported as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: use-after-free read in test_use_after_free_read+0xb3/0x143

Use-after-free read at 0xffff8c3f2e2a0000 (in kfence-#79):
 test_use_after_free_read+0xb3/0x143
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

kfence-#79: 0xffff8c3f2e2a0000-0xffff8c3f2e2a001f, size=32, cache=kmalloc-32

allocated by task 488 on cpu 2 at 33.871326s:
 test_alloc+0xfe/0x738
 test_use_after_free_read+0x76/0x143
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

freed by task 488 on cpu 2 at 33.871358s:
 test_use_after_free_read+0xa8/0x143
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

CPU: 2 PID: 488 Comm: kunit_try_catch Tainted: G    B             5.13.0-rc3+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
==================================================================
</pre></div>
</div>
<p>KFENCE also reports on invalid frees, such as double-frees:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: invalid free in test_double_free+0xdc/0x171

Invalid free of 0xffff8c3f2e2a4000 (in kfence-#81):
 test_double_free+0xdc/0x171
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

kfence-#81: 0xffff8c3f2e2a4000-0xffff8c3f2e2a401f, size=32, cache=kmalloc-32

allocated by task 490 on cpu 1 at 34.175321s:
 test_alloc+0xfe/0x738
 test_double_free+0x76/0x171
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

freed by task 490 on cpu 1 at 34.175348s:
 test_double_free+0xa8/0x171
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

CPU: 1 PID: 490 Comm: kunit_try_catch Tainted: G    B             5.13.0-rc3+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
==================================================================
</pre></div>
</div>
<p>KFENCE also uses pattern-based redzones on the other side of an object’s guard
page, to detect out-of-bounds writes on the unprotected side of the object.
These are reported on frees:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: memory corruption in test_kmalloc_aligned_oob_write+0xef/0x184

Corrupted memory at 0xffff8c3f2e33aff9 [ 0xac . . . . . . ] (in kfence-#156):
 test_kmalloc_aligned_oob_write+0xef/0x184
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

kfence-#156: 0xffff8c3f2e33afb0-0xffff8c3f2e33aff8, size=73, cache=kmalloc-96

allocated by task 502 on cpu 7 at 42.159302s:
 test_alloc+0xfe/0x738
 test_kmalloc_aligned_oob_write+0x57/0x184
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

CPU: 7 PID: 502 Comm: kunit_try_catch Tainted: G    B             5.13.0-rc3+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
==================================================================
</pre></div>
</div>
<p>For such errors, the address where the corruption occurred as well as the
invalidly written bytes (offset from the address) are shown; in this
representation, ‘.’ denote untouched bytes. In the example above <code class="docutils literal notranslate"><span class="pre">0xac</span></code> is
the value written to the invalid address at offset 0, and the remaining ‘.’
denote that no following bytes have been touched. Note that, real values are
only shown if the kernel was booted with <code class="docutils literal notranslate"><span class="pre">no_hash_pointers</span></code>; to avoid
information disclosure otherwise, ‘!’ is used instead to denote invalidly
written bytes.</p>
<p>And finally, KFENCE may also report on invalid accesses to any protected page
where it was not possible to determine an associated object, e.g. if adjacent
object pages had not yet been allocated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: invalid read in test_invalid_access+0x26/0xe0

Invalid read at 0xffffffffb670b00a:
 test_invalid_access+0x26/0xe0
 kunit_try_run_case+0x51/0x85
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x137/0x160
 ret_from_fork+0x22/0x30

CPU: 4 PID: 124 Comm: kunit_try_catch Tainted: G        W         5.8.0-rc6+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1 04/01/2014
==================================================================
</pre></div>
</div>
</section>
<section id="debugfs-interface">
<h3>DebugFS interface<a class="headerlink" href="#debugfs-interface" title="Link to this heading">¶</a></h3>
<p>Some debugging information is exposed via debugfs:</p>
<ul class="simple">
<li><p>The file <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/kfence/stats</span></code> provides runtime statistics.</p></li>
<li><p>The file <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/kfence/objects</span></code> provides a list of objects
allocated via KFENCE, including those already freed but protected.</p></li>
</ul>
</section>
</section>
<section id="implementation-details">
<h2>Implementation Details<a class="headerlink" href="#implementation-details" title="Link to this heading">¶</a></h2>
<p>Guarded allocations are set up based on the sample interval. After expiration
of the sample interval, the next allocation through the main allocator (SLAB or
SLUB) returns a guarded allocation from the KFENCE object pool (allocation
sizes up to PAGE_SIZE are supported). At this point, the timer is reset, and
the next allocation is set up after the expiration of the interval.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">CONFIG_KFENCE_STATIC_KEYS=y</span></code>, KFENCE allocations are “gated”
through the main allocator’s fast-path by relying on static branches via the
static keys infrastructure. The static branch is toggled to redirect the
allocation to KFENCE. Depending on sample interval, target workloads, and
system architecture, this may perform better than the simple dynamic branch.
Careful benchmarking is recommended.</p>
<p>KFENCE objects each reside on a dedicated page, at either the left or right
page boundaries selected at random. The pages to the left and right of the
object page are “guard pages”, whose attributes are changed to a protected
state, and cause page faults on any attempted access. Such page faults are then
intercepted by KFENCE, which handles the fault gracefully by reporting an
out-of-bounds access, and marking the page as accessible so that the faulting
code can (wrongly) continue executing (set <code class="docutils literal notranslate"><span class="pre">panic_on_warn</span></code> to panic instead).</p>
<p>To detect out-of-bounds writes to memory within the object’s page itself,
KFENCE also uses pattern-based redzones. For each object page, a redzone is set
up for all non-object memory. For typical alignments, the redzone is only
required on the unguarded side of an object. Because KFENCE must honor the
cache’s requested alignment, special alignments may result in unprotected gaps
on either side of an object, all of which are redzoned.</p>
<p>The following figure illustrates the page layout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>---+-----------+-----------+-----------+-----------+-----------+---
   | xxxxxxxxx | O :       | xxxxxxxxx |       : O | xxxxxxxxx |
   | xxxxxxxxx | B :       | xxxxxxxxx |       : B | xxxxxxxxx |
   | x GUARD x | J : RED-  | x GUARD x | RED-  : J | x GUARD x |
   | xxxxxxxxx | E :  ZONE | xxxxxxxxx |  ZONE : E | xxxxxxxxx |
   | xxxxxxxxx | C :       | xxxxxxxxx |       : C | xxxxxxxxx |
   | xxxxxxxxx | T :       | xxxxxxxxx |       : T | xxxxxxxxx |
---+-----------+-----------+-----------+-----------+-----------+---
</pre></div>
</div>
<p>Upon deallocation of a KFENCE object, the object’s page is again protected and
the object is marked as freed. Any further access to the object causes a fault
and KFENCE reports a use-after-free access. Freed objects are inserted at the
tail of KFENCE’s freelist, so that the least recently freed objects are reused
first, and the chances of detecting use-after-frees of recently freed objects
is increased.</p>
<p>If pool utilization reaches 75% (default) or above, to reduce the risk of the
pool eventually being fully occupied by allocated objects yet ensure diverse
coverage of allocations, KFENCE limits currently covered allocations of the
same source from further filling up the pool. The “source” of an allocation is
based on its partial allocation stack trace. A side-effect is that this also
limits frequent long-lived allocations (e.g. pagecache) of the same source
filling up the pool permanently, which is the most common risk for the pool
becoming full and the sampled allocation rate dropping to zero. The threshold
at which to start limiting currently covered allocations can be configured via
the boot parameter <code class="docutils literal notranslate"><span class="pre">kfence.skip_covered_thresh</span></code> (pool usage%).</p>
</section>
<section id="interface">
<h2>Interface<a class="headerlink" href="#interface" title="Link to this heading">¶</a></h2>
<p>The following describes the functions which are used by allocators as well as
page handling code to set up and deal with KFENCE allocations.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.is_kfence_address">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_kfence_address</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.is_kfence_address" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if an address belongs to KFENCE pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>address to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true or false depending on whether the address is within the KFENCE
object range.</p>
<p><strong>Description</strong></p>
<p>KFENCE objects live in a separate page range and are not to be intermixed
with regular heap objects (e.g. KFENCE objects must never be added to the
allocator freelists). Failing to do so may and will result in heap
corruptions, therefore <a class="reference internal" href="#c.is_kfence_address" title="is_kfence_address"><code class="xref c c-func docutils literal notranslate"><span class="pre">is_kfence_address()</span></code></a> must be used to check whether
an object requires specific handling.</p>
<p><strong>Note</strong></p>
<p>This function may be used in fast-paths, and is performance critical.
Future changes should take this into account; for instance, we want to avoid
introducing another load and therefore need to keep KFENCE_POOL_SIZE a
constant (until immediate patching support is added to the kernel).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfence_shutdown_cache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfence_shutdown_cache</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_shutdown_cache" title="Link to this definition">¶</a><br /></dt>
<dd><p>handle shutdown_cache() for KFENCE objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*s</span></code></dt><dd><p>cache being shut down</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Before shutting down a cache, one must ensure there are no remaining objects
allocated from it. Because KFENCE objects are not referenced from the cache
directly, we need to check them here.</p>
<p>Note that shutdown_cache() is internal to SL*B, and kmem_cache_destroy() does
not return if allocated objects still exist: it prints an error message and
simply aborts destruction of a cache, leaking memory.</p>
<p>If the only such objects are KFENCE objects, we will not leak the entire
cache, but instead try to provide more useful debug info by making allocated
objects “zombie allocations”. Objects may then still be used or freed (which
is handled gracefully), but usage will result in showing KFENCE error reports
which include stack traces to the user of the object, the original allocation
site, and caller to shutdown_cache().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfence_alloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kfence_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kmem_cache</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a KFENCE object with a low probability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*s</span></code></dt><dd><p>struct kmem_cache with object requirements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>exact size of the object to allocate (can be less than <strong>s-&gt;size</strong>
e.g. for kmalloc caches)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>GFP flags</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>NULL     - must proceed with allocating as usual,</p></li>
<li><p>non-NULL - pointer to a KFENCE object.</p></li>
</ul>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.kfence_alloc" title="kfence_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfence_alloc()</span></code></a> should be inserted into the heap allocation fast path,
allowing it to transparently return KFENCE-allocated objects with a low
probability using a static branch (the probability is controlled by the
kfence.sample_interval boot parameter).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfence_ksize">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfence_ksize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_ksize" title="Link to this definition">¶</a><br /></dt>
<dd><p>get actual amount of memory allocated for a KFENCE object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>pointer to a heap object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0     - not a KFENCE object, must call __ksize() instead,</p></li>
<li><p>non-0 - this many bytes can be accessed without causing a memory error.</p></li>
</ul>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.kfence_ksize" title="kfence_ksize"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfence_ksize()</span></code></a> returns the number of bytes requested for a KFENCE object at
allocation time. This number may be less than the object size of the
corresponding struct kmem_cache.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfence_object_start">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kfence_object_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_object_start" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the beginning of a KFENCE object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>address within a KFENCE-allocated object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>address of the beginning of the object.</p>
<p><strong>Description</strong></p>
<p>SL[AU]B-allocated objects are laid out within a page one by one, so it is
easy to calculate the beginning of an object given a pointer inside it and
the object size. The same is not true for KFENCE, which places a single
object at either end of the page. This helper function is used to find the
beginning of a KFENCE-allocated object.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__kfence_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__kfence_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__kfence_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a KFENCE heap object to KFENCE pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>object to be freed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Requires: is_kfence_address(addr)</p>
<p>Release a KFENCE object and mark it as freed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfence_free">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfence_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to release an arbitrary heap object to KFENCE pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>object to be freed</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>false - object doesn’t belong to KFENCE pool and was ignored,</p></li>
<li><p>true  - object was released to KFENCE pool.</p></li>
</ul>
<p><strong>Description</strong></p>
<p>Release a KFENCE object and mark it as freed. May be called on any object,
even non-KFENCE objects, to simplify integration of the hooks into the
allocator’s free codepath. The allocator must check the return value to
determine if it was a KFENCE object or not.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfence_handle_page_fault">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfence_handle_page_fault</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">is_write</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_regs</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">regs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_handle_page_fault" title="Link to this definition">¶</a><br /></dt>
<dd><p>perform page fault handling for KFENCE pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>faulting address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_write</span></code></dt><dd><p>is access a write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_regs</span> <span class="pre">*regs</span></code></dt><dd><p>current struct pt_regs (can be NULL, but shows full stack trace)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>false - address outside KFENCE pool,</p></li>
<li><p>true  - page fault handled by KFENCE, no additional handling required.</p></li>
</ul>
<p><strong>Description</strong></p>
<p>A page fault inside KFENCE pool indicates a memory error, such as an
out-of-bounds access, a use-after-free or an invalid memory access. In these
cases KFENCE prints an error message and marks the offending page as
present, so that the kernel can proceed.</p>
</div>
</section>
<section id="related-tools">
<h2>Related Tools<a class="headerlink" href="#related-tools" title="Link to this heading">¶</a></h2>
<p>In userspace, a similar approach is taken by <a class="reference external" href="http://llvm.org/docs/GwpAsan.html">GWP-ASan</a>. GWP-ASan also relies on guard pages and
a sampling strategy to detect memory unsafety bugs at scale. KFENCE’s design is
directly influenced by GWP-ASan, and can be seen as its kernel sibling. Another
similar but non-sampling approach, that also inspired the name “KFENCE”, can be
found in the userspace <a class="reference external" href="https://linux.die.net/man/3/efence">Electric Fence Malloc Debugger</a>.</p>
<p>In the kernel, several tools exist to debug memory access errors, and in
particular KASAN can detect all bug classes that KFENCE can detect. While KASAN
is more precise, relying on compiler instrumentation, this comes at a
performance cost.</p>
<p>It is worth highlighting that KASAN and KFENCE are complementary, with
different target environments. For instance, KASAN is the better debugging-aid,
where test cases or reproducers exists: due to the lower chance to detect the
error, it would require more effort using KFENCE to debug. Deployments at scale
that cannot afford to enable KASAN, however, would benefit from using KFENCE to
discover bugs due to code paths not exercised by test cases or fuzzers.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/dev-tools/kfence.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>