<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PARPORT interface documentation &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Generic PHY Framework" href="phy/index.html" />
    <link rel="prev" title="NVMEM Subsystem" href="nvmem.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.13.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/parport-lowlevel.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="parport-interface-documentation">
<h1>PARPORT interface documentation<a class="headerlink" href="#parport-interface-documentation" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Time-stamp<span class="colon">:</span></dt>
<dd class="field-odd"><p>&lt;2000-02-24 13:30:20 twaugh&gt;</p>
</dd>
</dl>
<p>Described here are the following functions:</p>
<dl class="simple">
<dt>Global functions::</dt><dd><p>parport_register_driver
parport_unregister_driver
parport_enumerate
parport_register_device
parport_unregister_device
parport_claim
parport_claim_or_block
parport_release
parport_yield
parport_yield_blocking
parport_wait_peripheral
parport_poll_peripheral
parport_wait_event
parport_negotiate
parport_read
parport_write
parport_open
parport_close
parport_device_id
parport_device_coords
parport_find_class
parport_find_device
parport_set_timeout</p>
</dd>
</dl>
<p>Port functions (can be overridden by low-level drivers):</p>
<blockquote>
<div><dl class="simple">
<dt>SPP::</dt><dd><p>port-&gt;ops-&gt;read_data
port-&gt;ops-&gt;write_data
port-&gt;ops-&gt;read_status
port-&gt;ops-&gt;read_control
port-&gt;ops-&gt;write_control
port-&gt;ops-&gt;frob_control
port-&gt;ops-&gt;enable_irq
port-&gt;ops-&gt;disable_irq
port-&gt;ops-&gt;data_forward
port-&gt;ops-&gt;data_reverse</p>
</dd>
<dt>EPP::</dt><dd><p>port-&gt;ops-&gt;epp_write_data
port-&gt;ops-&gt;epp_read_data
port-&gt;ops-&gt;epp_write_addr
port-&gt;ops-&gt;epp_read_addr</p>
</dd>
<dt>ECP::</dt><dd><p>port-&gt;ops-&gt;ecp_write_data
port-&gt;ops-&gt;ecp_read_data
port-&gt;ops-&gt;ecp_write_addr</p>
</dd>
<dt>Other::</dt><dd><p>port-&gt;ops-&gt;nibble_read_data
port-&gt;ops-&gt;byte_read_data
port-&gt;ops-&gt;compat_write_data</p>
</dd>
</dl>
</div></blockquote>
<p>The parport subsystem comprises <code class="docutils literal notranslate"><span class="pre">parport</span></code> (the core port-sharing
code), and a variety of low-level drivers that actually do the port
accesses.  Each low-level driver handles a particular style of port
(PC, Amiga, and so on).</p>
<p>The parport interface to the device driver author can be broken down
into global functions and port functions.</p>
<p>The global functions are mostly for communicating between the device
driver and the parport subsystem: acquiring a list of available ports,
claiming a port for exclusive use, and so on.  They also include
<code class="docutils literal notranslate"><span class="pre">generic</span></code> functions for doing standard things that will work on any
IEEE 1284-capable architecture.</p>
<p>The port functions are provided by the low-level drivers, although the
core parport module provides generic <code class="docutils literal notranslate"><span class="pre">defaults</span></code> for some routines.
The port functions can be split into three groups: SPP, EPP, and ECP.</p>
<p>SPP (Standard Parallel Port) functions modify so-called <code class="docutils literal notranslate"><span class="pre">SPP</span></code>
registers: data, status, and control.  The hardware may not actually
have registers exactly like that, but the PC does and this interface is
modelled after common PC implementations.  Other low-level drivers may
be able to emulate most of the functionality.</p>
<p>EPP (Enhanced Parallel Port) functions are provided for reading and
writing in IEEE 1284 EPP mode, and ECP (Extended Capabilities Port)
functions are used for IEEE 1284 ECP mode. (What about BECP? Does
anyone care?)</p>
<p>Hardware assistance for EPP and/or ECP transfers may or may not be
available, and if it is available it may or may not be used.  If
hardware is not used, the transfer will be software-driven.  In order
to cope with peripherals that only tenuously support IEEE 1284, a
low-level driver specific function is provided, for altering ‘fudge
factors’.</p>
<section id="global-functions">
<h2>Global functions<a class="headerlink" href="#global-functions" title="Link to this heading">¶</a></h2>
<section id="parport-register-driver-register-a-device-driver-with-parport">
<h3>parport_register_driver - register a device driver with parport<a class="headerlink" href="#parport-register-driver-register-a-device-driver-with-parport" title="Link to this heading">¶</a></h3>
<section id="synopsis">
<h4>SYNOPSIS<a class="headerlink" href="#synopsis" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_driver {
        const char *name;
        void (*attach) (struct parport *);
        void (*detach) (struct parport *);
        struct parport_driver *next;
};
int parport_register_driver (struct parport_driver *driver);
</pre></div>
</div>
</section>
<section id="description">
<h4>DESCRIPTION<a class="headerlink" href="#description" title="Link to this heading">¶</a></h4>
<p>In order to be notified about parallel ports when they are detected,
parport_register_driver should be called.  Your driver will
immediately be notified of all ports that have already been detected,
and of each new port as low-level drivers are loaded.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_driver</span></code> contains the textual name of your driver,
a pointer to a function to handle new ports, and a pointer to a
function to handle ports going away due to a low-level driver
unloading.  Ports will only be detached if they are not being used
(i.e. there are no devices registered on them).</p>
<p>The visible parts of the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span></code> argument given to
attach/detach are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct parport
{
        struct parport *next; /* next parport in list */
        const char *name;     /* port&#39;s name */
        unsigned int modes;   /* bitfield of hardware modes */
        struct parport_device_info probe_info;
                        /* IEEE1284 info */
        int number;           /* parport index */
        struct parport_operations *ops;
        ...
};
</pre></div>
</div>
<p>There are other members of the structure, but they should not be
touched.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">modes</span></code> member summarises the capabilities of the underlying
hardware.  It consists of flags which may be bitwise-ored together:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>PARPORT_MODE_PCSPP</p></td>
<td><p>IBM PC registers are available,
i.e. functions that act on data,
control and status registers are
probably writing directly to the
hardware.</p></td>
</tr>
<tr class="row-even"><td><p>PARPORT_MODE_TRISTATE</p></td>
<td><p>The data drivers may be turned off.
This allows the data lines to be used
for reverse (peripheral to host)
transfers.</p></td>
</tr>
<tr class="row-odd"><td><p>PARPORT_MODE_COMPAT</p></td>
<td><p>The hardware can assist with
compatibility-mode (printer)
transfers, i.e. compat_write_block.</p></td>
</tr>
<tr class="row-even"><td><p>PARPORT_MODE_EPP</p></td>
<td><p>The hardware can assist with EPP
transfers.</p></td>
</tr>
<tr class="row-odd"><td><p>PARPORT_MODE_ECP</p></td>
<td><p>The hardware can assist with ECP
transfers.</p></td>
</tr>
<tr class="row-even"><td><p>PARPORT_MODE_DMA</p></td>
<td><p>The hardware can use DMA, so you might
want to pass ISA DMA-able memory
(i.e. memory allocated using the
GFP_DMA flag with kmalloc) to the
low-level driver in order to take
advantage of it.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>There may be other flags in <code class="docutils literal notranslate"><span class="pre">modes</span></code> as well.</p>
<p>The contents of <code class="docutils literal notranslate"><span class="pre">modes</span></code> is advisory only.  For example, if the
hardware is capable of DMA, and PARPORT_MODE_DMA is in <code class="docutils literal notranslate"><span class="pre">modes</span></code>, it
doesn’t necessarily mean that DMA will always be used when possible.
Similarly, hardware that is capable of assisting ECP transfers won’t
necessarily be used.</p>
</section>
<section id="return-value">
<h4>RETURN VALUE<a class="headerlink" href="#return-value" title="Link to this heading">¶</a></h4>
<p>Zero on success, otherwise an error code.</p>
</section>
<section id="errors">
<h4>ERRORS<a class="headerlink" href="#errors" title="Link to this heading">¶</a></h4>
<p>None. (Can it fail? Why return int?)</p>
</section>
<section id="example">
<h4>EXAMPLE<a class="headerlink" href="#example" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void lp_attach (struct parport *port)
{
        ...
        private = kmalloc (...);
        dev[count++] = parport_register_device (...);
        ...
}

static void lp_detach (struct parport *port)
{
        ...
}

static struct parport_driver lp_driver = {
        &quot;lp&quot;,
        lp_attach,
        lp_detach,
        NULL /* always put NULL here */
};

int lp_init (void)
{
        ...
        if (parport_register_driver (&amp;lp_driver)) {
                /* Failed; nothing we can do. */
                return -EIO;
        }
        ...
}
</pre></div>
</div>
</section>
<section id="see-also">
<h4>SEE ALSO<a class="headerlink" href="#see-also" title="Link to this heading">¶</a></h4>
<p>parport_unregister_driver, parport_register_device, parport_enumerate</p>
</section>
</section>
<section id="parport-unregister-driver-tell-parport-to-forget-about-this-driver">
<h3>parport_unregister_driver - tell parport to forget about this driver<a class="headerlink" href="#parport-unregister-driver-tell-parport-to-forget-about-this-driver" title="Link to this heading">¶</a></h3>
<section id="id1">
<h4>SYNOPSIS<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_driver {
        const char *name;
        void (*attach) (struct parport *);
        void (*detach) (struct parport *);
        struct parport_driver *next;
};
void parport_unregister_driver (struct parport_driver *driver);
</pre></div>
</div>
</section>
<section id="id2">
<h4>DESCRIPTION<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<p>This tells parport not to notify the device driver of new ports or of
ports going away.  Registered devices belonging to that driver are NOT
unregistered: parport_unregister_device must be used for each one.</p>
</section>
<section id="id3">
<h4>EXAMPLE<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void cleanup_module (void)
{
        ...
        /* Stop notifications. */
        parport_unregister_driver (&amp;lp_driver);

        /* Unregister devices. */
        for (i = 0; i &lt; NUM_DEVS; i++)
                parport_unregister_device (dev[i]);
        ...
}
</pre></div>
</div>
</section>
<section id="id4">
<h4>SEE ALSO<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h4>
<p>parport_register_driver, parport_enumerate</p>
</section>
</section>
<section id="parport-enumerate-retrieve-a-list-of-parallel-ports-deprecated">
<h3>parport_enumerate - retrieve a list of parallel ports (DEPRECATED)<a class="headerlink" href="#parport-enumerate-retrieve-a-list-of-parallel-ports-deprecated" title="Link to this heading">¶</a></h3>
<section id="id5">
<h4>SYNOPSIS<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport *parport_enumerate (void);
</pre></div>
</div>
</section>
<section id="id6">
<h4>DESCRIPTION<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h4>
<p>Retrieve the first of a list of valid parallel ports for this machine.
Successive parallel ports can be found using the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span>
<span class="pre">*next</span></code> element of the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span></code> that is returned.  If <code class="docutils literal notranslate"><span class="pre">next</span></code>
is NULL, there are no more parallel ports in the list.  The number of
ports in the list will not exceed PARPORT_MAX.</p>
</section>
<section id="id7">
<h4>RETURN VALUE<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*</span></code> describing a valid parallel port for the machine,
or NULL if there are none.</p>
</section>
<section id="id8">
<h4>ERRORS<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h4>
<p>This function can return NULL to indicate that there are no parallel
ports to use.</p>
</section>
<section id="id9">
<h4>EXAMPLE<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int detect_device (void)
{
        struct parport *port;

        for (port = parport_enumerate ();
        port != NULL;
        port = port-&gt;next) {
                /* Try to detect a device on the port... */
                ...
        }
        }

        ...
}
</pre></div>
</div>
</section>
<section id="notes">
<h4>NOTES<a class="headerlink" href="#notes" title="Link to this heading">¶</a></h4>
<p>parport_enumerate is deprecated; parport_register_driver should be
used instead.</p>
</section>
<section id="id10">
<h4>SEE ALSO<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h4>
<p>parport_register_driver, parport_unregister_driver</p>
</section>
</section>
<section id="parport-register-device-register-to-use-a-port">
<h3>parport_register_device - register to use a port<a class="headerlink" href="#parport-register-device-register-to-use-a-port" title="Link to this heading">¶</a></h3>
<section id="id11">
<h4>SYNOPSIS<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

typedef int (*preempt_func) (void *handle);
typedef void (*wakeup_func) (void *handle);
typedef int (*irq_func) (int irq, void *handle, struct pt_regs *);

struct pardevice *parport_register_device(struct parport *port,
                                          const char *name,
                                          preempt_func preempt,
                                          wakeup_func wakeup,
                                          irq_func irq,
                                          int flags,
                                          void *handle);
</pre></div>
</div>
</section>
<section id="id12">
<h4>DESCRIPTION<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h4>
<p>Use this function to register your device driver on a parallel port
(<code class="docutils literal notranslate"><span class="pre">port</span></code>).  Once you have done that, you will be able to use
parport_claim and parport_release in order to use the port.</p>
<p>The (<code class="docutils literal notranslate"><span class="pre">name</span></code>) argument is the name of the device that appears in /proc
filesystem. The string must be valid for the whole lifetime of the
device (until parport_unregister_device is called).</p>
<p>This function will register three callbacks into your driver:
<code class="docutils literal notranslate"><span class="pre">preempt</span></code>, <code class="docutils literal notranslate"><span class="pre">wakeup</span></code> and <code class="docutils literal notranslate"><span class="pre">irq</span></code>.  Each of these may be NULL in order to
indicate that you do not want a callback.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">preempt</span></code> function is called, it is because another driver
wishes to use the parallel port.  The <code class="docutils literal notranslate"><span class="pre">preempt</span></code> function should return
non-zero if the parallel port cannot be released yet -- if zero is
returned, the port is lost to another driver and the port must be
re-claimed before use.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">wakeup</span></code> function is called once another driver has released the
port and no other driver has yet claimed it.  You can claim the
parallel port from within the <code class="docutils literal notranslate"><span class="pre">wakeup</span></code> function (in which case the
claim is guaranteed to succeed), or choose not to if you don’t need it
now.</p>
<p>If an interrupt occurs on the parallel port your driver has claimed,
the <code class="docutils literal notranslate"><span class="pre">irq</span></code> function will be called. (Write something about shared
interrupts here.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">handle</span></code> is a pointer to driver-specific data, and is passed to
the callback functions.</p>
<p><code class="docutils literal notranslate"><span class="pre">flags</span></code> may be a bitwise combination of the following flags:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Flag</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PARPORT_DEV_EXCL</p></td>
<td><p>The device cannot share the parallel port at all.
Use this only when absolutely necessary.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The typedefs are not actually defined -- they are only shown in order
to make the function prototype more readable.</p>
<p>The visible parts of the returned <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span></code> are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pardevice {
        struct parport *port;   /* Associated port */
        void *private;          /* Device driver&#39;s &#39;handle&#39; */
        ...
};
</pre></div>
</div>
</section>
<section id="id13">
<h4>RETURN VALUE<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*</span></code>: a handle to the registered parallel port
device that can be used for parport_claim, parport_release, etc.</p>
</section>
<section id="id14">
<h4>ERRORS<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h4>
<p>A return value of NULL indicates that there was a problem registering
a device on that port.</p>
</section>
<section id="id15">
<h4>EXAMPLE<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int preempt (void *handle)
{
        if (busy_right_now)
                return 1;

        must_reclaim_port = 1;
        return 0;
}

static void wakeup (void *handle)
{
        struct toaster *private = handle;
        struct pardevice *dev = private-&gt;dev;
        if (!dev) return; /* avoid races */

        if (want_port)
                parport_claim (dev);
}

static int toaster_detect (struct toaster *private, struct parport *port)
{
        private-&gt;dev = parport_register_device (port, &quot;toaster&quot;, preempt,
                                                wakeup, NULL, 0,
                                                private);
        if (!private-&gt;dev)
                /* Couldn&#39;t register with parport. */
                return -EIO;

        must_reclaim_port = 0;
        busy_right_now = 1;
        parport_claim_or_block (private-&gt;dev);
        ...
        /* Don&#39;t need the port while the toaster warms up. */
        busy_right_now = 0;
        ...
        busy_right_now = 1;
        if (must_reclaim_port) {
                parport_claim_or_block (private-&gt;dev);
                must_reclaim_port = 0;
        }
        ...
}
</pre></div>
</div>
</section>
<section id="id16">
<h4>SEE ALSO<a class="headerlink" href="#id16" title="Link to this heading">¶</a></h4>
<p>parport_unregister_device, parport_claim</p>
</section>
</section>
<section id="parport-unregister-device-finish-using-a-port">
<h3>parport_unregister_device - finish using a port<a class="headerlink" href="#parport-unregister-device-finish-using-a-port" title="Link to this heading">¶</a></h3>
<p>SYNPOPSIS</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

void parport_unregister_device (struct pardevice *dev);
</pre></div>
</div>
<section id="id17">
<h4>DESCRIPTION<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h4>
<p>This function is the opposite of parport_register_device.  After using
parport_unregister_device, <code class="docutils literal notranslate"><span class="pre">dev</span></code> is no longer a valid device handle.</p>
<p>You should not unregister a device that is currently claimed, although
if you do it will be released automatically.</p>
</section>
<section id="id18">
<h4>EXAMPLE<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>...
kfree (dev-&gt;private); /* before we lose the pointer */
parport_unregister_device (dev);
...
</pre></div>
</div>
</section>
<section id="id19">
<h4>SEE ALSO<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h4>
<p>parport_unregister_driver</p>
</section>
</section>
<section id="parport-claim-parport-claim-or-block-claim-the-parallel-port-for-a-device">
<h3>parport_claim, parport_claim_or_block - claim the parallel port for a device<a class="headerlink" href="#parport-claim-parport-claim-or-block-claim-the-parallel-port-for-a-device" title="Link to this heading">¶</a></h3>
<section id="id20">
<h4>SYNOPSIS<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

int parport_claim (struct pardevice *dev);
int parport_claim_or_block (struct pardevice *dev);
</pre></div>
</div>
</section>
<section id="id21">
<h4>DESCRIPTION<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h4>
<p>These functions attempt to gain control of the parallel port on which
<code class="docutils literal notranslate"><span class="pre">dev</span></code> is registered.  <code class="docutils literal notranslate"><span class="pre">parport_claim</span></code> does not block, but
<code class="docutils literal notranslate"><span class="pre">parport_claim_or_block</span></code> may do. (Put something here about blocking
interruptibly or non-interruptibly.)</p>
<p>You should not try to claim a port that you have already claimed.</p>
</section>
<section id="id22">
<h4>RETURN VALUE<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h4>
<p>A return value of zero indicates that the port was successfully
claimed, and the caller now has possession of the parallel port.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">parport_claim_or_block</span></code> blocks before returning successfully, the
return value is positive.</p>
</section>
<section id="id23">
<h4>ERRORS<a class="headerlink" href="#id23" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>-EAGAIN</p></td>
<td><p>The port is unavailable at the moment, but another attempt
to claim it may succeed.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id24">
<h4>SEE ALSO<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h4>
<p>parport_release</p>
</section>
</section>
<section id="parport-release-release-the-parallel-port">
<h3>parport_release - release the parallel port<a class="headerlink" href="#parport-release-release-the-parallel-port" title="Link to this heading">¶</a></h3>
<section id="id25">
<h4>SYNOPSIS<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

void parport_release (struct pardevice *dev);
</pre></div>
</div>
</section>
<section id="id26">
<h4>DESCRIPTION<a class="headerlink" href="#id26" title="Link to this heading">¶</a></h4>
<p>Once a parallel port device has been claimed, it can be released using
<code class="docutils literal notranslate"><span class="pre">parport_release</span></code>.  It cannot fail, but you should not release a
device that you do not have possession of.</p>
</section>
<section id="id27">
<h4>EXAMPLE<a class="headerlink" href="#id27" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static size_t write (struct pardevice *dev, const void *buf,
                size_t len)
{
        ...
        written = dev-&gt;port-&gt;ops-&gt;write_ecp_data (dev-&gt;port, buf,
                                                len);
        parport_release (dev);
        ...
}
</pre></div>
</div>
</section>
<section id="id28">
<h4>SEE ALSO<a class="headerlink" href="#id28" title="Link to this heading">¶</a></h4>
<p>change_mode, parport_claim, parport_claim_or_block, parport_yield</p>
</section>
</section>
<section id="parport-yield-parport-yield-blocking-temporarily-release-a-parallel-port">
<h3>parport_yield, parport_yield_blocking - temporarily release a parallel port<a class="headerlink" href="#parport-yield-parport-yield-blocking-temporarily-release-a-parallel-port" title="Link to this heading">¶</a></h3>
<section id="id29">
<h4>SYNOPSIS<a class="headerlink" href="#id29" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

int parport_yield (struct pardevice *dev)
int parport_yield_blocking (struct pardevice *dev);
</pre></div>
</div>
</section>
<section id="id30">
<h4>DESCRIPTION<a class="headerlink" href="#id30" title="Link to this heading">¶</a></h4>
<p>When a driver has control of a parallel port, it may allow another
driver to temporarily <code class="docutils literal notranslate"><span class="pre">borrow</span></code> it.  <code class="docutils literal notranslate"><span class="pre">parport_yield</span></code> does not block;
<code class="docutils literal notranslate"><span class="pre">parport_yield_blocking</span></code> may do.</p>
</section>
<section id="id31">
<h4>RETURN VALUE<a class="headerlink" href="#id31" title="Link to this heading">¶</a></h4>
<p>A return value of zero indicates that the caller still owns the port
and the call did not block.</p>
<p>A positive return value from <code class="docutils literal notranslate"><span class="pre">parport_yield_blocking</span></code> indicates that
the caller still owns the port and the call blocked.</p>
<p>A return value of -EAGAIN indicates that the caller no longer owns the
port, and it must be re-claimed before use.</p>
</section>
<section id="id32">
<h4>ERRORS<a class="headerlink" href="#id32" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>-EAGAIN</p></td>
<td><p>Ownership of the parallel port was given away.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id33">
<h4>SEE ALSO<a class="headerlink" href="#id33" title="Link to this heading">¶</a></h4>
<p>parport_release</p>
</section>
</section>
<section id="parport-wait-peripheral-wait-for-status-lines-up-to-35ms">
<h3>parport_wait_peripheral - wait for status lines, up to 35ms<a class="headerlink" href="#parport-wait-peripheral-wait-for-status-lines-up-to-35ms" title="Link to this heading">¶</a></h3>
<section id="id34">
<h4>SYNOPSIS<a class="headerlink" href="#id34" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

int parport_wait_peripheral (struct parport *port,
                             unsigned char mask,
                             unsigned char val);
</pre></div>
</div>
</section>
<section id="id35">
<h4>DESCRIPTION<a class="headerlink" href="#id35" title="Link to this heading">¶</a></h4>
<p>Wait for the status lines in mask to match the values in val.</p>
</section>
<section id="id36">
<h4>RETURN VALUE<a class="headerlink" href="#id36" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>-EINTR</p></td>
<td><p>a signal is pending</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>the status lines in mask have values in val</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>timed out while waiting (35ms elapsed)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id37">
<h4>SEE ALSO<a class="headerlink" href="#id37" title="Link to this heading">¶</a></h4>
<p>parport_poll_peripheral</p>
</section>
</section>
<section id="parport-poll-peripheral-wait-for-status-lines-in-usec">
<h3>parport_poll_peripheral - wait for status lines, in usec<a class="headerlink" href="#parport-poll-peripheral-wait-for-status-lines-in-usec" title="Link to this heading">¶</a></h3>
<section id="id38">
<h4>SYNOPSIS<a class="headerlink" href="#id38" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

int parport_poll_peripheral (struct parport *port,
                             unsigned char mask,
                             unsigned char val,
                             int usec);
</pre></div>
</div>
</section>
<section id="id39">
<h4>DESCRIPTION<a class="headerlink" href="#id39" title="Link to this heading">¶</a></h4>
<p>Wait for the status lines in mask to match the values in val.</p>
</section>
<section id="id40">
<h4>RETURN VALUE<a class="headerlink" href="#id40" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>-EINTR</p></td>
<td><p>a signal is pending</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>the status lines in mask have values in val</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>timed out while waiting (usec microseconds have elapsed)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id41">
<h4>SEE ALSO<a class="headerlink" href="#id41" title="Link to this heading">¶</a></h4>
<p>parport_wait_peripheral</p>
</section>
</section>
<section id="parport-wait-event-wait-for-an-event-on-a-port">
<h3>parport_wait_event - wait for an event on a port<a class="headerlink" href="#parport-wait-event-wait-for-an-event-on-a-port" title="Link to this heading">¶</a></h3>
<section id="id42">
<h4>SYNOPSIS<a class="headerlink" href="#id42" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

int parport_wait_event (struct parport *port, signed long timeout)
</pre></div>
</div>
</section>
<section id="id43">
<h4>DESCRIPTION<a class="headerlink" href="#id43" title="Link to this heading">¶</a></h4>
<p>Wait for an event (e.g. interrupt) on a port.  The timeout is in
jiffies.</p>
</section>
<section id="id44">
<h4>RETURN VALUE<a class="headerlink" href="#id44" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>success</p></td>
</tr>
<tr class="row-even"><td><p>&lt;0</p></td>
<td><p>error (exit as soon as possible)</p></td>
</tr>
<tr class="row-odd"><td><p>&gt;0</p></td>
<td><p>timed out</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="parport-negotiate-perform-ieee-1284-negotiation">
<h3>parport_negotiate - perform IEEE 1284 negotiation<a class="headerlink" href="#parport-negotiate-perform-ieee-1284-negotiation" title="Link to this heading">¶</a></h3>
<section id="id45">
<h4>SYNOPSIS<a class="headerlink" href="#id45" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

int parport_negotiate (struct parport *, int mode);
</pre></div>
</div>
</section>
<section id="id46">
<h4>DESCRIPTION<a class="headerlink" href="#id46" title="Link to this heading">¶</a></h4>
<p>Perform IEEE 1284 negotiation.</p>
</section>
<section id="id47">
<h4>RETURN VALUE<a class="headerlink" href="#id47" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>handshake OK; IEEE 1284 peripheral and mode available</p></td>
</tr>
<tr class="row-even"><td><p>-1</p></td>
<td><p>handshake failed; peripheral not compliant (or none present)</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>handshake OK; IEEE 1284 peripheral present but mode not
available</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id48">
<h4>SEE ALSO<a class="headerlink" href="#id48" title="Link to this heading">¶</a></h4>
<p>parport_read, parport_write</p>
</section>
</section>
<section id="parport-read-read-data-from-device">
<h3>parport_read - read data from device<a class="headerlink" href="#parport-read-read-data-from-device" title="Link to this heading">¶</a></h3>
<section id="id49">
<h4>SYNOPSIS<a class="headerlink" href="#id49" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

ssize_t parport_read (struct parport *, void *buf, size_t len);
</pre></div>
</div>
</section>
<section id="id50">
<h4>DESCRIPTION<a class="headerlink" href="#id50" title="Link to this heading">¶</a></h4>
<p>Read data from device in current IEEE 1284 transfer mode.  This only
works for modes that support reverse data transfer.</p>
</section>
<section id="id51">
<h4>RETURN VALUE<a class="headerlink" href="#id51" title="Link to this heading">¶</a></h4>
<p>If negative, an error code; otherwise the number of bytes transferred.</p>
</section>
<section id="id52">
<h4>SEE ALSO<a class="headerlink" href="#id52" title="Link to this heading">¶</a></h4>
<p>parport_write, parport_negotiate</p>
</section>
</section>
<section id="parport-write-write-data-to-device">
<h3>parport_write - write data to device<a class="headerlink" href="#parport-write-write-data-to-device" title="Link to this heading">¶</a></h3>
<section id="id53">
<h4>SYNOPSIS<a class="headerlink" href="#id53" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

ssize_t parport_write (struct parport *, const void *buf, size_t len);
</pre></div>
</div>
</section>
<section id="id54">
<h4>DESCRIPTION<a class="headerlink" href="#id54" title="Link to this heading">¶</a></h4>
<p>Write data to device in current IEEE 1284 transfer mode.  This only
works for modes that support forward data transfer.</p>
</section>
<section id="id55">
<h4>RETURN VALUE<a class="headerlink" href="#id55" title="Link to this heading">¶</a></h4>
<p>If negative, an error code; otherwise the number of bytes transferred.</p>
</section>
<section id="id56">
<h4>SEE ALSO<a class="headerlink" href="#id56" title="Link to this heading">¶</a></h4>
<p>parport_read, parport_negotiate</p>
</section>
</section>
<section id="parport-open-register-device-for-particular-device-number">
<h3>parport_open - register device for particular device number<a class="headerlink" href="#parport-open-register-device-for-particular-device-number" title="Link to this heading">¶</a></h3>
<section id="id57">
<h4>SYNOPSIS<a class="headerlink" href="#id57" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct pardevice *parport_open (int devnum, const char *name,
                                int (*pf) (void *),
                                void (*kf) (void *),
                                void (*irqf) (int, void *,
                                              struct pt_regs *),
                                int flags, void *handle);
</pre></div>
</div>
</section>
<section id="id58">
<h4>DESCRIPTION<a class="headerlink" href="#id58" title="Link to this heading">¶</a></h4>
<p>This is like parport_register_device but takes a device number instead
of a pointer to a struct parport.</p>
</section>
<section id="id59">
<h4>RETURN VALUE<a class="headerlink" href="#id59" title="Link to this heading">¶</a></h4>
<p>See parport_register_device.  If no device is associated with devnum,
NULL is returned.</p>
</section>
<section id="id60">
<h4>SEE ALSO<a class="headerlink" href="#id60" title="Link to this heading">¶</a></h4>
<p>parport_register_device</p>
</section>
</section>
<section id="parport-close-unregister-device-for-particular-device-number">
<h3>parport_close - unregister device for particular device number<a class="headerlink" href="#parport-close-unregister-device-for-particular-device-number" title="Link to this heading">¶</a></h3>
<section id="id61">
<h4>SYNOPSIS<a class="headerlink" href="#id61" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

void parport_close (struct pardevice *dev);
</pre></div>
</div>
</section>
<section id="id62">
<h4>DESCRIPTION<a class="headerlink" href="#id62" title="Link to this heading">¶</a></h4>
<p>This is the equivalent of parport_unregister_device for parport_open.</p>
</section>
<section id="id63">
<h4>SEE ALSO<a class="headerlink" href="#id63" title="Link to this heading">¶</a></h4>
<p>parport_unregister_device, parport_open</p>
</section>
</section>
<section id="parport-device-id-obtain-ieee-1284-device-id">
<h3>parport_device_id - obtain IEEE 1284 Device ID<a class="headerlink" href="#parport-device-id-obtain-ieee-1284-device-id" title="Link to this heading">¶</a></h3>
<section id="id64">
<h4>SYNOPSIS<a class="headerlink" href="#id64" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

ssize_t parport_device_id (int devnum, char *buffer, size_t len);
</pre></div>
</div>
</section>
<section id="id65">
<h4>DESCRIPTION<a class="headerlink" href="#id65" title="Link to this heading">¶</a></h4>
<p>Obtains the IEEE 1284 Device ID associated with a given device.</p>
</section>
<section id="id66">
<h4>RETURN VALUE<a class="headerlink" href="#id66" title="Link to this heading">¶</a></h4>
<p>If negative, an error code; otherwise, the number of bytes of buffer
that contain the device ID.  The format of the device ID is as
follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[length][ID]
</pre></div>
</div>
<p>The first two bytes indicate the inclusive length of the entire Device
ID, and are in big-endian order.  The ID is a sequence of pairs of the
form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>key:value;
</pre></div>
</div>
</section>
<section id="id67">
<h4>NOTES<a class="headerlink" href="#id67" title="Link to this heading">¶</a></h4>
<p>Many devices have ill-formed IEEE 1284 Device IDs.</p>
</section>
<section id="id68">
<h4>SEE ALSO<a class="headerlink" href="#id68" title="Link to this heading">¶</a></h4>
<p>parport_find_class, parport_find_device</p>
</section>
</section>
<section id="parport-device-coords-convert-device-number-to-device-coordinates">
<h3>parport_device_coords - convert device number to device coordinates<a class="headerlink" href="#parport-device-coords-convert-device-number-to-device-coordinates" title="Link to this heading">¶</a></h3>
<section id="id69">
<h4>SYNOPSIS<a class="headerlink" href="#id69" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

int parport_device_coords (int devnum, int *parport, int *mux,
                           int *daisy);
</pre></div>
</div>
</section>
<section id="id70">
<h4>DESCRIPTION<a class="headerlink" href="#id70" title="Link to this heading">¶</a></h4>
<p>Convert between device number (zero-based) and device coordinates
(port, multiplexor, daisy chain address).</p>
</section>
<section id="id71">
<h4>RETURN VALUE<a class="headerlink" href="#id71" title="Link to this heading">¶</a></h4>
<p>Zero on success, in which case the coordinates are (<code class="docutils literal notranslate"><span class="pre">*parport</span></code>, <code class="docutils literal notranslate"><span class="pre">*mux</span></code>,
<code class="docutils literal notranslate"><span class="pre">*daisy</span></code>).</p>
</section>
<section id="id72">
<h4>SEE ALSO<a class="headerlink" href="#id72" title="Link to this heading">¶</a></h4>
<p>parport_open, parport_device_id</p>
</section>
</section>
<section id="parport-find-class-find-a-device-by-its-class">
<h3>parport_find_class - find a device by its class<a class="headerlink" href="#parport-find-class-find-a-device-by-its-class" title="Link to this heading">¶</a></h3>
<section id="id73">
<h4>SYNOPSIS<a class="headerlink" href="#id73" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

typedef enum {
        PARPORT_CLASS_LEGACY = 0,       /* Non-IEEE1284 device */
        PARPORT_CLASS_PRINTER,
        PARPORT_CLASS_MODEM,
        PARPORT_CLASS_NET,
        PARPORT_CLASS_HDC,              /* Hard disk controller */
        PARPORT_CLASS_PCMCIA,
        PARPORT_CLASS_MEDIA,            /* Multimedia device */
        PARPORT_CLASS_FDC,              /* Floppy disk controller */
        PARPORT_CLASS_PORTS,
        PARPORT_CLASS_SCANNER,
        PARPORT_CLASS_DIGCAM,
        PARPORT_CLASS_OTHER,            /* Anything else */
        PARPORT_CLASS_UNSPEC,           /* No CLS field in ID */
        PARPORT_CLASS_SCSIADAPTER
} parport_device_class;

int parport_find_class (parport_device_class cls, int from);
</pre></div>
</div>
</section>
<section id="id74">
<h4>DESCRIPTION<a class="headerlink" href="#id74" title="Link to this heading">¶</a></h4>
<p>Find a device by class.  The search starts from device number from+1.</p>
</section>
<section id="id75">
<h4>RETURN VALUE<a class="headerlink" href="#id75" title="Link to this heading">¶</a></h4>
<p>The device number of the next device in that class, or -1 if no such
device exists.</p>
</section>
<section id="id76">
<h4>NOTES<a class="headerlink" href="#id76" title="Link to this heading">¶</a></h4>
<p>Example usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int devnum = -1;
while ((devnum = parport_find_class (PARPORT_CLASS_DIGCAM, devnum)) != -1) {
        struct pardevice *dev = parport_open (devnum, ...);
        ...
}
</pre></div>
</div>
</section>
<section id="id77">
<h4>SEE ALSO<a class="headerlink" href="#id77" title="Link to this heading">¶</a></h4>
<p>parport_find_device, parport_open, parport_device_id</p>
</section>
</section>
<section id="parport-find-device-find-a-device-by-its-class">
<h3>parport_find_device - find a device by its class<a class="headerlink" href="#parport-find-device-find-a-device-by-its-class" title="Link to this heading">¶</a></h3>
<section id="id78">
<h4>SYNOPSIS<a class="headerlink" href="#id78" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

int parport_find_device (const char *mfg, const char *mdl, int from);
</pre></div>
</div>
</section>
<section id="id79">
<h4>DESCRIPTION<a class="headerlink" href="#id79" title="Link to this heading">¶</a></h4>
<p>Find a device by vendor and model.  The search starts from device
number from+1.</p>
</section>
<section id="id80">
<h4>RETURN VALUE<a class="headerlink" href="#id80" title="Link to this heading">¶</a></h4>
<p>The device number of the next device matching the specifications, or
-1 if no such device exists.</p>
</section>
<section id="id81">
<h4>NOTES<a class="headerlink" href="#id81" title="Link to this heading">¶</a></h4>
<p>Example usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int devnum = -1;
while ((devnum = parport_find_device (&quot;IOMEGA&quot;, &quot;ZIP+&quot;, devnum)) != -1) {
        struct pardevice *dev = parport_open (devnum, ...);
        ...
}
</pre></div>
</div>
</section>
<section id="id82">
<h4>SEE ALSO<a class="headerlink" href="#id82" title="Link to this heading">¶</a></h4>
<p>parport_find_class, parport_open, parport_device_id</p>
</section>
</section>
<section id="parport-set-timeout-set-the-inactivity-timeout">
<h3>parport_set_timeout - set the inactivity timeout<a class="headerlink" href="#parport-set-timeout-set-the-inactivity-timeout" title="Link to this heading">¶</a></h3>
<section id="id83">
<h4>SYNOPSIS<a class="headerlink" href="#id83" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

long parport_set_timeout (struct pardevice *dev, long inactivity);
</pre></div>
</div>
</section>
<section id="id84">
<h4>DESCRIPTION<a class="headerlink" href="#id84" title="Link to this heading">¶</a></h4>
<p>Set the inactivity timeout, in jiffies, for a registered device.  The
previous timeout is returned.</p>
</section>
<section id="id85">
<h4>RETURN VALUE<a class="headerlink" href="#id85" title="Link to this heading">¶</a></h4>
<p>The previous timeout, in jiffies.</p>
</section>
<section id="id86">
<h4>NOTES<a class="headerlink" href="#id86" title="Link to this heading">¶</a></h4>
<p>Some of the port-&gt;ops functions for a parport may take time, owing to
delays at the peripheral.  After the peripheral has not responded for
<code class="docutils literal notranslate"><span class="pre">inactivity</span></code> jiffies, a timeout will occur and the blocking function
will return.</p>
<p>A timeout of 0 jiffies is a special case: the function must do as much
as it can without blocking or leaving the hardware in an unknown
state.  If port operations are performed from within an interrupt
handler, for instance, a timeout of 0 jiffies should be used.</p>
<p>Once set for a registered device, the timeout will remain at the set
value until set again.</p>
</section>
<section id="id87">
<h4>SEE ALSO<a class="headerlink" href="#id87" title="Link to this heading">¶</a></h4>
<p>port-&gt;ops-&gt;xxx_read/write_yyy</p>
</section>
</section>
</section>
<section id="port-functions">
<h2>PORT FUNCTIONS<a class="headerlink" href="#port-functions" title="Link to this heading">¶</a></h2>
<p>The functions in the port-&gt;ops structure (struct parport_operations)
are provided by the low-level driver responsible for that port.</p>
<section id="port-ops-read-data-read-the-data-register">
<h3>port-&gt;ops-&gt;read_data - read the data register<a class="headerlink" href="#port-ops-read-data-read-the-data-register" title="Link to this heading">¶</a></h3>
<section id="id88">
<h4>SYNOPSIS<a class="headerlink" href="#id88" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        unsigned char (*read_data) (struct parport *port);
        ...
};
</pre></div>
</div>
</section>
<section id="id89">
<h4>DESCRIPTION<a class="headerlink" href="#id89" title="Link to this heading">¶</a></h4>
<p>If port-&gt;modes contains the PARPORT_MODE_TRISTATE flag and the
PARPORT_CONTROL_DIRECTION bit in the control register is set, this
returns the value on the data pins.  If port-&gt;modes contains the
PARPORT_MODE_TRISTATE flag and the PARPORT_CONTROL_DIRECTION bit is
not set, the return value _may_ be the last value written to the data
register.  Otherwise the return value is undefined.</p>
</section>
<section id="id90">
<h4>SEE ALSO<a class="headerlink" href="#id90" title="Link to this heading">¶</a></h4>
<p>write_data, read_status, write_control</p>
</section>
</section>
<section id="port-ops-write-data-write-the-data-register">
<h3>port-&gt;ops-&gt;write_data - write the data register<a class="headerlink" href="#port-ops-write-data-write-the-data-register" title="Link to this heading">¶</a></h3>
<section id="id91">
<h4>SYNOPSIS<a class="headerlink" href="#id91" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        void (*write_data) (struct parport *port, unsigned char d);
        ...
};
</pre></div>
</div>
</section>
<section id="id92">
<h4>DESCRIPTION<a class="headerlink" href="#id92" title="Link to this heading">¶</a></h4>
<p>Writes to the data register.  May have side-effects (a STROBE pulse,
for instance).</p>
</section>
<section id="id93">
<h4>SEE ALSO<a class="headerlink" href="#id93" title="Link to this heading">¶</a></h4>
<p>read_data, read_status, write_control</p>
</section>
</section>
<section id="port-ops-read-status-read-the-status-register">
<h3>port-&gt;ops-&gt;read_status - read the status register<a class="headerlink" href="#port-ops-read-status-read-the-status-register" title="Link to this heading">¶</a></h3>
<section id="id94">
<h4>SYNOPSIS<a class="headerlink" href="#id94" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        unsigned char (*read_status) (struct parport *port);
        ...
};
</pre></div>
</div>
</section>
<section id="id95">
<h4>DESCRIPTION<a class="headerlink" href="#id95" title="Link to this heading">¶</a></h4>
<p>Reads from the status register.  This is a bitmask:</p>
<ul class="simple">
<li><p>PARPORT_STATUS_ERROR (printer fault, “nFault”)</p></li>
<li><p>PARPORT_STATUS_SELECT (on-line, “Select”)</p></li>
<li><p>PARPORT_STATUS_PAPEROUT (no paper, “PError”)</p></li>
<li><p>PARPORT_STATUS_ACK (handshake, “nAck”)</p></li>
<li><p>PARPORT_STATUS_BUSY (busy, “Busy”)</p></li>
</ul>
<p>There may be other bits set.</p>
</section>
<section id="id96">
<h4>SEE ALSO<a class="headerlink" href="#id96" title="Link to this heading">¶</a></h4>
<p>read_data, write_data, write_control</p>
</section>
</section>
<section id="port-ops-read-control-read-the-control-register">
<h3>port-&gt;ops-&gt;read_control - read the control register<a class="headerlink" href="#port-ops-read-control-read-the-control-register" title="Link to this heading">¶</a></h3>
<section id="id97">
<h4>SYNOPSIS<a class="headerlink" href="#id97" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        unsigned char (*read_control) (struct parport *port);
        ...
};
</pre></div>
</div>
</section>
<section id="id98">
<h4>DESCRIPTION<a class="headerlink" href="#id98" title="Link to this heading">¶</a></h4>
<p>Returns the last value written to the control register (either from
write_control or frob_control).  No port access is performed.</p>
</section>
<section id="id99">
<h4>SEE ALSO<a class="headerlink" href="#id99" title="Link to this heading">¶</a></h4>
<p>read_data, write_data, read_status, write_control</p>
</section>
</section>
<section id="port-ops-write-control-write-the-control-register">
<h3>port-&gt;ops-&gt;write_control - write the control register<a class="headerlink" href="#port-ops-write-control-write-the-control-register" title="Link to this heading">¶</a></h3>
<section id="id100">
<h4>SYNOPSIS<a class="headerlink" href="#id100" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        void (*write_control) (struct parport *port, unsigned char s);
        ...
};
</pre></div>
</div>
</section>
<section id="id101">
<h4>DESCRIPTION<a class="headerlink" href="#id101" title="Link to this heading">¶</a></h4>
<p>Writes to the control register. This is a bitmask:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                          _______
- PARPORT_CONTROL_STROBE (nStrobe)
                          _______
- PARPORT_CONTROL_AUTOFD (nAutoFd)
                        _____
- PARPORT_CONTROL_INIT (nInit)
                          _________
- PARPORT_CONTROL_SELECT (nSelectIn)
</pre></div>
</div>
</section>
<section id="id102">
<h4>SEE ALSO<a class="headerlink" href="#id102" title="Link to this heading">¶</a></h4>
<p>read_data, write_data, read_status, frob_control</p>
</section>
</section>
<section id="port-ops-frob-control-write-control-register-bits">
<h3>port-&gt;ops-&gt;frob_control - write control register bits<a class="headerlink" href="#port-ops-frob-control-write-control-register-bits" title="Link to this heading">¶</a></h3>
<section id="id103">
<h4>SYNOPSIS<a class="headerlink" href="#id103" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        unsigned char (*frob_control) (struct parport *port,
                                unsigned char mask,
                                unsigned char val);
        ...
};
</pre></div>
</div>
</section>
<section id="id104">
<h4>DESCRIPTION<a class="headerlink" href="#id104" title="Link to this heading">¶</a></h4>
<p>This is equivalent to reading from the control register, masking out
the bits in mask, exclusive-or’ing with the bits in val, and writing
the result to the control register.</p>
<p>As some ports don’t allow reads from the control port, a software copy
of its contents is maintained, so frob_control is in fact only one
port access.</p>
</section>
<section id="id105">
<h4>SEE ALSO<a class="headerlink" href="#id105" title="Link to this heading">¶</a></h4>
<p>read_data, write_data, read_status, write_control</p>
</section>
</section>
<section id="port-ops-enable-irq-enable-interrupt-generation">
<h3>port-&gt;ops-&gt;enable_irq - enable interrupt generation<a class="headerlink" href="#port-ops-enable-irq-enable-interrupt-generation" title="Link to this heading">¶</a></h3>
<section id="id106">
<h4>SYNOPSIS<a class="headerlink" href="#id106" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        void (*enable_irq) (struct parport *port);
        ...
};
</pre></div>
</div>
</section>
<section id="id107">
<h4>DESCRIPTION<a class="headerlink" href="#id107" title="Link to this heading">¶</a></h4>
<p>The parallel port hardware is instructed to generate interrupts at
appropriate moments, although those moments are
architecture-specific.  For the PC architecture, interrupts are
commonly generated on the rising edge of nAck.</p>
</section>
<section id="id108">
<h4>SEE ALSO<a class="headerlink" href="#id108" title="Link to this heading">¶</a></h4>
<p>disable_irq</p>
</section>
</section>
<section id="port-ops-disable-irq-disable-interrupt-generation">
<h3>port-&gt;ops-&gt;disable_irq - disable interrupt generation<a class="headerlink" href="#port-ops-disable-irq-disable-interrupt-generation" title="Link to this heading">¶</a></h3>
<section id="id109">
<h4>SYNOPSIS<a class="headerlink" href="#id109" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        void (*disable_irq) (struct parport *port);
        ...
};
</pre></div>
</div>
</section>
<section id="id110">
<h4>DESCRIPTION<a class="headerlink" href="#id110" title="Link to this heading">¶</a></h4>
<p>The parallel port hardware is instructed not to generate interrupts.
The interrupt itself is not masked.</p>
</section>
<section id="id111">
<h4>SEE ALSO<a class="headerlink" href="#id111" title="Link to this heading">¶</a></h4>
<p>enable_irq</p>
</section>
</section>
<section id="port-ops-data-forward-enable-data-drivers">
<h3>port-&gt;ops-&gt;data_forward - enable data drivers<a class="headerlink" href="#port-ops-data-forward-enable-data-drivers" title="Link to this heading">¶</a></h3>
<section id="id112">
<h4>SYNOPSIS<a class="headerlink" href="#id112" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        void (*data_forward) (struct parport *port);
        ...
};
</pre></div>
</div>
</section>
<section id="id113">
<h4>DESCRIPTION<a class="headerlink" href="#id113" title="Link to this heading">¶</a></h4>
<p>Enables the data line drivers, for 8-bit host-to-peripheral
communications.</p>
</section>
<section id="id114">
<h4>SEE ALSO<a class="headerlink" href="#id114" title="Link to this heading">¶</a></h4>
<p>data_reverse</p>
</section>
</section>
<section id="port-ops-data-reverse-tristate-the-buffer">
<h3>port-&gt;ops-&gt;data_reverse - tristate the buffer<a class="headerlink" href="#port-ops-data-reverse-tristate-the-buffer" title="Link to this heading">¶</a></h3>
<section id="id115">
<h4>SYNOPSIS<a class="headerlink" href="#id115" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        void (*data_reverse) (struct parport *port);
        ...
};
</pre></div>
</div>
</section>
<section id="id116">
<h4>DESCRIPTION<a class="headerlink" href="#id116" title="Link to this heading">¶</a></h4>
<p>Places the data bus in a high impedance state, if port-&gt;modes has the
PARPORT_MODE_TRISTATE bit set.</p>
</section>
<section id="id117">
<h4>SEE ALSO<a class="headerlink" href="#id117" title="Link to this heading">¶</a></h4>
<p>data_forward</p>
</section>
</section>
<section id="port-ops-epp-write-data-write-epp-data">
<h3>port-&gt;ops-&gt;epp_write_data - write EPP data<a class="headerlink" href="#port-ops-epp-write-data-write-epp-data" title="Link to this heading">¶</a></h3>
<section id="id118">
<h4>SYNOPSIS<a class="headerlink" href="#id118" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*epp_write_data) (struct parport *port, const void *buf,
                                size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id119">
<h4>DESCRIPTION<a class="headerlink" href="#id119" title="Link to this heading">¶</a></h4>
<p>Writes data in EPP mode, and returns the number of bytes written.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter may be one or more of the following,
bitwise-or’ed together:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>PARPORT_EPP_FAST</p></td>
<td><p>Use fast transfers. Some chips provide 16-bit and
32-bit registers.  However, if a transfer
times out, the return value may be unreliable.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id120">
<h4>SEE ALSO<a class="headerlink" href="#id120" title="Link to this heading">¶</a></h4>
<p>epp_read_data, epp_write_addr, epp_read_addr</p>
</section>
</section>
<section id="port-ops-epp-read-data-read-epp-data">
<h3>port-&gt;ops-&gt;epp_read_data - read EPP data<a class="headerlink" href="#port-ops-epp-read-data-read-epp-data" title="Link to this heading">¶</a></h3>
<section id="id121">
<h4>SYNOPSIS<a class="headerlink" href="#id121" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*epp_read_data) (struct parport *port, void *buf,
                                size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id122">
<h4>DESCRIPTION<a class="headerlink" href="#id122" title="Link to this heading">¶</a></h4>
<p>Reads data in EPP mode, and returns the number of bytes read.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter may be one or more of the following,
bitwise-or’ed together:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>PARPORT_EPP_FAST</p></td>
<td><p>Use fast transfers. Some chips provide 16-bit and
32-bit registers.  However, if a transfer
times out, the return value may be unreliable.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id123">
<h4>SEE ALSO<a class="headerlink" href="#id123" title="Link to this heading">¶</a></h4>
<p>epp_write_data, epp_write_addr, epp_read_addr</p>
</section>
</section>
<section id="port-ops-epp-write-addr-write-epp-address">
<h3>port-&gt;ops-&gt;epp_write_addr - write EPP address<a class="headerlink" href="#port-ops-epp-write-addr-write-epp-address" title="Link to this heading">¶</a></h3>
<section id="id124">
<h4>SYNOPSIS<a class="headerlink" href="#id124" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*epp_write_addr) (struct parport *port,
                                const void *buf, size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id125">
<h4>DESCRIPTION<a class="headerlink" href="#id125" title="Link to this heading">¶</a></h4>
<p>Writes EPP addresses (8 bits each), and returns the number written.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter may be one or more of the following,
bitwise-or’ed together:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>PARPORT_EPP_FAST</p></td>
<td><p>Use fast transfers. Some chips provide 16-bit and
32-bit registers.  However, if a transfer
times out, the return value may be unreliable.</p></td>
</tr>
</tbody>
</table>
<p>(Does PARPORT_EPP_FAST make sense for this function?)</p>
</section>
<section id="id126">
<h4>SEE ALSO<a class="headerlink" href="#id126" title="Link to this heading">¶</a></h4>
<p>epp_write_data, epp_read_data, epp_read_addr</p>
</section>
</section>
<section id="port-ops-epp-read-addr-read-epp-address">
<h3>port-&gt;ops-&gt;epp_read_addr - read EPP address<a class="headerlink" href="#port-ops-epp-read-addr-read-epp-address" title="Link to this heading">¶</a></h3>
<section id="id127">
<h4>SYNOPSIS<a class="headerlink" href="#id127" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*epp_read_addr) (struct parport *port, void *buf,
                                size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id128">
<h4>DESCRIPTION<a class="headerlink" href="#id128" title="Link to this heading">¶</a></h4>
<p>Reads EPP addresses (8 bits each), and returns the number read.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter may be one or more of the following,
bitwise-or’ed together:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>PARPORT_EPP_FAST</p></td>
<td><p>Use fast transfers. Some chips provide 16-bit and
32-bit registers.  However, if a transfer
times out, the return value may be unreliable.</p></td>
</tr>
</tbody>
</table>
<p>(Does PARPORT_EPP_FAST make sense for this function?)</p>
</section>
<section id="id129">
<h4>SEE ALSO<a class="headerlink" href="#id129" title="Link to this heading">¶</a></h4>
<p>epp_write_data, epp_read_data, epp_write_addr</p>
</section>
</section>
<section id="port-ops-ecp-write-data-write-a-block-of-ecp-data">
<h3>port-&gt;ops-&gt;ecp_write_data - write a block of ECP data<a class="headerlink" href="#port-ops-ecp-write-data-write-a-block-of-ecp-data" title="Link to this heading">¶</a></h3>
<section id="id130">
<h4>SYNOPSIS<a class="headerlink" href="#id130" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*ecp_write_data) (struct parport *port,
                                const void *buf, size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id131">
<h4>DESCRIPTION<a class="headerlink" href="#id131" title="Link to this heading">¶</a></h4>
<p>Writes a block of ECP data.  The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter is ignored.</p>
</section>
<section id="id132">
<h4>RETURN VALUE<a class="headerlink" href="#id132" title="Link to this heading">¶</a></h4>
<p>The number of bytes written.</p>
</section>
<section id="id133">
<h4>SEE ALSO<a class="headerlink" href="#id133" title="Link to this heading">¶</a></h4>
<p>ecp_read_data, ecp_write_addr</p>
</section>
</section>
<section id="port-ops-ecp-read-data-read-a-block-of-ecp-data">
<h3>port-&gt;ops-&gt;ecp_read_data - read a block of ECP data<a class="headerlink" href="#port-ops-ecp-read-data-read-a-block-of-ecp-data" title="Link to this heading">¶</a></h3>
<section id="id134">
<h4>SYNOPSIS<a class="headerlink" href="#id134" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*ecp_read_data) (struct parport *port,
                                void *buf, size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id135">
<h4>DESCRIPTION<a class="headerlink" href="#id135" title="Link to this heading">¶</a></h4>
<p>Reads a block of ECP data.  The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter is ignored.</p>
</section>
<section id="id136">
<h4>RETURN VALUE<a class="headerlink" href="#id136" title="Link to this heading">¶</a></h4>
<p>The number of bytes read.  NB. There may be more unread data in a
FIFO.  Is there a way of stunning the FIFO to prevent this?</p>
</section>
<section id="id137">
<h4>SEE ALSO<a class="headerlink" href="#id137" title="Link to this heading">¶</a></h4>
<p>ecp_write_block, ecp_write_addr</p>
</section>
</section>
<section id="port-ops-ecp-write-addr-write-a-block-of-ecp-addresses">
<h3>port-&gt;ops-&gt;ecp_write_addr - write a block of ECP addresses<a class="headerlink" href="#port-ops-ecp-write-addr-write-a-block-of-ecp-addresses" title="Link to this heading">¶</a></h3>
<section id="id138">
<h4>SYNOPSIS<a class="headerlink" href="#id138" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*ecp_write_addr) (struct parport *port,
                                const void *buf, size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id139">
<h4>DESCRIPTION<a class="headerlink" href="#id139" title="Link to this heading">¶</a></h4>
<p>Writes a block of ECP addresses.  The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter is ignored.</p>
</section>
<section id="id140">
<h4>RETURN VALUE<a class="headerlink" href="#id140" title="Link to this heading">¶</a></h4>
<p>The number of bytes written.</p>
</section>
<section id="id141">
<h4>NOTES<a class="headerlink" href="#id141" title="Link to this heading">¶</a></h4>
<p>This may use a FIFO, and if so shall not return until the FIFO is empty.</p>
</section>
<section id="id142">
<h4>SEE ALSO<a class="headerlink" href="#id142" title="Link to this heading">¶</a></h4>
<p>ecp_read_data, ecp_write_data</p>
</section>
</section>
<section id="port-ops-nibble-read-data-read-a-block-of-data-in-nibble-mode">
<h3>port-&gt;ops-&gt;nibble_read_data - read a block of data in nibble mode<a class="headerlink" href="#port-ops-nibble-read-data-read-a-block-of-data-in-nibble-mode" title="Link to this heading">¶</a></h3>
<section id="id143">
<h4>SYNOPSIS<a class="headerlink" href="#id143" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*nibble_read_data) (struct parport *port,
                                void *buf, size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id144">
<h4>DESCRIPTION<a class="headerlink" href="#id144" title="Link to this heading">¶</a></h4>
<p>Reads a block of data in nibble mode.  The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter is ignored.</p>
</section>
<section id="id145">
<h4>RETURN VALUE<a class="headerlink" href="#id145" title="Link to this heading">¶</a></h4>
<p>The number of whole bytes read.</p>
</section>
<section id="id146">
<h4>SEE ALSO<a class="headerlink" href="#id146" title="Link to this heading">¶</a></h4>
<p>byte_read_data, compat_write_data</p>
</section>
</section>
<section id="port-ops-byte-read-data-read-a-block-of-data-in-byte-mode">
<h3>port-&gt;ops-&gt;byte_read_data - read a block of data in byte mode<a class="headerlink" href="#port-ops-byte-read-data-read-a-block-of-data-in-byte-mode" title="Link to this heading">¶</a></h3>
<section id="id147">
<h4>SYNOPSIS<a class="headerlink" href="#id147" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*byte_read_data) (struct parport *port,
                                void *buf, size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id148">
<h4>DESCRIPTION<a class="headerlink" href="#id148" title="Link to this heading">¶</a></h4>
<p>Reads a block of data in byte mode.  The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter is ignored.</p>
</section>
<section id="id149">
<h4>RETURN VALUE<a class="headerlink" href="#id149" title="Link to this heading">¶</a></h4>
<p>The number of bytes read.</p>
</section>
<section id="id150">
<h4>SEE ALSO<a class="headerlink" href="#id150" title="Link to this heading">¶</a></h4>
<p>nibble_read_data, compat_write_data</p>
</section>
</section>
<section id="port-ops-compat-write-data-write-a-block-of-data-in-compatibility-mode">
<h3>port-&gt;ops-&gt;compat_write_data - write a block of data in compatibility mode<a class="headerlink" href="#port-ops-compat-write-data-write-a-block-of-data-in-compatibility-mode" title="Link to this heading">¶</a></h3>
<section id="id151">
<h4>SYNOPSIS<a class="headerlink" href="#id151" title="Link to this heading">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/parport.h&gt;

struct parport_operations {
        ...
        size_t (*compat_write_data) (struct parport *port,
                                const void *buf, size_t len, int flags);
        ...
};
</pre></div>
</div>
</section>
<section id="id152">
<h4>DESCRIPTION<a class="headerlink" href="#id152" title="Link to this heading">¶</a></h4>
<p>Writes a block of data in compatibility mode.  The <code class="docutils literal notranslate"><span class="pre">flags</span></code> parameter
is ignored.</p>
</section>
<section id="id153">
<h4>RETURN VALUE<a class="headerlink" href="#id153" title="Link to this heading">¶</a></h4>
<p>The number of bytes written.</p>
</section>
<section id="id154">
<h4>SEE ALSO<a class="headerlink" href="#id154" title="Link to this heading">¶</a></h4>
<p>nibble_read_data, byte_read_data</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/parport-lowlevel.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>