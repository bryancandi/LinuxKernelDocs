
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Legacy GPIO Interfaces &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="A driver for a selfmade cheap BT8xx based PCI GPIO-card (bt8xxgpio)" href="bt8xxgpio.html" />
    <link rel="prev" title="Subsystem drivers using GPIO" href="drivers-on-gpio.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.8.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver implementer's API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization (dma-buf)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer's API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer's Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas' 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer's Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">General Purpose Input/Output (GPIO)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="using-gpio.html">Using GPIO Lines in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="driver.html">GPIO Driver Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="consumer.html">GPIO Descriptor Consumer Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="board.html">GPIO Mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Legacy GPIO Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="bt8xxgpio.html">A driver for a selfmade cheap BT8xx based PCI GPIO-card (bt8xxgpio)</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#core">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#acpi-support">ACPI support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#device-tree-support">Device tree support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#device-managed-api">Device-managed API</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sysfs-helpers">sysfs helpers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - &quot;Virtual Function I/O&quot; </a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-pci-device-specific-driver-acceptance.html">Acceptance criteria for vfio-pci device specific driver variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../virtio/index.html">Virtio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tee.html">TEE (Trusted Execution Environment) driver API</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Kernel subsystem documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../RAS/ras.html">Reliability, Availability and Serviceability features</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/gpio/legacy.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../../translations/zh_CN/driver-api/gpio/legacy.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="legacy-gpio-interfaces">
<h1>Legacy GPIO Interfaces<a class="headerlink" href="#legacy-gpio-interfaces" title="Permalink to this heading">¶</a></h1>
<p>This provides an overview of GPIO access conventions on Linux.</p>
<p>These calls use the gpio_* naming prefix.  No other calls should use that
prefix, or the related __gpio_* prefix.</p>
<section id="what-is-a-gpio">
<h2>What is a GPIO?<a class="headerlink" href="#what-is-a-gpio" title="Permalink to this heading">¶</a></h2>
<p>A &quot;General Purpose Input/Output&quot; (GPIO) is a flexible software-controlled
digital signal.  They are provided from many kinds of chip, and are familiar
to Linux developers working with embedded and custom hardware.  Each GPIO
represents a bit connected to a particular pin, or &quot;ball&quot; on Ball Grid Array
(BGA) packages.  Board schematics show which external hardware connects to
which GPIOs.  Drivers can be written generically, so that board setup code
passes such pin configuration data to drivers.</p>
<p>System-on-Chip (SOC) processors heavily rely on GPIOs.  In some cases, every
non-dedicated pin can be configured as a GPIO; and most chips have at least
several dozen of them.  Programmable logic devices (like FPGAs) can easily
provide GPIOs; multifunction chips like power managers, and audio codecs
often have a few such pins to help with pin scarcity on SOCs; and there are
also &quot;GPIO Expander&quot; chips that connect using the I2C or SPI serial busses.
Most PC southbridges have a few dozen GPIO-capable pins (with only the BIOS
firmware knowing how they're used).</p>
<p>The exact capabilities of GPIOs vary between systems.  Common options:</p>
<blockquote>
<div><ul class="simple">
<li><p>Output values are writable (high=1, low=0).  Some chips also have
options about how that value is driven, so that for example only one
value might be driven ... supporting &quot;wire-OR&quot; and similar schemes
for the other value (notably, &quot;open drain&quot; signaling).</p></li>
<li><p>Input values are likewise readable (1, 0).  Some chips support readback
of pins configured as &quot;output&quot;, which is very useful in such &quot;wire-OR&quot;
cases (to support bidirectional signaling).  GPIO controllers may have
input de-glitch/debounce logic, sometimes with software controls.</p></li>
<li><p>Inputs can often be used as IRQ signals, often edge triggered but
sometimes level triggered.  Such IRQs may be configurable as system
wakeup events, to wake the system from a low power state.</p></li>
<li><p>Usually a GPIO will be configurable as either input or output, as needed
by different product boards; single direction ones exist too.</p></li>
<li><p>Most GPIOs can be accessed while holding spinlocks, but those accessed
through a serial bus normally can't.  Some systems support both types.</p></li>
</ul>
</div></blockquote>
<p>On a given board each GPIO is used for one specific purpose like monitoring
MMC/SD card insertion/removal, detecting card writeprotect status, driving
a LED, configuring a transceiver, bitbanging a serial bus, poking a hardware
watchdog, sensing a switch, and so on.</p>
</section>
<section id="gpio-conventions">
<h2>GPIO conventions<a class="headerlink" href="#gpio-conventions" title="Permalink to this heading">¶</a></h2>
<p>Note that this is called a &quot;convention&quot; because you don't need to do it this
way, and it's no crime if you don't.  There <strong>are</strong> cases where portability
is not the main issue; GPIOs are often used for the kind of board-specific
glue logic that may even change between board revisions, and can't ever be
used on a board that's wired differently.  Only least-common-denominator
functionality can be very portable.  Other features are platform-specific,
and that can be critical for glue logic.</p>
<p>Plus, this doesn't require any implementation framework, just an interface.
One platform might implement it as simple inline functions accessing chip
registers; another might implement it by delegating through abstractions
used for several very different kinds of GPIO controller.  (There is some
optional code supporting such an implementation strategy, described later
in this document, but drivers acting as clients to the GPIO interface must
not care how it's implemented.)</p>
<p>That said, if the convention is supported on their platform, drivers should
use it when possible.  Platforms must select GPIOLIB if GPIO functionality
is strictly required.  Drivers that can't work without
standard GPIO calls should have Kconfig entries which depend on GPIOLIB.  The
GPIO calls are available, either as &quot;real code&quot; or as optimized-away stubs,
when drivers use the include file:</p>
<blockquote>
<div><p>#include &lt;linux/gpio.h&gt;</p>
</div></blockquote>
<p>If you stick to this convention then it'll be easier for other developers to
see what your code is doing, and help maintain it.</p>
<p>Note that these operations include I/O barriers on platforms which need to
use them; drivers don't need to add them explicitly.</p>
<section id="identifying-gpios">
<h3>Identifying GPIOs<a class="headerlink" href="#identifying-gpios" title="Permalink to this heading">¶</a></h3>
<p>GPIOs are identified by unsigned integers in the range 0..MAX_INT.  That
reserves &quot;negative&quot; numbers for other purposes like marking signals as
&quot;not available on this board&quot;, or indicating faults.  Code that doesn't
touch the underlying hardware treats these integers as opaque cookies.</p>
<p>Platforms define how they use those integers, and usually #define symbols
for the GPIO lines so that board-specific setup code directly corresponds
to the relevant schematics.  In contrast, drivers should only use GPIO
numbers passed to them from that setup code, using platform_data to hold
board-specific pin configuration data (along with other board specific
data they need).  That avoids portability problems.</p>
<p>So for example one platform uses numbers 32-159 for GPIOs; while another
uses numbers 0..63 with one set of GPIO controllers, 64-79 with another
type of GPIO controller, and on one particular board 80-95 with an FPGA.
The numbers need not be contiguous; either of those platforms could also
use numbers 2000-2063 to identify GPIOs in a bank of I2C GPIO expanders.</p>
<p>If you want to initialize a structure with an invalid GPIO number, use
some negative number (perhaps &quot;-EINVAL&quot;); that will never be valid.  To
test if such number from such a structure could reference a GPIO, you
may use this predicate:</p>
<blockquote>
<div><p>int gpio_is_valid(int number);</p>
</div></blockquote>
<p>A number that's not valid will be rejected by calls which may request
or free GPIOs (see below).  Other numbers may also be rejected; for
example, a number might be valid but temporarily unused on a given board.</p>
<p>Whether a platform supports multiple GPIO controllers is a platform-specific
implementation issue, as are whether that support can leave &quot;holes&quot; in the space
of GPIO numbers, and whether new controllers can be added at runtime.  Such issues
can affect things including whether adjacent GPIO numbers are both valid.</p>
</section>
<section id="using-gpios">
<h3>Using GPIOs<a class="headerlink" href="#using-gpios" title="Permalink to this heading">¶</a></h3>
<p>The first thing a system should do with a GPIO is allocate it, using
the gpio_request() call; see later.</p>
<p>One of the next things to do with a GPIO, often in board setup code when
setting up a platform_device using the GPIO, is mark its direction:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* set as input or output, returning 0 or negative errno */
int gpio_direction_input(unsigned gpio);
int gpio_direction_output(unsigned gpio, int value);
</pre></div>
</div>
<p>The return value is zero for success, else a negative errno.  It should
be checked, since the get/set calls don't have error returns and since
misconfiguration is possible.  You should normally issue these calls from
a task context.  However, for spinlock-safe GPIOs it's OK to use them
before tasking is enabled, as part of early board setup.</p>
<p>For output GPIOs, the value provided becomes the initial output value.
This helps avoid signal glitching during system startup.</p>
<p>For compatibility with legacy interfaces to GPIOs, setting the direction
of a GPIO implicitly requests that GPIO (see below) if it has not been
requested already.  That compatibility is being removed from the optional
gpiolib framework.</p>
<p>Setting the direction can fail if the GPIO number is invalid, or when
that particular GPIO can't be used in that mode.  It's generally a bad
idea to rely on boot firmware to have set the direction correctly, since
it probably wasn't validated to do more than boot Linux.  (Similarly,
that board setup code probably needs to multiplex that pin as a GPIO,
and configure pullups/pulldowns appropriately.)</p>
</section>
<section id="spinlock-safe-gpio-access">
<h3>Spinlock-Safe GPIO access<a class="headerlink" href="#spinlock-safe-gpio-access" title="Permalink to this heading">¶</a></h3>
<p>Most GPIO controllers can be accessed with memory read/write instructions.
Those don't need to sleep, and can safely be done from inside hard
(nonthreaded) IRQ handlers and similar contexts.</p>
<p>Use the following calls to access such GPIOs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* GPIO INPUT:  return zero or nonzero */
int gpio_get_value(unsigned gpio);

/* GPIO OUTPUT */
void gpio_set_value(unsigned gpio, int value);
</pre></div>
</div>
<p>The values are boolean, zero for low, nonzero for high.  When reading the
value of an output pin, the value returned should be what's seen on the
pin ... that won't always match the specified output value, because of
issues including open-drain signaling and output latencies.</p>
<p>The get/set calls have no error returns because &quot;invalid GPIO&quot; should have
been reported earlier from gpio_direction_*().  However, note that not all
platforms can read the value of output pins; those that can't should always
return zero.  Also, using these calls for GPIOs that can't safely be accessed
without sleeping (see below) is an error.</p>
<p>Platform-specific implementations are encouraged to optimize the two
calls to access the GPIO value in cases where the GPIO number (and for
output, value) are constant.  It's normal for them to need only a couple
of instructions in such cases (reading or writing a hardware register),
and not to need spinlocks.  Such optimized calls can make bitbanging
applications a lot more efficient (in both space and time) than spending
dozens of instructions on subroutine calls.</p>
</section>
<section id="gpio-access-that-may-sleep">
<h3>GPIO access that may sleep<a class="headerlink" href="#gpio-access-that-may-sleep" title="Permalink to this heading">¶</a></h3>
<p>Some GPIO controllers must be accessed using message based busses like I2C
or SPI.  Commands to read or write those GPIO values require waiting to
get to the head of a queue to transmit a command and get its response.
This requires sleeping, which can't be done from inside IRQ handlers.
To access such GPIOs, a different set of accessors is defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* GPIO INPUT:  return zero or nonzero, might sleep */
int gpio_get_value_cansleep(unsigned gpio);

/* GPIO OUTPUT, might sleep */
void gpio_set_value_cansleep(unsigned gpio, int value);
</pre></div>
</div>
<p>Accessing such GPIOs requires a context which may sleep,  for example
a threaded IRQ handler, and those accessors must be used instead of
spinlock-safe accessors without the cansleep() name suffix.</p>
<p>Other than the fact that these accessors might sleep, and will work
on GPIOs that can't be accessed from hardIRQ handlers, these calls act
the same as the spinlock-safe calls.</p>
<p><strong>IN ADDITION</strong> calls to setup and configure such GPIOs must be made
from contexts which may sleep, since they may need to access the GPIO
controller chip too  (These setup calls are usually made from board
setup or driver probe/teardown code, so this is an easy constraint.):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        gpio_direction_input()
        gpio_direction_output()
        gpio_request()

##      gpio_request_one()
##      gpio_request_array()
##      gpio_free_array()

        gpio_free()
</pre></div>
</div>
</section>
<section id="claiming-and-releasing-gpios">
<h3>Claiming and Releasing GPIOs<a class="headerlink" href="#claiming-and-releasing-gpios" title="Permalink to this heading">¶</a></h3>
<p>To help catch system configuration errors, two calls are defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* request GPIO, returning 0 or negative errno.
 * non-null labels may be useful for diagnostics.
 */
int gpio_request(unsigned gpio, const char *label);

/* release previously-claimed GPIO */
void gpio_free(unsigned gpio);
</pre></div>
</div>
<p>Passing invalid GPIO numbers to gpio_request() will fail, as will requesting
GPIOs that have already been claimed with that call.  The return value of
gpio_request() must be checked.  You should normally issue these calls from
a task context.  However, for spinlock-safe GPIOs it's OK to request GPIOs
before tasking is enabled, as part of early board setup.</p>
<p>These calls serve two basic purposes.  One is marking the signals which
are actually in use as GPIOs, for better diagnostics; systems may have
several hundred potential GPIOs, but often only a dozen are used on any
given board.  Another is to catch conflicts, identifying errors when
(a) two or more drivers wrongly think they have exclusive use of that
signal, or (b) something wrongly believes it's safe to remove drivers
needed to manage a signal that's in active use.  That is, requesting a
GPIO can serve as a kind of lock.</p>
<p>Some platforms may also use knowledge about what GPIOs are active for
power management, such as by powering down unused chip sectors and, more
easily, gating off unused clocks.</p>
<p>For GPIOs that use pins known to the pinctrl subsystem, that subsystem should
be informed of their use; a gpiolib driver's .request() operation may call
pinctrl_gpio_request(), and a gpiolib driver's .free() operation may call
pinctrl_gpio_free(). The pinctrl subsystem allows a pinctrl_gpio_request()
to succeed concurrently with a pin or pingroup being &quot;owned&quot; by a device for
pin multiplexing.</p>
<p>Any programming of pin multiplexing hardware that is needed to route the
GPIO signal to the appropriate pin should occur within a GPIO driver's
.direction_input() or .direction_output() operations, and occur after any
setup of an output GPIO's value. This allows a glitch-free migration from a
pin's special function to GPIO. This is sometimes required when using a GPIO
to implement a workaround on signals typically driven by a non-GPIO HW block.</p>
<p>Some platforms allow some or all GPIO signals to be routed to different pins.
Similarly, other aspects of the GPIO or pin may need to be configured, such as
pullup/pulldown. Platform software should arrange that any such details are
configured prior to gpio_request() being called for those GPIOs, e.g. using
the pinctrl subsystem's mapping table, so that GPIO users need not be aware
of these details.</p>
<p>Also note that it's your responsibility to have stopped using a GPIO
before you free it.</p>
<p>Considering in most cases GPIOs are actually configured right after they
are claimed, three additional calls are defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* request a single GPIO, with initial configuration specified by
 * &#39;flags&#39;, identical to gpio_request() wrt other arguments and
 * return value
 */
int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);

/* request multiple GPIOs in a single call
 */
int gpio_request_array(struct gpio *array, size_t num);

/* release multiple GPIOs in a single call
 */
void gpio_free_array(struct gpio *array, size_t num);
</pre></div>
</div>
<p>where 'flags' is currently defined to specify the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><p>GPIOF_DIR_IN          - to configure direction as input</p></li>
<li><p>GPIOF_DIR_OUT         - to configure direction as output</p></li>
<li><p>GPIOF_INIT_LOW        - as output, set initial level to LOW</p></li>
<li><p>GPIOF_INIT_HIGH       - as output, set initial level to HIGH</p></li>
</ul>
</div></blockquote>
<p>since GPIOF_INIT_* are only valid when configured as output, so group valid
combinations as:</p>
<blockquote>
<div><ul class="simple">
<li><p>GPIOF_IN              - configure as input</p></li>
<li><p>GPIOF_OUT_INIT_LOW    - configured as output, initial level LOW</p></li>
<li><p>GPIOF_OUT_INIT_HIGH   - configured as output, initial level HIGH</p></li>
</ul>
</div></blockquote>
<p>Further more, to ease the claim/release of multiple GPIOs, 'struct gpio' is
introduced to encapsulate all three fields as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio {
        unsigned        gpio;
        unsigned long   flags;
        const char      *label;
};
</pre></div>
</div>
<p>A typical example of usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct gpio leds_gpios[] = {
        { 32, GPIOF_OUT_INIT_HIGH, &quot;Power LED&quot; }, /* default to ON */
        { 33, GPIOF_OUT_INIT_LOW,  &quot;Green LED&quot; }, /* default to OFF */
        { 34, GPIOF_OUT_INIT_LOW,  &quot;Red LED&quot;   }, /* default to OFF */
        { 35, GPIOF_OUT_INIT_LOW,  &quot;Blue LED&quot;  }, /* default to OFF */
        { ... },
};

err = gpio_request_one(31, GPIOF_IN, &quot;Reset Button&quot;);
if (err)
        ...

err = gpio_request_array(leds_gpios, ARRAY_SIZE(leds_gpios));
if (err)
        ...

gpio_free_array(leds_gpios, ARRAY_SIZE(leds_gpios));
</pre></div>
</div>
</section>
<section id="gpios-mapped-to-irqs">
<h3>GPIOs mapped to IRQs<a class="headerlink" href="#gpios-mapped-to-irqs" title="Permalink to this heading">¶</a></h3>
<p>GPIO numbers are unsigned integers; so are IRQ numbers.  These make up
two logically distinct namespaces (GPIO 0 need not use IRQ 0).  You can
map between them using calls like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* map GPIO numbers to IRQ numbers */
int gpio_to_irq(unsigned gpio);
</pre></div>
</div>
<p>Those return either the corresponding number in the other namespace, or
else a negative errno code if the mapping can't be done.  (For example,
some GPIOs can't be used as IRQs.)  It is an unchecked error to use a GPIO
number that wasn't set up as an input using gpio_direction_input(), or
to use an IRQ number that didn't originally come from gpio_to_irq().</p>
<p>These two mapping calls are expected to cost on the order of a single
addition or subtraction.  They're not allowed to sleep.</p>
<p>Non-error values returned from gpio_to_irq() can be passed to <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a>
or <a class="reference internal" href="../../core-api/genericirq.html#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a>.  They will often be stored into IRQ resources for platform
devices, by the board-specific initialization code.  Note that IRQ trigger
options are part of the IRQ interface, e.g. IRQF_TRIGGER_FALLING, as are
system wakeup capabilities.</p>
</section>
<section id="emulating-open-drain-signals">
<h3>Emulating Open Drain Signals<a class="headerlink" href="#emulating-open-drain-signals" title="Permalink to this heading">¶</a></h3>
<p>Sometimes shared signals need to use &quot;open drain&quot; signaling, where only the
low signal level is actually driven.  (That term applies to CMOS transistors;
&quot;open collector&quot; is used for TTL.)  A pullup resistor causes the high signal
level.  This is sometimes called a &quot;wire-AND&quot;; or more practically, from the
negative logic (low=true) perspective this is a &quot;wire-OR&quot;.</p>
<p>One common example of an open drain signal is a shared active-low IRQ line.
Also, bidirectional data bus signals sometimes use open drain signals.</p>
<p>Some GPIO controllers directly support open drain outputs; many don't.  When
you need open drain signaling but your hardware doesn't directly support it,
there's a common idiom you can use to emulate it with any GPIO pin that can
be used as either an input or an output:</p>
<blockquote>
<div><dl class="simple">
<dt>LOW:   gpio_direction_output(gpio, 0) ... this drives the signal</dt><dd><p>and overrides the pullup.</p>
</dd>
<dt>HIGH:  gpio_direction_input(gpio) ... this turns off the output,</dt><dd><p>so the pullup (or some other device) controls the signal.</p>
</dd>
</dl>
</div></blockquote>
<p>If you are &quot;driving&quot; the signal high but gpio_get_value(gpio) reports a low
value (after the appropriate rise time passes), you know some other component
is driving the shared signal low.  That's not necessarily an error.  As one
common example, that's how I2C clocks are stretched:  a slave that needs a
slower clock delays the rising edge of SCK, and the I2C master adjusts its
signaling rate accordingly.</p>
</section>
<section id="gpio-controllers-and-the-pinctrl-subsystem">
<h3>GPIO controllers and the pinctrl subsystem<a class="headerlink" href="#gpio-controllers-and-the-pinctrl-subsystem" title="Permalink to this heading">¶</a></h3>
<p>A GPIO controller on a SOC might be tightly coupled with the pinctrl
subsystem, in the sense that the pins can be used by other functions
together with an optional gpio feature. We have already covered the
case where e.g. a GPIO controller need to reserve a pin or set the
direction of a pin by calling any of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pinctrl_gpio_request()
pinctrl_gpio_free()
pinctrl_gpio_direction_input()
pinctrl_gpio_direction_output()
</pre></div>
</div>
<p>But how does the pin control subsystem cross-correlate the GPIO
numbers (which are a global business) to a certain pin on a certain
pin controller?</p>
<p>This is done by registering &quot;ranges&quot; of pins, which are essentially
cross-reference tables. These are described in
<a class="reference internal" href="../pin-control.html"><span class="doc">PINCTRL (PIN CONTROL) subsystem</span></a></p>
<p>While the pin allocation is totally managed by the pinctrl subsystem,
gpio (under gpiolib) is still maintained by gpio drivers. It may happen
that different pin ranges in a SoC is managed by different gpio drivers.</p>
<p>This makes it logical to let gpio drivers announce their pin ranges to
the pin ctrl subsystem before it will call 'pinctrl_gpio_request' in order
to request the corresponding pin to be prepared by the pinctrl subsystem
before any gpio usage.</p>
<p>For this, the gpio controller can register its pin range with pinctrl
subsystem. There are two ways of doing it currently: with or without DT.</p>
<p>For with DT support refer to Documentation/devicetree/bindings/gpio/gpio.txt.</p>
<p>For non-DT support, user can call <a class="reference internal" href="index.html#c.gpiochip_add_pin_range" title="gpiochip_add_pin_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_add_pin_range()</span></code></a> with appropriate
parameters to register a range of gpio pins with a pinctrl driver. For this
exact name string of pinctrl device has to be passed as one of the
argument to this routine.</p>
</section>
</section>
<section id="what-do-these-conventions-omit">
<h2>What do these conventions omit?<a class="headerlink" href="#what-do-these-conventions-omit" title="Permalink to this heading">¶</a></h2>
<p>One of the biggest things these conventions omit is pin multiplexing, since
this is highly chip-specific and nonportable.  One platform might not need
explicit multiplexing; another might have just two options for use of any
given pin; another might have eight options per pin; another might be able
to route a given GPIO to any one of several pins.  (Yes, those examples all
come from systems that run Linux today.)</p>
<p>Related to multiplexing is configuration and enabling of the pullups or
pulldowns integrated on some platforms.  Not all platforms support them,
or support them in the same way; and any given board might use external
pullups (or pulldowns) so that the on-chip ones should not be used.
(When a circuit needs 5 kOhm, on-chip 100 kOhm resistors won't do.)
Likewise drive strength (2 mA vs 20 mA) and voltage (1.8V vs 3.3V) is a
platform-specific issue, as are models like (not) having a one-to-one
correspondence between configurable pins and GPIOs.</p>
<p>There are other system-specific mechanisms that are not specified here,
like the aforementioned options for input de-glitching and wire-OR output.
Hardware may support reading or writing GPIOs in gangs, but that's usually
configuration dependent:  for GPIOs sharing the same bank.  (GPIOs are
commonly grouped in banks of 16 or 32, with a given SOC having several such
banks.)  Some systems can trigger IRQs from output GPIOs, or read values
from pins not managed as GPIOs.  Code relying on such mechanisms will
necessarily be nonportable.</p>
<p>Dynamic definition of GPIOs is not currently standard; for example, as
a side effect of configuring an add-on board with some GPIO expanders.</p>
</section>
<section id="gpio-implementor-s-framework-optional">
<h2>GPIO implementor's framework (OPTIONAL)<a class="headerlink" href="#gpio-implementor-s-framework-optional" title="Permalink to this heading">¶</a></h2>
<p>As noted earlier, there is an optional implementation framework making it
easier for platforms to support different kinds of GPIO controller using
the same programming interface.  This framework is called &quot;gpiolib&quot;.</p>
<p>As a debugging aid, if debugfs is available a /sys/kernel/debug/gpio file
will be found there.  That will list all the controllers registered through
this framework, and the state of the GPIOs currently in use.</p>
<section id="controller-drivers-gpio-chip">
<h3>Controller Drivers: gpio_chip<a class="headerlink" href="#controller-drivers-gpio-chip" title="Permalink to this heading">¶</a></h3>
<p>In this framework each GPIO controller is packaged as a &quot;<a class="reference internal" href="index.html#c.gpio_chip" title="gpio_chip"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a>&quot;
with information common to each controller of that type:</p>
<blockquote>
<div><ul class="simple">
<li><p>methods to establish GPIO direction</p></li>
<li><p>methods used to access GPIO values</p></li>
<li><p>flag saying whether calls to its methods may sleep</p></li>
<li><p>optional debugfs dump method (showing extra state like pullup config)</p></li>
<li><p>label for diagnostics</p></li>
</ul>
</div></blockquote>
<p>There is also per-instance data, which may come from device.platform_data:
the number of its first GPIO, and how many GPIOs it exposes.</p>
<p>The code implementing a gpio_chip should support multiple instances of the
controller, possibly using the driver model.  That code will configure each
gpio_chip and issue gpiochip_add().  Removing a GPIO controller should be
rare; use <a class="reference internal" href="index.html#c.gpiochip_remove" title="gpiochip_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_remove()</span></code></a> when it is unavoidable.</p>
<p>Most often a gpio_chip is part of an instance-specific structure with state
not exposed by the GPIO interfaces, such as addressing, power management,
and more.  Chips such as codecs will have complex non-GPIO state.</p>
<p>Any debugfs dump method should normally ignore signals which haven't been
requested as GPIOs.  They can use gpiochip_is_requested(), which returns
either NULL or the label associated with that GPIO when it was requested.</p>
</section>
<section id="platform-support">
<h3>Platform Support<a class="headerlink" href="#platform-support" title="Permalink to this heading">¶</a></h3>
<p>To force-enable this framework, a platform's Kconfig will &quot;select&quot; GPIOLIB,
else it is up to the user to configure support for GPIO.</p>
<p>If neither of these options are selected, the platform does not support
GPIOs through GPIO-lib and the code cannot be enabled by the user.</p>
<p>Trivial implementations of those functions can directly use framework
code, which always dispatches through the gpio_chip:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define gpio_get_value        __gpio_get_value
#define gpio_set_value        __gpio_set_value
</pre></div>
</div>
<p>Fancier implementations could instead define those as inline functions with
logic optimizing access to specific SOC-based GPIOs.  For example, if the
referenced GPIO is the constant &quot;12&quot;, getting or setting its value could
cost as little as two or three instructions, never sleeping.  When such an
optimization is not possible those calls must delegate to the framework
code, costing at least a few dozen instructions.  For bitbanged I/O, such
instruction savings can be significant.</p>
<p>For SOCs, platform-specific code defines and registers gpio_chip instances
for each bank of on-chip GPIOs.  Those GPIOs should be numbered/labeled to
match chip vendor documentation, and directly match board schematics.  They
may well start at zero and go up to a platform-specific limit.  Such GPIOs
are normally integrated into platform initialization to make them always be
available, from arch_initcall() or earlier; they can often serve as IRQs.</p>
</section>
<section id="board-support">
<h3>Board Support<a class="headerlink" href="#board-support" title="Permalink to this heading">¶</a></h3>
<p>For external GPIO controllers -- such as I2C or SPI expanders, ASICs, multi
function devices, FPGAs or CPLDs -- most often board-specific code handles
registering controller devices and ensures that their drivers know what GPIO
numbers to use with gpiochip_add().  Their numbers often start right after
platform-specific GPIOs.</p>
<p>For example, board setup code could create structures identifying the range
of GPIOs that chip will expose, and passes them to each GPIO expander chip
using platform_data.  Then the chip driver's probe() routine could pass that
data to gpiochip_add().</p>
<p>Initialization order can be important.  For example, when a device relies on
an I2C-based GPIO, its probe() routine should only be called after that GPIO
becomes available.  That may mean the device should not be registered until
calls for that GPIO can work.  One way to address such dependencies is for
such gpio_chip controllers to provide setup() and teardown() callbacks to
board specific code; those board specific callbacks would register devices
once all the necessary resources are available, and remove them later when
the GPIO controller device becomes unavailable.</p>
</section>
</section>
<section id="sysfs-interface-for-userspace-optional">
<h2>Sysfs Interface for Userspace (OPTIONAL)<a class="headerlink" href="#sysfs-interface-for-userspace-optional" title="Permalink to this heading">¶</a></h2>
<p>Platforms which use the &quot;gpiolib&quot; implementors framework may choose to
configure a sysfs user interface to GPIOs.  This is different from the
debugfs interface, since it provides control over GPIO direction and
value instead of just showing a gpio state summary.  Plus, it could be
present on production systems without debugging support.</p>
<p>Given appropriate hardware documentation for the system, userspace could
know for example that GPIO #23 controls the write protect line used to
protect boot loader segments in flash memory.  System upgrade procedures
may need to temporarily remove that protection, first importing a GPIO,
then changing its output state, then updating the code before re-enabling
the write protection.  In normal use, GPIO #23 would never be touched,
and the kernel would have no need to know about it.</p>
<p>Again depending on appropriate hardware documentation, on some systems
userspace GPIO can be used to determine system configuration data that
standard kernels won't know about.  And for some tasks, simple userspace
GPIO drivers could be all that the system really needs.</p>
<p>Note that standard kernel drivers exist for common &quot;LEDs and Buttons&quot;
GPIO tasks:  &quot;leds-gpio&quot; and &quot;gpio_keys&quot;, respectively.  Use those
instead of talking directly to the GPIOs; they integrate with kernel
frameworks better than your userspace code could.</p>
<section id="paths-in-sysfs">
<h3>Paths in Sysfs<a class="headerlink" href="#paths-in-sysfs" title="Permalink to this heading">¶</a></h3>
<p>There are three kinds of entry in /sys/class/gpio:</p>
<blockquote>
<div><ul class="simple">
<li><p>Control interfaces used to get userspace control over GPIOs;</p></li>
<li><p>GPIOs themselves; and</p></li>
<li><p>GPIO controllers (&quot;gpio_chip&quot; instances).</p></li>
</ul>
</div></blockquote>
<p>That's in addition to standard files including the &quot;device&quot; symlink.</p>
<p>The control interfaces are write-only:</p>
<blockquote>
<div><p>/sys/class/gpio/</p>
<blockquote>
<div><dl>
<dt>&quot;export&quot; ... Userspace may ask the kernel to export control of</dt><dd><p>a GPIO to userspace by writing its number to this file.</p>
<p>Example:  &quot;echo 19 &gt; export&quot; will create a &quot;gpio19&quot; node
for GPIO #19, if that's not requested by kernel code.</p>
</dd>
</dl>
<p>&quot;unexport&quot; ... Reverses the effect of exporting to userspace.</p>
<blockquote>
<div><p>Example:  &quot;echo 19 &gt; unexport&quot; will remove a &quot;gpio19&quot;
node exported using the &quot;export&quot; file.</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>GPIO signals have paths like /sys/class/gpio/gpio42/ (for GPIO #42)
and have the following read/write attributes:</p>
<blockquote>
<div><p>/sys/class/gpio/gpioN/</p>
<blockquote>
<div><dl>
<dt>&quot;direction&quot; ... reads as either &quot;in&quot; or &quot;out&quot;.  This value may</dt><dd><p>normally be written.  Writing as &quot;out&quot; defaults to
initializing the value as low.  To ensure glitch free
operation, values &quot;low&quot; and &quot;high&quot; may be written to
configure the GPIO as an output with that initial value.</p>
<p>Note that this attribute <em>will not exist</em> if the kernel
doesn't support changing the direction of a GPIO, or
it was exported by kernel code that didn't explicitly
allow userspace to reconfigure this GPIO's direction.</p>
</dd>
<dt>&quot;value&quot; ... reads as either 0 (low) or 1 (high).  If the GPIO</dt><dd><p>is configured as an output, this value may be written;
any nonzero value is treated as high.</p>
<p>If the pin can be configured as interrupt-generating interrupt
and if it has been configured to generate interrupts (see the
description of &quot;edge&quot;), you can poll(2) on that file and
poll(2) will return whenever the interrupt was triggered. If
you use poll(2), set the events POLLPRI. If you use select(2),
set the file descriptor in exceptfds. After poll(2) returns,
either lseek(2) to the beginning of the sysfs file and read the
new value or close the file and re-open it to read the value.</p>
</dd>
<dt>&quot;edge&quot; ... reads as either &quot;none&quot;, &quot;rising&quot;, &quot;falling&quot;, or</dt><dd><p>&quot;both&quot;. Write these strings to select the signal edge(s)
that will make poll(2) on the &quot;value&quot; file return.</p>
<p>This file exists only if the pin can be configured as an
interrupt generating input pin.</p>
</dd>
<dt>&quot;active_low&quot; ... reads as either 0 (false) or 1 (true).  Write</dt><dd><p>any nonzero value to invert the value attribute both
for reading and writing.  Existing and subsequent
poll(2) support configuration via the edge attribute
for &quot;rising&quot; and &quot;falling&quot; edges will follow this
setting.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>GPIO controllers have paths like /sys/class/gpio/gpiochip42/ (for the
controller implementing GPIOs starting at #42) and have the following
read-only attributes:</p>
<blockquote>
<div><p>/sys/class/gpio/gpiochipN/</p>
<blockquote>
<div><p>&quot;base&quot; ... same as N, the first GPIO managed by this chip</p>
<p>&quot;label&quot; ... provided for diagnostics (not always unique)</p>
<p>&quot;ngpio&quot; ... how many GPIOs this manges (N to N + ngpio - 1)</p>
</div></blockquote>
</div></blockquote>
<p>Board documentation should in most cases cover what GPIOs are used for
what purposes.  However, those numbers are not always stable; GPIOs on
a daughtercard might be different depending on the base board being used,
or other cards in the stack.  In such cases, you may need to use the
gpiochip nodes (possibly in conjunction with schematics) to determine
the correct GPIO number to use for a given signal.</p>
</section>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this heading">¶</a></h2>
<p>The functions listed in this section are deprecated. The GPIO descriptor based
API should be used in new code.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.gpio_request_one">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gpio_request_one</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">gpio</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">label</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_request_one" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request a single GPIO with initial configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt><dd><p>the GPIO number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>GPIO configuration as specified by GPIOF_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>a literal description string of this GPIO</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.gpio_request_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gpio_request_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gpio</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">array</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_request_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request multiple GPIOs in a single call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio</span> <span class="pre">*array</span></code></dt><dd><p>array of the 'struct gpio'</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>how many GPIOs in the array</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.gpio_free_array">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gpio_free_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gpio</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">array</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_free_array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release multiple GPIOs in a single call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio</span> <span class="pre">*array</span></code></dt><dd><p>array of the 'struct gpio'</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>how many GPIOs in the array</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/gpio/legacy.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>