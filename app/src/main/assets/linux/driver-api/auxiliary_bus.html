<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Auxiliary Bus &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Compute Express Link" href="cxl/index.html" />
    <link rel="prev" title="VFIO - “Virtual Function I/O”" href="vfio.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.13.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Auxiliary Bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l3"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l3"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l3"><a class="reference internal" href="virtio/index.html">Virtio</a></li>
<li class="toctree-l3"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/auxiliary_bus.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="auxiliary-bus">
<span id="id1"></span><h1>Auxiliary Bus<a class="headerlink" href="#auxiliary-bus" title="Link to this heading">¶</a></h1>
<p>In some subsystems, the functionality of the core device (PCI/ACPI/other) is
too complex for a single device to be managed by a monolithic driver (e.g.
Sound Open Firmware), multiple devices might implement a common intersection
of functionality (e.g. NICs + RDMA), or a driver may want to export an
interface for another subsystem to drive (e.g. SIOV Physical Function export
Virtual Function management).  A split of the functionality into child-
devices representing sub-domains of functionality makes it possible to
compartmentalize, layer, and distribute domain-specific concerns via a Linux
device-driver model.</p>
<p>An example for this kind of requirement is the audio subsystem where a
single IP is handling multiple entities such as HDMI, Soundwire, local
devices such as mics/speakers etc. The split for the core’s functionality
can be arbitrary or be defined by the DSP firmware topology and include
hooks for test/debug. This allows for the audio core device to be minimal
and focused on hardware-specific control and communication.</p>
<p>Each auxiliary_device represents a part of its parent functionality. The
generic behavior can be extended and specialized as needed by encapsulating
an auxiliary_device within other domain-specific structures and the use of
.ops callbacks. Devices on the auxiliary bus do not share any structures and
the use of a communication channel with the parent is domain-specific.</p>
<p>Note that ops are intended as a way to augment instance behavior within a
class of auxiliary devices, it is not the mechanism for exporting common
infrastructure from the parent. Consider EXPORT_SYMBOL_NS() to convey
infrastructure from the parent module to the auxiliary module(s).</p>
<section id="when-should-the-auxiliary-bus-be-used">
<h2>When Should the Auxiliary Bus Be Used<a class="headerlink" href="#when-should-the-auxiliary-bus-be-used" title="Link to this heading">¶</a></h2>
<p>The auxiliary bus is to be used when a driver and one or more kernel
modules, who share a common header file with the driver, need a mechanism to
connect and provide access to a shared object allocated by the
auxiliary_device’s registering driver.  The registering driver for the
auxiliary_device(s) and the kernel module(s) registering auxiliary_drivers
can be from the same subsystem, or from multiple subsystems.</p>
<p>The emphasis here is on a common generic interface that keeps subsystem
customization out of the bus infrastructure.</p>
<p>One example is a PCI network device that is RDMA-capable and exports a child
device to be driven by an auxiliary_driver in the RDMA subsystem.  The PCI
driver allocates and registers an auxiliary_device for each physical
function on the NIC.  The RDMA driver registers an auxiliary_driver that
claims each of these auxiliary_devices.  This conveys data/ops published by
the parent PCI device/driver to the RDMA auxiliary_driver.</p>
<p>Another use case is for the PCI device to be split out into multiple sub
functions.  For each sub function an auxiliary_device is created.  A PCI sub
function driver binds to such devices that creates its own one or more class
devices.  A PCI sub function auxiliary device is likely to be contained in a
struct with additional attributes such as user defined sub function number
and optional attributes such as resources and a link to the parent device.
These attributes could be used by systemd/udev; and hence should be
initialized before a driver binds to an auxiliary_device.</p>
<p>A key requirement for utilizing the auxiliary bus is that there is no
dependency on a physical bus, device, register accesses or regmap support.
These individual devices split from the core cannot live on the platform bus
as they are not physical devices that are controlled by DT/ACPI.  The same
argument applies for not using MFD in this scenario as MFD relies on
individual function devices being physical devices.</p>
</section>
<section id="auxiliary-device-creation">
<h2>Auxiliary Device Creation<a class="headerlink" href="#auxiliary-device-creation" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.auxiliary_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">auxiliary_device</span></span></span><a class="headerlink" href="#c.auxiliary_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>auxiliary device object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct auxiliary_device {
    struct device dev;
    const char *name;
    u32 id;
    struct {
        struct xarray irqs;
        struct mutex lock;
        bool irq_dir_exists;
    } sysfs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device,
The release and parent fields of the device structure must be filled
in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Match name found by the auxiliary device driver,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique identitier if multiple devices of the same name are exported,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs</span></code></dt><dd><p>embedded struct which hold all sysfs related fields,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs.irqs</span></code></dt><dd><p>irqs xarray contains irq indices which are used by the device,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs.lock</span></code></dt><dd><p>Synchronize irq sysfs creation,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs.irq_dir_exists</span></code></dt><dd><p>whether “irqs” directory exists,</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>An auxiliary_device represents a part of its parent device’s functionality.
It is given a name that, combined with the registering drivers
KBUILD_MODNAME, creates a match_name that is used for driver binding, and an
id that combined with the match_name provide a unique name to register with
the bus subsystem.  For example, a driver registering an auxiliary device is
named ‘foo_mod.ko’ and the subdevice is named ‘foo_dev’.  The match name is
therefore ‘foo_mod.foo_dev’.</p>
<p>Registering an auxiliary_device is a three-step process.</p>
<p>First, a ‘<a class="reference internal" href="#c.auxiliary_device" title="auxiliary_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">auxiliary_device</span></code></a>’ needs to be defined or allocated for each
sub-device desired.  The name, id, dev.release, and dev.parent fields of
this structure must be filled in as follows.</p>
<p>The ‘name’ field is to be given a name that is recognized by the auxiliary
driver.  If two auxiliary_devices with the same match_name, eg
“foo_mod.foo_dev”, are registered onto the bus, they must have unique id
values (e.g. “x” and “y”) so that the registered devices names are
“foo_mod.foo_dev.x” and “foo_mod.foo_dev.y”.  If match_name + id are not
unique, then the device_add fails and generates an error message.</p>
<p>The auxiliary_device.dev.type.release or auxiliary_device.dev.release must
be populated with a non-NULL pointer to successfully register the
auxiliary_device.  This release call is where resources associated with the
auxiliary device must be free’ed.  Because once the device is placed on the
bus the parent driver can not tell what other code may have a reference to
this data.</p>
<p>The auxiliary_device.dev.parent should be set.  Typically to the registering
drivers device.</p>
<p>Second, call <a class="reference internal" href="#c.auxiliary_device_init" title="auxiliary_device_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">auxiliary_device_init()</span></code></a>, which checks several aspects of the
auxiliary_device struct and performs a <a class="reference internal" href="infrastructure.html#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a>.  After this step
completes, any error state must have a call to auxiliary_device_uninit() in
its resolution path.</p>
<p>The third and final step in registering an auxiliary_device is to perform a
call to auxiliary_device_add(), which sets the name of the device and adds
the device to the bus.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MY_DEVICE_NAME &quot;foo_dev&quot;</span>

<span class="p">...</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_device</span><span class="w"> </span><span class="o">*</span><span class="n">my_aux_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_aux_dev_alloc</span><span class="p">(</span><span class="n">xxx</span><span class="p">);</span>

<span class="c1">// Step 1:</span>
<span class="n">my_aux_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_DEVICE_NAME</span><span class="p">;</span>
<span class="n">my_aux_dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_unique_id_alloc</span><span class="p">(</span><span class="n">xxx</span><span class="p">);</span>
<span class="n">my_aux_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_aux_dev_release</span><span class="p">;</span>
<span class="n">my_aux_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_dev</span><span class="p">;</span>

<span class="c1">// Step 2:</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">auxiliary_device_init</span><span class="p">(</span><span class="n">my_aux_dev</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span>

<span class="c1">// Step 3:</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">auxiliary_device_add</span><span class="p">(</span><span class="n">my_aux_dev</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">auxiliary_device_uninit</span><span class="p">(</span><span class="n">my_aux_dev</span><span class="p">);</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>
</pre></div>
</div>
<p>Unregistering an auxiliary_device is a two-step process to mirror the
register process.  First call auxiliary_device_delete(), then call
auxiliary_device_uninit().</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">auxiliary_device_delete</span><span class="p">(</span><span class="n">my_dev</span><span class="o">-&gt;</span><span class="n">my_aux_dev</span><span class="p">);</span>
<span class="n">auxiliary_device_uninit</span><span class="p">(</span><span class="n">my_dev</span><span class="o">-&gt;</span><span class="n">my_aux_dev</span><span class="p">);</span>
</pre></div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.auxiliary_device_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">auxiliary_device_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.auxiliary_device" title="auxiliary_device"><span class="n"><span class="pre">auxiliary_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">auxdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.auxiliary_device_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>check auxiliary_device and initialize</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">auxiliary_device</span> <span class="pre">*auxdev</span></code></dt><dd><p>auxiliary device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the second step in the three-step process to register an
auxiliary_device.</p>
<p>When this function returns an error code, then the device_initialize will
<em>not</em> have been performed, and the caller will be responsible to free any
memory allocated for the auxiliary_device in the error path directly.</p>
<p>It returns 0 on success.  On success, the device_initialize has been
performed.  After this point any error unwinding will need to include a call
to auxiliary_device_uninit().  In this post-initialize error scenario, a call
to the device’s .release callback will be triggered, and all memory clean-up
is expected to be handled there.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__auxiliary_device_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__auxiliary_device_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.auxiliary_device" title="auxiliary_device"><span class="n"><span class="pre">auxiliary_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">auxdev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">modname</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__auxiliary_device_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add an auxiliary bus device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">auxiliary_device</span> <span class="pre">*auxdev</span></code></dt><dd><p>auxiliary bus device to add to the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*modname</span></code></dt><dd><p>name of the parent device’s driver module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the third step in the three-step process to register an
auxiliary_device.</p>
<p>This function must be called after a successful call to
<a class="reference internal" href="#c.auxiliary_device_init" title="auxiliary_device_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">auxiliary_device_init()</span></code></a>, which will perform the device_initialize.  This
means that if this returns an error code, then a call to
auxiliary_device_uninit() must be performed so that the .release callback
will be triggered to free the memory associated with the auxiliary_device.</p>
<p>The expectation is that users will call the “auxiliary_device_add” macro so
that the caller’s KBUILD_MODNAME is automatically inserted for the modname
parameter.  Only if a user requires a custom name would this version be
called directly.</p>
</div>
<section id="auxiliary-device-memory-model-and-lifespan">
<h3>Auxiliary Device Memory Model and Lifespan<a class="headerlink" href="#auxiliary-device-memory-model-and-lifespan" title="Link to this heading">¶</a></h3>
<p>The registering driver is the entity that allocates memory for the
auxiliary_device and registers it on the auxiliary bus.  It is important to
note that, as opposed to the platform bus, the registering driver is wholly
responsible for the management of the memory used for the device object.</p>
<p>To be clear the memory for the auxiliary_device is freed in the release()
callback defined by the registering driver.  The registering driver should
only call auxiliary_device_delete() and then auxiliary_device_uninit() when
it is done with the device.  The release() function is then automatically
called if and when other code releases their reference to the devices.</p>
<p>A parent object, defined in the shared header file, contains the
auxiliary_device.  It also contains a pointer to the shared object(s), which
also is defined in the shared header.  Both the parent object and the shared
object(s) are allocated by the registering driver.  This layout allows the
auxiliary_driver’s registering module to perform a container_of() call to go
from the pointer to the auxiliary_device, that is passed during the call to
the auxiliary_driver’s probe function, up to the parent object, and then
have access to the shared object(s).</p>
<p>The memory for the shared object(s) must have a lifespan equal to, or
greater than, the lifespan of the memory for the auxiliary_device.  The
auxiliary_driver should only consider that the shared object is valid as
long as the auxiliary_device is still registered on the auxiliary bus.  It
is up to the registering driver to manage (e.g. free or keep available) the
memory for the shared object beyond the life of the auxiliary_device.</p>
<p>The registering driver must unregister all auxiliary devices before its own
driver.remove() is completed.  An easy way to ensure this is to use the
devm_add_action_or_reset() call to register a function against the parent
device which unregisters the auxiliary device object(s).</p>
<p>Finally, any operations which operate on the auxiliary devices must continue
to function (if only to return an error) after the registering driver
unregisters the auxiliary device.</p>
</section>
</section>
<section id="auxiliary-drivers">
<h2>Auxiliary Drivers<a class="headerlink" href="#auxiliary-drivers" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.auxiliary_driver">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">auxiliary_driver</span></span></span><a class="headerlink" href="#c.auxiliary_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>Definition of an auxiliary bus driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct auxiliary_driver {
    int (*probe)(struct auxiliary_device *auxdev, const struct auxiliary_device_id *id);
    void (*remove)(struct auxiliary_device *auxdev);
    void (*shutdown)(struct auxiliary_device *auxdev);
    int (*suspend)(struct auxiliary_device *auxdev, pm_message_t state);
    int (*resume)(struct auxiliary_device *auxdev);
    const char *name;
    struct device_driver driver;
    const struct auxiliary_device_id *id_table;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Called when a matching device is added to the bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>Called when device is removed from the bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>Called at shut-down time to quiesce the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Called to put the device to sleep mode. Usually to a power state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Called to bring a device from sleep mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Driver name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>Core driver structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_table</span></code></dt><dd><p>Table of devices this driver should match on the bus.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Auxiliary drivers follow the standard driver model convention, where
discovery/enumeration is handled by the core, and drivers provide probe()
and remove() methods. They support power management and shutdown
notifications using the standard conventions.</p>
<p>Auxiliary drivers register themselves with the bus by calling
auxiliary_driver_register(). The id_table contains the match_names of
auxiliary devices that a driver can bind with.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_device_id</span><span class="w"> </span><span class="n">my_auxiliary_id_table</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo_mod.foo_dev&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">{},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">auxiliary</span><span class="p">,</span><span class="w"> </span><span class="n">my_auxiliary_id_table</span><span class="p">);</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_driver</span><span class="w"> </span><span class="n">my_drv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;myauxiliarydrv&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">id_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_auxiliary_id_table</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_drv_probe</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_drv_remove</span>
<span class="p">};</span>
</pre></div>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.module_auxiliary_driver">
<span class="sig-name descname"><span class="n"><span class="pre">module_auxiliary_driver</span></span></span><a class="headerlink" href="#c.module_auxiliary_driver" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">module_auxiliary_driver</span> <span class="pre">(__auxiliary_driver)</span></code></p>
<blockquote>
<div><p>Helper macro for registering an auxiliary driver</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__auxiliary_driver</span></code></dt><dd><p>auxiliary driver struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for auxiliary drivers which do not do anything special in
module init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">module_auxiliary_driver</span><span class="p">(</span><span class="n">my_drv</span><span class="p">);</span>
</pre></div>
</div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__auxiliary_driver_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__auxiliary_driver_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.auxiliary_driver" title="auxiliary_driver"><span class="n"><span class="pre">auxiliary_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">auxdrv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">modname</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__auxiliary_driver_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a driver for auxiliary bus devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">auxiliary_driver</span> <span class="pre">*auxdrv</span></code></dt><dd><p>auxiliary_driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owning module/driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*modname</span></code></dt><dd><p>KBUILD_MODNAME for parent driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The expectation is that users will call the “auxiliary_driver_register”
macro so that the caller’s KBUILD_MODNAME is automatically inserted for the
modname parameter.  Only if a user requires a custom name would this version
be called directly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.auxiliary_driver_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">auxiliary_driver_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.auxiliary_driver" title="auxiliary_driver"><span class="n"><span class="pre">auxiliary_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">auxdrv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.auxiliary_driver_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">auxiliary_driver</span> <span class="pre">*auxdrv</span></code></dt><dd><p>auxiliary_driver structure</p>
</dd>
</dl>
</div>
</section>
<section id="example-usage">
<h2>Example Usage<a class="headerlink" href="#example-usage" title="Link to this heading">¶</a></h2>
<p>Auxiliary devices are created and registered by a subsystem-level core
device that needs to break up its functionality into smaller fragments. One
way to extend the scope of an auxiliary_device is to encapsulate it within a
domain-specific structure defined by the parent device. This structure
contains the auxiliary_device and any associated shared data/callbacks
needed to establish the connection with the parent.</p>
<p>An example is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_device</span><span class="w"> </span><span class="n">auxdev</span><span class="p">;</span>
<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_device</span><span class="w"> </span><span class="o">*</span><span class="n">auxdev</span><span class="p">);</span>
<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_device</span><span class="w"> </span><span class="o">*</span><span class="n">auxdev</span><span class="p">);</span>
<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The parent device then registers the auxiliary_device by calling
<a class="reference internal" href="#c.auxiliary_device_init" title="auxiliary_device_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">auxiliary_device_init()</span></code></a>, and then auxiliary_device_add(), with the pointer
to the auxdev member of the above structure. The parent provides a name for
the auxiliary_device that, combined with the parent’s KBUILD_MODNAME,
creates a match_name that is be used for matching and binding with a driver.</p>
<p>Whenever an auxiliary_driver is registered, based on the match_name, the
auxiliary_driver’s probe() is invoked for the matching devices.  The
auxiliary_driver can also be encapsulated inside custom drivers that make
the core device’s functionality extensible by adding additional
domain-specific ops as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">my_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">send</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_device</span><span class="w"> </span><span class="o">*</span><span class="n">auxdev</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">receive</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_device</span><span class="w"> </span><span class="o">*</span><span class="n">auxdev</span><span class="p">);</span>
<span class="p">};</span>


<span class="k">struct</span><span class="w"> </span><span class="nc">my_driver</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_driver</span><span class="w"> </span><span class="n">auxiliary_drv</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_ops</span><span class="w"> </span><span class="n">ops</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>An example of this type of usage is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">auxiliary_device_id</span><span class="w"> </span><span class="n">my_auxiliary_id_table</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo_mod.foo_dev&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_ops</span><span class="w"> </span><span class="n">my_custom_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_tx</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">receive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_rx</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_driver</span><span class="w"> </span><span class="n">my_drv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">auxiliary_drv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;myauxiliarydrv&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">id_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_auxiliary_id_table</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_probe</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_remove</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">shutdown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_shutdown</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_custom_ops</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/auxiliary_bus.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>