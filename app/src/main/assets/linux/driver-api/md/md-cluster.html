<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>MD Cluster &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="RAID 4/5/6 cache" href="raid5-cache.html" />
    <link rel="prev" title="RAID" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.13.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/md/md-cluster.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="md-cluster">
<h1>MD Cluster<a class="headerlink" href="#md-cluster" title="Link to this heading">¶</a></h1>
<p>The cluster MD is a shared-device RAID for a cluster, it supports
two levels: raid1 and raid10 (limited support).</p>
<section id="on-disk-format">
<h2>1. On-disk format<a class="headerlink" href="#on-disk-format" title="Link to this heading">¶</a></h2>
<p>Separate write-intent-bitmaps are used for each cluster node.
The bitmaps record all writes that may have been started on that node,
and may not yet have finished. The on-disk layout is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0                    4k                     8k                    12k
-------------------------------------------------------------------
| idle                | md super            | bm super [0] + bits |
| bm bits[0, contd]   | bm super[1] + bits  | bm bits[1, contd]   |
| bm super[2] + bits  | bm bits [2, contd]  | bm super[3] + bits  |
| bm bits [3, contd]  |                     |                     |
</pre></div>
</div>
<p>During “normal” functioning we assume the filesystem ensures that only
one node writes to any given block at a time, so a write request will</p>
<blockquote>
<div><ul class="simple">
<li><p>set the appropriate bit (if not already set)</p></li>
<li><p>commit the write to all mirrors</p></li>
<li><p>schedule the bit to be cleared after a timeout.</p></li>
</ul>
</div></blockquote>
<p>Reads are just handled normally. It is up to the filesystem to ensure
one node doesn’t read from a location where another node (or the same
node) is writing.</p>
</section>
<section id="dlm-locks-for-management">
<h2>2. DLM Locks for management<a class="headerlink" href="#dlm-locks-for-management" title="Link to this heading">¶</a></h2>
<p>There are three groups of locks for managing the device:</p>
<section id="bitmap-lock-resource-bm-lockres">
<h3>2.1 Bitmap lock resource (bm_lockres)<a class="headerlink" href="#bitmap-lock-resource-bm-lockres" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>The bm_lockres protects individual node bitmaps. They are named in
the form bitmap000 for node 1, bitmap001 for node 2 and so on. When a
node joins the cluster, it acquires the lock in PW mode and it stays
so during the lifetime the node is part of the cluster. The lock
resource number is based on the slot number returned by the DLM
subsystem. Since DLM starts node count from one and bitmap slots
start from zero, one is subtracted from the DLM slot number to arrive
at the bitmap slot number.</p>
<p>The LVB of the bitmap lock for a particular node records the range
of sectors that are being re-synced by that node.  No other
node may write to those sectors.  This is used when a new nodes
joins the cluster.</p>
</div></blockquote>
</section>
<section id="message-passing-locks">
<h3>2.2 Message passing locks<a class="headerlink" href="#message-passing-locks" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Each node has to communicate with other nodes when starting or ending
resync, and for metadata superblock updates.  This communication is
managed through three locks: “token”, “message”, and “ack”, together
with the Lock Value Block (LVB) of one of the “message” lock.</p>
</div></blockquote>
</section>
<section id="new-device-management">
<h3>2.3 new-device management<a class="headerlink" href="#new-device-management" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>A single lock: “no-new-dev” is used to coordinate the addition of
new devices - this must be synchronized across the array.
Normally all nodes hold a concurrent-read lock on this device.</p>
</div></blockquote>
</section>
</section>
<section id="communication">
<h2>3. Communication<a class="headerlink" href="#communication" title="Link to this heading">¶</a></h2>
<blockquote>
<div><p>Messages can be broadcast to all nodes, and the sender waits for all
other nodes to acknowledge the message before proceeding.  Only one
message can be processed at a time.</p>
</div></blockquote>
<section id="message-types">
<h3>3.1 Message Types<a class="headerlink" href="#message-types" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>There are six types of messages which are passed:</p>
</div></blockquote>
<section id="metadata-updated">
<h4>3.1.1 METADATA_UPDATED<a class="headerlink" href="#metadata-updated" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>informs other nodes that the metadata has
been updated, and the node must re-read the md superblock. This is
performed synchronously. It is primarily used to signal device
failure.</p>
</div></blockquote>
</section>
<section id="resyncing">
<h4>3.1.2 RESYNCING<a class="headerlink" href="#resyncing" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>informs other nodes that a resync is initiated or
ended so that each node may suspend or resume the region.  Each
RESYNCING message identifies a range of the devices that the
sending node is about to resync. This overrides any previous
notification from that node: only one ranged can be resynced at a
time per-node.</p>
</div></blockquote>
</section>
<section id="newdisk">
<h4>3.1.3 NEWDISK<a class="headerlink" href="#newdisk" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>informs other nodes that a device is being added to
the array. Message contains an identifier for that device.  See
below for further details.</p>
</div></blockquote>
</section>
<section id="remove">
<h4>3.1.4 REMOVE<a class="headerlink" href="#remove" title="Link to this heading">¶</a></h4>
<blockquote>
<div><blockquote>
<div><p>A failed or spare device is being removed from the
array. The slot-number of the device is included in the message.</p>
</div></blockquote>
<p>3.1.5 RE_ADD:</p>
<blockquote>
<div><p>A failed device is being re-activated - the assumption
is that it has been determined to be working again.</p>
</div></blockquote>
<p>3.1.6 BITMAP_NEEDS_SYNC:</p>
<blockquote>
<div><p>If a node is stopped locally but the bitmap
isn’t clean, then another node is informed to take the ownership of
resync.</p>
</div></blockquote>
</div></blockquote>
</section>
</section>
<section id="communication-mechanism">
<h3>3.2 Communication mechanism<a class="headerlink" href="#communication-mechanism" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>The DLM LVB is used to communicate within nodes of the cluster. There
are three resources used for the purpose:</p>
</div></blockquote>
<section id="token">
<h4>3.2.1 token<a class="headerlink" href="#token" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>The resource which protects the entire communication
system. The node having the token resource is allowed to
communicate.</p>
</div></blockquote>
</section>
<section id="message">
<h4>3.2.2 message<a class="headerlink" href="#message" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>The lock resource which carries the data to communicate.</p>
</div></blockquote>
</section>
<section id="ack">
<h4>3.2.3 ack<a class="headerlink" href="#ack" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>The resource, acquiring which means the message has been
acknowledged by all nodes in the cluster. The BAST of the resource
is used to inform the receiving node that a node wants to
communicate.</p>
</div></blockquote>
<p>The algorithm is:</p>
<blockquote>
<div><ol class="arabic">
<li><p>receive status - all nodes have concurrent-reader lock on “ack”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sender                         receiver                 receiver
&quot;ack&quot;:CR                       &quot;ack&quot;:CR                 &quot;ack&quot;:CR
</pre></div>
</div>
</li>
<li><p>sender get EX on “token”,
sender get EX on “message”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sender                        receiver                 receiver
&quot;token&quot;:EX                    &quot;ack&quot;:CR                 &quot;ack&quot;:CR
&quot;message&quot;:EX
&quot;ack&quot;:CR
</pre></div>
</div>
<p>Sender checks that it still needs to send a message. Messages
received or other events that happened while waiting for the
“token” may have made this message inappropriate or redundant.</p>
</li>
<li><p>sender writes LVB</p>
<p>sender down-convert “message” from EX to CW</p>
<p>sender try to get EX of “ack”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> [ wait until all receivers have *processed* the &quot;message&quot; ]

                                  [ triggered by bast of &quot;ack&quot; ]
                                  receiver get CR on &quot;message&quot;
                                  receiver read LVB
                                  receiver processes the message
                                  [ wait finish ]
                                  receiver releases &quot;ack&quot;
                                  receiver tries to get PR on &quot;message&quot;

sender                         receiver                  receiver
&quot;token&quot;:EX                     &quot;message&quot;:CR              &quot;message&quot;:CR
&quot;message&quot;:CW
&quot;ack&quot;:EX
</pre></div>
</div>
</li>
<li><p>triggered by grant of EX on “ack” (indicating all receivers
have processed message)</p>
<p>sender down-converts “ack” from EX to CR</p>
<p>sender releases “message”</p>
<p>sender releases “token”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                            receiver upconvert to PR on &quot;message&quot;
                            receiver get CR of &quot;ack&quot;
                            receiver release &quot;message&quot;

sender                      receiver                   receiver
&quot;ack&quot;:CR                    &quot;ack&quot;:CR                   &quot;ack&quot;:CR
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</section>
</section>
</section>
<section id="handling-failures">
<h2>4. Handling Failures<a class="headerlink" href="#handling-failures" title="Link to this heading">¶</a></h2>
<section id="node-failure">
<h3>4.1 Node Failure<a class="headerlink" href="#node-failure" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>When a node fails, the DLM informs the cluster with the slot
number. The node starts a cluster recovery thread. The cluster
recovery thread:</p>
<blockquote>
<div><ul class="simple">
<li><p>acquires the bitmap&lt;number&gt; lock of the failed node</p></li>
<li><p>opens the bitmap</p></li>
<li><p>reads the bitmap of the failed node</p></li>
<li><p>copies the set bitmap to local node</p></li>
<li><p>cleans the bitmap of the failed node</p></li>
<li><p>releases bitmap&lt;number&gt; lock of the failed node</p></li>
<li><p>initiates resync of the bitmap on the current node
md_check_recovery is invoked within recover_bitmaps,
then md_check_recovery -&gt; metadata_update_start/finish,
it will lock the communication by lock_comm.
Which means when one node is resyncing it blocks all
other nodes from writing anywhere on the array.</p></li>
</ul>
</div></blockquote>
<p>The resync process is the regular md resync. However, in a clustered
environment when a resync is performed, it needs to tell other nodes
of the areas which are suspended. Before a resync starts, the node
send out RESYNCING with the (lo,hi) range of the area which needs to
be suspended. Each node maintains a suspend_list, which contains the
list of ranges which are currently suspended. On receiving RESYNCING,
the node adds the range to the suspend_list. Similarly, when the node
performing resync finishes, it sends RESYNCING with an empty range to
other nodes and other nodes remove the corresponding entry from the
suspend_list.</p>
<p>A helper function, -&gt;area_resyncing() can be used to check if a
particular I/O range should be suspended or not.</p>
</div></blockquote>
</section>
</section>
<section id="device-failure">
<h2>4.2 Device Failure<a class="headerlink" href="#device-failure" title="Link to this heading">¶</a></h2>
<blockquote>
<div><p>Device failures are handled and communicated with the metadata update
routine.  When a node detects a device failure it does not allow
any further writes to that device until the failure has been
acknowledged by all other nodes.</p>
</div></blockquote>
<section id="adding-a-new-device">
<h3>5. Adding a new Device<a class="headerlink" href="#adding-a-new-device" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>For adding a new device, it is necessary that all nodes “see” the new
device to be added. For this, the following algorithm is used:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Node 1 issues mdadm --manage /dev/mdX --add /dev/sdYY which issues
ioctl(ADD_NEW_DISK with disc.state set to MD_DISK_CLUSTER_ADD)</p></li>
<li><p>Node 1 sends a NEWDISK message with uuid and slot number</p></li>
<li><p>Other nodes issue kobject_uevent_env with uuid and slot number
(Steps 4,5 could be a udev rule)</p></li>
<li><p>In userspace, the node searches for the disk, perhaps
using blkid -t SUB_UUID=””</p></li>
<li><p>Other nodes issue either of the following depending on whether
the disk was found:
ioctl(ADD_NEW_DISK with disc.state set to MD_DISK_CANDIDATE and
disc.number set to slot number)
ioctl(CLUSTERED_DISK_NACK)</p></li>
<li><p>Other nodes drop lock on “no-new-devs” (CR) if device is found</p></li>
<li><p>Node 1 attempts EX lock on “no-new-dev”</p></li>
<li><p>If node 1 gets the lock, it sends METADATA_UPDATED after
unmarking the disk as SpareLocal</p></li>
<li><p>If not (get “no-new-dev” lock), it fails the operation and sends
METADATA_UPDATED.</p></li>
<li><p>Other nodes get the information whether a disk is added or not
by the following METADATA_UPDATED.</p></li>
</ol>
</div></blockquote>
</div></blockquote>
</section>
</section>
<section id="module-interface">
<h2>6. Module interface<a class="headerlink" href="#module-interface" title="Link to this heading">¶</a></h2>
<blockquote>
<div><p>There are 17 call-backs which the md core can make to the cluster
module.  Understanding these can give a good overview of the whole
process.</p>
</div></blockquote>
<section id="join-nodes-and-leave">
<h3>6.1 join(nodes) and leave()<a class="headerlink" href="#join-nodes-and-leave" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>These are called when an array is started with a clustered bitmap,
and when the array is stopped.  join() ensures the cluster is
available and initializes the various resources.
Only the first ‘nodes’ nodes in the cluster can use the array.</p>
</div></blockquote>
</section>
<section id="slot-number">
<h3>6.2 slot_number()<a class="headerlink" href="#slot-number" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>Reports the slot number advised by the cluster infrastructure.
Range is from 0 to nodes-1.</p>
</div></blockquote>
</section>
<section id="resync-info-update">
<h3>6.3 resync_info_update()<a class="headerlink" href="#resync-info-update" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>This updates the resync range that is stored in the bitmap lock.
The starting point is updated as the resync progresses.  The
end point is always the end of the array.
It does <em>not</em> send a RESYNCING message.</p>
</div></blockquote>
</section>
<section id="resync-start-resync-finish">
<h3>6.4 resync_start(), resync_finish()<a class="headerlink" href="#resync-start-resync-finish" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>These are called when resync/recovery/reshape starts or stops.
They update the resyncing range in the bitmap lock and also
send a RESYNCING message.  resync_start reports the whole
array as resyncing, resync_finish reports none of it.</p>
<p>resync_finish() also sends a BITMAP_NEEDS_SYNC message which
allows some other node to take over.</p>
</div></blockquote>
</section>
<section id="metadata-update-start-metadata-update-finish-metadata-update-cancel">
<h3>6.5 metadata_update_start(), metadata_update_finish(), metadata_update_cancel()<a class="headerlink" href="#metadata-update-start-metadata-update-finish-metadata-update-cancel" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>metadata_update_start is used to get exclusive access to
the metadata.  If a change is still needed once that access is
gained, metadata_update_finish() will send a METADATA_UPDATE
message to all other nodes, otherwise metadata_update_cancel()
can be used to release the lock.</p>
</div></blockquote>
</section>
<section id="area-resyncing">
<h3>6.6 area_resyncing()<a class="headerlink" href="#area-resyncing" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>This combines two elements of functionality.</p>
<p>Firstly, it will check if any node is currently resyncing
anything in a given range of sectors.  If any resync is found,
then the caller will avoid writing or read-balancing in that
range.</p>
<p>Secondly, while node recovery is happening it reports that
all areas are resyncing for READ requests.  This avoids races
between the cluster-filesystem and the cluster-RAID handling
a node failure.</p>
</div></blockquote>
</section>
<section id="add-new-disk-start-add-new-disk-finish-new-disk-ack">
<h3>6.7 add_new_disk_start(), add_new_disk_finish(), new_disk_ack()<a class="headerlink" href="#add-new-disk-start-add-new-disk-finish-new-disk-ack" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>These are used to manage the new-disk protocol described above.
When a new device is added, add_new_disk_start() is called before
it is bound to the array and, if that succeeds, add_new_disk_finish()
is called the device is fully added.</p>
<p>When a device is added in acknowledgement to a previous
request, or when the device is declared “unavailable”,
new_disk_ack() is called.</p>
</div></blockquote>
</section>
<section id="remove-disk">
<h3>6.8 remove_disk()<a class="headerlink" href="#remove-disk" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>This is called when a spare or failed device is removed from
the array.  It causes a REMOVE message to be send to other nodes.</p>
</div></blockquote>
</section>
<section id="gather-bitmaps">
<h3>6.9 gather_bitmaps()<a class="headerlink" href="#gather-bitmaps" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>This sends a RE_ADD message to all other nodes and then
gathers bitmap information from all bitmaps.  This combined
bitmap is then used to recovery the re-added device.</p>
</div></blockquote>
</section>
<section id="lock-all-bitmaps-and-unlock-all-bitmaps">
<h3>6.10 lock_all_bitmaps() and unlock_all_bitmaps()<a class="headerlink" href="#lock-all-bitmaps-and-unlock-all-bitmaps" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>These are called when change bitmap to none. If a node plans
to clear the cluster raid’s bitmap, it need to make sure no other
nodes are using the raid which is achieved by lock all bitmap
locks within the cluster, and also those locks are unlocked
accordingly.</p>
</div></blockquote>
</section>
</section>
<section id="unsupported-features">
<h2>7. Unsupported features<a class="headerlink" href="#unsupported-features" title="Link to this heading">¶</a></h2>
<p>There are somethings which are not supported by cluster MD yet.</p>
<ul class="simple">
<li><p>change array_sectors.</p></li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/md/md-cluster.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>