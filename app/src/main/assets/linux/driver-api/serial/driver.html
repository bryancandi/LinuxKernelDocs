<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Low Level Serial API &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ISO7816 Serial Communications" href="serial-iso7816.html" />
    <link rel="prev" title="Support for Serial devices" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.9.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/serial/driver.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="low-level-serial-api">
<h1>Low Level Serial API<a class="headerlink" href="#low-level-serial-api" title="Link to this heading">¶</a></h1>
<p>This document is meant as a brief overview of some aspects of the new serial
driver.  It is not complete, any questions you have should be directed to
&lt;<a class="reference external" href="mailto:rmk&#37;&#52;&#48;arm&#46;linux&#46;org&#46;uk">rmk<span>&#64;</span>arm<span>&#46;</span>linux<span>&#46;</span>org<span>&#46;</span>uk</a>&gt;</p>
<p>The reference implementation is contained within amba-pl011.c.</p>
<section id="low-level-serial-hardware-driver">
<h2>Low Level Serial Hardware Driver<a class="headerlink" href="#low-level-serial-hardware-driver" title="Link to this heading">¶</a></h2>
<p>The low level serial hardware driver is responsible for supplying port
information (defined by uart_port) and a set of control methods (defined
by uart_ops) to the core serial driver.  The low level driver is also
responsible for handling interrupts for the port, and providing any
console support.</p>
</section>
<section id="console-support">
<h2>Console Support<a class="headerlink" href="#console-support" title="Link to this heading">¶</a></h2>
<p>The serial core provides a few helper functions.  This includes identifying
the correct port structure (via <a class="reference internal" href="#c.uart_get_console" title="uart_get_console"><code class="xref c c-func docutils literal notranslate"><span class="pre">uart_get_console()</span></code></a>) and decoding command line
arguments (<a class="reference internal" href="#c.uart_parse_options" title="uart_parse_options"><code class="xref c c-func docutils literal notranslate"><span class="pre">uart_parse_options()</span></code></a>).</p>
<p>There is also a helper function (<a class="reference internal" href="#c.uart_console_write" title="uart_console_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">uart_console_write()</span></code></a>) which performs a
character by character write, translating newlines to CRLF sequences.
Driver writers are recommended to use this function rather than implementing
their own version.</p>
</section>
<section id="locking">
<h2>Locking<a class="headerlink" href="#locking" title="Link to this heading">¶</a></h2>
<p>It is the responsibility of the low level hardware driver to perform the
necessary locking using port-&gt;lock.  There are some exceptions (which
are described in the <a class="reference internal" href="#c.uart_ops" title="uart_ops"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_ops</span></code></a> listing below.)</p>
<p>There are two locks.  A per-port spinlock, and an overall semaphore.</p>
<p>From the core driver perspective, the port-&gt;lock locks the following
data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>port-&gt;mctrl
port-&gt;icount
port-&gt;state-&gt;xmit.head (circ_buf-&gt;head)
port-&gt;state-&gt;xmit.tail (circ_buf-&gt;tail)
</pre></div>
</div>
<p>The low level driver is free to use this lock to provide any additional
locking.</p>
<p>The port_sem semaphore is used to protect against ports being added/
removed or reconfigured at inappropriate times. Since v2.6.27, this
semaphore has been the ‘mutex’ member of the tty_port struct, and
commonly referred to as the port mutex.</p>
</section>
<section id="uart-ops">
<h2>uart_ops<a class="headerlink" href="#uart-ops" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.uart_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_ops</span></span></span><a class="headerlink" href="#c.uart_ops" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>interface between serial_core and the driver</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uart_ops {
    unsigned int    (*tx_empty)(struct uart_port *);
    void (*set_mctrl)(struct uart_port *, unsigned int mctrl);
    unsigned int    (*get_mctrl)(struct uart_port *);
    void (*stop_tx)(struct uart_port *);
    void (*start_tx)(struct uart_port *);
    void (*throttle)(struct uart_port *);
    void (*unthrottle)(struct uart_port *);
    void (*send_xchar)(struct uart_port *, char ch);
    void (*stop_rx)(struct uart_port *);
    void (*start_rx)(struct uart_port *);
    void (*enable_ms)(struct uart_port *);
    void (*break_ctl)(struct uart_port *, int ctl);
    int (*startup)(struct uart_port *);
    void (*shutdown)(struct uart_port *);
    void (*flush_buffer)(struct uart_port *);
    void (*set_termios)(struct uart_port *, struct ktermios *new, const struct ktermios *old);
    void (*set_ldisc)(struct uart_port *, struct ktermios *);
    void (*pm)(struct uart_port *, unsigned int state, unsigned int oldstate);
    const char      *(*type)(struct uart_port *);
    void (*release_port)(struct uart_port *);
    int (*request_port)(struct uart_port *);
    void (*config_port)(struct uart_port *, int);
    int (*verify_port)(struct uart_port *, struct serial_struct *);
    int (*ioctl)(struct uart_port *, unsigned int, unsigned long);
#ifdef CONFIG_CONSOLE_POLL;
    int (*poll_init)(struct uart_port *);
    void (*poll_put_char)(struct uart_port *, unsigned char);
    int (*poll_get_char)(struct uart_port *);
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">tx_empty</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>This function tests whether the transmitter fifo and shifter for the
<strong>port</strong> is empty. If it is empty, this function should return
<code class="docutils literal notranslate"><span class="pre">TIOCSER_TEMT</span></code>, otherwise return 0. If the port does not support this
operation, then it should return <code class="docutils literal notranslate"><span class="pre">TIOCSER_TEMT</span></code>.</p>
<p>Locking: none.
Interrupts: caller dependent.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_mctrl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mctrl)</span></code></p>
<p>This function sets the modem control lines for <strong>port</strong> to the state
described by <strong>mctrl</strong>. The relevant bits of <strong>mctrl</strong> are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_RTS</span></code>    RTS signal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_DTR</span></code>    DTR signal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_OUT1</span></code>   OUT1 signal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_OUT2</span></code>   OUT2 signal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_LOOP</span></code>   Set the port into loopback mode.</p></li>
</ul>
</div></blockquote>
<p>If the appropriate bit is set, the signal should be driven
active.  If the bit is clear, the signal should be driven
inactive.</p>
<p>Locking: <strong>port-&gt;lock</strong> taken.
Interrupts: locally disabled.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_mctrl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Returns the current state of modem control inputs of <strong>port</strong>. The state
of the outputs should not be returned, since the core keeps track of
their state. The state information should include:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_CAR</span></code>    state of DCD signal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_CTS</span></code>    state of CTS signal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_DSR</span></code>    state of DSR signal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TIOCM_RI</span></code>     state of RI signal</p></li>
</ul>
</div></blockquote>
<p>The bit is set if the signal is currently driven active.  If
the port does not support CTS, DCD or DSR, the driver should
indicate that the signal is permanently active. If RI is
not available, the signal should not be indicated as active.</p>
<p>Locking: <strong>port-&gt;lock</strong> taken.
Interrupts: locally disabled.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_tx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Stop transmitting characters. This might be due to the CTS line
becoming inactive or the tty layer indicating we want to stop
transmission due to an <code class="docutils literal notranslate"><span class="pre">XOFF</span></code> character.</p>
<p>The driver should stop transmitting characters as soon as possible.</p>
<p>Locking: <strong>port-&gt;lock</strong> taken.
Interrupts: locally disabled.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_tx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Start transmitting characters.</p>
<p>Locking: <strong>port-&gt;lock</strong> taken.
Interrupts: locally disabled.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">throttle</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Notify the serial driver that input buffers for the line discipline are
close to full, and it should somehow signal that no more characters
should be sent to the serial port.
This will be called only if hardware assisted flow control is enabled.</p>
<p>Locking: serialized with <strong>unthrottle()</strong> and termios modification by the
tty layer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unthrottle</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Notify the serial driver that characters can now be sent to the serial
port without fear of overrunning the input buffers of the line
disciplines.</p>
<p>This will be called only if hardware assisted flow control is enabled.</p>
<p>Locking: serialized with <strong>throttle()</strong> and termios modification by the
tty layer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_xchar</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">char</span> <span class="pre">ch)</span></code></p>
<p>Transmit a high priority character, even if the port is stopped. This
is used to implement XON/XOFF flow control and tcflow(). If the serial
driver does not implement this function, the tty core will append the
character to the circular buffer and then call start_tx() / stop_tx()
to flush the data out.</p>
<p>Do not transmit if <strong>ch</strong> == ‘0’ (<code class="docutils literal notranslate"><span class="pre">__DISABLED_CHAR</span></code>).</p>
<p>Locking: none.
Interrupts: caller dependent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_rx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Stop receiving characters; the <strong>port</strong> is in the process of being closed.</p>
<p>Locking: <strong>port-&gt;lock</strong> taken.
Interrupts: locally disabled.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_rx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Start receiving characters.</p>
<p>Locking: <strong>port-&gt;lock</strong> taken.
Interrupts: locally disabled.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_ms</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Enable the modem status interrupts.</p>
<p>This method may be called multiple times. Modem status interrupts
should be disabled when the <strong>shutdown()</strong> method is called.</p>
<p>Locking: <strong>port-&gt;lock</strong> taken.
Interrupts: locally disabled.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">break_ctl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">int</span> <span class="pre">ctl)</span></code></p>
<p>Control the transmission of a break signal. If <strong>ctl</strong> is nonzero, the
break signal should be transmitted. The signal should be terminated
when another call is made with a zero <strong>ctl</strong>.</p>
<p>Locking: caller holds tty_port-&gt;mutex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">startup</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Grab any interrupt resources and initialise any low level driver state.
Enable the port for reception. It should not activate RTS nor DTR;
this will be done via a separate call to <strong>set_mctrl()</strong>.</p>
<p>This method will only be called when the port is initially opened.</p>
<p>Locking: port_sem taken.
Interrupts: globally disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Disable the <strong>port</strong>, disable any break condition that may be in effect,
and free any interrupt resources. It should not disable RTS nor DTR;
this will have already been done via a separate call to <strong>set_mctrl()</strong>.</p>
<p>Drivers must not access <strong>port-&gt;state</strong> once this call has completed.</p>
<p>This method will only be called when there are no more users of this
<strong>port</strong>.</p>
<p>Locking: port_sem taken.
Interrupts: caller dependent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush_buffer</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Flush any write buffers, reset any DMA state and stop any ongoing DMA
transfers.</p>
<p>This will be called whenever the <strong>port-&gt;state-&gt;xmit</strong> circular buffer is
cleared.</p>
<p>Locking: <strong>port-&gt;lock</strong> taken.
Interrupts: locally disabled.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_termios</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*new,</span>
<span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*old)</span></code></p>
<blockquote>
<div><p>Change the <strong>port</strong> parameters, including word length, parity, stop bits.
Update <strong>port-&gt;read_status_mask</strong> and <strong>port-&gt;ignore_status_mask</strong> to
indicate the types of events we are interested in receiving. Relevant
ktermios::c_cflag bits are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CSIZE</span></code> - word size</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CSTOPB</span></code> - 2 stop bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PARENB</span></code> - parity enable</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PARODD</span></code> - odd parity (when <code class="docutils literal notranslate"><span class="pre">PARENB</span></code> is in force)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADDRB</span></code> - address bit (changed through uart_port::rs485_config()).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CREAD</span></code> - enable reception of characters (if not set, still receive
characters from the port, but throw them away).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CRTSCTS</span></code> - if set, enable CTS status change reporting.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CLOCAL</span></code> - if not set, enable modem status change reporting.</p></li>
</ul>
<p>Relevant ktermios::c_iflag bits are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">INPCK</span></code> - enable frame and parity error events to be passed to the TTY
layer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BRKINT</span></code> / <code class="docutils literal notranslate"><span class="pre">PARMRK</span></code> - both of these enable break events to be passed to
the TTY layer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IGNPAR</span></code> - ignore parity and framing errors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IGNBRK</span></code> - ignore break errors. If <code class="docutils literal notranslate"><span class="pre">IGNPAR</span></code> is also set, ignore overrun
errors as well.</p></li>
</ul>
<p>The interaction of the ktermios::c_iflag bits is as follows (parity
error given as an example):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parity error</p></th>
<th class="head"><p>INPCK</p></th>
<th class="head"><p>IGNPAR</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>n/a</p></td>
<td><p>0</p></td>
<td><p>n/a</p></td>
<td><p>character received, marked as <code class="docutils literal notranslate"><span class="pre">TTY_NORMAL</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>None</p></td>
<td><p>1</p></td>
<td><p>n/a</p></td>
<td><p>character received, marked as <code class="docutils literal notranslate"><span class="pre">TTY_NORMAL</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Yes</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>character received, marked as <code class="docutils literal notranslate"><span class="pre">TTY_PARITY</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Yes</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>character discarded</p></td>
</tr>
</tbody>
</table>
<p>Other flags may be used (eg, xon/xoff characters) if your hardware
supports hardware “soft” flow control.</p>
<p>Locking: caller holds tty_port-&gt;mutex
Interrupts: caller dependent.
This call must not sleep</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_ldisc</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*termios)</span></code></p>
<p>Notifier for discipline change. See
<a class="reference internal" href="../tty/tty_ldisc.html"><span class="doc">TTY Line Discipline</span></a>.</p>
<p>Locking: caller holds tty_port-&gt;mutex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">state,</span>
<span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">oldstate)</span></code></p>
<blockquote>
<div><p>Perform any power management related activities on the specified <strong>port</strong>.
<strong>state</strong> indicates the new state (defined by enum uart_pm_state),
<strong>oldstate</strong> indicates the previous state.</p>
<p>This function should not be used to grab any resources.</p>
<p>This will be called when the <strong>port</strong> is initially opened and finally
closed, except when the <strong>port</strong> is also the system console. This will
occur even if <code class="docutils literal notranslate"><span class="pre">CONFIG_PM</span></code> is not set.</p>
<p>Locking: none.
Interrupts: caller dependent.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Return a pointer to a string constant describing the specified <strong>port</strong>,
or return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, in which case the string ‘unknown’ is substituted.</p>
<p>Locking: none.
Interrupts: caller dependent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release_port</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Release any memory and IO region resources currently in use by the
<strong>port</strong>.</p>
<p>Locking: none.
Interrupts: caller dependent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_port</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Request any memory and IO region resources required by the port. If any
fail, no resources should be registered when this function returns, and
it should return -<code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on failure.</p>
<p>Locking: none.
Interrupts: caller dependent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config_port</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">int</span> <span class="pre">type)</span></code></p>
<p>Perform any autoconfiguration steps required for the <strong>port</strong>. <strong>type</strong>
contains a bit mask of the required configuration. <code class="docutils literal notranslate"><span class="pre">UART_CONFIG_TYPE</span></code>
indicates that the port requires detection and identification.
<strong>port-&gt;type</strong> should be set to the type found, or <code class="docutils literal notranslate"><span class="pre">PORT_UNKNOWN</span></code> if no
port was detected.</p>
<p><code class="docutils literal notranslate"><span class="pre">UART_CONFIG_IRQ</span></code> indicates autoconfiguration of the interrupt signal,
which should be probed using standard kernel autoprobing techniques.
This is not necessary on platforms where ports have interrupts
internally hard wired (eg, system on a chip implementations).</p>
<p>Locking: none.
Interrupts: caller dependent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">verify_port</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span>
<span class="pre">struct</span> <span class="pre">serial_struct</span> <span class="pre">*serinfo)</span></code></p>
<blockquote>
<div><p>Verify the new serial port information contained within <strong>serinfo</strong> is
suitable for this port type.</p>
<p>Locking: none.
Interrupts: caller dependent.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span>
<span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg)</span></code></p>
<blockquote>
<div><p>Perform any port specific IOCTLs. IOCTL commands must be defined using
the standard numbering system found in &lt;asm/ioctl.h&gt;.</p>
<p>Locking: none.
Interrupts: caller dependent.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_init</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Called by kgdb to perform the minimal hardware initialization needed to
support <strong>poll_put_char()</strong> and <strong>poll_get_char()</strong>. Unlike <strong>startup()</strong>, this
should not request interrupts.</p>
<p>Locking: <code class="docutils literal notranslate"><span class="pre">tty_mutex</span></code> and tty_port-&gt;mutex taken.
Interrupts: n/a.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_put_char</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port,</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">ch)</span></code></p>
<p>Called by kgdb to write a single character <strong>ch</strong> directly to the serial
<strong>port</strong>. It can and should block until there is space in the TX FIFO.</p>
<p>Locking: none.
Interrupts: caller dependent.
This call must not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_get_char</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">uart_port</span> <span class="pre">*port)</span></code></p>
<p>Called by kgdb to read a single character directly from the serial
port. If data is available, it should be returned; otherwise the
function should return <code class="docutils literal notranslate"><span class="pre">NO_POLL_CHAR</span></code> immediately.</p>
<p>Locking: none.
Interrupts: caller dependent.
This call must not sleep</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure describes all the operations that can be done on the
physical hardware.</p>
</section>
<section id="other-functions">
<h2>Other functions<a class="headerlink" href="#other-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_write_wakeup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_write_wakeup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_write_wakeup" title="Link to this definition">¶</a><br /></dt>
<dd><p>schedule write processing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port</span></code></dt><dd><p>port to be processed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is used by the interrupt handler to schedule processing in the
software interrupt portion of the driver. A driver is expected to call this
function when the number of characters in the transmit buffer have dropped
below a threshold.</p>
<p>Locking: <strong>port-&gt;lock</strong> should be held</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_update_timeout">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_update_timeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cflag</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">baud</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_update_timeout" title="Link to this definition">¶</a><br /></dt>
<dd><p>update per-port frame timing information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port</span></code></dt><dd><p>uart_port structure describing the port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cflag</span></code></dt><dd><p>termios cflag value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baud</span></code></dt><dd><p>speed of the port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the <strong>port</strong> frame timing information from which the FIFO timeout value is
derived. The <strong>cflag</strong> value should reflect the actual hardware settings as
number of bits, parity, stop bits and baud rate is taken into account here.</p>
<p>Locking: caller is expected to take <strong>port-&gt;lock</strong></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_get_baud_rate">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_get_baud_rate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ktermios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">termios</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ktermios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_get_baud_rate" title="Link to this definition">¶</a><br /></dt>
<dd><p>return baud rate for a particular port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port</span></code></dt><dd><p>uart_port structure describing the port in question.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*termios</span></code></dt><dd><p>desired termios settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*old</span></code></dt><dd><p>old termios (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>minimum acceptable baud rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>maximum acceptable baud rate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decode the termios structure into a numeric baud rate, taking account of the
magic 38400 baud rate (with spd_* flags), and mapping the <code class="docutils literal notranslate"><span class="pre">B0</span></code> rate to 9600
baud.</p>
<p>If the new baud rate is invalid, try the <strong>old</strong> termios setting. If it’s still
invalid, we try 9600 baud. If that is also invalid 0 is returned.</p>
<p>The <strong>termios</strong> structure is updated to reflect the baud rate we’re actually
going to be using. Don’t do this for the case where B0 is requested (“hang
up”).</p>
<p>Locking: caller dependent</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_get_divisor">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_get_divisor</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">baud</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_get_divisor" title="Link to this definition">¶</a><br /></dt>
<dd><p>return uart clock divisor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port</span></code></dt><dd><p>uart_port structure describing the port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baud</span></code></dt><dd><p>desired baud rate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the divisor (baud_base / baud) for the specified <strong>baud</strong>,
appropriately rounded.</p>
<p>If 38400 baud and custom divisor is selected, return the custom divisor
instead.</p>
<p>Locking: caller dependent</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_get_lsr_info">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_get_lsr_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../tty/tty_struct.html#c.tty_struct" title="tty_struct"><span class="n"><span class="pre">tty_struct</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tty</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_get_lsr_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>get line status register info</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty</span></code></dt><dd><p>tty associated with the UART</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_state</span> <span class="pre">*state</span></code></dt><dd><p>UART being queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">__user</span> <span class="pre">*value</span></code></dt><dd><p>returned modem value</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_console_write">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_console_write</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">putchar</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_console_write" title="Link to this definition">¶</a><br /></dt>
<dd><p>write a console message to a serial port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port</span></code></dt><dd><p>the port to write the message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>array of characters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of characters in string to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*putchar)(struct</span> <span class="pre">uart_port</span> <span class="pre">*,</span> <span class="pre">unsigned</span> <span class="pre">char)</span></code></dt><dd><p>function to write character to port</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_get_console">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">uart_get_console</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ports</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../tty/console.html#c.console" title="console"><span class="n"><span class="pre">console</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">co</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_get_console" title="Link to this definition">¶</a><br /></dt>
<dd><p>get uart port for console</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*ports</span></code></dt><dd><p>ports to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>number of <strong>ports</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">console</span> <span class="pre">*co</span></code></dt><dd><p>console to search for</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>uart_port for the console <strong>co</strong></p>
<p><strong>Description</strong></p>
<p>Check whether an invalid uart number has been specified (as <strong>co-&gt;index</strong>), and
if so, search for the first available port that does have console support.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_parse_earlycon">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_parse_earlycon</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iotype</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_parse_earlycon" title="Link to this definition">¶</a><br /></dt>
<dd><p>Parse earlycon options</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*p</span></code></dt><dd><p>ptr to 2nd field (ie., just beyond ‘&lt;name&gt;,’)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*iotype</span></code></dt><dd><p>ptr for decoded iotype (out)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">*addr</span></code></dt><dd><p>ptr for decoded mapbase/iobase (out)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**options</span></code></dt><dd><p>ptr for &lt;options&gt; field; <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not present (out)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Decodes earlycon kernel command line parameters of the form:</dt><dd><ul class="simple">
<li><p>earlycon=&lt;name&gt;,io|mmio|mmio16|mmio32|mmio32be|mmio32native,&lt;addr&gt;,&lt;options&gt;</p></li>
<li><p>console=&lt;name&gt;,io|mmio|mmio16|mmio32|mmio32be|mmio32native,&lt;addr&gt;,&lt;options&gt;</p></li>
</ul>
</dd>
<dt>The optional form:</dt><dd><ul class="simple">
<li><p>earlycon=&lt;name&gt;,0x&lt;addr&gt;,&lt;options&gt;</p></li>
<li><p>console=&lt;name&gt;,0x&lt;addr&gt;,&lt;options&gt;</p></li>
</ul>
</dd>
</dl>
<p>is also accepted; the returned <strong>iotype</strong> will be <code class="docutils literal notranslate"><span class="pre">UPIO_MEM</span></code>.</p>
<p><strong>Return</strong></p>
<p>0 on success or -<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_parse_options">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_parse_options</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">options</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">baud</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parity</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">flow</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_parse_options" title="Link to this definition">¶</a><br /></dt>
<dd><p>Parse serial port baud/parity/bits/flow control.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*options</span></code></dt><dd><p>pointer to option string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*baud</span></code></dt><dd><p>pointer to an ‘int’ variable for the baud rate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*parity</span></code></dt><dd><p>pointer to an ‘int’ variable for the parity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*bits</span></code></dt><dd><p>pointer to an ‘int’ variable for the number of data bits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*flow</span></code></dt><dd><p>pointer to an ‘int’ variable for the flow control character.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.uart_parse_options" title="uart_parse_options"><code class="xref c c-func docutils literal notranslate"><span class="pre">uart_parse_options()</span></code></a> decodes a string containing the serial console
options. The format of the string is &lt;baud&gt;&lt;parity&gt;&lt;bits&gt;&lt;flow&gt;,
eg: 115200n8r</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_set_options">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_set_options</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../tty/console.html#c.console" title="console"><span class="n"><span class="pre">console</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">co</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">baud</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">parity</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flow</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_set_options" title="Link to this definition">¶</a><br /></dt>
<dd><p>setup the serial console parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port</span></code></dt><dd><p>pointer to the serial ports uart_port structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">console</span> <span class="pre">*co</span></code></dt><dd><p>console pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">baud</span></code></dt><dd><p>baud rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">parity</span></code></dt><dd><p>parity character - ‘n’ (none), ‘o’ (odd), ‘e’ (even)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of data bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flow</span></code></dt><dd><p>flow control character - ‘r’ (rts)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locking: Caller must hold console_list_lock in order to serialize
early initialization of the serial-console lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_register_driver">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_register_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_register_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a driver with the uart core layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_driver</span> <span class="pre">*drv</span></code></dt><dd><p>low level driver structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a uart driver with the core driver. We in turn register with the
tty layer, and initialise the core driver per-port state.</p>
<p>We have a proc file in /proc/tty/driver which is named after the normal
driver.</p>
<p><strong>drv-&gt;port</strong> should be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and the per-port structures should be registered
using uart_add_one_port() after this call has succeeded.</p>
<p>Locking: none, Interrupts: enabled</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_unregister_driver">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_unregister_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_unregister_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a driver from the uart core layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_driver</span> <span class="pre">*drv</span></code></dt><dd><p>low level driver structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove all references to a driver from the core driver. The low level
driver must have removed all its ports via the uart_remove_one_port() if it
registered them with uart_add_one_port(). (I.e. <strong>drv-&gt;port</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.)</p>
<p>Locking: none, Interrupts: enabled</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_match_port">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_match_port</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_match_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>are the two ports equivalent?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port1</span></code></dt><dd><p>first port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port2</span></code></dt><dd><p>second port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This utility function can be used to determine whether two uart_port
structures describe the same port.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_handle_dcd_change">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_handle_dcd_change</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uport</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">active</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_handle_dcd_change" title="Link to this definition">¶</a><br /></dt>
<dd><p>handle a change of carrier detect state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*uport</span></code></dt><dd><p>uart_port structure for the open port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">active</span></code></dt><dd><p>new carrier detect status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold uport-&gt;lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_handle_cts_change">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_handle_cts_change</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uport</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">active</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_handle_cts_change" title="Link to this definition">¶</a><br /></dt>
<dd><p>handle a change of clear-to-send state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*uport</span></code></dt><dd><p>uart_port structure for the open port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">active</span></code></dt><dd><p>new clear-to-send status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold uport-&gt;lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uart_try_toggle_sysrq">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uart_try_toggle_sysrq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">ch</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uart_try_toggle_sysrq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Enables SysRq from serial line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port</span></code></dt><dd><p>uart_port structure where char(s) after BREAK met</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">ch</span></code></dt><dd><p>new character in the sequence after received BREAK</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables magic SysRq when the required sequence is met on port
(see CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE).</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>ch</strong> is out of enabling sequence and should be
handled some other way, <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>ch</strong> was consumed.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.uart_port_tx_limited">
<span class="sig-name descname"><span class="n"><span class="pre">uart_port_tx_limited</span></span></span><a class="headerlink" href="#c.uart_port_tx_limited" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">uart_port_tx_limited</span> <span class="pre">(port,</span> <span class="pre">ch,</span> <span class="pre">count,</span> <span class="pre">tx_ready,</span> <span class="pre">put_char,</span> <span class="pre">tx_done)</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>transmit helper for uart_port with count limiting</p></li>
</ul>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt><dd><p>uart port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ch</span></code></dt><dd><p>variable to store a character to be written to the HW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>a limit of characters to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_ready</span></code></dt><dd><p>can HW accept more data function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">put_char</span></code></dt><dd><p>function to write a character</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_done</span></code></dt><dd><p>function to call after the loop is done</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper transmits characters from the xmit buffer to the hardware using
<strong>put_char()</strong>. It does so until <strong>count</strong> characters are sent and while <strong>tx_ready</strong>
evaluates to true.</p>
<dl class="simple">
<dt>The expression in macro parameters shall be designed as follows:</dt><dd><ul class="simple">
<li><p><strong>tx_ready:</strong> should evaluate to true if the HW can accept more data to
be sent. This parameter can be <code class="docutils literal notranslate"><span class="pre">true</span></code>, which means the HW is always ready.</p></li>
<li><p><strong>put_char:</strong> shall write <strong>ch</strong> to the device of <strong>port</strong>.</p></li>
<li><p><strong>tx_done:</strong> when the write loop is done, this can perform arbitrary
action before potential invocation of ops-&gt;stop_tx() happens. If the
driver does not need to do anything, use e.g. ({}).</p></li>
</ul>
</dd>
</dl>
<p>For all of them, <strong>port-&gt;lock</strong> is held, interrupts are locally disabled and
the expressions must not sleep.</p>
<p><strong>Return</strong></p>
<p>the number of characters in the xmit buffer when done.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.uart_port_tx">
<span class="sig-name descname"><span class="n"><span class="pre">uart_port_tx</span></span></span><a class="headerlink" href="#c.uart_port_tx" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">uart_port_tx</span> <span class="pre">(port,</span> <span class="pre">ch,</span> <span class="pre">tx_ready,</span> <span class="pre">put_char)</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>transmit helper for uart_port</p></li>
</ul>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt><dd><p>uart port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ch</span></code></dt><dd><p>variable to store a character to be written to the HW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_ready</span></code></dt><dd><p>can HW accept more data function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">put_char</span></code></dt><dd><p>function to write a character</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.uart_port_tx_limited" title="uart_port_tx_limited"><code class="xref c c-func docutils literal notranslate"><span class="pre">uart_port_tx_limited()</span></code></a> for more details.</p>
</div>
</section>
<section id="other-notes">
<h2>Other notes<a class="headerlink" href="#other-notes" title="Link to this heading">¶</a></h2>
<p>It is intended some day to drop the ‘unused’ entries from uart_port, and
allow low level drivers to register their own individual uart_port’s with
the core.  This will allow drivers to use uart_port as a pointer to a
structure containing both the uart_port entry with their own extensions,
thus:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_port {
        struct uart_port        port;
        int                     my_stuff;
};
</pre></div>
</div>
</section>
<section id="modem-control-lines-via-gpio">
<h2>Modem control lines via GPIO<a class="headerlink" href="#modem-control-lines-via-gpio" title="Link to this heading">¶</a></h2>
<p>Some helpers are provided in order to set/get modem control lines via GPIO.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.mctrl_gpio_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mctrl_gpio_set</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl_gpios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpios</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mctrl_gpio_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>set gpios according to mctrl state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mctrl_gpios</span> <span class="pre">*gpios</span></code></dt><dd><p>gpios to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mctrl</span></code></dt><dd><p>state to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the gpios according to the mctrl state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mctrl_gpio_to_gpiod">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gpio_desc</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mctrl_gpio_to_gpiod</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl_gpios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpios</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl_gpio_idx</span></span><span class="w"> </span><span class="n"><span class="pre">gidx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mctrl_gpio_to_gpiod" title="Link to this definition">¶</a><br /></dt>
<dd><p>obtain gpio_desc of modem line index</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mctrl_gpios</span> <span class="pre">*gpios</span></code></dt><dd><p>gpios to look into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mctrl_gpio_idx</span> <span class="pre">gidx</span></code></dt><dd><p>index of the modem line</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the gpio_desc structure associated to the modem line index</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mctrl_gpio_get">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mctrl_gpio_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl_gpios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpios</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mctrl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mctrl_gpio_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>update mctrl with the gpios values.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mctrl_gpios</span> <span class="pre">*gpios</span></code></dt><dd><p>gpios to get the info from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*mctrl</span></code></dt><dd><p>mctrl to set</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>modified mctrl (the same value as in <strong>mctrl</strong>)</p>
<p><strong>Description</strong></p>
<p>Update mctrl with the gpios values.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mctrl_gpio_init">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl_gpios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mctrl_gpio_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mctrl_gpio_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize uart gpios</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span> <span class="pre">*port</span></code></dt><dd><p>port to initialize gpios for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index of the gpio in the <strong>port</strong>’s device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will get the {cts,rts,...}-gpios from device tree if they are present
and request them, set direction etc, and return an allocated structure.
<cite>devm_*</cite> functions are used, so there’s no need to call <a class="reference internal" href="#c.mctrl_gpio_free" title="mctrl_gpio_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">mctrl_gpio_free()</span></code></a>.
As this sets up the irq handling, make sure to not handle changes to the
gpio input lines in your driver, too.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mctrl_gpio_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mctrl_gpio_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl_gpios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpios</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mctrl_gpio_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>explicitly free uart gpios</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>uart port’s device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mctrl_gpios</span> <span class="pre">*gpios</span></code></dt><dd><p>gpios structure to be freed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will free the requested gpios in <a class="reference internal" href="#c.mctrl_gpio_init" title="mctrl_gpio_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mctrl_gpio_init()</span></code></a>. As <cite>devm_*</cite>
functions are used, there’s generally no need to call this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mctrl_gpio_enable_ms">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mctrl_gpio_enable_ms</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl_gpios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpios</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mctrl_gpio_enable_ms" title="Link to this definition">¶</a><br /></dt>
<dd><p>enable irqs and handling of changes to the ms lines</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mctrl_gpios</span> <span class="pre">*gpios</span></code></dt><dd><p>gpios to enable</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mctrl_gpio_disable_ms">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mctrl_gpio_disable_ms</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mctrl_gpios</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpios</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mctrl_gpio_disable_ms" title="Link to this definition">¶</a><br /></dt>
<dd><p>disable irqs and handling of changes to the ms lines</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mctrl_gpios</span> <span class="pre">*gpios</span></code></dt><dd><p>gpios to disable</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/serial/driver.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>