<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>NAND Error-correction Code &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="SPI NOR framework" href="spi-nor.html" />
    <link rel="prev" title="Upgrading BIOS using spi-intel" href="spi-intel.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.13.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/mtd/nand_ecc.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="nand-error-correction-code">
<h1>NAND Error-correction Code<a class="headerlink" href="#nand-error-correction-code" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Having looked at the linux mtd/nand Hamming software ECC engine driver
I felt there was room for optimisation. I bashed the code for a few hours
performing tricks like table lookup removing superfluous code etc.
After that the speed was increased by 35-40%.
Still I was not too happy as I felt there was additional room for improvement.</p>
<p>Bad! I was hooked.
I decided to annotate my steps in this file. Perhaps it is useful to someone
or someone learns something from it.</p>
</section>
<section id="the-problem">
<h2>The problem<a class="headerlink" href="#the-problem" title="Link to this heading">¶</a></h2>
<p>NAND flash (at least SLC one) typically has sectors of 256 bytes.
However NAND flash is not extremely reliable so some error detection
(and sometimes correction) is needed.</p>
<p>This is done by means of a Hamming code. I’ll try to explain it in
laymans terms (and apologies to all the pro’s in the field in case I do
not use the right terminology, my coding theory class was almost 30
years ago, and I must admit it was not one of my favourites).</p>
<p>As I said before the ecc calculation is performed on sectors of 256
bytes. This is done by calculating several parity bits over the rows and
columns. The parity used is even parity which means that the parity bit = 1
if the data over which the parity is calculated is 1 and the parity bit = 0
if the data over which the parity is calculated is 0. So the total
number of bits over the data over which the parity is calculated + the
parity bit is even. (see wikipedia if you can’t follow this).
Parity is often calculated by means of an exclusive or operation,
sometimes also referred to as xor. In C the operator for xor is ^</p>
<p>Back to ecc.
Let’s give a small figure:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>byte   0:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp2</p></td>
<td><p>rp4</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-even"><td><p>byte   1:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp1</p></td>
<td><p>rp2</p></td>
<td><p>rp4</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-odd"><td><p>byte   2:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp3</p></td>
<td><p>rp4</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-even"><td><p>byte   3:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp1</p></td>
<td><p>rp3</p></td>
<td><p>rp4</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-odd"><td><p>byte   4:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp2</p></td>
<td><p>rp5</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr class="row-even"><td><p>...</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>byte 254:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp3</p></td>
<td><p>rp5</p></td>
<td><p>...</p></td>
<td><p>rp15</p></td>
</tr>
<tr class="row-even"><td><p>byte 255:</p></td>
<td><p>bit7
cp1
cp3
cp5</p></td>
<td><p>bit6
cp0
cp3
cp5</p></td>
<td><p>bit5
cp1
cp2
cp5</p></td>
<td><p>bit4
cp0
cp2
cp5</p></td>
<td><p>bit3
cp1
cp3
cp4</p></td>
<td><p>bit2
cp0
cp3
cp4</p></td>
<td><p>bit1
cp1
cp2
cp4</p></td>
<td><p>bit0
cp0
cp2
cp4</p></td>
<td><p>rp1</p></td>
<td><p>rp3</p></td>
<td><p>rp5</p></td>
<td><p>...</p></td>
<td><p>rp15</p></td>
</tr>
</tbody>
</table>
<p>This figure represents a sector of 256 bytes.
cp is my abbreviation for column parity, rp for row parity.</p>
<p>Let’s start to explain column parity.</p>
<ul>
<li><p>cp0 is the parity that belongs to all bit0, bit2, bit4, bit6.</p>
<p>so the sum of all bit0, bit2, bit4 and bit6 values + cp0 itself is even.</p>
</li>
</ul>
<p>Similarly cp1 is the sum of all bit1, bit3, bit5 and bit7.</p>
<ul class="simple">
<li><p>cp2 is the parity over bit0, bit1, bit4 and bit5</p></li>
<li><p>cp3 is the parity over bit2, bit3, bit6 and bit7.</p></li>
<li><p>cp4 is the parity over bit0, bit1, bit2 and bit3.</p></li>
<li><p>cp5 is the parity over bit4, bit5, bit6 and bit7.</p></li>
</ul>
<p>Note that each of cp0 .. cp5 is exactly one bit.</p>
<p>Row parity actually works almost the same.</p>
<ul>
<li><p>rp0 is the parity of all even bytes (0, 2, 4, 6, ... 252, 254)</p></li>
<li><p>rp1 is the parity of all odd bytes (1, 3, 5, 7, ..., 253, 255)</p></li>
<li><p>rp2 is the parity of all bytes 0, 1, 4, 5, 8, 9, ...
(so handle two bytes, then skip 2 bytes).</p></li>
<li><p>rp3 is covers the half rp2 does not cover (bytes 2, 3, 6, 7, 10, 11, ...)</p></li>
<li><p>for rp4 the rule is cover 4 bytes, skip 4 bytes, cover 4 bytes, skip 4 etc.</p>
<p>so rp4 calculates parity over bytes 0, 1, 2, 3, 8, 9, 10, 11, 16, ...)</p>
</li>
<li><p>and rp5 covers the other half, so bytes 4, 5, 6, 7, 12, 13, 14, 15, 20, ..</p></li>
</ul>
<p>The story now becomes quite boring. I guess you get the idea.</p>
<ul class="simple">
<li><p>rp6 covers 8 bytes then skips 8 etc</p></li>
<li><p>rp7 skips 8 bytes then covers 8 etc</p></li>
<li><p>rp8 covers 16 bytes then skips 16 etc</p></li>
<li><p>rp9 skips 16 bytes then covers 16 etc</p></li>
<li><p>rp10 covers 32 bytes then skips 32 etc</p></li>
<li><p>rp11 skips 32 bytes then covers 32 etc</p></li>
<li><p>rp12 covers 64 bytes then skips 64 etc</p></li>
<li><p>rp13 skips 64 bytes then covers 64 etc</p></li>
<li><p>rp14 covers 128 bytes then skips 128</p></li>
<li><p>rp15 skips 128 bytes then covers 128</p></li>
</ul>
<p>In the end the parity bits are grouped together in three bytes as
follows:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>ECC</p></th>
<th class="head"><p>Bit 7</p></th>
<th class="head"><p>Bit 6</p></th>
<th class="head"><p>Bit 5</p></th>
<th class="head"><p>Bit 4</p></th>
<th class="head"><p>Bit 3</p></th>
<th class="head"><p>Bit 2</p></th>
<th class="head"><p>Bit 1</p></th>
<th class="head"><p>Bit 0</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ECC 0</p></td>
<td><p>rp07</p></td>
<td><p>rp06</p></td>
<td><p>rp05</p></td>
<td><p>rp04</p></td>
<td><p>rp03</p></td>
<td><p>rp02</p></td>
<td><p>rp01</p></td>
<td><p>rp00</p></td>
</tr>
<tr class="row-odd"><td><p>ECC 1</p></td>
<td><p>rp15</p></td>
<td><p>rp14</p></td>
<td><p>rp13</p></td>
<td><p>rp12</p></td>
<td><p>rp11</p></td>
<td><p>rp10</p></td>
<td><p>rp09</p></td>
<td><p>rp08</p></td>
</tr>
<tr class="row-even"><td><p>ECC 2</p></td>
<td><p>cp5</p></td>
<td><p>cp4</p></td>
<td><p>cp3</p></td>
<td><p>cp2</p></td>
<td><p>cp1</p></td>
<td><p>cp0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>I detected after writing this that ST application note AN1823
(<a class="reference external" href="http://www.st.com/stonline/">http://www.st.com/stonline/</a>) gives a much
nicer picture.(but they use line parity as term where I use row parity)
Oh well, I’m graphically challenged, so suffer with me for a moment :-)</p>
<p>And I could not reuse the ST picture anyway for copyright reasons.</p>
</section>
<section id="attempt-0">
<h2>Attempt 0<a class="headerlink" href="#attempt-0" title="Link to this heading">¶</a></h2>
<p>Implementing the parity calculation is pretty simple.
In C pseudocode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; 256; i++)
{
  if (i &amp; 0x01)
     rp1 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp1;
  else
     rp0 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp0;
  if (i &amp; 0x02)
     rp3 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp3;
  else
     rp2 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp2;
  if (i &amp; 0x04)
    rp5 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp5;
  else
    rp4 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp4;
  if (i &amp; 0x08)
    rp7 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp7;
  else
    rp6 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp6;
  if (i &amp; 0x10)
    rp9 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp9;
  else
    rp8 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp8;
  if (i &amp; 0x20)
    rp11 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp11;
  else
    rp10 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp10;
  if (i &amp; 0x40)
    rp13 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp13;
  else
    rp12 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp12;
  if (i &amp; 0x80)
    rp15 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp15;
  else
    rp14 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp14;
  cp0 = bit6 ^ bit4 ^ bit2 ^ bit0 ^ cp0;
  cp1 = bit7 ^ bit5 ^ bit3 ^ bit1 ^ cp1;
  cp2 = bit5 ^ bit4 ^ bit1 ^ bit0 ^ cp2;
  cp3 = bit7 ^ bit6 ^ bit3 ^ bit2 ^ cp3
  cp4 = bit3 ^ bit2 ^ bit1 ^ bit0 ^ cp4
  cp5 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ cp5
}
</pre></div>
</div>
</section>
<section id="analysis-0">
<h2>Analysis 0<a class="headerlink" href="#analysis-0" title="Link to this heading">¶</a></h2>
<p>C does have bitwise operators but not really operators to do the above
efficiently (and most hardware has no such instructions either).
Therefore without implementing this it was clear that the code above was
not going to bring me a Nobel prize :-)</p>
<p>Fortunately the exclusive or operation is commutative, so we can combine
the values in any order. So instead of calculating all the bits
individually, let us try to rearrange things.
For the column parity this is easy. We can just xor the bytes and in the
end filter out the relevant bits. This is pretty nice as it will bring
all cp calculation out of the for loop.</p>
<p>Similarly we can first xor the bytes for the various rows.
This leads to:</p>
</section>
<section id="attempt-1">
<h2>Attempt 1<a class="headerlink" href="#attempt-1" title="Link to this heading">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>const char parity[256] = {
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0
};

void ecc1(const unsigned char *buf, unsigned char *code)
{
    int i;
    const unsigned char *bp = buf;
    unsigned char cur;
    unsigned char rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;
    unsigned char rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15;
    unsigned char par;

    par = 0;
    rp0 = 0; rp1 = 0; rp2 = 0; rp3 = 0;
    rp4 = 0; rp5 = 0; rp6 = 0; rp7 = 0;
    rp8 = 0; rp9 = 0; rp10 = 0; rp11 = 0;
    rp12 = 0; rp13 = 0; rp14 = 0; rp15 = 0;

    for (i = 0; i &lt; 256; i++)
    {
        cur = *bp++;
        par ^= cur;
        if (i &amp; 0x01) rp1 ^= cur; else rp0 ^= cur;
        if (i &amp; 0x02) rp3 ^= cur; else rp2 ^= cur;
        if (i &amp; 0x04) rp5 ^= cur; else rp4 ^= cur;
        if (i &amp; 0x08) rp7 ^= cur; else rp6 ^= cur;
        if (i &amp; 0x10) rp9 ^= cur; else rp8 ^= cur;
        if (i &amp; 0x20) rp11 ^= cur; else rp10 ^= cur;
        if (i &amp; 0x40) rp13 ^= cur; else rp12 ^= cur;
        if (i &amp; 0x80) rp15 ^= cur; else rp14 ^= cur;
    }
    code[0] =
        (parity[rp7] &lt;&lt; 7) |
        (parity[rp6] &lt;&lt; 6) |
        (parity[rp5] &lt;&lt; 5) |
        (parity[rp4] &lt;&lt; 4) |
        (parity[rp3] &lt;&lt; 3) |
        (parity[rp2] &lt;&lt; 2) |
        (parity[rp1] &lt;&lt; 1) |
        (parity[rp0]);
    code[1] =
        (parity[rp15] &lt;&lt; 7) |
        (parity[rp14] &lt;&lt; 6) |
        (parity[rp13] &lt;&lt; 5) |
        (parity[rp12] &lt;&lt; 4) |
        (parity[rp11] &lt;&lt; 3) |
        (parity[rp10] &lt;&lt; 2) |
        (parity[rp9]  &lt;&lt; 1) |
        (parity[rp8]);
    code[2] =
        (parity[par &amp; 0xf0] &lt;&lt; 7) |
        (parity[par &amp; 0x0f] &lt;&lt; 6) |
        (parity[par &amp; 0xcc] &lt;&lt; 5) |
        (parity[par &amp; 0x33] &lt;&lt; 4) |
        (parity[par &amp; 0xaa] &lt;&lt; 3) |
        (parity[par &amp; 0x55] &lt;&lt; 2);
    code[0] = ~code[0];
    code[1] = ~code[1];
    code[2] = ~code[2];
}
</pre></div>
</div>
<p>Still pretty straightforward. The last three invert statements are there to
give a checksum of 0xff 0xff 0xff for an empty flash. In an empty flash
all data is 0xff, so the checksum then matches.</p>
<p>I also introduced the parity lookup. I expected this to be the fastest
way to calculate the parity, but I will investigate alternatives later
on.</p>
</section>
<section id="analysis-1">
<h2>Analysis 1<a class="headerlink" href="#analysis-1" title="Link to this heading">¶</a></h2>
<p>The code works, but is not terribly efficient. On my system it took
almost 4 times as much time as the linux driver code. But hey, if it was
<em>that</em> easy this would have been done long before.
No pain. no gain.</p>
<p>Fortunately there is plenty of room for improvement.</p>
<p>In step 1 we moved from bit-wise calculation to byte-wise calculation.
However in C we can also use the unsigned long data type and virtually
every modern microprocessor supports 32 bit operations, so why not try
to write our code in such a way that we process data in 32 bit chunks.</p>
<p>Of course this means some modification as the row parity is byte by
byte. A quick analysis:
for the column parity we use the par variable. When extending to 32 bits
we can in the end easily calculate rp0 and rp1 from it.
(because par now consists of 4 bytes, contributing to rp1, rp0, rp1, rp0
respectively, from MSB to LSB)
also rp2 and rp3 can be easily retrieved from par as rp3 covers the
first two MSBs and rp2 covers the last two LSBs.</p>
<p>Note that of course now the loop is executed only 64 times (256/4).
And note that care must taken wrt byte ordering. The way bytes are
ordered in a long is machine dependent, and might affect us.
Anyway, if there is an issue: this code is developed on x86 (to be
precise: a DELL PC with a D920 Intel CPU)</p>
<p>And of course the performance might depend on alignment, but I expect
that the I/O buffers in the nand driver are aligned properly (and
otherwise that should be fixed to get maximum performance).</p>
<p>Let’s give it a try...</p>
</section>
<section id="attempt-2">
<h2>Attempt 2<a class="headerlink" href="#attempt-2" title="Link to this heading">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>extern const char parity[256];

void ecc2(const unsigned char *buf, unsigned char *code)
{
    int i;
    const unsigned long *bp = (unsigned long *)buf;
    unsigned long cur;
    unsigned long rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;
    unsigned long rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15;
    unsigned long par;

    par = 0;
    rp0 = 0; rp1 = 0; rp2 = 0; rp3 = 0;
    rp4 = 0; rp5 = 0; rp6 = 0; rp7 = 0;
    rp8 = 0; rp9 = 0; rp10 = 0; rp11 = 0;
    rp12 = 0; rp13 = 0; rp14 = 0; rp15 = 0;

    for (i = 0; i &lt; 64; i++)
    {
        cur = *bp++;
        par ^= cur;
        if (i &amp; 0x01) rp5 ^= cur; else rp4 ^= cur;
        if (i &amp; 0x02) rp7 ^= cur; else rp6 ^= cur;
        if (i &amp; 0x04) rp9 ^= cur; else rp8 ^= cur;
        if (i &amp; 0x08) rp11 ^= cur; else rp10 ^= cur;
        if (i &amp; 0x10) rp13 ^= cur; else rp12 ^= cur;
        if (i &amp; 0x20) rp15 ^= cur; else rp14 ^= cur;
    }
    /*
       we need to adapt the code generation for the fact that rp vars are now
       long; also the column parity calculation needs to be changed.
       we&#39;ll bring rp4 to 15 back to single byte entities by shifting and
       xoring
    */
    rp4 ^= (rp4 &gt;&gt; 16); rp4 ^= (rp4 &gt;&gt; 8); rp4 &amp;= 0xff;
    rp5 ^= (rp5 &gt;&gt; 16); rp5 ^= (rp5 &gt;&gt; 8); rp5 &amp;= 0xff;
    rp6 ^= (rp6 &gt;&gt; 16); rp6 ^= (rp6 &gt;&gt; 8); rp6 &amp;= 0xff;
    rp7 ^= (rp7 &gt;&gt; 16); rp7 ^= (rp7 &gt;&gt; 8); rp7 &amp;= 0xff;
    rp8 ^= (rp8 &gt;&gt; 16); rp8 ^= (rp8 &gt;&gt; 8); rp8 &amp;= 0xff;
    rp9 ^= (rp9 &gt;&gt; 16); rp9 ^= (rp9 &gt;&gt; 8); rp9 &amp;= 0xff;
    rp10 ^= (rp10 &gt;&gt; 16); rp10 ^= (rp10 &gt;&gt; 8); rp10 &amp;= 0xff;
    rp11 ^= (rp11 &gt;&gt; 16); rp11 ^= (rp11 &gt;&gt; 8); rp11 &amp;= 0xff;
    rp12 ^= (rp12 &gt;&gt; 16); rp12 ^= (rp12 &gt;&gt; 8); rp12 &amp;= 0xff;
    rp13 ^= (rp13 &gt;&gt; 16); rp13 ^= (rp13 &gt;&gt; 8); rp13 &amp;= 0xff;
    rp14 ^= (rp14 &gt;&gt; 16); rp14 ^= (rp14 &gt;&gt; 8); rp14 &amp;= 0xff;
    rp15 ^= (rp15 &gt;&gt; 16); rp15 ^= (rp15 &gt;&gt; 8); rp15 &amp;= 0xff;
    rp3 = (par &gt;&gt; 16); rp3 ^= (rp3 &gt;&gt; 8); rp3 &amp;= 0xff;
    rp2 = par &amp; 0xffff; rp2 ^= (rp2 &gt;&gt; 8); rp2 &amp;= 0xff;
    par ^= (par &gt;&gt; 16);
    rp1 = (par &gt;&gt; 8); rp1 &amp;= 0xff;
    rp0 = (par &amp; 0xff);
    par ^= (par &gt;&gt; 8); par &amp;= 0xff;

    code[0] =
        (parity[rp7] &lt;&lt; 7) |
        (parity[rp6] &lt;&lt; 6) |
        (parity[rp5] &lt;&lt; 5) |
        (parity[rp4] &lt;&lt; 4) |
        (parity[rp3] &lt;&lt; 3) |
        (parity[rp2] &lt;&lt; 2) |
        (parity[rp1] &lt;&lt; 1) |
        (parity[rp0]);
    code[1] =
        (parity[rp15] &lt;&lt; 7) |
        (parity[rp14] &lt;&lt; 6) |
        (parity[rp13] &lt;&lt; 5) |
        (parity[rp12] &lt;&lt; 4) |
        (parity[rp11] &lt;&lt; 3) |
        (parity[rp10] &lt;&lt; 2) |
        (parity[rp9]  &lt;&lt; 1) |
        (parity[rp8]);
    code[2] =
        (parity[par &amp; 0xf0] &lt;&lt; 7) |
        (parity[par &amp; 0x0f] &lt;&lt; 6) |
        (parity[par &amp; 0xcc] &lt;&lt; 5) |
        (parity[par &amp; 0x33] &lt;&lt; 4) |
        (parity[par &amp; 0xaa] &lt;&lt; 3) |
        (parity[par &amp; 0x55] &lt;&lt; 2);
    code[0] = ~code[0];
    code[1] = ~code[1];
    code[2] = ~code[2];
}
</pre></div>
</div>
<p>The parity array is not shown any more. Note also that for these
examples I kinda deviated from my regular programming style by allowing
multiple statements on a line, not using { } in then and else blocks
with only a single statement and by using operators like ^=</p>
</section>
<section id="analysis-2">
<h2>Analysis 2<a class="headerlink" href="#analysis-2" title="Link to this heading">¶</a></h2>
<p>The code (of course) works, and hurray: we are a little bit faster than
the linux driver code (about 15%). But wait, don’t cheer too quickly.
There is more to be gained.
If we look at e.g. rp14 and rp15 we see that we either xor our data with
rp14 or with rp15. However we also have par which goes over all data.
This means there is no need to calculate rp14 as it can be calculated from
rp15 through rp14 = par ^ rp15, because par = rp14 ^ rp15;
(or if desired we can avoid calculating rp15 and calculate it from
rp14).  That is why some places refer to inverse parity.
Of course the same thing holds for rp4/5, rp6/7, rp8/9, rp10/11 and rp12/13.
Effectively this means we can eliminate the else clause from the if
statements. Also we can optimise the calculation in the end a little bit
by going from long to byte first. Actually we can even avoid the table
lookups</p>
</section>
<section id="attempt-3">
<h2>Attempt 3<a class="headerlink" href="#attempt-3" title="Link to this heading">¶</a></h2>
<p>Odd replaced:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (i &amp; 0x01) rp5 ^= cur; else rp4 ^= cur;
if (i &amp; 0x02) rp7 ^= cur; else rp6 ^= cur;
if (i &amp; 0x04) rp9 ^= cur; else rp8 ^= cur;
if (i &amp; 0x08) rp11 ^= cur; else rp10 ^= cur;
if (i &amp; 0x10) rp13 ^= cur; else rp12 ^= cur;
if (i &amp; 0x20) rp15 ^= cur; else rp14 ^= cur;
</pre></div>
</div>
<p>with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (i &amp; 0x01) rp5 ^= cur;
if (i &amp; 0x02) rp7 ^= cur;
if (i &amp; 0x04) rp9 ^= cur;
if (i &amp; 0x08) rp11 ^= cur;
if (i &amp; 0x10) rp13 ^= cur;
if (i &amp; 0x20) rp15 ^= cur;
</pre></div>
</div>
<p>and outside the loop added:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp4  = par ^ rp5;
rp6  = par ^ rp7;
rp8  = par ^ rp9;
rp10  = par ^ rp11;
rp12  = par ^ rp13;
rp14  = par ^ rp15;
</pre></div>
</div>
<p>And after that the code takes about 30% more time, although the number of
statements is reduced. This is also reflected in the assembly code.</p>
</section>
<section id="analysis-3">
<h2>Analysis 3<a class="headerlink" href="#analysis-3" title="Link to this heading">¶</a></h2>
<p>Very weird. Guess it has to do with caching or instruction parallelism
or so. I also tried on an eeePC (Celeron, clocked at 900 Mhz). Interesting
observation was that this one is only 30% slower (according to time)
executing the code as my 3Ghz D920 processor.</p>
<p>Well, it was expected not to be easy so maybe instead move to a
different track: let’s move back to the code from attempt2 and do some
loop unrolling. This will eliminate a few if statements. I’ll try
different amounts of unrolling to see what works best.</p>
</section>
<section id="attempt-4">
<h2>Attempt 4<a class="headerlink" href="#attempt-4" title="Link to this heading">¶</a></h2>
<p>Unrolled the loop 1, 2, 3 and 4 times.
For 4 the code starts with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++;
    par ^= cur;
    rp4 ^= cur;
    rp6 ^= cur;
    rp8 ^= cur;
    rp10 ^= cur;
    if (i &amp; 0x1) rp13 ^= cur; else rp12 ^= cur;
    if (i &amp; 0x2) rp15 ^= cur; else rp14 ^= cur;
    cur = *bp++;
    par ^= cur;
    rp5 ^= cur;
    rp6 ^= cur;
    ...
</pre></div>
</div>
</section>
<section id="analysis-4">
<h2>Analysis 4<a class="headerlink" href="#analysis-4" title="Link to this heading">¶</a></h2>
<p>Unrolling once gains about 15%</p>
<p>Unrolling twice keeps the gain at about 15%</p>
<p>Unrolling three times gives a gain of 30% compared to attempt 2.</p>
<p>Unrolling four times gives a marginal improvement compared to unrolling
three times.</p>
<p>I decided to proceed with a four time unrolled loop anyway. It was my gut
feeling that in the next steps I would obtain additional gain from it.</p>
<p>The next step was triggered by the fact that par contains the xor of all
bytes and rp4 and rp5 each contain the xor of half of the bytes.
So in effect par = rp4 ^ rp5. But as xor is commutative we can also say
that rp5 = par ^ rp4. So no need to keep both rp4 and rp5 around. We can
eliminate rp5 (or rp4, but I already foresaw another optimisation).
The same holds for rp6/7, rp8/9, rp10/11 rp12/13 and rp14/15.</p>
</section>
<section id="attempt-5">
<h2>Attempt 5<a class="headerlink" href="#attempt-5" title="Link to this heading">¶</a></h2>
<p>Effectively so all odd digit rp assignments in the loop were removed.
This included the else clause of the if statements.
Of course after the loop we need to correct things by adding code like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp5 = par ^ rp4;
</pre></div>
</div>
<p>Also the initial assignments (rp5 = 0; etc) could be removed.
Along the line I also removed the initialisation of rp0/1/2/3.</p>
</section>
<section id="analysis-5">
<h2>Analysis 5<a class="headerlink" href="#analysis-5" title="Link to this heading">¶</a></h2>
<p>Measurements showed this was a good move. The run-time roughly halved
compared with attempt 4 with 4 times unrolled, and we only require 1/3rd
of the processor time compared to the current code in the linux kernel.</p>
<p>However, still I thought there was more. I didn’t like all the if
statements. Why not keep a running parity and only keep the last if
statement. Time for yet another version!</p>
</section>
<section id="attempt-6">
<h2>Attempt 6<a class="headerlink" href="#attempt-6" title="Link to this heading">¶</a></h2>
<p>THe code within the for loop was changed to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++; tmppar  = cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= tmppar;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp10 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= cur;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;

    par ^= tmppar;
    if ((i &amp; 0x1) == 0) rp12 ^= tmppar;
    if ((i &amp; 0x2) == 0) rp14 ^= tmppar;
}
</pre></div>
</div>
<p>As you can see tmppar is used to accumulate the parity within a for
iteration. In the last 3 statements is added to par and, if needed,
to rp12 and rp14.</p>
<p>While making the changes I also found that I could exploit that tmppar
contains the running parity for this iteration. So instead of having:
rp4 ^= cur; rp6 ^= cur;
I removed the rp6 ^= cur; statement and did rp6 ^= tmppar; on next
statement. A similar change was done for rp8 and rp10</p>
</section>
<section id="analysis-6">
<h2>Analysis 6<a class="headerlink" href="#analysis-6" title="Link to this heading">¶</a></h2>
<p>Measuring this code again showed big gain. When executing the original
linux code 1 million times, this took about 1 second on my system.
(using time to measure the performance). After this iteration I was back
to 0.075 sec. Actually I had to decide to start measuring over 10
million iterations in order not to lose too much accuracy. This one
definitely seemed to be the jackpot!</p>
<p>There is a little bit more room for improvement though. There are three
places with statements:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp4 ^= cur; rp6 ^= cur;
</pre></div>
</div>
<p>It seems more efficient to also maintain a variable rp4_6 in the while
loop; This eliminates 3 statements per loop. Of course after the loop we
need to correct by adding:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp4 ^= rp4_6;
rp6 ^= rp4_6
</pre></div>
</div>
<p>Furthermore there are 4 sequential assignments to rp8. This can be
encoded slightly more efficiently by saving tmppar before those 4 lines
and later do rp8 = rp8 ^ tmppar ^ notrp8;
(where notrp8 is the value of rp8 before those 4 lines).
Again a use of the commutative property of xor.
Time for a new test!</p>
</section>
<section id="attempt-7">
<h2>Attempt 7<a class="headerlink" href="#attempt-7" title="Link to this heading">¶</a></h2>
<p>The new code now looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++; tmppar  = cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= tmppar;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp10 ^= tmppar;

    notrp8 = tmppar;
    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;
    rp8 = rp8 ^ tmppar ^ notrp8;

    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;

    par ^= tmppar;
    if ((i &amp; 0x1) == 0) rp12 ^= tmppar;
    if ((i &amp; 0x2) == 0) rp14 ^= tmppar;
}
rp4 ^= rp4_6;
rp6 ^= rp4_6;
</pre></div>
</div>
<p>Not a big change, but every penny counts :-)</p>
</section>
<section id="analysis-7">
<h2>Analysis 7<a class="headerlink" href="#analysis-7" title="Link to this heading">¶</a></h2>
<p>Actually this made things worse. Not very much, but I don’t want to move
into the wrong direction. Maybe something to investigate later. Could
have to do with caching again.</p>
<p>Guess that is what there is to win within the loop. Maybe unrolling one
more time will help. I’ll keep the optimisations from 7 for now.</p>
</section>
<section id="attempt-8">
<h2>Attempt 8<a class="headerlink" href="#attempt-8" title="Link to this heading">¶</a></h2>
<p>Unrolled the loop one more time.</p>
</section>
<section id="analysis-8">
<h2>Analysis 8<a class="headerlink" href="#analysis-8" title="Link to this heading">¶</a></h2>
<p>This makes things worse. Let’s stick with attempt 6 and continue from there.
Although it seems that the code within the loop cannot be optimised
further there is still room to optimize the generation of the ecc codes.
We can simply calculate the total parity. If this is 0 then rp4 = rp5
etc. If the parity is 1, then rp4 = !rp5;</p>
<p>But if rp4 = rp5 we do not need rp5 etc. We can just write the even bits
in the result byte and then do something like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>code[0] |= (code[0] &lt;&lt; 1);
</pre></div>
</div>
<p>Lets test this.</p>
</section>
<section id="attempt-9">
<h2>Attempt 9<a class="headerlink" href="#attempt-9" title="Link to this heading">¶</a></h2>
<p>Changed the code but again this slightly degrades performance. Tried all
kind of other things, like having dedicated parity arrays to avoid the
shift after parity[rp7] &lt;&lt; 7; No gain.
Change the lookup using the parity array by using shift operators (e.g.
replace parity[rp7] &lt;&lt; 7 with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rp7 ^= (rp7 &lt;&lt; 4);
rp7 ^= (rp7 &lt;&lt; 2);
rp7 ^= (rp7 &lt;&lt; 1);
rp7 &amp;= 0x80;
</pre></div>
</div>
<p>No gain.</p>
<p>The only marginal change was inverting the parity bits, so we can remove
the last three invert statements.</p>
<p>Ah well, pity this does not deliver more. Then again 10 million
iterations using the linux driver code takes between 13 and 13.5
seconds, whereas my code now takes about 0.73 seconds for those 10
million iterations. So basically I’ve improved the performance by a
factor 18 on my system. Not that bad. Of course on different hardware
you will get different results. No warranties!</p>
<p>But of course there is no such thing as a free lunch. The codesize almost
tripled (from 562 bytes to 1434 bytes). Then again, it is not that much.</p>
</section>
<section id="correcting-errors">
<h2>Correcting errors<a class="headerlink" href="#correcting-errors" title="Link to this heading">¶</a></h2>
<p>For correcting errors I again used the ST application note as a starter,
but I also peeked at the existing code.</p>
<p>The algorithm itself is pretty straightforward. Just xor the given and
the calculated ecc. If all bytes are 0 there is no problem. If 11 bits
are 1 we have one correctable bit error. If there is 1 bit 1, we have an
error in the given ecc code.</p>
<p>It proved to be fastest to do some table lookups. Performance gain
introduced by this is about a factor 2 on my system when a repair had to
be done, and 1% or so if no repair had to be done.</p>
<p>Code size increased from 330 bytes to 686 bytes for this function.
(gcc 4.2, -O3)</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading">¶</a></h2>
<p>The gain when calculating the ecc is tremendous. Om my development hardware
a speedup of a factor of 18 for ecc calculation was achieved. On a test on an
embedded system with a MIPS core a factor 7 was obtained.</p>
<p>On a test with a Linksys NSLU2 (ARMv5TE processor) the speedup was a factor
5 (big endian mode, gcc 4.1.2, -O3)</p>
<p>For correction not much gain could be obtained (as bitflips are rare). Then
again there are also much less cycles spent there.</p>
<p>It seems there is not much more gain possible in this, at least when
programmed in C. Of course it might be possible to squeeze something more
out of it with an assembler program, but due to pipeline behaviour etc
this is very tricky (at least for intel hw).</p>
<p>Author: Frans Meulenbroeks</p>
<p>Copyright (C) 2008 Koninklijke Philips Electronics NV.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/mtd/nand_ecc.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>