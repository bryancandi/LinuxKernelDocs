<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Device drivers infrastructure &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ioctl based interfaces" href="ioctl.html" />
    <link rel="prev" title="Device links" href="device_link.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.10.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Device drivers infrastructure</a></li>
<li class="toctree-l3"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/infrastructure.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="device-drivers-infrastructure">
<h1>Device drivers infrastructure<a class="headerlink" href="#device-drivers-infrastructure" title="Link to this heading">¶</a></h1>
<section id="the-basic-device-driver-model-structures">
<h2>The Basic Device Driver-Model Structures<a class="headerlink" href="#the-basic-device-driver-model-structures" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.subsys_interface">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">subsys_interface</span></span></span><a class="headerlink" href="#c.subsys_interface" title="Link to this definition">¶</a><br /></dt>
<dd><p>interfaces to device functions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct subsys_interface {
    const char *name;
    const struct bus_type *subsys;
    struct list_head node;
    int (*add_dev)(struct device *dev, struct subsys_interface *sif);
    void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the device function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subsys</span></code></dt><dd><p>subsystem of the devices to attach to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>the list of functions registered at the subsystem</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_dev</span></code></dt><dd><p>device hookup to device function handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove_dev</span></code></dt><dd><p>device hookup to device function handler</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Simple interfaces attached to a subsystem. Multiple interfaces can
attach to a subsystem and its devices. Unlike drivers, they do not
exclusively claim or control devices. Interfaces usually represent
a specific functionality of a subsystem/class of devices.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.device_attribute">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_attribute</span></span></span><a class="headerlink" href="#c.device_attribute" title="Link to this definition">¶</a><br /></dt>
<dd><p>Interface for exporting device attributes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device_attribute {
    struct attribute        attr;
    ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf);
    ssize_t (*store)(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">attr</span></code></dt><dd><p>sysfs attribute definition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">show</span></code></dt><dd><p>Show handler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">store</span></code></dt><dd><p>Store handler.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dev_ext_attribute">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dev_ext_attribute</span></span></span><a class="headerlink" href="#c.dev_ext_attribute" title="Link to this definition">¶</a><br /></dt>
<dd><p>Exported device attribute with extra context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dev_ext_attribute {
    struct device_attribute attr;
    void *var;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">attr</span></code></dt><dd><p>Exported device attribute.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">var</span></code></dt><dd><p>Pointer to context.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_ATTR">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_ATTR</span></span></span><a class="headerlink" href="#c.DEVICE_ATTR" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_ATTR</span> <span class="pre">(_name,</span> <span class="pre">_mode,</span> <span class="pre">_show,</span> <span class="pre">_store)</span></code></p>
<blockquote>
<div><p>Define a device attribute.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mode</span></code></dt><dd><p>File mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_show</span></code></dt><dd><p>Show handler. Optional, but mandatory if attribute is readable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_store</span></code></dt><dd><p>Store handler. Optional, but mandatory if attribute is writable.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenience macro for defining a <a class="reference internal" href="#c.device_attribute" title="device_attribute"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_attribute</span></code></a>.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">DEVICE_ATTR(foo,</span> <span class="pre">0644,</span> <span class="pre">foo_show,</span> <span class="pre">foo_store);</span></code> expands to:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">device_attribute</span><span class="w"> </span><span class="n">dev_attr_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">attr</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0644</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">.</span><span class="n">show</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">foo_show</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">store</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">foo_store</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_ATTR_PREALLOC">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_ATTR_PREALLOC</span></span></span><a class="headerlink" href="#c.DEVICE_ATTR_PREALLOC" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_ATTR_PREALLOC</span> <span class="pre">(_name,</span> <span class="pre">_mode,</span> <span class="pre">_show,</span> <span class="pre">_store)</span></code></p>
<blockquote>
<div><p>Define a preallocated device attribute.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mode</span></code></dt><dd><p>File mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_show</span></code></dt><dd><p>Show handler. Optional, but mandatory if attribute is readable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_store</span></code></dt><dd><p>Store handler. Optional, but mandatory if attribute is writable.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ATTR" title="DEVICE_ATTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ATTR()</span></code></a>, but <code class="docutils literal notranslate"><span class="pre">SYSFS_PREALLOC</span></code> is set on <strong>_mode</strong>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_ATTR_RW">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_ATTR_RW</span></span></span><a class="headerlink" href="#c.DEVICE_ATTR_RW" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_ATTR_RW</span> <span class="pre">(_name)</span></code></p>
<blockquote>
<div><p>Define a read-write device attribute.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ATTR" title="DEVICE_ATTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ATTR()</span></code></a>, but <strong>_mode</strong> is 0644, <strong>_show</strong> is &lt;_name&gt;_show,
and <strong>_store</strong> is &lt;_name&gt;_store.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_ATTR_ADMIN_RW">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_ATTR_ADMIN_RW</span></span></span><a class="headerlink" href="#c.DEVICE_ATTR_ADMIN_RW" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_ATTR_ADMIN_RW</span> <span class="pre">(_name)</span></code></p>
<blockquote>
<div><p>Define an admin-only read-write device attribute.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ATTR_RW" title="DEVICE_ATTR_RW"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ATTR_RW()</span></code></a>, but <strong>_mode</strong> is 0600.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_ATTR_RO">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_ATTR_RO</span></span></span><a class="headerlink" href="#c.DEVICE_ATTR_RO" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_ATTR_RO</span> <span class="pre">(_name)</span></code></p>
<blockquote>
<div><p>Define a readable device attribute.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ATTR" title="DEVICE_ATTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ATTR()</span></code></a>, but <strong>_mode</strong> is 0444 and <strong>_show</strong> is &lt;_name&gt;_show.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_ATTR_ADMIN_RO">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_ATTR_ADMIN_RO</span></span></span><a class="headerlink" href="#c.DEVICE_ATTR_ADMIN_RO" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_ATTR_ADMIN_RO</span> <span class="pre">(_name)</span></code></p>
<blockquote>
<div><p>Define an admin-only readable device attribute.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ATTR_RO" title="DEVICE_ATTR_RO"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ATTR_RO()</span></code></a>, but <strong>_mode</strong> is 0400.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_ATTR_WO">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_ATTR_WO</span></span></span><a class="headerlink" href="#c.DEVICE_ATTR_WO" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_ATTR_WO</span> <span class="pre">(_name)</span></code></p>
<blockquote>
<div><p>Define an admin-only writable device attribute.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ATTR" title="DEVICE_ATTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ATTR()</span></code></a>, but <strong>_mode</strong> is 0200 and <strong>_store</strong> is &lt;_name&gt;_store.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_ULONG_ATTR">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_ULONG_ATTR</span></span></span><a class="headerlink" href="#c.DEVICE_ULONG_ATTR" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_ULONG_ATTR</span> <span class="pre">(_name,</span> <span class="pre">_mode,</span> <span class="pre">_var)</span></code></p>
<blockquote>
<div><p>Define a device attribute backed by an unsigned long.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mode</span></code></dt><dd><p>File mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_var</span></code></dt><dd><p>Identifier of unsigned long.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ATTR" title="DEVICE_ATTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ATTR()</span></code></a>, but <strong>_show</strong> and <strong>_store</strong> are automatically provided
such that reads and writes to the attribute from userspace affect <strong>_var</strong>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_INT_ATTR">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_INT_ATTR</span></span></span><a class="headerlink" href="#c.DEVICE_INT_ATTR" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_INT_ATTR</span> <span class="pre">(_name,</span> <span class="pre">_mode,</span> <span class="pre">_var)</span></code></p>
<blockquote>
<div><p>Define a device attribute backed by an int.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mode</span></code></dt><dd><p>File mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_var</span></code></dt><dd><p>Identifier of int.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ULONG_ATTR" title="DEVICE_ULONG_ATTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ULONG_ATTR()</span></code></a>, but <strong>_var</strong> is an int.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_BOOL_ATTR">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_BOOL_ATTR</span></span></span><a class="headerlink" href="#c.DEVICE_BOOL_ATTR" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_BOOL_ATTR</span> <span class="pre">(_name,</span> <span class="pre">_mode,</span> <span class="pre">_var)</span></code></p>
<blockquote>
<div><p>Define a device attribute backed by a bool.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mode</span></code></dt><dd><p>File mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_var</span></code></dt><dd><p>Identifier of bool.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ULONG_ATTR" title="DEVICE_ULONG_ATTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ULONG_ATTR()</span></code></a>, but <strong>_var</strong> is a bool.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEVICE_STRING_ATTR_RO">
<span class="sig-name descname"><span class="n"><span class="pre">DEVICE_STRING_ATTR_RO</span></span></span><a class="headerlink" href="#c.DEVICE_STRING_ATTR_RO" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEVICE_STRING_ATTR_RO</span> <span class="pre">(_name,</span> <span class="pre">_mode,</span> <span class="pre">_var)</span></code></p>
<blockquote>
<div><p>Define a device attribute backed by a r/o string.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_name</span></code></dt><dd><p>Attribute name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_mode</span></code></dt><dd><p>File mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_var</span></code></dt><dd><p>Identifier of string.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.DEVICE_ULONG_ATTR" title="DEVICE_ULONG_ATTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEVICE_ULONG_ATTR()</span></code></a>, but <strong>_var</strong> is a string. Because the length of the
string allocation is unknown, the attribute must be read-only.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.devm_alloc_percpu">
<span class="sig-name descname"><span class="n"><span class="pre">devm_alloc_percpu</span></span></span><a class="headerlink" href="#c.devm_alloc_percpu" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">devm_alloc_percpu</span> <span class="pre">(dev,</span> <span class="pre">type)</span></code></p>
<blockquote>
<div><p>Resource-managed alloc_percpu</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device to allocate per-cpu memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type to allocate per-cpu memory for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed alloc_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.dl_dev_state">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dl_dev_state</span></span></span><a class="headerlink" href="#c.dl_dev_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>Device driver presence tracking information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_NO_DRIVER</span></code></dt><dd><p>There is no driver attached to the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_PROBING</span></code></dt><dd><p>A driver is probing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_DRIVER_BOUND</span></code></dt><dd><p>The driver has been bound to the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_UNBINDING</span></code></dt><dd><p>The driver is unbinding from the device.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.device_removable">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_removable</span></span></span><a class="headerlink" href="#c.device_removable" title="Link to this definition">¶</a><br /></dt>
<dd><p>Whether the device is removable. The criteria for a device to be classified as removable is determined by its subsystem or bus.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_REMOVABLE_NOT_SUPPORTED</span></code></dt><dd><p>This attribute is not supported for this
device (default).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_REMOVABLE_UNKNOWN</span></code></dt><dd><p>Device location is Unknown.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_FIXED</span></code></dt><dd><p>Device is not removable by the user.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_REMOVABLE</span></code></dt><dd><p>Device is removable by the user.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dev_links_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dev_links_info</span></span></span><a class="headerlink" href="#c.dev_links_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Device data related to device links.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dev_links_info {
    struct list_head suppliers;
    struct list_head consumers;
    struct list_head defer_sync;
    enum dl_dev_state status;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">suppliers</span></code></dt><dd><p>List of links to supplier devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumers</span></code></dt><dd><p>List of links to consumer devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">defer_sync</span></code></dt><dd><p>Hook to global list of devices that have deferred sync_state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>Driver status information.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dev_msi_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dev_msi_info</span></span></span><a class="headerlink" href="#c.dev_msi_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Device data related to MSI</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dev_msi_info {
#ifdef CONFIG_GENERIC_MSI_IRQ;
    struct irq_domain       *domain;
    struct msi_device_data  *data;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">domain</span></code></dt><dd><p>The MSI interrupt domain associated to the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Pointer to MSI device data</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.device_physical_location_panel">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_physical_location_panel</span></span></span><a class="headerlink" href="#c.device_physical_location_panel" title="Link to this definition">¶</a><br /></dt>
<dd><p>Describes which panel surface of the system’s housing the device connection point resides on.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_TOP</span></code></dt><dd><p>Device connection point is on the top panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_BOTTOM</span></code></dt><dd><p>Device connection point is on the bottom panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_LEFT</span></code></dt><dd><p>Device connection point is on the left panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_RIGHT</span></code></dt><dd><p>Device connection point is on the right panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_FRONT</span></code></dt><dd><p>Device connection point is on the front panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_BACK</span></code></dt><dd><p>Device connection point is on the back panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_UNKNOWN</span></code></dt><dd><p>The panel with device connection point is unknown.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.device_physical_location_vertical_position">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_physical_location_vertical_position</span></span></span><a class="headerlink" href="#c.device_physical_location_vertical_position" title="Link to this definition">¶</a><br /></dt>
<dd><p>Describes vertical position of the device connection point on the panel surface.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_VERT_POS_UPPER</span></code></dt><dd><p>Device connection point is at upper part of panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_VERT_POS_CENTER</span></code></dt><dd><p>Device connection point is at center part of panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_VERT_POS_LOWER</span></code></dt><dd><p>Device connection point is at lower part of panel.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.device_physical_location_horizontal_position">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_physical_location_horizontal_position</span></span></span><a class="headerlink" href="#c.device_physical_location_horizontal_position" title="Link to this definition">¶</a><br /></dt>
<dd><p>Describes horizontal position of the device connection point on the panel surface.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_HORI_POS_LEFT</span></code></dt><dd><p>Device connection point is at left part of panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_HORI_POS_CENTER</span></code></dt><dd><p>Device connection point is at center part of panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_HORI_POS_RIGHT</span></code></dt><dd><p>Device connection point is at right part of panel.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.device_physical_location">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_physical_location</span></span></span><a class="headerlink" href="#c.device_physical_location" title="Link to this definition">¶</a><br /></dt>
<dd><p>Device data related to physical location of the device connection point.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device_physical_location {
    enum device_physical_location_panel panel;
    enum device_physical_location_vertical_position vertical_position;
    enum device_physical_location_horizontal_position horizontal_position;
    bool dock;
    bool lid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">panel</span></code></dt><dd><p>Panel surface of the system’s housing that the device connection
point resides on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vertical_position</span></code></dt><dd><p>Vertical position of the device connection point within
the panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">horizontal_position</span></code></dt><dd><p>Horizontal position of the device connection point
within the panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dock</span></code></dt><dd><p>Set if the device connection point resides in a docking station or
port replicator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lid</span></code></dt><dd><p>Set if this device connection point resides on the lid of laptop
system.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device</span></span></span><a class="headerlink" href="#c.device" title="Link to this definition">¶</a><br /></dt>
<dd><p>The basic device structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device {
    struct kobject kobj;
    struct device           *parent;
    struct device_private   *p;
    const char              *init_name;
    const struct device_type *type;
    const struct bus_type   *bus;
    struct device_driver *driver;
    void *platform_data;
    void *driver_data;
    struct mutex            mutex;
    struct dev_links_info   links;
    struct dev_pm_info      power;
    struct dev_pm_domain    *pm_domain;
#ifdef CONFIG_ENERGY_MODEL;
    struct em_perf_domain   *em_pd;
#endif;
#ifdef CONFIG_PINCTRL;
    struct dev_pin_info     *pins;
#endif;
    struct dev_msi_info     msi;
#ifdef CONFIG_DMA_OPS;
    const struct dma_map_ops *dma_ops;
#endif;
    u64 *dma_mask;
    u64 coherent_dma_mask;
    u64 bus_dma_limit;
    const struct bus_dma_region *dma_range_map;
    struct device_dma_parameters *dma_parms;
    struct list_head        dma_pools;
#ifdef CONFIG_DMA_DECLARE_COHERENT;
    struct dma_coherent_mem *dma_mem;
#endif;
#ifdef CONFIG_DMA_CMA;
    struct cma *cma_area;
#endif;
#ifdef CONFIG_SWIOTLB;
    struct io_tlb_mem *dma_io_tlb_mem;
#endif;
#ifdef CONFIG_SWIOTLB_DYNAMIC;
    struct list_head dma_io_tlb_pools;
    spinlock_t dma_io_tlb_lock;
    bool dma_uses_io_tlb;
#endif;
    struct dev_archdata     archdata;
    struct device_node      *of_node;
    struct fwnode_handle    *fwnode;
#ifdef CONFIG_NUMA;
    int numa_node;
#endif;
    dev_t devt;
    u32 id;
    spinlock_t devres_lock;
    struct list_head        devres_head;
    const struct class      *class;
    const struct attribute_group **groups;
    void (*release)(struct device *dev);
    struct iommu_group      *iommu_group;
    struct dev_iommu        *iommu;
    struct device_physical_location *physical_location;
    enum device_removable   removable;
    bool offline_disabled:1;
    bool offline:1;
    bool of_node_reused:1;
    bool state_synced:1;
    bool can_match:1;
#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) ||     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) ||     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL);
    bool dma_coherent:1;
#endif;
#ifdef CONFIG_DMA_OPS_BYPASS;
    bool dma_ops_bypass : 1;
#endif;
#ifdef CONFIG_DMA_NEED_SYNC;
    bool dma_skip_sync:1;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kobj</span></code></dt><dd><p>A top-level, abstract class from which other classes are derived.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>The device’s “parent” device, the device to which it is attached.
In most cases, a parent device is some sort of bus or host
controller. If parent is NULL, the device, is a top-level device,
which is not usually what you want.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Holds the private data of the driver core portions of the device.
See the comment of the struct device_private for detail.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_name</span></code></dt><dd><p>Initial name of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>The type of device.
This identifies the device type and carries type-specific
information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>Type of bus device is on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>Which driver has allocated this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">platform_data</span></code></dt><dd><p>Platform data specific to the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Private pointer for driver specific info.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>Mutex to synchronize calls to its driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">links</span></code></dt><dd><p>Links to suppliers and consumers of this device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">power</span></code></dt><dd><p>For device power management.
See <a class="reference internal" href="pm/devices.html"><span class="doc">Device Power Management Basics</span></a> for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm_domain</span></code></dt><dd><p>Provide callbacks that are executed during system suspend,
hibernation, system resume and during runtime PM transitions
along with subsystem-level and driver-level callbacks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">em_pd</span></code></dt><dd><p>device’s energy model performance domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pins</span></code></dt><dd><p>For device pin management.
See <a class="reference internal" href="pin-control.html"><span class="doc">PINCTRL (PIN CONTROL) subsystem</span></a> for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msi</span></code></dt><dd><p>MSI related data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_ops</span></code></dt><dd><p>DMA mapping operations for this device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_mask</span></code></dt><dd><p>Dma mask (if dma’ble device).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coherent_dma_mask</span></code></dt><dd><p>Like dma_mask, but for alloc_coherent mapping as not all
hardware supports 64-bit addresses for consistent allocations
such descriptors.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_dma_limit</span></code></dt><dd><p>Limit of an upstream bridge or bus which imposes a smaller
DMA limit than the device itself supports.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_range_map</span></code></dt><dd><p>map for DMA memory ranges relative to that of RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_parms</span></code></dt><dd><p>A low level driver may set these to teach IOMMU code about
segment limitations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_pools</span></code></dt><dd><p>Dma pools (if dma’ble device).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_mem</span></code></dt><dd><p>Internal for coherent mem override.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cma_area</span></code></dt><dd><p>Contiguous memory area for dma allocations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_io_tlb_mem</span></code></dt><dd><p>Software IO TLB allocator.  Not for driver use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_io_tlb_pools</span></code></dt><dd><p>List of transient swiotlb memory pools.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_io_tlb_lock</span></code></dt><dd><p>Protects changes to the list of active pools.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_uses_io_tlb</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if device has used the software IO TLB.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">archdata</span></code></dt><dd><p>For arch-specific additions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>Associated device tree node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>Associated device node supplied by platform firmware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">numa_node</span></code></dt><dd><p>NUMA node this device is close to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devt</span></code></dt><dd><p>For creating the sysfs “dev”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devres_lock</span></code></dt><dd><p>Spinlock to protect the resource of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devres_head</span></code></dt><dd><p>The resources list of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class</span></code></dt><dd><p>The class of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">groups</span></code></dt><dd><p>Optional attribute groups.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Callback to free the device after all references have
gone away. This should be set by the allocator of the
device (i.e. the bus driver that discovered the device).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iommu_group</span></code></dt><dd><p>IOMMU group the device belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iommu</span></code></dt><dd><p>Per device generic IOMMU runtime data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">physical_location</span></code></dt><dd><p>Describes physical location of the device connection
point in the system housing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">removable</span></code></dt><dd><p>Whether the device can be removed from the system. This
should be set by the subsystem / bus driver that discovered
the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offline_disabled</span></code></dt><dd><p>If set, the device is permanently online.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offline</span></code></dt><dd><p>Set after successful invocation of bus type’s .offline().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node_reused</span></code></dt><dd><p>Set if the device-tree node is shared with an ancestor
device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_synced</span></code></dt><dd><p>The hardware state of this device has been synced to match
the software state of this device by calling the driver/bus
sync_state() callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_match</span></code></dt><dd><p>The device has matched with a driver at least once or it is in
a bus (like AMBA) which can’t check for matching drivers until
other devices probe successfully.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_coherent</span></code></dt><dd><p>this particular device is dma coherent, even if the
architecture supports non-coherent devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_ops_bypass</span></code></dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">true</span></code> then the dma_ops are bypassed for the
streaming DMA operations (-&gt;map_* / -&gt;unmap_* / -&gt;sync_*),
and optionall (if the coherent mask is large enough) also
for dma allocations.  This flag is managed by the dma ops
instance from -&gt;dma_supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_skip_sync</span></code></dt><dd><p>DMA sync operations can be skipped for coherent buffers.</p>
</dd>
</dl>
</div>
<p><strong>Example</strong></p>
<dl class="simple">
<dt>For devices on custom boards, as typical of embedded</dt><dd><p>and SOC based hardware, Linux often uses platform_data to point
to board-specific structures describing devices and how they
are wired.  That can include what ports are available, chip
variants, which GPIO pins act in what additional roles, and so
on.  This shrinks the “Board Support Packages” (BSPs) and
minimizes board-specific #ifdefs in drivers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>At the lowest level, every device in a Linux system is represented by an
instance of <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>. The device structure contains the information
that the device model core needs to model the system. Most subsystems,
however, track additional information about the devices they host. As a
result, it is rare for devices to be represented by bare device structures;
instead, that structure, like kobject structures, is usually embedded within
a higher-level representation of the device.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.device_link">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_link</span></span></span><a class="headerlink" href="#c.device_link" title="Link to this definition">¶</a><br /></dt>
<dd><p>Device link representation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device_link {
    struct device *supplier;
    struct list_head s_node;
    struct device *consumer;
    struct list_head c_node;
    struct device link_dev;
    enum device_link_state status;
    u32 flags;
    refcount_t rpm_active;
    struct kref kref;
    struct work_struct rm_work;
    bool supplier_preactivated;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supplier</span></code></dt><dd><p>The device on the supplier end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_node</span></code></dt><dd><p>Hook to the supplier device’s list of links to consumers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumer</span></code></dt><dd><p>The device on the consumer end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_node</span></code></dt><dd><p>Hook to the consumer device’s list of links to suppliers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_dev</span></code></dt><dd><p>device used to expose link details in sysfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>The state of the link (with respect to the presence of drivers).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Link flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rpm_active</span></code></dt><dd><p>Whether or not the consumer device is runtime-PM-active.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>Count repeated addition of the same link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rm_work</span></code></dt><dd><p>Work structure used for removing the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supplier_preactivated</span></code></dt><dd><p>Supplier has been made active before consumer probe.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_iommu_mapped">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_iommu_mapped</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_iommu_mapped" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true when the device DMA is translated by an IOMMU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to perform the check on</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dev_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dev_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_name" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a device’s name.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device with name to get.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The kobject name of the device, or its initial name if unavailable.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dev_bus_name">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dev_bus_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_bus_name" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a device’s bus/class name, if at all possible</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to get the bus/class name of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will return the name of the bus/class the device is attached to.  If it is
not attached to a bus/class, an empty string will be returned.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.device_lock_set_class">
<span class="sig-name descname"><span class="n"><span class="pre">device_lock_set_class</span></span></span><a class="headerlink" href="#c.device_lock_set_class" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">device_lock_set_class</span> <span class="pre">(dev,</span> <span class="pre">key)</span></code></p>
<blockquote>
<div><p>Specify a temporary lock class while a device is attached to a driver</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>lock class key data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called with the device_lock() already held, for example
from driver -&gt;probe(). Take care to only override the default
lockdep_no_validate class.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.device_lock_reset_class">
<span class="sig-name descname"><span class="n"><span class="pre">device_lock_reset_class</span></span></span><a class="headerlink" href="#c.device_lock_reset_class" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">device_lock_reset_class</span> <span class="pre">(dev)</span></code></p>
<blockquote>
<div><p>Return a device to the default lockdep novalidate state</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called with the device_lock() already held, for example
from driver -&gt;remove().</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.bus_type">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bus_type</span></span></span><a class="headerlink" href="#c.bus_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>The bus type of the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct bus_type {
    const char              *name;
    const char              *dev_name;
    const struct attribute_group **bus_groups;
    const struct attribute_group **dev_groups;
    const struct attribute_group **drv_groups;
    int (*match)(struct device *dev, struct device_driver *drv);
    int (*uevent)(const struct device *dev, struct kobj_uevent_env *env);
    int (*probe)(struct device *dev);
    void (*sync_state)(struct device *dev);
    void (*remove)(struct device *dev);
    void (*shutdown)(struct device *dev);
    int (*online)(struct device *dev);
    int (*offline)(struct device *dev);
    int (*suspend)(struct device *dev, pm_message_t state);
    int (*resume)(struct device *dev);
    int (*num_vf)(struct device *dev);
    int (*dma_configure)(struct device *dev);
    void (*dma_cleanup)(struct device *dev);
    const struct dev_pm_ops *pm;
    bool need_parent_lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The name of the bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_name</span></code></dt><dd><p>Used for subsystems to enumerate devices like (“foo``u``”, dev-&gt;id).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_groups</span></code></dt><dd><p>Default attributes of the bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_groups</span></code></dt><dd><p>Default attributes of the devices on the bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv_groups</span></code></dt><dd><p>Default attributes of the device drivers on the bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">match</span></code></dt><dd><p>Called, perhaps multiple times, whenever a new device or driver
is added for this bus. It should return a positive value if the
given device can be handled by the given driver and zero
otherwise. It may also return error code if determining that
the driver supports the device is not possible. In case of
-EPROBE_DEFER it will queue the device for deferred probing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uevent</span></code></dt><dd><p>Called when a device is added, removed, or a few other things
that generate uevents to add the environment variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Called when a new device or driver add to this bus, and callback
the specific driver’s probe to initial the matched device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync_state</span></code></dt><dd><p>Called to sync device state to software state after all the
state tracking consumers linked to this device (present at
the time of late_initcall) have successfully bound to a
driver. If the device has no consumers, this function will
be called at late_initcall_sync level. If the device has
consumers that are never bound to a driver, this function
will never get called until they do.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>Called when a device removed from this bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>Called at shut-down time to quiesce the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">online</span></code></dt><dd><p>Called to put the device back online (after offlining it).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offline</span></code></dt><dd><p>Called to put the device offline for hot-removal. May fail.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Called when a device on this bus wants to go to sleep mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Called to bring a device on this bus out of sleep mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_vf</span></code></dt><dd><p>Called to find out how many virtual functions a device on this
bus supports.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_configure</span></code></dt><dd><p>Called to setup DMA configuration on a device on
this bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_cleanup</span></code></dt><dd><p>Called to cleanup DMA configuration on a device on
this bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm</span></code></dt><dd><p>Power management operations of this bus, callback the specific
device driver’s pm-ops.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">need_parent_lock</span></code></dt><dd><p>When probing or removing a device on this bus, the
device core should lock the device’s parent.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A bus is a channel between the processor and one or more devices. For the
purposes of the device model, all devices are connected via a bus, even if
it is an internal, virtual, “platform” bus. Buses can plug into each other.
A USB controller is usually a PCI device, for example. The device model
represents the actual connections between buses and the devices they control.
A bus is represented by the bus_type structure. It contains the name, the
default attributes, the bus’ methods, PM operations, and the driver core’s
private data.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.bus_notifier_event">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bus_notifier_event</span></span></span><a class="headerlink" href="#c.bus_notifier_event" title="Link to this definition">¶</a><br /></dt>
<dd><p>Bus Notifier events that have happened</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_ADD_DEVICE</span></code></dt><dd><p>device is added to this bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_DEL_DEVICE</span></code></dt><dd><p>device is about to be removed from this bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_REMOVED_DEVICE</span></code></dt><dd><p>device is successfully removed from this bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_BIND_DRIVER</span></code></dt><dd><p>a driver is about to be bound to this device on this bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_BOUND_DRIVER</span></code></dt><dd><p>a driver is successfully bound to this device on this bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_UNBIND_DRIVER</span></code></dt><dd><p>a driver is about to be unbound from this device on this bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_UNBOUND_DRIVER</span></code></dt><dd><p>a driver is successfully unbound from this device on this bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BUS_NOTIFY_DRIVER_NOT_BOUND</span></code></dt><dd><p>a driver failed to be bound to this device on this bus</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These are the value passed to a bus notifier when a specific event happens.</p>
<p>Note that bus notifiers are likely to be called with the device lock already
held by the driver core, so be careful in any notifier callback as to what
you do with the device structure.</p>
<p>All bus notifiers are called with the target <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> * as an argument.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.class">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class</span></span></span><a class="headerlink" href="#c.class" title="Link to this definition">¶</a><br /></dt>
<dd><p>device classes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct class {
    const char              *name;
    const struct attribute_group    **class_groups;
    const struct attribute_group    **dev_groups;
    int (*dev_uevent)(const struct device *dev, struct kobj_uevent_env *env);
    char *(*devnode)(const struct device *dev, umode_t *mode);
    void (*class_release)(const struct class *class);
    void (*dev_release)(struct device *dev);
    int (*shutdown_pre)(struct device *dev);
    const struct kobj_ns_type_operations *ns_type;
    const void *(*namespace)(const struct device *dev);
    void (*get_ownership)(const struct device *dev, kuid_t *uid, kgid_t *gid);
    const struct dev_pm_ops *pm;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class_groups</span></code></dt><dd><p>Default attributes of this class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_groups</span></code></dt><dd><p>Default attributes of the devices that belong to the class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_uevent</span></code></dt><dd><p>Called when a device is added, removed from this class, or a
few other things that generate uevents to add the environment
variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devnode</span></code></dt><dd><p>Callback to provide the devtmpfs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class_release</span></code></dt><dd><p>Called to release this class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_release</span></code></dt><dd><p>Called to release the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown_pre</span></code></dt><dd><p>Called at shut-down time before driver shutdown.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ns_type</span></code></dt><dd><p>Callbacks so sysfs can detemine namespaces.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namespace</span></code></dt><dd><p>Namespace of the device belongs to this class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_ownership</span></code></dt><dd><p>Allows class to specify uid/gid of the sysfs directories
for the devices belonging to the class. Usually tied to
device’s namespace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm</span></code></dt><dd><p>The default device power management operations of this class.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A class is a higher-level view of a device that abstracts out low-level
implementation details. Drivers may see a SCSI disk or an ATA disk, but,
at the class level, they are all simply disks. Classes allow user space
to work with devices based on what they do, rather than how they are
connected or how they work.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.probe_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">probe_type</span></span></span><a class="headerlink" href="#c.probe_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>device driver probe type to try Device drivers may opt in for special handling of their respective probe routines. This tells the core what to expect and prefer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PROBE_DEFAULT_STRATEGY</span></code></dt><dd><p>Used by drivers that work equally well
whether probed synchronously or asynchronously.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PROBE_PREFER_ASYNCHRONOUS</span></code></dt><dd><p>Drivers for “slow” devices which
probing order is not essential for booting the system may
opt into executing their probes asynchronously.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PROBE_FORCE_SYNCHRONOUS</span></code></dt><dd><p>Use this to annotate drivers that need
their probe routines to run synchronously with driver and
device registration (with the exception of -EPROBE_DEFER
handling - re-probing always ends up being done asynchronously).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that the end goal is to switch the kernel to use asynchronous
probing by default, so annotating drivers with
<code class="docutils literal notranslate"><span class="pre">PROBE_PREFER_ASYNCHRONOUS</span></code> is a temporary measure that allows us
to speed up boot process while we are validating the rest of the
drivers.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.device_driver">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_driver</span></span></span><a class="headerlink" href="#c.device_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>The basic device driver structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device_driver {
    const char              *name;
    const struct bus_type   *bus;
    struct module           *owner;
    const char              *mod_name;
    bool suppress_bind_attrs;
    enum probe_type probe_type;
    const struct of_device_id       *of_match_table;
    const struct acpi_device_id     *acpi_match_table;
    int (*probe) (struct device *dev);
    void (*sync_state)(struct device *dev);
    int (*remove) (struct device *dev);
    void (*shutdown) (struct device *dev);
    int (*suspend) (struct device *dev, pm_message_t state);
    int (*resume) (struct device *dev);
    const struct attribute_group **groups;
    const struct attribute_group **dev_groups;
    const struct dev_pm_ops *pm;
    void (*coredump) (struct device *dev);
    struct driver_private *p;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the device driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>The bus which the device of this driver belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>The module owner.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mod_name</span></code></dt><dd><p>Used for built-in modules.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suppress_bind_attrs</span></code></dt><dd><p>Disables bind/unbind via sysfs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_type</span></code></dt><dd><p>Type of the probe (synchronous or asynchronous) to use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_match_table</span></code></dt><dd><p>The open firmware table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acpi_match_table</span></code></dt><dd><p>The ACPI match table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Called to query the existence of a specific device,
whether this driver can work with it, and bind the driver
to a specific device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync_state</span></code></dt><dd><p>Called to sync device state to software state after all the
state tracking consumers linked to this device (present at
the time of late_initcall) have successfully bound to a
driver. If the device has no consumers, this function will
be called at late_initcall_sync level. If the device has
consumers that are never bound to a driver, this function
will never get called until they do.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>Called when the device is removed from the system to
unbind a device from this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>Called at shut-down time to quiesce the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Called to put the device to sleep mode. Usually to a
low power state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Called to bring a device from sleep mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">groups</span></code></dt><dd><p>Default attributes that get created by the driver core
automatically.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_groups</span></code></dt><dd><p>Additional attributes attached to device instance once
it is bound to the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm</span></code></dt><dd><p>Power management operations of the device which matched
this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coredump</span></code></dt><dd><p>Called when sysfs entry is written to. The device driver
is expected to call the dev_coredump API resulting in a
uevent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Driver core’s private data, no one other than the driver
core can touch this.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The device driver-model tracks all of the drivers known to the system.
The main reason for this tracking is to enable the driver core to match
up drivers with new devices. Once drivers are known objects within the
system, however, a number of other things become possible. Device drivers
can export information and configuration variables that are independent
of any specific device.</p>
</section>
<section id="device-drivers-base">
<h2>Device Drivers Base<a class="headerlink" href="#device-drivers-base" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize driver model.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call the driver model init functions to initialize their
subsystems. Called early from init/main.c.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_find_device_by_name">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">driver_find_device_by_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device_by_name" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device of a specific name.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the device to match</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_find_device_by_of_node">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">driver_find_device_by_of_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">np</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device_by_of_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device by of_node pointer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>of_node pointer to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_find_device_by_fwnode">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">driver_find_device_by_fwnode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device_by_fwnode" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device by fwnode pointer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>fwnode pointer to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_find_device_by_devt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">driver_find_device_by_devt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">devt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device_by_devt" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device by devt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>devt pointer to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_find_device_by_acpi_dev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">driver_find_device_by_acpi_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">acpi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device_by_acpi_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the ACPI_COMPANION device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">acpi_device</span> <span class="pre">*adev</span></code></dt><dd><p>ACPI_COMPANION device to match.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.module_driver">
<span class="sig-name descname"><span class="n"><span class="pre">module_driver</span></span></span><a class="headerlink" href="#c.module_driver" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">module_driver</span> <span class="pre">(__driver,</span> <span class="pre">__register,</span> <span class="pre">__unregister,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>Helper macro for drivers that don’t do anything special in module init/exit. This eliminates a lot of boilerplate. Each module may only use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a>.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__driver</span></code></dt><dd><p>driver name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__register</span></code></dt><dd><p>register function for this driver type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__unregister</span></code></dt><dd><p>unregister function for this driver type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Additional arguments to be passed to __register and __unregister.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this macro to construct bus specific macros for registering
drivers, and do not use it on its own.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.builtin_driver">
<span class="sig-name descname"><span class="n"><span class="pre">builtin_driver</span></span></span><a class="headerlink" href="#c.builtin_driver" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">builtin_driver</span> <span class="pre">(__driver,</span> <span class="pre">__register,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>Helper macro for drivers that don’t do anything special in init and have no exit. This eliminates some boilerplate. Each driver may only use this macro once, and calling it replaces device_initcall (or in some cases, the legacy __initcall). This is meant to be a direct parallel of <a class="reference internal" href="#c.module_driver" title="module_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_driver()</span></code></a> above but without the __exit stuff that is not used for builtin cases.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__driver</span></code></dt><dd><p>driver name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__register</span></code></dt><dd><p>register function for this driver type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Additional arguments to be passed to __register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this macro to construct bus specific macros for registering
drivers, and do not use it on its own.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_set_override">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_set_override</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">override</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_set_override" title="Link to this definition">¶</a><br /></dt>
<dd><p>Helper to set or clear driver override.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">**override</span></code></dt><dd><p>Address of string to change (e.g. <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device-&gt;driver_override</span></code></a>);
The contents will be freed and hold newly allocated override.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>NUL-terminated string, new driver name to force a match, pass empty
string to clear it (”” or “n”, where the latter is only for sysfs
interface).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of <strong>s</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to set or clear driver override in a device, intended for the cases
when the driver_override field is allocated by driver/bus code.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_for_each_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_for_each_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_for_each_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Iterator for devices bound to a driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>Driver we’re iterating.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to pass to the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to call for each device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the <strong>drv</strong>’s list of devices calling <strong>fn</strong> for each one.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_find_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">driver_find_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>The device’s driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to pass to match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>Callback function to check device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.driver_for_each_device" title="driver_for_each_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">driver_for_each_device()</span></code></a> function above, but
it returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_create_file">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_create_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">driver_attribute</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_create_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>create sysfs file for driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">driver_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>driver attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_remove_file">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_remove_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">driver_attribute</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_remove_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove sysfs file for driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">driver_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>driver attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register driver with bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We pass off most of the work to the bus_add_driver() call,
since most of the things we have to do deal with the bus
structures.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove driver from system.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Again, we pass off most of the work to the bus-level call.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_link_wait_removal">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_link_wait_removal</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_wait_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait for ongoing devlink removal jobs to terminate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_link_add">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_link" title="device_link"><span class="n"><span class="pre">device_link</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">device_link_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">consumer</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">supplier</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a link between two devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*consumer</span></code></dt><dd><p>Consumer end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*supplier</span></code></dt><dd><p>Supplier end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>Link flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller is responsible for the proper synchronization of the link creation
with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will cause the
runtime PM framework to take the link into account.  Second, if the
DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices will
be forced into the active meta state and reference-counted upon the creation
of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
ignored.</p>
<p>If DL_FLAG_STATELESS is set in <strong>flags</strong>, the caller of this function is
expected to release the link returned by it directly with the help of either
<a class="reference internal" href="#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or <a class="reference internal" href="#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a>.</p>
<p>If that flag is not set, however, the caller of this function is handing the
management of the link over to the driver core entirely and its return value
can only be used to check whether or not the link is present.  In that case,
the DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER device link
flags can be used to indicate to the driver core when the link can be safely
deleted.  Namely, setting one of them in <strong>flags</strong> indicates to the driver core
that the link is not going to be used (by the given caller of this function)
after unbinding the consumer or supplier driver, respectively, from its
device, so the link can be deleted at that point.  If none of them is set,
the link will be maintained until one of the devices pointed to by it (either
the consumer or the supplier) is unregistered.</p>
<p>Also, if DL_FLAG_STATELESS, DL_FLAG_AUTOREMOVE_CONSUMER and
DL_FLAG_AUTOREMOVE_SUPPLIER are not set in <strong>flags</strong> (that is, a persistent
managed device link is being added), the DL_FLAG_AUTOPROBE_CONSUMER flag can
be used to request the driver core to automatically probe for a consumer
driver after successfully binding a driver to the supplier device.</p>
<p>The combination of DL_FLAG_STATELESS and one of DL_FLAG_AUTOREMOVE_CONSUMER,
DL_FLAG_AUTOREMOVE_SUPPLIER, or DL_FLAG_AUTOPROBE_CONSUMER set in <strong>flags</strong> at
the same time is invalid and will cause NULL to be returned upfront.
However, if a device link between the given <strong>consumer</strong> and <strong>supplier</strong> pair
exists already when this function is called for them, the existing link will
be returned regardless of its current type and status (the link’s flags may
be modified then).  The caller of this function is then expected to treat
the link as though it has just been created, so (in particular) if
DL_FLAG_STATELESS was passed in <strong>flags</strong>, the link needs to be released
explicitly when not needed any more (as stated above).</p>
<p>A side effect of the link creation is re-ordering of dpm_list and the
devices_kset list by moving the consumer device and all devices depending
on it to the ends of these lists (that does not happen to devices that have
not been registered when this function is called).</p>
<p>The supplier device is required to be registered when this function is called
and NULL will be returned if that is not the case.  The consumer device need
not be registered, however.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_link_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_link_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_link" title="device_link"><span class="n"><span class="pre">device_link</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">link</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_del" title="Link to this definition">¶</a><br /></dt>
<dd><p>Delete a stateless link between two devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_link</span> <span class="pre">*link</span></code></dt><dd><p>Device link to delete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.  If the link was added multiple times, it needs to be deleted as often.
Care is required for hotplugged devices:  Their links are purged on removal
and calling <a class="reference internal" href="#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> is then no longer allowed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_link_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_link_remove</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">consumer</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">supplier</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Delete a stateless link between two devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*consumer</span></code></dt><dd><p>Consumer end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*supplier</span></code></dt><dd><p>Supplier end of the link.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dev_driver_string">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dev_driver_string</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_driver_string" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a device’s driver name, if at all possible</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to get the name of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will return the device’s driver’s name if it is bound to a device.  If
the device is not bound to a driver, it will return the name of the bus
it is attached to.  If it is not attached to a bus either, an empty
string will be returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_device_add_group">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_device_add_group</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">attribute_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">grp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_add_group" title="Link to this definition">¶</a><br /></dt>
<dd><p>given a device, create a managed attribute group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device to create the group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*grp</span></code></dt><dd><p>The attribute group to create</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a group for the first time.  It will explicitly
warn and error if any of the attribute files being created already exist.</p>
<p>Returns 0 on success or error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_create_file">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_create_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_attribute" title="device_attribute"><span class="n"><span class="pre">device_attribute</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>create sysfs attribute file for device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_remove_file">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_remove_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_attribute" title="device_attribute"><span class="n"><span class="pre">device_attribute</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove sysfs attribute file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_remove_file_self">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_remove_file_self</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_attribute" title="device_attribute"><span class="n"><span class="pre">device_attribute</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_file_self" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove sysfs attribute file from its own method.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device attribute descriptor.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See kernfs_remove_self() for details.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_create_bin_file">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_create_bin_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bin_attribute</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_bin_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>create sysfs binary attribute file for device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device binary attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_remove_bin_file">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_remove_bin_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bin_attribute</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_bin_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove sysfs binary attribute file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device binary attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_initialize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_initialize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_initialize" title="Link to this definition">¶</a><br /></dt>
<dd><p>init device structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the device for use by other layers by initializing
its fields.
It is the first half of <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>, if called by
that function, though it can also be called separately, so one
may use <strong>dev</strong>’s fields. In particular, <a class="reference internal" href="#c.get_device" title="get_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_device()</span></code></a>/<a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a>
may be used for reference counting of <strong>dev</strong> after calling this
function.</p>
<p>All fields in <strong>dev</strong> must be initialized by the caller to 0, except
for those explicitly set to some other value.  The simplest
approach is to use <a class="reference internal" href="../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a> to allocate the structure containing
<strong>dev</strong>.</p>
<p><strong>NOTE</strong></p>
<p>Use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up your reference instead of freeing
<strong>dev</strong> directly once you have called this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dev_set_name">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dev_set_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_name" title="Link to this definition">¶</a><br /></dt>
<dd><p>set a device name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format string for the device’s name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add device to device hierarchy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part 2 of <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>, though may be called
separately _iff_ <a class="reference internal" href="#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a> has been called separately.</p>
<p>This adds <strong>dev</strong> to the kobject hierarchy via <a class="reference internal" href="basics.html#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>, adds it
to the global and sibling lists for the device, then
adds it to the other relevant subsystems of the driver model.</p>
<p>Do not call this routine or <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a> more than once for
any device structure.  The driver model core is not designed to work
with devices that get unregistered and then spring back to life.
(Among other things, it’s very hard to guarantee that all references
to the previous incarnation of <strong>dev</strong> have been dropped.)  Allocate
and register a fresh new <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> instead.</p>
<p>Rule of thumb is: if <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> succeeds, you should call
<a class="reference internal" href="#c.device_del" title="device_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_del()</span></code></a> when you want to get rid of it. If <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> has
<em>not</em> succeeded, use <em>only</em> <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to drop the reference
count.</p>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>dev</strong> after calling this function, even
if it returned an error! Always use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up your
reference instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a device with the system.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This happens in two clean steps - initialize the device
and add it to the system. The two steps can be called
separately, but this is the easiest and most common.
I.e. you should only call the two helpers separately if
have a clearly defined need to use and refcount the device
before it is added to the hierarchy.</p>
<p>For more information, see the kerneldoc for <a class="reference internal" href="#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a>
and <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>dev</strong> after calling this function, even
if it returned an error! Always use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up the
reference initialized in this function instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>increment reference count for device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This simply forwards the call to <a class="reference internal" href="basics.html#c.kobject_get" title="kobject_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_get()</span></code></a>, though
we do take care to provide for the case that we get a NULL
pointer passed in.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrement reference count.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device in question.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_del" title="Link to this definition">¶</a><br /></dt>
<dd><p>delete device from system.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first part of the device unregistration
sequence. This removes the device from the lists we control
from here, has it removed from the other driver model
subsystems it was added to in <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a>, and removes it
from the kobject hierarchy.</p>
<p><strong>NOTE</strong></p>
<p>this should be called manually _iff_ <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> was
also called manually.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister device from system.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device going away.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We do this in two parts, like we do <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>. First,
we remove it from all the subsystems with <a class="reference internal" href="#c.device_del" title="device_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_del()</span></code></a>, then
we decrement the reference count via <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a>. If that
is the final reference count, the device will be cleaned up
via device_release() above. Otherwise, the structure will
stick around until the final reference to the device is dropped.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_for_each_child">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_for_each_child</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_for_each_child" title="Link to this definition">¶</a><br /></dt>
<dd><p>device child iterator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>function to be called for each device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>parent</strong>’s child devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_for_each_child_reverse">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_for_each_child_reverse</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_for_each_child_reverse" title="Link to this definition">¶</a><br /></dt>
<dd><p>device child iterator in reversed order.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>function to be called for each device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>parent</strong>’s child devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_find_child">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">device_find_child</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_child" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to pass to match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>Callback function to check device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_for_each_child" title="device_for_each_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_for_each_child()</span></code></a> function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero and a reference to the
current device can be obtained, this function will return to the caller
and not iterate over any more devices.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_find_child_by_name">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">device_find_child_by_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_child_by_name" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a child device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the child device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_find_child" title="device_find_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_find_child()</span></code></a> function above, but it
returns a reference to a device that has the name <strong>name</strong>.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_find_any_child">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">device_find_any_child</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_any_child" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a child device, if any.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_find_child" title="device_find_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_find_child()</span></code></a> function above, but it
returns a reference to a child device, if any.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__root_device_register">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__root_device_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__root_device_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate and register a root device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>root device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module of the root device, usually THIS_MODULE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates a root device and registers it
using <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>. In order to free the returned
device, use <a class="reference internal" href="#c.root_device_unregister" title="root_device_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">root_device_unregister()</span></code></a>.</p>
<p>Root devices are dummy devices which allow other devices
to be grouped under /sys/devices. Use this function to
allocate a root device and then use it as the parent of
any device which should appear under /sys/devices/{name}</p>
<p>The /sys/devices/{name} directory will also contain a
‘module’ symlink which points to the <strong>owner</strong> directory
in sysfs.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
<p><strong>Note</strong></p>
<p>You probably want to use root_device_register().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.root_device_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">root_device_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.root_device_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister and free a root device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device going away</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters and cleans up a device that was created by
root_device_register().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">device_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_create" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">devt</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drvdata</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.class" title="class"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a> that this device should be registered to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> of this new device, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>the dev_t for the char device to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*drvdata</span></code></dt><dd><p>the data to be added to the device for callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>string for the device’s name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>
will be created in sysfs, registered to the specified class.</p>
<p>A “dev” file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> is passed in, the newly created
<a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will be a child of that device in sysfs.
The pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_create_with_groups">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">device_create_with_groups</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_create_with_groups" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">devt</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drvdata</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">attribute_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">groups</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_with_groups" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.class" title="class"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a> that this device should be registered to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> of this new device, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>the dev_t for the char device to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*drvdata</span></code></dt><dd><p>the data to be added to the device for callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**groups</span></code></dt><dd><p>NULL-terminated list of attribute groups to be created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>string for the device’s name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>
will be created in sysfs, registered to the specified class.
Additional attributes specified in the groups parameter will also
be created automatically.</p>
<p>A “dev” file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> is passed in, the newly created
<a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will be a child of that device in sysfs.
The pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_destroy" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">devt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>removes a device that was created with <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.class" title="class"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a> that this device was registered with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>the dev_t of the device that was previously registered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call unregisters and cleans up a device that was created with a
call to <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_rename">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_rename</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_rename" title="Link to this definition">¶</a><br /></dt>
<dd><p>renames a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to be renamed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*new_name</span></code></dt><dd><p>the new name of the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the responsibility of the caller to provide mutual
exclusion between two different calls of device_rename
on the same device to ensure that new_name is valid and
won’t conflict with other devices.</p>
<p>However, if you’re writing new code, do not call this function. The following
text from Kay Sievers offers some insight:</p>
<p>Renaming devices is racy at many levels, symlinks and other stuff are not
replaced atomically, and you get a “move” uevent, but it’s not easy to
connect the event to the old and new device. Device nodes are not renamed at
all, there isn’t even support for that in the kernel now.</p>
<p>In the meantime, during renaming, your target name might be taken by another
driver, creating conflicts. Or the old name is taken directly after you
renamed it -- then you get events for the same DEVPATH, before you even see
the “move” event. It’s just a mess, and nothing new should ever rely on
kernel device renaming. Besides that, it’s not even implemented now for
other things than (driver-core wise very simple) network devices.</p>
<p>Make up a “real” name in the driver before you register anything, or add
some other attributes for userspace to find the device, or use udev to add
symlinks -- but never rename kernel devices later, it’s a complete mess. We
don’t even want to get into that and try to implement the missing pieces in
the core. We really have other pieces to fix in the driver core mess. :)</p>
<p><strong>Note</strong></p>
<p>given that some subsystems (networking and infiniband) use this
function, with no immediate plans for this to change, we cannot assume or
require that this function not be called at all.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_move">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_move</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_parent</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.device_move" title="dpm_order"><span class="n"><span class="pre">dpm_order</span></span></a><span class="w"> </span><span class="n"><span class="pre">dpm_order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_move" title="Link to this definition">¶</a><br /></dt>
<dd><p>moves a device to a new parent</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to be moved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*new_parent</span></code></dt><dd><p>the new parent of the device (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dpm_order</span> <span class="pre">dpm_order</span></code></dt><dd><p>how to reorder the dpm_list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_change_owner">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_change_owner</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">kuid_t</span></span><span class="w"> </span><span class="n"><span class="pre">kuid</span></span>, <span class="n"><span class="pre">kgid_t</span></span><span class="w"> </span><span class="n"><span class="pre">kgid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_change_owner" title="Link to this definition">¶</a><br /></dt>
<dd><p>change the owner of an existing device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kuid_t</span> <span class="pre">kuid</span></code></dt><dd><p>new owner’s kuid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kgid_t</span> <span class="pre">kgid</span></code></dt><dd><p>new owner’s kgid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This changes the owner of <strong>dev</strong> and its corresponding sysfs entries to
<strong>kuid</strong>/<strong>kgid</strong>. This function closely mirrors how <strong>dev</strong> was added via driver
core.</p>
<p>Returns 0 on success or error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dev_err_probe">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dev_err_probe</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">err</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_err_probe" title="Link to this definition">¶</a><br /></dt>
<dd><p>probe error check and log helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">err</span></code></dt><dd><p>error value to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>printf-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>arguments as specified in the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper implements common pattern present in probe functions for error
checking: print debug or error message depending if the error value is
-EPROBE_DEFER and propagate error upwards.
In case of -EPROBE_DEFER it sets also defer probe reason, which can be
checked later by reading devices_deferred debugfs attribute.
It replaces code sequence:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (err != -EPROBE_DEFER)
        dev_err(dev, ...);
else
        dev_dbg(dev, ...);
return err;
</pre></div>
</div>
<p>with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>return dev_err_probe(dev, err, ...);
</pre></div>
</div>
<p>Using this helper in your probe function is totally fine even if <strong>err</strong> is
known to never be -EPROBE_DEFER.
The benefit compared to a normal dev_err() is the standardized format
of the error code, it being emitted symbolically (i.e. you get “EAGAIN”
instead of “-35”) and the fact that the error code is returned which allows
more compact error paths.</p>
<p>Returns <strong>err</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_primary_fwnode">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_primary_fwnode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_primary_fwnode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Change the primary firmware node of a given device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>New primary firmware node of the device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the device’s firmware node pointer to <strong>fwnode</strong>, but if a secondary
firmware node of the device is present, preserve it.</p>
<dl class="simple">
<dt>Valid fwnode cases are:</dt><dd><ul class="simple">
<li><p>primary --&gt; secondary --&gt; -ENODEV</p></li>
<li><p>primary --&gt; NULL</p></li>
<li><p>secondary --&gt; -ENODEV</p></li>
<li><p>NULL</p></li>
</ul>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_secondary_fwnode">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_secondary_fwnode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_secondary_fwnode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Change the secondary firmware node of a given device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>New secondary firmware node of the device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a primary firmware node of the device is present, set its secondary
pointer to <strong>fwnode</strong>.  Otherwise, set the device’s firmware node pointer to
<strong>fwnode</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_set_of_node_from_dev">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_set_of_node_from_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_set_of_node_from_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>reuse device-tree node of another device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device whose device-tree node is being set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev2</span></code></dt><dd><p>device whose device-tree node is being reused</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes another reference to the new device-tree node after first dropping
any reference held to the old node.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.register_syscore_ops">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">register_syscore_ops</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">syscore_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.register_syscore_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register a set of system core operations.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">syscore_ops</span> <span class="pre">*ops</span></code></dt><dd><p>System core operations to register.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unregister_syscore_ops">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unregister_syscore_ops</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">syscore_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_syscore_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unregister a set of system core operations.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">syscore_ops</span> <span class="pre">*ops</span></code></dt><dd><p>System core operations to unregister.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.syscore_suspend">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">syscore_suspend</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.syscore_suspend" title="Link to this definition">¶</a><br /></dt>
<dd><p>Execute all the registered system core suspend callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is executed with one CPU on-line and disabled interrupts.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.syscore_resume">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">syscore_resume</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.syscore_resume" title="Link to this definition">¶</a><br /></dt>
<dd><p>Execute all the registered system core resume callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is executed with one CPU on-line and disabled interrupts.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_find_device_by_name">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_find_device_by_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_find_device_by_name" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device_by_name" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device of a specific name.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>class type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the device to match</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_find_device_by_of_node">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_find_device_by_of_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_find_device_by_of_node" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">np</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device_by_of_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the of_node.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>class type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>of_node of the device to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_find_device_by_fwnode">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_find_device_by_fwnode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_find_device_by_fwnode" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device_by_fwnode" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the fwnode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>class type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>fwnode of the device to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_find_device_by_devt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_find_device_by_devt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_find_device_by_devt" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">devt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device_by_devt" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the device type.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>class type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>device type of the device to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_find_device_by_acpi_dev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_find_device_by_acpi_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_find_device_by_acpi_dev" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">acpi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device_by_acpi_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the ACPI_COMPANION device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>class type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">acpi_device</span> <span class="pre">*adev</span></code></dt><dd><p>ACPI_COMPANION device to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a <a class="reference internal" href="#c.class" title="class"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a> structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pointer to a string for the name of this class.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to create a <a class="reference internal" href="#c.class" title="class"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a> pointer that can then be used
in calls to <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a>.</p>
<p>Returns <a class="reference internal" href="#c.class" title="class"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
<p>Note, the pointer created here is to be destroyed when finished by
making a call to <a class="reference internal" href="#c.class_destroy" title="class_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">class_destroy()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cls</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroys a <a class="reference internal" href="#c.class" title="class"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a> structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*cls</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.class" title="class"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a> that is to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, the pointer to be destroyed must have been created with a call
to <a class="reference internal" href="#c.class_create" title="class_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">class_create()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_dev_iter_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class_dev_iter_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">class_dev_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_dev_iter_init" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_type</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize class device iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>class iterator to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>the class we wanna iterate over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>the device to start iterating from, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_type</span> <span class="pre">*type</span></code></dt><dd><p>device_type of the devices to iterate over, NULL for all</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize class iterator <strong>iter</strong> such that it iterates over devices
of <strong>class</strong>.  If <strong>start</strong> is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_dev_iter_next">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_dev_iter_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">class_dev_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_next" title="Link to this definition">¶</a><br /></dt>
<dd><p>iterate to the next device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>class iterator to proceed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>iter</strong> to the next device and return it.  Returns NULL if
iteration is complete.</p>
<p>The returned device is referenced and won’t be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into class code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_dev_iter_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class_dev_iter_exit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">class_dev_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_exit" title="Link to this definition">¶</a><br /></dt>
<dd><p>finish iteration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>class iterator to finish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_for_each_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class_for_each_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_for_each_device" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_for_each_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>the class we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>the device to start with in the list, if any.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to be called for each device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>class</strong>’s list of devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.  If <strong>start</strong> is set, the list iteration will start
there, otherwise if it is NULL, the iteration starts at the
beginning of the list.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<p><strong>fn</strong> is allowed to do anything including calling back into class
code.  There’s no locking restriction.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_find_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_find_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_find_device" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>the class we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to check device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the class_for_each_dev() function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
<p>Note, you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
<p><strong>match</strong> is allowed to do anything including calling back into class
code.  There’s no locking restriction.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_compat_register">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">class_compat</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">class_compat_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a compatibility class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name of the class</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatibility class are meant as a temporary user-space compatibility
workaround when converting a family of class devices to a bus devices.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_compat_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class_compat_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">class_compat</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cls</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a compatibility class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*cls</span></code></dt><dd><p>the class to unregister</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_compat_create_link">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class_compat_create_link</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">class_compat</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cls</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device_link</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_create_link" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a compatibility class device link to a bus device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*cls</span></code></dt><dd><p>the compatibility class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the target bus device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device_link</span></code></dt><dd><p>an optional device to which a “device” link should be created</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_compat_remove_link">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class_compat_remove_link</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">class_compat</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cls</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device_link</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_remove_link" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a compatibility class device link to a bus device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*cls</span></code></dt><dd><p>the compatibility class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the target bus device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device_link</span></code></dt><dd><p>an optional device to which a “device” link was previously
created</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.class_is_registered">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">class_is_registered</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.class_is_registered" title="class"><span class="n"><span class="pre">class</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">class</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.class_is_registered" title="Link to this definition">¶</a><br /></dt>
<dd><p>determine if at this moment in time, a class is registered in the driver core or not.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>the class to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a boolean to state if the class is registered in the driver core
or not.  Note that the value could switch right after this call is made,
so only use this in places where you “know” it is safe to do so (usually
to determine if the specific class has been registered yet or not).</p>
<p>Be careful in using this.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.node_access_nodes">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">node_access_nodes</span></span></span><a class="headerlink" href="#c.node_access_nodes" title="Link to this definition">¶</a><br /></dt>
<dd><p>Access class device to hold user visible relationships to other nodes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct node_access_nodes {
    struct device           dev;
    struct list_head        list_node;
    unsigned int            access;
#ifdef CONFIG_HMEM_REPORTING;
    struct access_coordinate        coord;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device for this memory access class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list_node</span></code></dt><dd><p>List element in the node’s access list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access</span></code></dt><dd><p>The access class rank</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coord</span></code></dt><dd><p>Heterogeneous memory performance coordinates</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.node_cache_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">node_cache_info</span></span></span><a class="headerlink" href="#c.node_cache_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Internal tracking for memory node caches</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct node_cache_info {
    struct device dev;
    struct list_head node;
    struct node_cache_attrs cache_attrs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device represeting the cache level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>List element for tracking in the node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache_attrs</span></code></dt><dd><p>Attributes for this cache level</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.node_add_cache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">node_add_cache</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">node_cache_attrs</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cache_attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.node_add_cache" title="Link to this definition">¶</a><br /></dt>
<dd><p>add cache attribute to a memory node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>Node identifier that has new cache attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node_cache_attrs</span> <span class="pre">*cache_attrs</span></code></dt><dd><p>Attributes for the cache being added</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unregister_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unregister_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.unregister_node" title="node"><span class="n"><span class="pre">node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a node device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node</span> <span class="pre">*node</span></code></dt><dd><p>node going away</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a node device <strong>node</strong>.  All the devices on the node must be
unregistered before calling this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.register_memory_node_under_compute_node">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">register_memory_node_under_compute_node</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mem_nid</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu_nid</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">access_coordinate_class</span></span><span class="w"> </span><span class="n"><span class="pre">access</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.register_memory_node_under_compute_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>link memory node to its compute node for a given access class.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mem_nid</span></code></dt><dd><p>Memory node number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu_nid</span></code></dt><dd><p>Cpu  node number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">access_coordinate_class</span> <span class="pre">access</span></code></dt><dd><p>Access class to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>For use with platforms that may have separate memory and compute nodes.
This function will export node relationships linking which memory
initiator nodes can access memory targets at a given ranked access
class.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.transport_class_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transport_class_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">transport_class</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tclass</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_class_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register an initial transport class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">transport_class</span> <span class="pre">*tclass</span></code></dt><dd><p>a pointer to the transport class structure to be initialised</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The transport class contains an embedded class which is used to
identify it.  The caller should initialise this structure with
zeros and then generic class must have been initialised with the
actual transport class unique name.  There’s a macro
DECLARE_TRANSPORT_CLASS() to do this (declared classes still must
be registered).</p>
<p>Returns 0 on success or error on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.transport_class_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transport_class_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">transport_class</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tclass</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_class_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a previously registered class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">transport_class</span> <span class="pre">*tclass</span></code></dt><dd><p>The transport class to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called prior to deallocating the memory for the transport
class.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.anon_transport_class_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">anon_transport_class_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">anon_transport_class</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">atc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_transport_class_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register an anonymous class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_transport_class</span> <span class="pre">*atc</span></code></dt><dd><p>The anon transport class to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The anonymous transport class contains both a transport class and a
container.  The idea of an anonymous class is that it never
actually has any device attributes associated with it (and thus
saves on container storage).  So it can only be used for triggering
events.  Use prezero and then use DECLARE_ANON_TRANSPORT_CLASS() to
initialise the anon transport class storage.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.anon_transport_class_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">anon_transport_class_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">anon_transport_class</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">atc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_transport_class_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister an anon class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_transport_class</span> <span class="pre">*atc</span></code></dt><dd><p>Pointer to the anon transport class to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called prior to deallocating the memory for the anon
transport class.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.transport_setup_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transport_setup_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_setup_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>declare a new dev for transport class association but don’t make it visible yet.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the generic device representing the entity being added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point to see if any set of transport
classes wishes to associate with the added device.  This allocates
storage for the class device and initialises it, but does not yet
add it to the system or add attributes to it (you do this with
transport_add_device).  If you have no need for a separate setup
and add operations, use transport_register_device (see
transport_class.h).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.transport_add_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transport_add_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_add_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>declare a new dev for transport class association</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the generic device representing the entity being added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point used to add the device to the
system and register attributes for it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.transport_configure_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transport_configure_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_configure_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>configure an already set up device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>generic device representing device to be configured</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The idea of configure is simply to provide a point within the setup
process to allow the transport class to extract information from a
device after it has been setup.  This is used in SCSI because we
have to have a setup device to begin using the HBA, but after we
send the initial inquiry, we use configure to extract the device
parameters.  The device need not have been added to be configured.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.transport_remove_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transport_remove_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_remove_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove the visibility of a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>generic device to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call removes the visibility of the device (to the user from
sysfs), but does not destroy it.  To eliminate a device entirely
you must also call transport_destroy_device.  If you don’t need to
do remove and destroy as separate operations, use
transport_unregister_device() (see transport_class.h) which will
perform both calls for you.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.transport_destroy_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">transport_destroy_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_destroy_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroy a removed device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to eliminate from the transport class.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call triggers the elimination of storage associated with the
transport classdev.  Note: all it really does is relinquish a
reference to the classdev.  The memory will not be freed until the
last reference goes to zero.  Note also that the classdev retains a
reference count on dev, so dev too will remain for as long as the
transport class device remains around.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_deferred_probe_check_state">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_deferred_probe_check_state</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_deferred_probe_check_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check deferred probe state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>-ENODEV if initcalls have completed and modules are disabled.</p></li>
<li><p>-ETIMEDOUT if the deferred probe timeout was set and has expired
and modules are enabled.</p></li>
<li><p>-EPROBE_DEFER in other cases.</p></li>
</ul>
<p><strong>Description</strong></p>
<p>Drivers or subsystems can opt-in to calling this function instead of directly
returning -EPROBE_DEFER.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_bind_driver">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_bind_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_bind_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>bind a driver to one device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow manual attachment of a driver to a device.
Caller must have already set <strong>dev-&gt;driver</strong>.</p>
<p>Note that this does not modify the bus reference count.
Please verify that is accounted for before calling this.
(It is ok to call with no other effort from a driver’s probe() method.)</p>
<p>This function must be called with the device lock held.</p>
<p>Callers should prefer to use <a class="reference internal" href="#c.device_driver_attach" title="device_driver_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_driver_attach()</span></code></a> instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wait_for_device_probe">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wait_for_device_probe</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_for_device_probe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for device probing to be completed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_attach">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_attach</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_attach" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to attach device to a driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of drivers that the bus has and call
driver_probe_device() for each pair. If a compatible
pair is found, break out and return.</p>
<p>Returns 1 if the device was bound to a driver;
0 if no matching driver was found;
-ENODEV if the device is not registered.</p>
<p>When called for a USB interface, <strong>dev-&gt;parent</strong> lock must be held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_driver_attach">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_driver_attach</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_driver_attach" title="Link to this definition">¶</a><br /></dt>
<dd><p>attach a specific driver to a specific device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>Driver to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to attach it to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Manually attach driver to a device. Will acquire both <strong>dev</strong> lock and
<strong>dev-&gt;parent</strong> lock if needed. Returns 0 on success, -ERR on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_attach">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">driver_attach</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_attach" title="Link to this definition">¶</a><br /></dt>
<dd><p>try to bind driver to devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of devices that the bus has on it and try to
match the driver with each one.  If driver_probe_device()
returns 0 and the <strong>dev-&gt;driver</strong> is set, we’ve found a
compatible pair.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_release_driver">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_release_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_release_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>manually detach device from driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Manually detach device from driver.
When called for a USB interface, <strong>dev-&gt;parent</strong> lock must be held.</p>
<p>If this function is to be called with <strong>dev-&gt;parent</strong> lock held, ensure that
the device’s consumers are unbound in advance or that their locks can be
acquired under the <strong>dev-&gt;parent</strong> lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_register_resndata">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_register_resndata</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_resndata" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a platform-level device with resources and platform-specific data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device for the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>base name of the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>instance id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>set of resources that needs to be allocated for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of resources</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>platform specific data for this platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of platform specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_register_simple">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_register_simple</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_simple" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a platform-level device and its resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>base name of the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>instance id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>set of resources that needs to be allocated for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of resources</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.</p>
<p>This interface is primarily intended for use with legacy drivers which
probe hardware directly.  Because such drivers create sysfs device nodes
themselves, rather than letting system infrastructure handle such device
enumeration tasks, they don’t fully conform to the Linux driver model.
In particular, when such drivers are built as modules, they can’t be
“hotplugged”.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_register_data">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_register_data</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a platform-level device with platform-specific data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device for the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>base name of the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>instance id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>platform specific data for this platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of platform specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_get_resource">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">platform_get_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_resource" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a resource for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>resource type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>resource index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the resource or NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_platform_get_and_ioremap_resource">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__iomem</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_platform_get_and_ioremap_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_get_and_ioremap_resource" title="Link to this definition">¶</a><br /></dt>
<dd><p>call devm_ioremap_resource() for a platform device and get resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device to use both for memory resource lookup as well as
resource management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>resource index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">**res</span></code></dt><dd><p>optional output parameter to store a pointer to the obtained resource.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the remapped memory or an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> encoded error code
on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_platform_ioremap_resource">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__iomem</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_platform_ioremap_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_ioremap_resource" title="Link to this definition">¶</a><br /></dt>
<dd><p>call devm_ioremap_resource() for a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device to use both for memory resource lookup as well as
resource management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>resource index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the remapped memory or an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> encoded error code
on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_platform_ioremap_resource_byname">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__iomem</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_platform_ioremap_resource_byname</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_ioremap_resource_byname" title="Link to this definition">¶</a><br /></dt>
<dd><p>call devm_ioremap_resource for a platform device, retrieve the resource by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device to use both for memory resource lookup as well as
resource management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the resource</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the remapped memory or an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> encoded error code
on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_get_irq_optional">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_get_irq_optional</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_optional" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an optional IRQ for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>IRQ number index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets an IRQ for a platform device. Device drivers should check the return
value for errors so as to not pass a negative integer value to the
<a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> APIs. This is the same as <a class="reference internal" href="#c.platform_get_irq" title="platform_get_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq()</span></code></a>, except that it
does not print an error message if an IRQ can not be obtained.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int irq = platform_get_irq_optional(pdev, 0);
if (irq &lt; 0)
        return irq;
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>non-zero IRQ number on success, negative error number on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_get_irq">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_get_irq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an IRQ for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>IRQ number index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets an IRQ for a platform device and prints an error message if finding the
IRQ fails. Device drivers should check the return value for errors so as to
not pass a negative integer value to the <a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> APIs.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int irq = platform_get_irq(pdev, 0);
if (irq &lt; 0)
        return irq;
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>non-zero IRQ number on success, negative error number on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_irq_count">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_irq_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_irq_count" title="Link to this definition">¶</a><br /></dt>
<dd><p>Count the number of IRQs a platform device uses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of IRQs a platform device uses or EPROBE_DEFER</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_platform_get_irqs_affinity">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_platform_get_irqs_affinity</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../core-api/genericirq.html#c.irq_affinity" title="irq_affinity"><span class="n"><span class="pre">irq_affinity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">affd</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">minvec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">maxvec</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">irqs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_get_irqs_affinity" title="Link to this definition">¶</a><br /></dt>
<dd><p>devm method to get a set of IRQs for a device using an interrupt affinity descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_affinity</span> <span class="pre">*affd</span></code></dt><dd><p>affinity descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">minvec</span></code></dt><dd><p>minimum count of interrupt vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">maxvec</span></code></dt><dd><p>maximum count of interrupt vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">**irqs</span></code></dt><dd><p>pointer holder for IRQ numbers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets a set of IRQs for a platform device, and updates IRQ afffinty according
to the passed affinity descriptor</p>
<p><strong>Return</strong></p>
<p>Number of vectors on success, negative error number on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_get_resource_byname">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">platform_get_resource_byname</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_resource_byname" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a resource for a device by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>resource type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>resource name</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_get_irq_byname">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_get_irq_byname</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_byname" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an IRQ for a device by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>IRQ name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get an IRQ like <a class="reference internal" href="#c.platform_get_irq" title="platform_get_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq()</span></code></a>, but then by name rather then by index.</p>
<p><strong>Return</strong></p>
<p>non-zero IRQ number on success, negative error number on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_get_irq_byname_optional">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_get_irq_byname_optional</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_byname_optional" title="Link to this definition">¶</a><br /></dt>
<dd><p>get an optional IRQ for a device by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>IRQ name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get an optional IRQ by name like <a class="reference internal" href="#c.platform_get_irq_byname" title="platform_get_irq_byname"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq_byname()</span></code></a>. Except that it
does not print an error message if an IRQ can not be obtained.</p>
<p><strong>Return</strong></p>
<p>non-zero IRQ number on success, negative error number on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_add_devices">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_add_devices</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">devs</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_add_devices" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a numbers of platform devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">**devs</span></code></dt><dd><p>array of platform devices to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of platform devices in array</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, negative error number on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>destroy a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all memory associated with a platform device.  This function must
_only_ be externally called in error cases.  All other usage is a bug.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>base name of the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>instance id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a platform device object which can have other objects attached
to it, and which will have attached objects freed when it is released.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_add_resources">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_add_resources</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_resources" title="Link to this definition">¶</a><br /></dt>
<dd><p>add resources to a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device allocated by platform_device_alloc to add resources to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>set of resources that needs to be allocated for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of resources</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a copy of the resources to the platform device.  The memory
associated with the resources will be freed when the platform device is
released.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_add_data">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_add_data</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>add platform-specific data to a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device allocated by platform_device_alloc to add resources to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>platform specific data for this platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of platform specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a copy of platform specific data to the platform device’s
platform_data pointer.  The memory associated with the platform data
will be freed when the platform device is released.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a platform device to device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device we’re adding</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part 2 of <a class="reference internal" href="#c.platform_device_register" title="platform_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_register()</span></code></a>, though may be called
separately _iff_ pdev was allocated by <a class="reference internal" href="#c.platform_device_alloc" title="platform_device_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_alloc()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_del" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a platform-level device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device we’re removing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function will also release all memory- and port-based
resources owned by the device (<strong>dev-&gt;resource</strong>).  This function must
_only_ be externally called in error cases.  All other usage is a bug.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a platform-level device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device we’re adding</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>pdev</strong> after calling this function, even if it
returned an error! Always use <a class="reference internal" href="#c.platform_device_put" title="platform_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_put()</span></code></a> to give up the
reference initialised in this function instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a platform-level device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device we’re unregistering</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregistration is done in 2 steps. First we release all resources
and remove it from the subsystem, then we drop reference count by
calling <a class="reference internal" href="#c.platform_device_put" title="platform_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_put()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_device_register_full">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">platform_device_register_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdevinfo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_full" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a platform-level device with resources and platform-specific data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">platform_device_info</span> <span class="pre">*pdevinfo</span></code></dt><dd><p>data used to create device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__platform_driver_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__platform_driver_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_driver_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a driver for platform-level devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*drv</span></code></dt><dd><p>platform driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owning module/driver</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_driver_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_driver_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_driver_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a driver for platform-level devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*drv</span></code></dt><dd><p>platform driver structure</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__platform_driver_probe">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__platform_driver_probe</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">probe</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__platform_driver_probe" title="module"><span class="n"><span class="pre">module</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">module</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_driver_probe" title="Link to this definition">¶</a><br /></dt>
<dd><p>register driver for non-hotpluggable device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*drv</span></code></dt><dd><p>platform driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*probe)(struct</span> <span class="pre">platform_device</span> <span class="pre">*)</span></code></dt><dd><p>the driver probe routine, probably from an __init section</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>module which will be the owner of the driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this instead of platform_driver_register() when you know the device
is not hotpluggable and has already been registered, and you want to
remove its run-once probe() infrastructure from memory after the driver
has bound to the device.</p>
<p>One typical use for this would be with drivers for controllers integrated
into system-on-chip processors, where the controller devices have been
configured as part of board setup.</p>
<p>Note that this is incompatible with deferred probing.</p>
<p>Returns zero if the driver registered and bound to a device, else returns
a negative error code and with the driver not registered.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__platform_create_bundle">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__platform_create_bundle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">probe</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_device</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n_res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__platform_create_bundle" title="module"><span class="n"><span class="pre">module</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">module</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_create_bundle" title="Link to this definition">¶</a><br /></dt>
<dd><p>register driver and create corresponding device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*driver</span></code></dt><dd><p>platform driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*probe)(struct</span> <span class="pre">platform_device</span> <span class="pre">*)</span></code></dt><dd><p>the driver probe routine, probably from an __init section</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>set of resources that needs to be allocated for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_res</span></code></dt><dd><p>number of resources</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>platform specific data for this platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of platform specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>module which will be the owner of the driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this in legacy-style modules that probe hardware directly and
register a single platform device and corresponding platform driver.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__platform_register_drivers">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__platform_register_drivers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drivers</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_register_drivers" title="Link to this definition">¶</a><br /></dt>
<dd><p>register an array of platform drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*drivers</span></code></dt><dd><p>an array of drivers to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of drivers to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module owning the drivers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers platform drivers specified by an array. On failure to register a
driver, all previously registered drivers will be unregistered. Callers of
this API should use <a class="reference internal" href="#c.platform_unregister_drivers" title="platform_unregister_drivers"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_unregister_drivers()</span></code></a> to unregister drivers in
the reverse order.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_unregister_drivers">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">platform_unregister_drivers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">platform_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drivers</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_unregister_drivers" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister an array of platform drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*drivers</span></code></dt><dd><p>an array of drivers to unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of drivers to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters platform drivers specified by an array. This is typically used
to complement an earlier call to platform_register_drivers(). Drivers are
unregistered in the reverse order in which they were registered.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.platform_find_device_by_driver">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">platform_find_device_by_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_find_device_by_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find a platform device with a given driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>The device to start the search from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>The device driver to look for.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_find_device_by_name">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bus_find_device_by_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device_by_name" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device of a specific name.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the device to match</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_find_device_by_of_node">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bus_find_device_by_of_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">np</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device_by_of_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the of_node.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>of_node of the device to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_find_device_by_fwnode">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bus_find_device_by_fwnode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device_by_fwnode" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the fwnode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>fwnode of the device to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_find_device_by_devt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bus_find_device_by_devt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">devt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device_by_devt" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the device type.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>device type of the device to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_find_next_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bus_find_next_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cur</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_next_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the next device after a given device in a given bus.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*cur</span></code></dt><dd><p>device to begin the search with.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_find_device_by_acpi_dev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bus_find_device_by_acpi_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">acpi_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device_by_acpi_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device matching the ACPI COMPANION device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">acpi_device</span> <span class="pre">*adev</span></code></dt><dd><p>ACPI COMPANION device to match.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_for_each_dev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bus_for_each_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_for_each_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>device to start iterating from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to be called for each device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>bus</strong>’s list of devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>. If <strong>start</strong> is not NULL, we use that device to
begin iterating from.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<p><strong>NOTE</strong></p>
<p>The device that returns a non-zero value is not retained
in any way, nor is its refcount incremented. If the caller needs
to retain this data, it should do so, and increment the reference
count in the supplied callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_find_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bus_find_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">match</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to pass to match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>Callback function to check device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.bus_for_each_dev" title="bus_for_each_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">bus_for_each_dev()</span></code></a> function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_for_each_drv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bus_for_each_drv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_for_each_drv" title="Link to this definition">¶</a><br /></dt>
<dd><p>driver iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus we’re dealing with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*start</span></code></dt><dd><p>driver to start iterating on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data to pass to the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device_driver</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to call for each driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is nearly identical to the device iterator above.
We iterate over each driver that belongs to <strong>bus</strong>, and call
<strong>fn</strong> for each. If <strong>fn</strong> returns anything but 0, we break out
and return it. If <strong>start</strong> is not NULL, we use it as the head
of the list.</p>
<p><strong>NOTE</strong></p>
<p>we don’t return the driver that returns a non-zero
value, nor do we leave the reference count incremented for that
driver. If the caller needs to know that info, it must set it
in the callback. It must also be sure to increment the refcount
so it doesn’t disappear before returning to the caller.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_rescan_devices">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bus_rescan_devices</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_rescan_devices" title="Link to this definition">¶</a><br /></dt>
<dd><p>rescan devices on the bus for possible drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>the bus to scan.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will look for devices on the bus with no driver
attached and rescan it against existing drivers to see if it matches
any by calling <a class="reference internal" href="#c.device_attach" title="device_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_attach()</span></code></a> for the unbound devices.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_reprobe">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_reprobe</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_reprobe" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove driver for a device and probe for a new driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device to reprobe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function detaches the attached driver (if any) for the given
device and restarts the driver probing process.  It is intended
to use if probing criteria changed during a devices lifetime and
driver attachment should change accordingly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bus_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a driver-core subsystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Once we have that, we register the bus with the kobject
infrastructure, then register the children subsystems it has:
the devices and drivers that belong to the subsystem.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bus_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a bus from the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister the child subsystems and the bus itself.
Finally, we call bus_put() to release the refcount</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.subsys_system_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">subsys_system_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">subsys</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">attribute_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">groups</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_system_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a subsystem at /sys/devices/system/</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*subsys</span></code></dt><dd><p>system subsystem</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**groups</span></code></dt><dd><p>default attributes for the root device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All ‘system’ subsystems have a /sys/devices/system/&lt;name&gt; root device
with the name of the subsystem. The root device can carry subsystem-
wide attributes. All registered devices are below this single root
device and are named after the subsystem with a simple enumeration
number appended. The registered devices are not explicitly named;
only ‘id’ in the device needs to be set.</p>
<p>Do not use this interface for anything new, it exists for compatibility
with bad ideas only. New subsystems should use plain subsystems; and
add the subsystem-wide attributes should be added to the subsystem
directory itself and not some create fake root-device placed in
/sys/devices/system/&lt;name&gt;.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.subsys_virtual_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">subsys_virtual_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">subsys</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">attribute_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">groups</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_virtual_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a subsystem at /sys/devices/virtual/</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*subsys</span></code></dt><dd><p>virtual subsystem</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**groups</span></code></dt><dd><p>default attributes for the root device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All ‘virtual’ subsystems have a /sys/devices/system/&lt;name&gt; root device
with the name of the subystem.  The root device can carry subsystem-wide
attributes.  All registered devices are below this single root device.
There’s no restriction on device naming.  This is for kernel software
constructs which need sysfs interface.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.driver_find">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device_driver" title="device_driver"><span class="n"><span class="pre">device_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">driver_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>locate driver on a bus by its name.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus to scan for the driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="basics.html#c.kset_find_obj" title="kset_find_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">kset_find_obj()</span></code></a> to iterate over list of drivers on
a bus to find driver by name. Return driver if found.</p>
<p>This routine provides no locking to prevent the driver it returns
from being unregistered or unloaded while the caller is using it.
The caller is responsible for preventing this.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bus_get_dev_root">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bus_get_dev_root</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bus_type" title="bus_type"><span class="n"><span class="pre">bus_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bus</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_get_dev_root" title="Link to this definition">¶</a><br /></dt>
<dd><p>return a pointer to the “device root” of a bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus to return the device root of.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a bus has a “device root” structure, return it, WITH THE REFERENCE
COUNT INCREMENTED.</p>
<p>Note, when finished with the device, a call to <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> is required.</p>
<p>If the device root is not present (or bus is not a valid pointer), NULL
will be returned.</p>
</div>
</section>
<section id="device-drivers-dma-management">
<h2>Device Drivers DMA Management<a class="headerlink" href="#device-drivers-dma-management" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.dmam_free_coherent">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dmam_free_coherent</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vaddr</span></span>, <span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">dma_handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_free_coherent" title="Link to this definition">¶</a><br /></dt>
<dd><p>Managed dma_free_coherent()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to free coherent memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*vaddr</span></code></dt><dd><p>Virtual address of the memory to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma_handle</span></code></dt><dd><p>DMA handle of the memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed dma_free_coherent().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dmam_alloc_attrs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">dmam_alloc_attrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_handle</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_alloc_attrs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Managed dma_alloc_attrs()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate non_coherent memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*dma_handle</span></code></dt><dd><p>Out argument for allocated DMA handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt><dd><p>Flags in the DMA_ATTR_* namespace.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed dma_alloc_attrs().  Memory allocated using this function will be
automatically released on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_map_sg_attrs">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_map_sg_attrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scatterlist</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nents</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">dma_data_direction</span></span><span class="w"> </span><span class="n"><span class="pre">dir</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_map_sg_attrs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Map the given buffer for DMA</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device for which to perform the DMA operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sg</span></code></dt><dd><p>The sg_table object describing the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nents</span></code></dt><dd><p>Number of entries to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>DMA direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt><dd><p>Optional DMA attributes for the map operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps a buffer described by a scatterlist passed in the sg argument with
nents segments for the <strong>dir</strong> DMA operation by the <strong>dev</strong> device.</p>
<p>Returns the number of mapped entries (which can be less than nents)
on success. Zero is returned for any error.</p>
<p>dma_unmap_sg_attrs() should be used to unmap the buffer with the
original sg and original nents (not the value returned by this funciton).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_map_sgtable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_map_sgtable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgt</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">dma_data_direction</span></span><span class="w"> </span><span class="n"><span class="pre">dir</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_map_sgtable" title="Link to this definition">¶</a><br /></dt>
<dd><p>Map the given buffer for DMA</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device for which to perform the DMA operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>The sg_table object describing the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>DMA direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt><dd><p>Optional DMA attributes for the map operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps a buffer described by a scatterlist stored in the given sg_table
object for the <strong>dir</strong> DMA operation by the <strong>dev</strong> device. After success, the
ownership for the buffer is transferred to the DMA domain.  One has to
call dma_sync_sgtable_for_cpu() or dma_unmap_sgtable() to move the
ownership of the buffer back to the CPU domain before touching the
buffer by the CPU.</p>
<p>Returns 0 on success or a negative error code on error. The following
error codes are supported with the given meaning:</p>
<blockquote>
<div><dl class="option-list">
<dt><kbd><span class="option">-E<var>INVAL</var></span></kbd></dt>
<dd><p>An invalid argument, unaligned access or other error
in usage. Will not succeed if retried.</p>
</dd>
<dt><kbd><span class="option">-E<var>NOMEM</var></span></kbd></dt>
<dd><p>Insufficient resources (like memory or IOVA space) to
complete the mapping. Should succeed if retried later.</p>
</dd>
<dt><kbd><span class="option">-E<var>IO</var></span></kbd></dt>
<dd><p>Legacy error code with an unknown meaning. eg. this is
returned if a lower level call returned
DMA_MAPPING_ERROR.</p>
</dd>
<dt><kbd><span class="option">-E<var>REMOTEIO</var></span></kbd></dt>
<dd><p>The DMA device cannot access P2PDMA memory specified
in the sg_table. This will not succeed if retried.</p>
</dd>
</dl>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_can_mmap">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_can_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_can_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>check if a given device supports dma_mmap_*</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dev</strong> supports dma_mmap_coherent() and <a class="reference internal" href="#c.dma_mmap_attrs" title="dma_mmap_attrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_mmap_attrs()</span></code></a> to
map DMA allocations to userspace.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_mmap_attrs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_mmap_attrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cpu_addr</span></span>, <span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="n"><span class="pre">dma_addr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_mmap_attrs" title="Link to this definition">¶</a><br /></dt>
<dd><p>map a coherent DMA allocation into user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>valid <a class="reference internal" href="#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer, or NULL for ISA and EISA-like devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vm_area_struct describing requested user mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*cpu_addr</span></code></dt><dd><p>kernel CPU-view address returned from dma_alloc_attrs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma_addr</span></code></dt><dd><p>device-view address returned from dma_alloc_attrs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of memory originally requested in dma_alloc_attrs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt><dd><p>attributes of mapping properties requested in dma_alloc_attrs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map a coherent DMA buffer previously allocated by dma_alloc_attrs into user
space.  The coherent DMA buffer must not be freed by the driver until the
user space mapping has been released.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.dma_addressing_limited">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dma_addressing_limited</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_addressing_limited" title="Link to this definition">¶</a><br /></dt>
<dd><p>return if the device is addressing limited</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the devices DMA mask is too small to address all memory in
the system, else <code class="docutils literal notranslate"><span class="pre">false</span></code>.  Lack of addressing bits is the prime reason for
bounce buffering, but might not be the only one.</p>
</div>
</section>
<section id="device-drivers-pnp-support">
<h2>Device drivers PnP support<a class="headerlink" href="#device-drivers-pnp-support" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_register_protocol">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_register_protocol</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_protocol</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">protocol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_register_protocol" title="Link to this definition">¶</a><br /></dt>
<dd><p>adds a pnp protocol to the pnp layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_protocol</span> <span class="pre">*protocol</span></code></dt><dd><p>pointer to the corresponding pnp_protocol structure</p>
<p>Ex protocols: ISAPNP, PNPBIOS, etc</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_unregister_protocol">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_unregister_protocol</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_protocol</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">protocol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_unregister_protocol" title="Link to this definition">¶</a><br /></dt>
<dd><p>removes a pnp protocol from the pnp layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_protocol</span> <span class="pre">*protocol</span></code></dt><dd><p>pointer to the corresponding pnp_protocol structure</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_request_card_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pnp_request_card_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_card_link</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clink</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_request_card_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Searches for a PnP device under the specified card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_link</span> <span class="pre">*clink</span></code></dt><dd><p>pointer to the card link, cannot be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>pointer to a PnP ID structure that explains the rules for finding the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*from</span></code></dt><dd><p>Starting place to search from. If NULL it will start from the beginning.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_release_card_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_release_card_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_release_card_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>call this when the driver no longer needs the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the PnP device structure</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_register_card_driver">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_register_card_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_card_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_register_card_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>registers a PnP card driver with the PnP Layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_driver</span> <span class="pre">*drv</span></code></dt><dd><p>pointer to the driver to register</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_unregister_card_driver">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_unregister_card_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_card_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_unregister_card_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregisters a PnP card driver from the PnP Layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_driver</span> <span class="pre">*drv</span></code></dt><dd><p>pointer to the driver to unregister</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_add_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_id</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pnp_add_id</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_add_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>adds an EISA id to the specified device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>pointer to an EISA id string</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_start_dev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_start_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_start_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>low-level start of the PnP device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>assumes that resources have already been allocated</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_stop_dev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_stop_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_stop_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>low-level disable of the PnP device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>does not free resources</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_activate_dev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_activate_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_activate_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>activates a PnP device for use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>does not validate or set resources so be careful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_disable_dev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_disable_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_disable_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>disables device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>inform the correct pnp protocol so that resources can be used by other devices</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pnp_is_active">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pnp_is_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pnp_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_is_active" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determines if a device is active based on its current resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired PnP device</p>
</dd>
</dl>
</div>
</section>
<section id="userspace-io-devices">
<h2>Userspace IO devices<a class="headerlink" href="#userspace-io-devices" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.uio_event_notify">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uio_event_notify</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.uio_info" title="uio_info"><span class="n"><span class="pre">uio_info</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_event_notify" title="Link to this definition">¶</a><br /></dt>
<dd><p>trigger an interrupt event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__uio_register_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__uio_register_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.uio_info" title="uio_info"><span class="n"><span class="pre">uio_info</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__uio_register_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a new userspace IO device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module that creates the new device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__devm_uio_register_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__devm_uio_register_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.uio_info" title="uio_info"><span class="n"><span class="pre">uio_info</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__devm_uio_register_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resource managed <a class="reference internal" href="#c.uio_register_device" title="uio_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">uio_register_device()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module that creates the new device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uio_unregister_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uio_unregister_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.uio_info" title="uio_info"><span class="n"><span class="pre">uio_info</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_unregister_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a industrial IO device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.uio_mem">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uio_mem</span></span></span><a class="headerlink" href="#c.uio_mem" title="Link to this definition">¶</a><br /></dt>
<dd><p>description of a UIO memory region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_mem {
    const char              *name;
    phys_addr_t addr;
    dma_addr_t dma_addr;
    unsigned long           offs;
    resource_size_t size;
    int memtype;
    void __iomem            *internal_addr;
    struct device           *dma_device;
    struct uio_map          *map;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the memory region for identification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>address of the device’s memory rounded to page
size (phys_addr is used since addr can be
logical, virtual, or physical &amp; phys_addr_t
should always be large enough to handle any of
the address types)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr</span></code></dt><dd><p>DMA handle set by dma_alloc_coherent, used with
UIO_MEM_DMA_COHERENT only (<strong>addr</strong> should be the
void * returned from the same dma_alloc_coherent call)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offs</span></code></dt><dd><p>offset of device memory within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size of IO (multiple of page size)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memtype</span></code></dt><dd><p>type of memory addr points to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal_addr</span></code></dt><dd><p>ioremap-ped version of addr, for driver internal use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_device</span></code></dt><dd><p>device struct that was passed to dma_alloc_coherent,
used with UIO_MEM_DMA_COHERENT only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>for use by the UIO core only.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.uio_port">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uio_port</span></span></span><a class="headerlink" href="#c.uio_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>description of a UIO port region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_port {
    const char              *name;
    unsigned long           start;
    unsigned long           size;
    int porttype;
    struct uio_portio       *portio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the port region for identification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>start of port region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size of port region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">porttype</span></code></dt><dd><p>type of port (see UIO_PORT_* below)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">portio</span></code></dt><dd><p>for use by the UIO core only.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.uio_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uio_info</span></span></span><a class="headerlink" href="#c.uio_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>UIO device capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_info {
    struct uio_device       *uio_dev;
    const char              *name;
    const char              *version;
    struct uio_mem          mem[MAX_UIO_MAPS];
    struct uio_port         port[MAX_UIO_PORT_REGIONS];
    long irq;
    unsigned long           irq_flags;
    void *priv;
    irqreturn_t (*handler)(int irq, struct uio_info *dev_info);
    int (*mmap)(struct uio_info *info, struct vm_area_struct *vma);
    int (*open)(struct uio_info *info, struct inode *inode);
    int (*release)(struct uio_info *info, struct inode *inode);
    int (*irqcontrol)(struct uio_info *info, s32 irq_on);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uio_dev</span></code></dt><dd><p>the UIO device this info belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>device driver version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem</span></code></dt><dd><p>list of mappable memory regions, size==0 for end of list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt><dd><p>list of port regions, size==0 for end of list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>interrupt number or UIO_IRQ_CUSTOM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_flags</span></code></dt><dd><p>flags for <a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>optional private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>the device’s irq handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>mmap operation for this uio device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>open operation for this uio device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>release operation for this uio device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irqcontrol</span></code></dt><dd><p>disable/enable irqs when 0/1 is written to /dev/uioX</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.uio_register_device">
<span class="sig-name descname"><span class="n"><span class="pre">uio_register_device</span></span></span><a class="headerlink" href="#c.uio_register_device" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">uio_register_device</span> <span class="pre">(parent,</span> <span class="pre">info)</span></code></p>
<blockquote>
<div><p>register a new userspace IO device</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.devm_uio_register_device">
<span class="sig-name descname"><span class="n"><span class="pre">devm_uio_register_device</span></span></span><a class="headerlink" href="#c.devm_uio_register_device" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">devm_uio_register_device</span> <span class="pre">(parent,</span> <span class="pre">info)</span></code></p>
<blockquote>
<div><p>Resource managed <a class="reference internal" href="#c.uio_register_device" title="uio_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">uio_register_device()</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/infrastructure.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>