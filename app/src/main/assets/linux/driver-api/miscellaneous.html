<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Parallel Port Devices &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="MMC/SD/SDIO card support" href="mmc/index.html" />
    <link rel="prev" title="Miscellaneous Devices" href="misc_devices.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.14.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="extcon.html">Extcon Device Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/miscellaneous.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="parallel-port-devices">
<h1>Parallel Port Devices<a class="headerlink" href="#parallel-port-devices" title="Link to this heading">¶</a></h1>
<dl class="c macro">
<dt class="sig sig-object c" id="c.parport_register_driver">
<span class="sig-name descname"><span class="n"><span class="pre">parport_register_driver</span></span></span><a class="headerlink" href="#c.parport_register_driver" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">parport_register_driver</span> <span class="pre">(driver)</span></code></p>
<blockquote>
<div><p>register a parallel port device driver</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>structure describing the driver</p>
<p>This can be called by a parallel port device driver in order
to receive notifications about ports being found in the
system, as well as ports no longer available.</p>
<p>The <strong>driver</strong> structure is allocated by the caller and must not be
deallocated until after calling <a class="reference internal" href="#c.parport_unregister_driver" title="parport_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_unregister_driver()</span></code></a>.</p>
<p>If using the non device model:
The driver’s attach() function may block.  The port that
attach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.  Calling
parport_register_device() on that port will do this for you.</p>
<p>The driver’s detach() function may block.  The port that
detach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.</p>
<p>Returns 0 on success. The non device model will always succeeds.
but the new device model can fail and will return the error code.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.module_parport_driver">
<span class="sig-name descname"><span class="n"><span class="pre">module_parport_driver</span></span></span><a class="headerlink" href="#c.module_parport_driver" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">module_parport_driver</span> <span class="pre">(__parport_driver)</span></code></p>
<blockquote>
<div><p>Helper macro for registering a modular parport driver</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__parport_driver</span></code></dt><dd><p>struct parport_driver to be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for parport drivers which do not do anything special in module
init and exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_yield">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_yield</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_yield" title="Link to this definition">¶</a><br /></dt>
<dd><p>relinquish a parallel port temporarily</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>a device on the parallel port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
<a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>, and the return value is the same as for
<a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>.  If it fails, the port is left unclaimed and it is
the driver’s responsibility to reclaim the port.</p>
<p>The <a class="reference internal" href="#c.parport_yield" title="parport_yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_yield()</span></code></a> and <a class="reference internal" href="#c.parport_yield_blocking" title="parport_yield_blocking"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_yield_blocking()</span></code></a> functions are for
marking points in the driver at which other drivers may claim the
port and use their devices.  Yielding the port is similar to
releasing it and reclaiming it, but is more efficient because no
action is taken if there are no other devices needing the port.  In
fact, nothing is done even if there are other devices waiting but
the current device is still within its “timeslice”.  The default
timeslice is half a second, but it can be adjusted via the /proc
interface.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_yield_blocking">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_yield_blocking</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_yield_blocking" title="Link to this definition">¶</a><br /></dt>
<dd><p>relinquish a parallel port temporarily</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>a device on the parallel port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
<a class="reference internal" href="#c.parport_claim_or_block" title="parport_claim_or_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim_or_block()</span></code></a>, and the return value is the same as for
<a class="reference internal" href="#c.parport_claim_or_block" title="parport_claim_or_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim_or_block()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_wait_event">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_wait_event</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_wait_event" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for an event on a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>time to wait (in jiffies)</p>
<p>This function waits for up to <strong>timeout</strong> jiffies for an
interrupt to occur on a parallel port.  If the port timeout is
set to zero, it returns immediately.</p>
<p>If an interrupt occurs before the timeout period elapses, this
function returns zero immediately.  If it times out, it returns
one.  An error code less than zero indicates an error (most
likely a pending signal), and the calling code should finish
what it’s doing as soon as it can.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_wait_peripheral">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_wait_peripheral</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_wait_peripheral" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for status lines to change in 35ms</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to watch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">mask</span></code></dt><dd><p>status lines to watch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">result</span></code></dt><dd><p>desired values of chosen status lines</p>
<p>This function waits until the masked status lines have the
desired values, or until 35ms have elapsed (see IEEE 1284-1994
page 24 to 25 for why this value in particular is hardcoded).
The <strong>mask</strong> and <strong>result</strong> parameters are bitmasks, with the bits
defined by the constants in parport.h: <code class="docutils literal notranslate"><span class="pre">PARPORT_STATUS_BUSY</span></code>,
and so on.</p>
<p>The port is polled quickly to start off with, in anticipation
of a fast response from the peripheral.  This fast polling
time is configurable (using /proc), and defaults to 500usec.
If the timeout for this port (see <a class="reference internal" href="#c.parport_set_timeout" title="parport_set_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_set_timeout()</span></code></a>) is
zero, the fast polling time is 35ms, and this function does
not call schedule().</p>
<p>If the timeout for this port is non-zero, after the fast
polling fails it uses <a class="reference internal" href="#c.parport_wait_event" title="parport_wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_event()</span></code></a> to wait for up to
10ms, waking up if an interrupt occurs.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_negotiate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_negotiate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_negotiate" title="Link to this definition">¶</a><br /></dt>
<dd><p>negotiate an IEEE 1284 mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>mode to negotiate to</p>
<p>Use this to negotiate to a particular IEEE 1284 transfer mode.
The <strong>mode</strong> parameter should be one of the constants in
parport.h starting <code class="docutils literal notranslate"><span class="pre">IEEE1284_MODE_xxx</span></code>.</p>
<p>The return value is 0 if the peripheral has accepted the
negotiation to the mode specified, -1 if the peripheral is not
IEEE 1284 compliant (or not present), or 1 if the peripheral
has rejected the negotiation.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_write">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_write</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_write" title="Link to this definition">¶</a><br /></dt>
<dd><p>write a block of data to a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>data buffer (in kernel space)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes of data to transfer</p>
<p>This will write up to <strong>len</strong> bytes of <strong>buffer</strong> to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using <a class="reference internal" href="#c.parport_negotiate" title="parport_negotiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_negotiate()</span></code></a>), as long as that
mode supports forward transfers (host to peripheral).</p>
<p>It is the caller’s responsibility to ensure that the first
<strong>len</strong> bytes of <strong>buffer</strong> are valid.</p>
<p>This function returns the number of bytes transferred (if zero
or positive), or else an error code.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_read">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>read a block of data from a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>data buffer (in kernel space)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes of data to transfer</p>
<p>This will read up to <strong>len</strong> bytes of <strong>buffer</strong> to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using <a class="reference internal" href="#c.parport_negotiate" title="parport_negotiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_negotiate()</span></code></a>), as long as that
mode supports reverse transfers (peripheral to host).</p>
<p>It is the caller’s responsibility to ensure that the first
<strong>len</strong> bytes of <strong>buffer</strong> are available to write to.</p>
<p>This function returns the number of bytes transferred (if zero
or positive), or else an error code.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_set_timeout">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_set_timeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">inactivity</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_set_timeout" title="Link to this definition">¶</a><br /></dt>
<dd><p>set the inactivity timeout for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>device on a port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">inactivity</span></code></dt><dd><p>inactivity timeout (in jiffies)</p>
<p>This sets the inactivity timeout for a particular device on a
port.  This affects functions like <a class="reference internal" href="#c.parport_wait_peripheral" title="parport_wait_peripheral"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_peripheral()</span></code></a>.
The special value 0 means not to call schedule() while dealing
with this device.</p>
<p>The return value is the previous inactivity timeout.</p>
<p>Any callers of <a class="reference internal" href="#c.parport_wait_event" title="parport_wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_event()</span></code></a> for this device are woken
up.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__parport_register_driver">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__parport_register_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mod_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__parport_register_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a parallel port device driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_driver</span> <span class="pre">*drv</span></code></dt><dd><p>structure describing the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module of drv</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>module name string</p>
<p>This can be called by a parallel port device driver in order
to receive notifications about ports being found in the
system, as well as ports no longer available.</p>
<p>If devmodel is true then the new device model is used
for registration.</p>
<p>The <strong>drv</strong> structure is allocated by the caller and must not be
deallocated until after calling <a class="reference internal" href="#c.parport_unregister_driver" title="parport_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_unregister_driver()</span></code></a>.</p>
<p>If using the non device model:
The driver’s attach() function may block.  The port that
attach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.  Calling
parport_register_device() on that port will do this for you.</p>
<p>The driver’s detach() function may block.  The port that
detach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.</p>
<p>Returns 0 on success. The non device model will always succeeds.
but the new device model can fail and will return the error code.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_unregister_driver">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_unregister_driver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport_driver</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_unregister_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>deregister a parallel port device driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_driver</span> <span class="pre">*drv</span></code></dt><dd><p>structure describing the driver that was given to
<a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a></p>
<blockquote>
<div><p>This should be called by a parallel port device driver that
has registered itself using <a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a> when it
is about to be unloaded.</p>
<p>When it returns, the driver’s attach() routine will no longer
be called, and for each port that attach() was called for, the
detach() routine will have been called.</p>
<p>All the driver’s attach() and detach() calls are guaranteed to have
finished by the time this function returns.</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_get_port">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">parport_get_port</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_get_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>increment a port’s reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>the port</p>
<p>This ensures that a struct parport pointer remains valid
until the matching <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a> call.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_put_port">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_put_port</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_put_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrement a port’s reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>the port</p>
<p>This should be called once for each call to <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a>,
once the port is no longer needed. When the reference count reaches
zero (port is no longer used), free_port is called.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_register_port">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">parport_register_port</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">irq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dma</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport_operations</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_register_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt><dd><p>base I/O address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>IRQ line</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma</span></code></dt><dd><p>DMA channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_operations</span> <span class="pre">*ops</span></code></dt><dd><p>pointer to the port driver’s port operations structure</p>
<p>When a parallel port (lowlevel) driver finds a port that
should be made available to parallel port device drivers, it
should call <a class="reference internal" href="#c.parport_register_port" title="parport_register_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_port()</span></code></a>.  The <strong>base</strong>, <strong>irq</strong>, and
<strong>dma</strong> parameters are for the convenience of port drivers, and
for ports where they aren’t meaningful needn’t be set to
anything special.  They can be altered afterwards by adjusting
the relevant members of the parport structure that is returned
and represents the port.  They should not be tampered with
after calling parport_announce_port, however.</p>
<p>If there are parallel port device drivers in the system that
have registered themselves using <a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a>,
they are not told about the port at this time; that is done by
<a class="reference internal" href="#c.parport_announce_port" title="parport_announce_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_announce_port()</span></code></a>.</p>
<p>The <strong>ops</strong> structure is allocated by the caller, and must not be
deallocated before calling <a class="reference internal" href="#c.parport_remove_port" title="parport_remove_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_remove_port()</span></code></a>.</p>
<p>If there is no memory to allocate a new parport structure,
this function will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_announce_port">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_announce_port</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_announce_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>tell device drivers about a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>parallel port to announce</p>
<p>After a port driver has registered a parallel port with
parport_register_port, and performed any necessary
initialisation or adjustments, it should call
<a class="reference internal" href="#c.parport_announce_port" title="parport_announce_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_announce_port()</span></code></a> in order to notify all device drivers
that have called <a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a>.  Their attach()
functions will be called, with <strong>port</strong> as the parameter.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_remove_port">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_remove_port</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_remove_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>deregister a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>parallel port to deregister</p>
<p>When a parallel port driver is forcibly unloaded, or a
parallel port becomes inaccessible, the port driver must call
this function in order to deal with device drivers that still
want to use it.</p>
<p>The parport structure associated with the port has its
operations structure replaced with one containing ‘null’
operations that return errors or just don’t do anything.</p>
<p>Any drivers that have registered themselves using
<a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a> are notified that the port is no
longer accessible by having their detach() routines called
with <strong>port</strong> as the parameter.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_register_dev_model">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">parport_register_dev_model</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardev_cb</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">par_dev_cb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_register_dev_model" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a device on a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to which the device is attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a name to refer to the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pardev_cb</span> <span class="pre">*par_dev_cb</span></code></dt><dd><p>struct containing callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>device number to be given to the device</p>
<p>This function, called by parallel port device drivers,
declares that a device is connected to a port, and tells the
system all it needs to know.</p>
<p>The struct pardev_cb contains pointer to callbacks. preemption
callback function, <strong>preempt</strong>, is called when this device driver
has claimed access to the port but another device driver wants
to use it.  It is given, <strong>private</strong>, as its parameter, and should
return zero if it is willing for the system to release the port
to another driver on its behalf. If it wants to keep control of
the port it should return non-zero, and no action will be taken.
It is good manners for the driver to try to release the port at
the earliest opportunity after its preemption callback rejects a
preemption attempt. Note that if a preemption callback is happy
for preemption to go ahead, there is no need to release the
port; it is done automatically. This function may not block, as
it may be called from interrupt context. If the device driver
does not support preemption, <strong>preempt</strong> can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>The wake-up (“kick”) callback function, <strong>wakeup</strong>, is called when
the port is available to be claimed for exclusive access; that
is, <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a> is guaranteed to succeed when called from
inside the wake-up callback function.  If the driver wants to
claim the port it should do so; otherwise, it need not take
any action.  This function may not block, as it may be called
from interrupt context.  If the device driver does not want to
be explicitly invited to claim the port in this way, <strong>wakeup</strong> can
be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>The interrupt handler, <strong>irq_func</strong>, is called when an interrupt
arrives from the parallel port.  Note that if a device driver
wants to use interrupts it should use parport_enable_irq(),
and can also check the irq member of the parport structure
representing the port.</p>
<p>The parallel port (lowlevel) driver is the one that has called
<a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> and whose interrupt handler is called first.
This handler does whatever needs to be done to the hardware to
acknowledge the interrupt (for PC-style ports there is nothing
special to be done).  It then tells the IEEE 1284 code about
the interrupt, which may involve reacting to an IEEE 1284
event depending on the current IEEE 1284 phase.  After this,
it calls <strong>irq_func</strong>.  Needless to say, <strong>irq_func</strong> will be called
from interrupt context, and may not block.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PARPORT_DEV_EXCL</span></code> flag is for preventing port sharing, and
so should only be used when sharing the port with other device
drivers is impossible and would lead to incorrect behaviour.
Use it sparingly!  Normally, <strong>flags</strong> will be zero.</p>
<p>This function returns a pointer to a structure that represents
the device on the port, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is not enough memory
to allocate space for that structure.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_unregister_device">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_unregister_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_unregister_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>deregister a device on a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to structure representing device</p>
<p>This undoes the effect of parport_register_device().</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_find_number">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">parport_find_number</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">number</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_find_number" title="Link to this definition">¶</a><br /></dt>
<dd><p>find a parallel port by number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">number</span></code></dt><dd><p>parallel port number</p>
<p>This returns the parallel port with the specified number, or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is none.</p>
<p>There is an implicit <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> done already; to throw
away the reference to the port that <a class="reference internal" href="#c.parport_find_number" title="parport_find_number"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_find_number()</span></code></a>
gives you, use <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_find_base">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">parport</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">parport_find_base</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_find_base" title="Link to this definition">¶</a><br /></dt>
<dd><p>find a parallel port by base address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt><dd><p>base I/O address</p>
<p>This returns the parallel port with the specified base
address, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is none.</p>
<p>There is an implicit <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> done already; to throw
away the reference to the port that <a class="reference internal" href="#c.parport_find_base" title="parport_find_base"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_find_base()</span></code></a>
gives you, use <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_claim">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_claim</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_claim" title="Link to this definition">¶</a><br /></dt>
<dd><p>claim access to a parallel port device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to structure representing a device on the port</p>
<p>This function will not block and so can be used from interrupt
context.  If <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a> succeeds in claiming access to
the port it returns zero and the port is available to use.  It
may fail (returning non-zero) if the port is in use by another
driver and that driver is not willing to relinquish control of
the port.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_claim_or_block">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_claim_or_block</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_claim_or_block" title="Link to this definition">¶</a><br /></dt>
<dd><p>claim access to a parallel port device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to structure representing a device on the port</p>
<p>This behaves like <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>, but will block if necessary
to wait for the port to be free.  A return value of 1
indicates that it slept; 0 means that it succeeded without
needing to sleep.  A negative error code indicates failure.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_release</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>give up access to a parallel port device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to structure representing parallel port device</p>
<p>This function cannot fail, but it should not be called without
the port claimed.  Similarly, if the port is already claimed
you should not try claiming it again.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_open">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">parport_open</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">devnum</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_open" title="Link to this definition">¶</a><br /></dt>
<dd><p>find a device by canonical device number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devnum</span></code></dt><dd><p>canonical device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name to associate with the device</p>
<p>This function is similar to parport_register_device(), except
that it locates a device by its number rather than by the port
it is attached to.</p>
<p>All parameters except for <strong>devnum</strong> are the same as for
parport_register_device().  The return value is the same as
for parport_register_device().</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parport_close">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parport_close</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pardevice</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_close" title="Link to this definition">¶</a><br /></dt>
<dd><p>close a device opened with <a class="reference internal" href="#c.parport_open" title="parport_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_open()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>device to close</p>
<p>This is to <a class="reference internal" href="#c.parport_open" title="parport_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_open()</span></code></a> as <a class="reference internal" href="#c.parport_unregister_device" title="parport_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_unregister_device()</span></code></a> is to
parport_register_device().</p>
</dd>
</dl>
</div>
</section>
<section id="x50-uart-driver">
<h1>16x50 UART Driver<a class="headerlink" href="#x50-uart-driver" title="Link to this heading">¶</a></h1>
<dl class="c function">
<dt class="sig sig-object c" id="c.serial8250_get_port">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_8250_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">serial8250_get_port</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">line</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_get_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>retrieve struct uart_8250_port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt><dd><p>serial line number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function retrieves struct uart_8250_port for the specific line.
This struct <em>must</em> <em>not</em> be used to perform a 8250 or serial core operation
which is not accessible otherwise. Its only purpose is to make the struct
accessible to the runtime-pm callbacks for context suspend/restore.
The lock assumption made here is none because runtime-pm suspend/resume
callbacks should not be invoked if there is any operation performed on the
port.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.serial8250_suspend_port">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">serial8250_suspend_port</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">line</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_suspend_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>suspend one serial port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt><dd><p>serial line number</p>
<p>Suspend one serial port.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.serial8250_resume_port">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">serial8250_resume_port</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">line</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_resume_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>resume one serial port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt><dd><p>serial line number</p>
<p>Resume one serial port.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.serial8250_register_8250_port">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">serial8250_register_8250_port</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">uart_8250_port</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">up</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_register_8250_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a serial port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">uart_8250_port</span> <span class="pre">*up</span></code></dt><dd><p>serial port template</p>
<p>Configure the serial port specified by the request. If the
port exists and is in use, it is hung up and unregistered
first.</p>
<p>The port is then probed and if necessary the IRQ is autodetected
If this fails an error is returned.</p>
<p>On success the port is ready to use and the line number is returned.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.serial8250_unregister_port">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">serial8250_unregister_port</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">line</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_unregister_port" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a 16x50 serial port at runtime</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt><dd><p>serial line number</p>
<p>Remove one serial port.  This may not be called from interrupt
context.  We hand the port back to the our control.</p>
</dd>
</dl>
</div>
<p>See <a class="reference internal" href="serial/driver.html"><span class="doc">Low Level Serial API</span></a> for related APIs.</p>
</section>
<section id="pulse-width-modulation-pwm">
<h1>Pulse-Width Modulation (PWM)<a class="headerlink" href="#pulse-width-modulation-pwm" title="Link to this heading">¶</a></h1>
<p>Pulse-width modulation is a modulation technique primarily used to
control power supplied to electrical devices.</p>
<p>The PWM framework provides an abstraction for providers and consumers of
PWM signals. A controller that provides one or more PWM signals is
registered as <a class="reference internal" href="#c.pwm_chip" title="pwm_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span></code></a>. Providers
are expected to embed this structure in a driver-specific structure.
This structure contains fields that describe a particular chip.</p>
<p>A chip exposes one or more PWM signal sources, each of which exposed as
a <a class="reference internal" href="#c.pwm_device" title="pwm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span></code></a>. Operations can be
performed on PWM devices to control the period, duty cycle, polarity and
active state of the signal.</p>
<p>Note that PWM devices are exclusive resources: they can always only be
used by one consumer at a time.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.pwm_polarity">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_polarity</span></span></span><a class="headerlink" href="#c.pwm_polarity" title="Link to this definition">¶</a><br /></dt>
<dd><p>polarity of a PWM signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PWM_POLARITY_NORMAL</span></code></dt><dd><p>a high signal for the duration of the duty-
cycle, followed by a low signal for the remainder of the pulse
period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PWM_POLARITY_INVERSED</span></code></dt><dd><p>a low signal for the duration of the duty-
cycle, followed by a high signal for the remainder of the pulse
period</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.pwm_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_args</span></span></span><a class="headerlink" href="#c.pwm_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>board-dependent PWM arguments</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_args {
    u64 period;
    enum pwm_polarity polarity;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">period</span></code></dt><dd><p>reference period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">polarity</span></code></dt><dd><p>reference polarity</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure describes board-dependent arguments attached to a PWM
device. These arguments are usually retrieved from the PWM lookup table or
device tree.</p>
<p>Do not confuse this with the PWM state: PWM arguments represent the initial
configuration that users want to use on this PWM device rather than the
current PWM hardware state.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.pwm_waveform">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_waveform</span></span></span><a class="headerlink" href="#c.pwm_waveform" title="Link to this definition">¶</a><br /></dt>
<dd><p>description of a PWM waveform</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_waveform {
    u64 period_length_ns;
    u64 duty_length_ns;
    u64 duty_offset_ns;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">period_length_ns</span></code></dt><dd><p>PWM period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duty_length_ns</span></code></dt><dd><p>PWM duty cycle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duty_offset_ns</span></code></dt><dd><p>offset of the rising edge from the period’s start</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is a representation of a PWM waveform alternative to struct pwm_state
below. It’s more expressive than struct pwm_state as it contains a
duty_offset_ns and so can represent offsets other than zero (with .polarity =
PWM_POLARITY_NORMAL) and period - duty_cycle (.polarity =
PWM_POLARITY_INVERSED).</p>
<p>Note there is no explicit bool for enabled. A “disabled” PWM is represented
by .period_length_ns = 0. Note further that the behaviour of a “disabled” PWM
is undefined. Depending on the hardware’s capabilities it might drive the
active or inactive level, go high-z or even continue to toggle.</p>
<p>The unit for all three members is nanoseconds.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.pwm_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_device</span></span></span><a class="headerlink" href="#c.pwm_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>PWM channel object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_device {
    const char *label;
    unsigned long flags;
    unsigned int hwpwm;
    struct pwm_chip *chip;
    struct pwm_args args;
    struct pwm_state state;
    struct pwm_state last;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>name of the PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags associated with the PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwpwm</span></code></dt><dd><p>per-chip relative index of the PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt><dd><p>PWM chip providing this PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args</span></code></dt><dd><p>PWM arguments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>last applied state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code></dt><dd><p>last implemented state (for PWM_DEBUG)</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_get_state">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_get_state</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pwm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>retrieve the current PWM state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>state to fill with the current PWM state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned PWM state represents the state that was applied by a previous call to
<a class="reference internal" href="#c.pwm_apply_might_sleep" title="pwm_apply_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_might_sleep()</span></code></a>. Drivers may have to slightly tweak that state before programming it to
hardware. If <a class="reference internal" href="#c.pwm_apply_might_sleep" title="pwm_apply_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_might_sleep()</span></code></a> was never called, this returns either the current hardware
state (if supported) or the default settings.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_init_state">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_init_state</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pwm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_init_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>prepare a new state to be applied with <a class="reference internal" href="#c.pwm_apply_might_sleep" title="pwm_apply_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_might_sleep()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>state to fill with the prepared PWM state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions prepares a state that can later be tweaked and applied
to the PWM device with <a class="reference internal" href="#c.pwm_apply_might_sleep" title="pwm_apply_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_might_sleep()</span></code></a>. This is a convenient function
that first retrieves the current PWM state and the replaces the period
and polarity fields with the reference values defined in pwm-&gt;args.
Once the function returns, you can adjust the -&gt;enabled and -&gt;duty_cycle
fields according to your needs before calling <a class="reference internal" href="#c.pwm_apply_might_sleep" title="pwm_apply_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_might_sleep()</span></code></a>.</p>
<p>-&gt;duty_cycle is initially set to zero to avoid cases where the current
-&gt;duty_cycle value exceed the pwm_args-&gt;period one, which would trigger
an error if the user calls <a class="reference internal" href="#c.pwm_apply_might_sleep" title="pwm_apply_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_might_sleep()</span></code></a> without adjusting -&gt;duty_cycle
first.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_get_relative_duty_cycle">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_get_relative_duty_cycle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pwm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">scale</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_relative_duty_cycle" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a relative duty cycle value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>PWM state to extract the duty cycle from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt><dd><p>target scale of the relative duty cycle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions converts the absolute duty cycle stored in <strong>state</strong> (expressed
in nanosecond) into a value relative to the period.</p>
<p>For example if you want to get the duty_cycle expressed in percent, call:</p>
<p>pwm_get_state(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);
duty = pwm_get_relative_duty_cycle(<code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>, 100);</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_set_relative_duty_cycle">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_set_relative_duty_cycle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pwm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">duty_cycle</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">scale</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_set_relative_duty_cycle" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set a relative duty cycle value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>PWM state to fill</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">duty_cycle</span></code></dt><dd><p>relative duty cycle value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt><dd><p>scale in which <strong>duty_cycle</strong> is expressed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions converts a relative into an absolute duty cycle (expressed
in nanoseconds), and puts the result in state-&gt;duty_cycle.</p>
<p>For example if you want to configure a 50% duty cycle, call:</p>
<p>pwm_init_state(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);
pwm_set_relative_duty_cycle(<code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>, 50, 100);
pwm_apply_might_sleep(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);</p>
<p>This functions returns -EINVAL if <strong>duty_cycle</strong> and/or <strong>scale</strong> are
inconsistent (<strong>scale</strong> == 0 or <strong>duty_cycle</strong> &gt; <strong>scale</strong>).</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.pwm_capture">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_capture</span></span></span><a class="headerlink" href="#c.pwm_capture" title="Link to this definition">¶</a><br /></dt>
<dd><p>PWM capture data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_capture {
    unsigned int period;
    unsigned int duty_cycle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">period</span></code></dt><dd><p>period of the PWM signal (in nanoseconds)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duty_cycle</span></code></dt><dd><p>duty cycle of the PWM signal (in nanoseconds)</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.pwm_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_ops</span></span></span><a class="headerlink" href="#c.pwm_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>PWM controller operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_ops {
    int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
    void (*free)(struct pwm_chip *chip, struct pwm_device *pwm);
    int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_capture *result, unsigned long timeout);
    size_t sizeof_wfhw;
    int (*round_waveform_tohw)(struct pwm_chip *chip, struct pwm_device *pwm, const struct pwm_waveform *wf, void *wfhw);
    int (*round_waveform_fromhw)(struct pwm_chip *chip, struct pwm_device *pwm, const void *wfhw, struct pwm_waveform *wf);
    int (*read_waveform)(struct pwm_chip *chip, struct pwm_device *pwm, void *wfhw);
    int (*write_waveform)(struct pwm_chip *chip, struct pwm_device *pwm, const void *wfhw);
    int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm, const struct pwm_state *state);
    int (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>optional hook for requesting a PWM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt><dd><p>optional hook for freeing a PWM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capture</span></code></dt><dd><p>capture and report PWM signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sizeof_wfhw</span></code></dt><dd><p>size (in bytes) of driver specific waveform presentation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">round_waveform_tohw</span></code></dt><dd><p>convert a <a class="reference internal" href="#c.pwm_waveform" title="pwm_waveform"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_waveform</span></code></a> to driver specific presentation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">round_waveform_fromhw</span></code></dt><dd><p>convert a driver specific waveform presentation to <a class="reference internal" href="#c.pwm_waveform" title="pwm_waveform"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_waveform</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_waveform</span></code></dt><dd><p>read driver specific waveform presentation from hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_waveform</span></code></dt><dd><p>write driver specific waveform presentation to hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply</span></code></dt><dd><p>atomically apply a new PWM config</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_state</span></code></dt><dd><p>get the current PWM state.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.pwm_chip">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_chip</span></span></span><a class="headerlink" href="#c.pwm_chip" title="Link to this definition">¶</a><br /></dt>
<dd><p>abstract a PWM controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_chip {
    struct device dev;
    const struct pwm_ops *ops;
    struct module *owner;
    unsigned int id;
    unsigned int npwm;
    struct pwm_device * (*of_xlate)(struct pwm_chip *chip, const struct of_phandle_args *args);
    bool atomic;
    bool uses_pwmchip_alloc;
    bool operational;
    union {
        struct mutex nonatomic_lock;
        spinlock_t atomic_lock;
    };
    struct pwm_device pwms[] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device providing the PWMs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>callbacks for this PWM controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>module providing this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique number of this PWM chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">npwm</span></code></dt><dd><p>number of PWMs controlled by this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_xlate</span></code></dt><dd><p>request a PWM device given a device tree PWM specifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic</span></code></dt><dd><p>can the driver’s -&gt;apply() be called in atomic context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uses_pwmchip_alloc</span></code></dt><dd><p>signals if pwmchip_allow was used to allocate this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">operational</span></code></dt><dd><p>signals if the chip can be used (or is already deregistered)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nonatomic_lock</span></code></dt><dd><p>mutex for nonatomic chips</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_lock</span></code></dt><dd><p>mutex for atomic chips</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pwms</span></code></dt><dd><p>array of PWM devices allocated by the framework</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwmchip_supports_waveform">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwmchip_supports_waveform</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_chip" title="pwm_chip"><span class="n"><span class="pre">pwm_chip</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chip</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwmchip_supports_waveform" title="Link to this definition">¶</a><br /></dt>
<dd><p>checks if the given chip supports waveform callbacks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The pwm_chip to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true iff the pwm chip support the waveform functions like
<a class="reference internal" href="#c.pwm_set_waveform_might_sleep" title="pwm_set_waveform_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_set_waveform_might_sleep()</span></code></a> and <a class="reference internal" href="#c.pwm_round_waveform_might_sleep" title="pwm_round_waveform_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_round_waveform_might_sleep()</span></code></a></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_config">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_config</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">duty_ns</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">period_ns</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_config" title="Link to this definition">¶</a><br /></dt>
<dd><p>change a PWM device configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duty_ns</span></code></dt><dd><p>“on” time (in nanoseconds)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">period_ns</span></code></dt><dd><p>duration (in nanoseconds) of one cycle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_enable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_enable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_enable" title="Link to this definition">¶</a><br /></dt>
<dd><p>start a PWM output toggling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_disable">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_disable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_disable" title="Link to this definition">¶</a><br /></dt>
<dd><p>stop a PWM output toggling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_might_sleep">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_might_sleep</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_might_sleep" title="Link to this definition">¶</a><br /></dt>
<dd><p>is <a class="reference internal" href="#c.pwm_apply_atomic" title="pwm_apply_atomic"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_atomic()</span></code></a> supported?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>false if <a class="reference internal" href="#c.pwm_apply_atomic" title="pwm_apply_atomic"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_atomic()</span></code></a> can be called from atomic context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_round_waveform_might_sleep">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_round_waveform_might_sleep</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_waveform" title="pwm_waveform"><span class="n"><span class="pre">pwm_waveform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_round_waveform_might_sleep" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query hardware capabilities Cannot be used in atomic context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_waveform</span> <span class="pre">*wf</span></code></dt><dd><p>waveform to round and output parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Typically a given waveform cannot be implemented exactly by hardware, e.g.
because hardware only supports coarse period resolution or no duty_offset.
This function returns the actually implemented waveform if you pass wf to
pwm_set_waveform_might_sleep now.</p>
<p>Note however that the world doesn’t stop turning when you call it, so when
doing</p>
<blockquote>
<div><p>pwm_round_waveform_might_sleep(mypwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">wf</span></code>);
pwm_set_waveform_might_sleep(mypwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">wf</span></code>, true);</p>
</div></blockquote>
<p>the latter might fail, e.g. because an input clock changed its rate between
these two calls and the waveform determined by
<a class="reference internal" href="#c.pwm_round_waveform_might_sleep" title="pwm_round_waveform_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_round_waveform_might_sleep()</span></code></a> cannot be implemented any more.</p>
<p>Returns 0 on success, 1 if there is no valid hardware configuration matching
the input waveform under the PWM rounding rules or a negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_get_waveform_might_sleep">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_get_waveform_might_sleep</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_waveform" title="pwm_waveform"><span class="n"><span class="pre">pwm_waveform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_waveform_might_sleep" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query hardware about current configuration Cannot be used in atomic context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_waveform</span> <span class="pre">*wf</span></code></dt><dd><p>output parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stores the current configuration of the PWM in <strong>wf</strong>. Note this is the
equivalent of <a class="reference internal" href="#c.pwm_get_state_hw" title="pwm_get_state_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get_state_hw()</span></code></a> (and not <a class="reference internal" href="#c.pwm_get_state" title="pwm_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get_state()</span></code></a>) for pwm_waveform.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_set_waveform_might_sleep">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_set_waveform_might_sleep</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_waveform" title="pwm_waveform"><span class="n"><span class="pre">pwm_waveform</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wf</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_set_waveform_might_sleep" title="Link to this definition">¶</a><br /></dt>
<dd><p>Apply a new waveform Cannot be used in atomic context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_waveform</span> <span class="pre">*wf</span></code></dt><dd><p>The waveform to apply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">exact</span></code></dt><dd><p>If true no rounding is allowed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Typically a requested waveform cannot be implemented exactly, e.g. because
you requested .period_length_ns = 100 ns, but the hardware can only set
periods that are a multiple of 8.5 ns. With that hardware passing exact =
true results in <a class="reference internal" href="#c.pwm_set_waveform_might_sleep" title="pwm_set_waveform_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_set_waveform_might_sleep()</span></code></a> failing and returning 1. If
exact = false you get a period of 93.5 ns (i.e. the biggest period not bigger
than the requested value).
Note that even with exact = true, some rounding by less than 1 is
possible/needed. In the above example requesting .period_length_ns = 94 and
exact = true, you get the hardware configured with period = 93.5 ns.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_apply_might_sleep">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_apply_might_sleep</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pwm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_apply_might_sleep" title="Link to this definition">¶</a><br /></dt>
<dd><p>atomically apply a new state to a PWM device Cannot be used in atomic context.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>new state to apply</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_apply_atomic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_apply_atomic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pwm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_apply_atomic" title="Link to this definition">¶</a><br /></dt>
<dd><p>apply a new state to a PWM device from atomic context Not all PWM devices support this function, check with <a class="reference internal" href="#c.pwm_might_sleep" title="pwm_might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_might_sleep()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>new state to apply</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_get_state_hw">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_get_state_hw</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pwm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_state_hw" title="Link to this definition">¶</a><br /></dt>
<dd><p>get the current PWM state from hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>state to fill with the current PWM state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.pwm_get_state" title="pwm_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get_state()</span></code></a> but reads the current PWM state from hardware
instead of the requested state.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<p><strong>Context</strong></p>
<p>May sleep.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_adjust_config">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_adjust_config</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_adjust_config" title="Link to this definition">¶</a><br /></dt>
<dd><p>adjust the current PWM config to the PWM arguments</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will adjust the PWM config to the PWM arguments provided
by the DT or PWM lookup table. This is particularly useful to adapt
the bootloader config to the Linux one.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pwm_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">con_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>look up and request a PWM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for PWM consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>consumer name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup is first attempted using DT. If the device was not instantiated from
a device tree, a PWM chip and a relative index is looked up via a table
supplied by board setup code (see pwm_add_table()).</p>
<p>Once a PWM chip has been found the specified PWM device will be requested
and is ready to be used.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>-encoded
error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwm_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwm_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pwm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a PWM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_pwm_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_pwm_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">con_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pwm_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>resource managed <a class="reference internal" href="#c.pwm_get" title="pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for PWM consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>consumer name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function performs like <a class="reference internal" href="#c.pwm_get" title="pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get()</span></code></a> but the acquired PWM device will
automatically be released on driver detach.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>-encoded
error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_fwnode_pwm_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_device" title="pwm_device"><span class="n"><span class="pre">pwm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_fwnode_pwm_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fwnode_handle</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwnode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">con_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_fwnode_pwm_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>request a resource managed PWM from firmware node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for PWM consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>firmware node to get the PWM from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>consumer name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the PWM device parsed from the firmware node. See of_pwm_get() and
acpi_pwm_get() for a detailed description.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>-encoded
error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__pwmchip_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__pwmchip_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_chip" title="pwm_chip"><span class="n"><span class="pre">pwm_chip</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chip</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__pwmchip_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a new PWM chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*chip</span></code></dt><dd><p>the PWM chip to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>reference to the module providing the chip.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a new PWM chip. <strong>owner</strong> is supposed to be THIS_MODULE, use the
pwmchip_add wrapper to do this right.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pwmchip_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pwmchip_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pwm_chip" title="pwm_chip"><span class="n"><span class="pre">pwm_chip</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chip</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pwmchip_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a PWM chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*chip</span></code></dt><dd><p>the PWM chip to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a PWM chip.</p>
</div>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/miscellaneous.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>