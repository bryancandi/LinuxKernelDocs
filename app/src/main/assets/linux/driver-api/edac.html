<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Error Detection And Correction (EDAC) Devices &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Extcon Device Subsystem" href="extcon.html" />
    <link rel="prev" title="The Linux kernel dpll subsystem" href="dpll.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.14.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="extcon.html">Extcon Device Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/edac.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="error-detection-and-correction-edac-devices">
<h1>Error Detection And Correction (EDAC) Devices<a class="headerlink" href="#error-detection-and-correction-edac-devices" title="Link to this heading">¶</a></h1>
<section id="main-concepts-used-at-the-edac-subsystem">
<h2>Main Concepts used at the EDAC subsystem<a class="headerlink" href="#main-concepts-used-at-the-edac-subsystem" title="Link to this heading">¶</a></h2>
<p>There are several things to be aware of that aren’t at all obvious, like
<em>sockets, *socket sets</em>, <em>banks</em>, <em>rows</em>, <em>chip-select rows</em>, <em>channels</em>,
etc...</p>
<p>These are some of the many terms that are thrown about that don’t always
mean what people think they mean (Inconceivable!).  In the interest of
creating a common ground for discussion, terms and their definitions
will be established.</p>
<ul class="simple">
<li><p>Memory devices</p></li>
</ul>
<p>The individual DRAM chips on a memory stick.  These devices commonly
output 4 and 8 bits each (x4, x8). Grouping several of these in parallel
provides the number of bits that the memory controller expects:
typically 72 bits, in order to provide 64 bits + 8 bits of ECC data.</p>
<ul class="simple">
<li><p>Memory Stick</p></li>
</ul>
<p>A printed circuit board that aggregates multiple memory devices in
parallel.  In general, this is the Field Replaceable Unit (FRU) which
gets replaced, in the case of excessive errors. Most often it is also
called DIMM (Dual Inline Memory Module).</p>
<ul class="simple">
<li><p>Memory Socket</p></li>
</ul>
<p>A physical connector on the motherboard that accepts a single memory
stick. Also called as “slot” on several datasheets.</p>
<ul class="simple">
<li><p>Channel</p></li>
</ul>
<p>A memory controller channel, responsible to communicate with a group of
DIMMs. Each channel has its own independent control (command) and data
bus, and can be used independently or grouped with other channels.</p>
<ul class="simple">
<li><p>Branch</p></li>
</ul>
<p>It is typically the highest hierarchy on a Fully-Buffered DIMM memory
controller. Typically, it contains two channels. Two channels at the
same branch can be used in single mode or in lockstep mode. When
lockstep is enabled, the cacheline is doubled, but it generally brings
some performance penalty. Also, it is generally not possible to point to
just one memory stick when an error occurs, as the error correction code
is calculated using two DIMMs instead of one. Due to that, it is capable
of correcting more errors than on single mode.</p>
<ul class="simple">
<li><p>Single-channel</p></li>
</ul>
<p>The data accessed by the memory controller is contained into one dimm
only. E. g. if the data is 64 bits-wide, the data flows to the CPU using
one 64 bits parallel access. Typically used with SDR, DDR, DDR2 and DDR3
memories. FB-DIMM and RAMBUS use a different concept for channel, so
this concept doesn’t apply there.</p>
<ul class="simple">
<li><p>Double-channel</p></li>
</ul>
<p>The data size accessed by the memory controller is interlaced into two
dimms, accessed at the same time. E. g. if the DIMM is 64 bits-wide (72
bits with ECC), the data flows to the CPU using a 128 bits parallel
access.</p>
<ul class="simple">
<li><p>Chip-select row</p></li>
</ul>
<p>This is the name of the DRAM signal used to select the DRAM ranks to be
accessed. Common chip-select rows for single channel are 64 bits, for
dual channel 128 bits. It may not be visible by the memory controller,
as some DIMM types have a memory buffer that can hide direct access to
it from the Memory Controller.</p>
<ul class="simple">
<li><p>Single-Ranked stick</p></li>
</ul>
<p>A Single-ranked stick has 1 chip-select row of memory. Motherboards
commonly drive two chip-select pins to a memory stick. A single-ranked
stick, will occupy only one of those rows. The other will be unused.</p>
<ul class="simple" id="doubleranked">
<li><p>Double-Ranked stick</p></li>
</ul>
<p>A double-ranked stick has two chip-select rows which access different
sets of memory devices.  The two rows cannot be accessed concurrently.</p>
<ul class="simple">
<li><p>Double-sided stick</p></li>
</ul>
<p><strong>DEPRECATED TERM</strong>, see <a class="reference internal" href="#doubleranked"><span class="std std-ref">Double-Ranked stick</span></a>.</p>
<p>A double-sided stick has two chip-select rows which access different sets
of memory devices. The two rows cannot be accessed concurrently.
“Double-sided” is irrespective of the memory devices being mounted on
both sides of the memory stick.</p>
<ul class="simple">
<li><p>Socket set</p></li>
</ul>
<p>All of the memory sticks that are required for a single memory access or
all of the memory sticks spanned by a chip-select row.  A single socket
set has two chip-select rows and if double-sided sticks are used these
will occupy those chip-select rows.</p>
<ul class="simple">
<li><p>Bank</p></li>
</ul>
<p>This term is avoided because it is unclear when needing to distinguish
between chip-select rows and socket sets.</p>
<ul class="simple">
<li><p>High Bandwidth Memory (HBM)</p></li>
</ul>
<p>HBM is a new memory type with low power consumption and ultra-wide
communication lanes. It uses vertically stacked memory chips (DRAM dies)
interconnected by microscopic wires called “through-silicon vias,” or
TSVs.</p>
<p>Several stacks of HBM chips connect to the CPU or GPU through an ultra-fast
interconnect called the “interposer”. Therefore, HBM’s characteristics
are nearly indistinguishable from on-chip integrated RAM.</p>
</section>
<section id="memory-controllers">
<h2>Memory Controllers<a class="headerlink" href="#memory-controllers" title="Link to this heading">¶</a></h2>
<p>Most of the EDAC core is focused on doing Memory Controller error detection.
The <a class="reference internal" href="#c.edac_mc_alloc" title="edac_mc_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_alloc()</span></code></a>. It uses internally the struct <code class="docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>
to describe the memory controllers, with is an opaque struct for the EDAC
drivers. Only the EDAC core is allowed to touch it.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.dev_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dev_type</span></span></span><a class="headerlink" href="#c.dev_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>describe the type of memory DRAM chips used at the stick</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEV_UNKNOWN</span></code></dt><dd><p>Can’t be determined, or MC doesn’t support detect it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X1</span></code></dt><dd><p>1 bit for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X2</span></code></dt><dd><p>2 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X4</span></code></dt><dd><p>4 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X8</span></code></dt><dd><p>8 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X16</span></code></dt><dd><p>16 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X32</span></code></dt><dd><p>32 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X64</span></code></dt><dd><p>64 bits for data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Typical values are x4 and x8.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.hw_event_mc_err_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hw_event_mc_err_type</span></span></span><a class="headerlink" href="#c.hw_event_mc_err_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>type of the detected error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_CORRECTED</span></code></dt><dd><p>Corrected Error - Indicates that an ECC
corrected error was detected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_UNCORRECTED</span></code></dt><dd><p>Uncorrected Error - Indicates an error that
can’t be corrected by ECC, but it is not
fatal (maybe it is on an unused memory area,
or the memory controller could recover from
it for example, by re-trying the operation).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_DEFERRED</span></code></dt><dd><p>Deferred Error - Indicates an uncorrectable
error whose handling is not urgent. This could
be due to hardware data poisoning where the
system can continue operation until the poisoned
data is consumed. Preemptive measures may also
be taken, e.g. offlining pages, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_FATAL</span></code></dt><dd><p>Fatal Error - Uncorrected error that could not
be recovered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_INFO</span></code></dt><dd><p>Informational - The CPER spec defines a forth
type of error: informational logs.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.mem_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mem_type</span></span></span><a class="headerlink" href="#c.mem_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>memory types. For a more detailed reference, please see <a class="reference external" href="http://en.wikipedia.org/wiki/DRAM">http://en.wikipedia.org/wiki/DRAM</a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MEM_EMPTY</span></code></dt><dd><p>Empty csrow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RESERVED</span></code></dt><dd><p>Reserved csrow type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_UNKNOWN</span></code></dt><dd><p>Unknown csrow type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_FPM</span></code></dt><dd><p>FPM - Fast Page Mode, used on systems up to 1995.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_EDO</span></code></dt><dd><p>EDO - Extended data out, used on systems up to 1998.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_BEDO</span></code></dt><dd><p>BEDO - Burst Extended data out, an EDO variant.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_SDR</span></code></dt><dd><p>SDR - Single data rate SDRAM
<a class="reference external" href="http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory</a>
They use 3 pins for chip select: Pins 0 and 2 are
for rank 0; pins 1 and 3 are for rank 1, if the memory
is dual-rank.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDR</span></code></dt><dd><p>Registered SDR SDRAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR</span></code></dt><dd><p>Double data rate SDRAM
<a class="reference external" href="http://en.wikipedia.org/wiki/DDR_SDRAM">http://en.wikipedia.org/wiki/DDR_SDRAM</a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR</span></code></dt><dd><p>Registered Double data rate SDRAM
This is a variant of the DDR memories.
A registered memory has a buffer inside it, hiding
part of the memory details to the memory controller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RMBS</span></code></dt><dd><p>Rambus DRAM, used on a few Pentium III/IV controllers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR2</span></code></dt><dd><p>DDR2 RAM, as described at JEDEC JESD79-2F.
Those memories are labeled as “PC2-” instead of “PC” to
differentiate from DDR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_FB_DDR2</span></code></dt><dd><p>Fully-Buffered DDR2, as described at JEDEC Std No. 205
and JESD206.
Those memories are accessed per DIMM slot, and not by
a chip select signal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR2</span></code></dt><dd><p>Registered DDR2 RAM
This is a variant of the DDR2 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_XDR</span></code></dt><dd><p>Rambus XDR
It is an evolution of the original RAMBUS memories,
created to compete with DDR2. Weren’t used on any
x86 arch, but cell_edac PPC memory controller uses it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR3</span></code></dt><dd><p>DDR3 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR3</span></code></dt><dd><p>Registered DDR3 RAM
This is a variant of the DDR3 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LRDDR3</span></code></dt><dd><p>Load-Reduced DDR3 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LPDDR3</span></code></dt><dd><p>Low-Power DDR3 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR4</span></code></dt><dd><p>Unbuffered DDR4 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR4</span></code></dt><dd><p>Registered DDR4 RAM
This is a variant of the DDR4 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LRDDR4</span></code></dt><dd><p>Load-Reduced DDR4 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LPDDR4</span></code></dt><dd><p>Low-Power DDR4 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR5</span></code></dt><dd><p>Unbuffered DDR5 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR5</span></code></dt><dd><p>Registered DDR5 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LRDDR5</span></code></dt><dd><p>Load-Reduced DDR5 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_NVDIMM</span></code></dt><dd><p>Non-volatile RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_WIO2</span></code></dt><dd><p>Wide I/O 2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_HBM2</span></code></dt><dd><p>High bandwidth Memory Gen 2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_HBM3</span></code></dt><dd><p>High bandwidth Memory Gen 3.</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.edac_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_type</span></span></span><a class="headerlink" href="#c.edac_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Error Detection and Correction capabilities and mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_UNKNOWN</span></code></dt><dd><p>Unknown if ECC is available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_NONE</span></code></dt><dd><p>Doesn’t support ECC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_RESERVED</span></code></dt><dd><p>Reserved ECC type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_PARITY</span></code></dt><dd><p>Detects parity errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_EC</span></code></dt><dd><p>Error Checking - no correction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_SECDED</span></code></dt><dd><p>Single bit error correction, Double detection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S2ECD2ED</span></code></dt><dd><p>Chipkill x2 devices - do these exist?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S4ECD4ED</span></code></dt><dd><p>Chipkill x4 devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S8ECD8ED</span></code></dt><dd><p>Chipkill x8 devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S16ECD16ED</span></code></dt><dd><p>Chipkill x16 devices</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.scrub_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scrub_type</span></span></span><a class="headerlink" href="#c.scrub_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>scrubbing capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_UNKNOWN</span></code></dt><dd><p>Unknown if scrubber is available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_NONE</span></code></dt><dd><p>No scrubber</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_PROG</span></code></dt><dd><p>SW progressive (sequential) scrubbing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_SRC</span></code></dt><dd><p>Software scrub only errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_PROG_SRC</span></code></dt><dd><p>Progressive software scrub from an error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_TUNABLE</span></code></dt><dd><p>Software scrub frequency is tunable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_PROG</span></code></dt><dd><p>HW progressive (sequential) scrubbing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_SRC</span></code></dt><dd><p>Hardware scrub only errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_PROG_SRC</span></code></dt><dd><p>Progressive hardware scrub from an error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_TUNABLE</span></code></dt><dd><p>Hardware scrub frequency is tunable</p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.edac_mc_layer_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_mc_layer_type</span></span></span><a class="headerlink" href="#c.edac_mc_layer_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>memory controller hierarchy layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_BRANCH</span></code></dt><dd><p>memory layer is named “branch”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_CHANNEL</span></code></dt><dd><p>memory layer is named “channel”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_SLOT</span></code></dt><dd><p>memory layer is named “slot”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_CHIP_SELECT</span></code></dt><dd><p>memory layer is named “chip select”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_ALL_MEM</span></code></dt><dd><p>memory layout is unknown. All memory is mapped
as a single memory area. This is used when
retrieving errors from a firmware driven driver.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This enum is used by the drivers to tell edac_mc_sysfs what name should
be used when describing a memory stick location.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.edac_mc_layer">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_mc_layer</span></span></span><a class="headerlink" href="#c.edac_mc_layer" title="Link to this definition">¶</a><br /></dt>
<dd><p>describes the memory controller hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct edac_mc_layer {
    enum edac_mc_layer_type type;
    unsigned size;
    bool is_virt_csrow;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>layer type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>number of components per layer. For example,
if the channel layer has two channels, size = 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_virt_csrow</span></code></dt><dd><p>This layer is part of the “csrow” when old API
compatibility mode is enabled. Otherwise, it is
a channel</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.rank_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rank_info</span></span></span><a class="headerlink" href="#c.rank_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>contains the information for one DIMM rank</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rank_info {
    int chan_idx;
    struct csrow_info *csrow;
    struct dimm_info *dimm;
    u32 ce_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chan_idx</span></code></dt><dd><p>channel number where the rank is (typically, 0 or 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csrow</span></code></dt><dd><p>A pointer to the chip select row structure (the parent
structure). The location of the rank is given by
the (csrow-&gt;csrow_idx, chan_idx) vector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dimm</span></code></dt><dd><p>A pointer to the DIMM structure, where the DIMM label
information is stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ce_count</span></code></dt><dd><p>number of correctable errors for this rank</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>FIXME: Currently, the EDAC core model will assume one DIMM per rank.</dt><dd><p>This is a bad assumption, but it makes this patch easier. Later
patches in this series will fix this issue.</p>
</dd>
</dl>
<dl class="c struct">
<dt class="sig sig-object c" id="c.edac_raw_error_desc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_raw_error_desc</span></span></span><a class="headerlink" href="#c.edac_raw_error_desc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Raw error report structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct edac_raw_error_desc {
    char location[LOCATION_SIZE];
    char label[(EDAC_MC_LABEL_LEN + 1 + sizeof(OTHER_LABEL)) * EDAC_MAX_LABELS];
    long grain;
    u16 error_count;
    enum hw_event_mc_err_type type;
    int top_layer;
    int mid_layer;
    int low_layer;
    unsigned long page_frame_number;
    unsigned long offset_in_page;
    unsigned long syndrome;
    const char *msg;
    const char *other_detail;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">location</span></code></dt><dd><p>location of the error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>label of the affected DIMM(s)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grain</span></code></dt><dd><p>minimum granularity for an error report, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error_count</span></code></dt><dd><p>number of errors of the same type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>severity of the error (CE/UE/Fatal)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">top_layer</span></code></dt><dd><p>top layer of the error (layer[0])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mid_layer</span></code></dt><dd><p>middle layer of the error (layer[1])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">low_layer</span></code></dt><dd><p>low layer of the error (layer[2])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_frame_number</span></code></dt><dd><p>page where the error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset_in_page</span></code></dt><dd><p>page offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syndrome</span></code></dt><dd><p>syndrome of the error (or 0 if unknown or if
the syndrome is not applicable)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg</span></code></dt><dd><p>error message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">other_detail</span></code></dt><dd><p>other driver-specific detail about the error</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_get_dimm">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dimm_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_get_dimm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mci</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">layer0</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">layer1</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">layer2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_get_dimm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get DIMM info from a memory controller given by [layer0,layer1,layer2] position</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*mci</span></code></dt><dd><p>MC descriptor struct mem_ctl_info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer0</span></code></dt><dd><p>layer0 position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer1</span></code></dt><dd><p>layer1 position. Unused if n_layers &lt; 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer2</span></code></dt><dd><p>layer2 position. Unused if n_layers &lt; 3</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For 1 layer, this function returns “dimms[layer0]”;</p>
<p>For 2 layers, this function is similar to allocating a two-dimensional
array and returning “dimms[layer0][layer1]”;</p>
<p>For 3 layers, this function is similar to allocating a tri-dimensional
array and returning “dimms[layer0][layer1][layer2]”;</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_mc_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_mc_alloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mc_num</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n_layers</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.edac_mc_layer" title="edac_mc_layer"><span class="n"><span class="pre">edac_mc_layer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">layers</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sz_pvt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate and partially fill a struct <code class="xref c c-type docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mc_num</span></code></dt><dd><p>Memory controller number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_layers</span></code></dt><dd><p>Number of MC hierarchy layers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_mc_layer</span> <span class="pre">*layers</span></code></dt><dd><p>Describes each layer as seen by the Memory Controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz_pvt</span></code></dt><dd><p>size of private storage needed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Everything is kmalloc’ed as one big chunk - more efficient.
Only can be used if all structures have the same lifetime - otherwise
you have to allocate and initialize your own structures.</p>
<p>Use <a class="reference internal" href="#c.edac_mc_free" title="edac_mc_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_free()</span></code></a> to free mc structures allocated by this function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>drivers handle multi-rank memories in different ways: in some
drivers, one multi-rank memory stick is mapped as one entry, while, in
others, a single multi-rank memory stick would be mapped into several
entries. Currently, this function will allocate multiple struct dimm_info
on such scenarios, as grouping the multiple ranks require drivers change.</p>
</div>
<p><strong>Return</strong></p>
<blockquote>
<div><p>On success, return a pointer to struct mem_ctl_info pointer;
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_get_owner">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_get_owner</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_get_owner" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the owner’s mod_name of EDAC MC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to mod_name string when EDAC MC is owned. NULL otherwise.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_mc_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_mc_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mci</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>Frees a previously allocated <strong>mci</strong> structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*mci</span></code></dt><dd><p>pointer to a struct mem_ctl_info structure</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_has_mcs">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_has_mcs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_has_mcs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check if any MCs have been allocated.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if MC instances have been registered successfully.
False otherwise.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_mc_find">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_mc_find</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>Search for a mem_ctl_info structure whose index is <strong>idx</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index to be seek</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If found, return a pointer to the structure.
Else return NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_mci_by_dev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">find_mci_by_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_mci_by_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>Scan list of controllers looking for the one that manages the <strong>dev</strong> device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> related with the MCI</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>on success, returns a pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>;
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_mc_del_mc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_mc_del_mc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_del_mc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove sysfs entries for mci structure associated with <strong>dev</strong> and remove mci structure from global list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> representing mci structure to remove.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>pointer to removed mci structure, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_mc_find_csrow_by_page">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_mc_find_csrow_by_page</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mci</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_find_csrow_by_page" title="Link to this definition">¶</a><br /></dt>
<dd><p>Ancillary routine to identify what csrow contains a memory page.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*mci</span></code></dt><dd><p>pointer to a struct mem_ctl_info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page</span></code></dt><dd><p>memory page to find</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>on success, returns the csrow. -1 if not found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_raw_mc_handle_error">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_raw_mc_handle_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.edac_raw_error_desc" title="edac_raw_error_desc"><span class="n"><span class="pre">edac_raw_error_desc</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_raw_mc_handle_error" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reports a memory event to userspace without doing anything to discover the error location.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_raw_error_desc</span> <span class="pre">*e</span></code></dt><dd><p>error description</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This raw function is used internally by <a class="reference internal" href="#c.edac_mc_handle_error" title="edac_mc_handle_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_handle_error()</span></code></a>. It should
only be called directly when the hardware error come directly from BIOS,
like in the case of APEI GHES driver.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_mc_handle_error">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_mc_handle_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.hw_event_mc_err_type" title="hw_event_mc_err_type"><span class="n"><span class="pre">hw_event_mc_err_type</span></span></a><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mem_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mci</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">error_count</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">page_frame_number</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">offset_in_page</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">syndrome</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">top_layer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mid_layer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">low_layer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">other_detail</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_handle_error" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reports a memory event to userspace.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hw_event_mc_err_type</span> <span class="pre">type</span></code></dt><dd><p>severity of the error (CE/UE/Fatal)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*mci</span></code></dt><dd><p>a struct mem_ctl_info pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">error_count</span></code></dt><dd><p>Number of errors of the same type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_frame_number</span></code></dt><dd><p>mem page where the error occurred</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">offset_in_page</span></code></dt><dd><p>offset of the error inside the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">syndrome</span></code></dt><dd><p>ECC syndrome</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">top_layer</span></code></dt><dd><p>Memory layer[0] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">mid_layer</span></code></dt><dd><p>Memory layer[1] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">low_layer</span></code></dt><dd><p>Memory layer[2] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>Message meaningful to the end users that
explains the event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*other_detail</span></code></dt><dd><p>Technical details about the event that
may help hardware manufacturers and
EDAC developers to analyse the event</p>
</dd>
</dl>
</div>
</section>
<section id="pci-controllers">
<h2>PCI Controllers<a class="headerlink" href="#pci-controllers" title="Link to this heading">¶</a></h2>
<p>The EDAC subsystem provides a mechanism to handle PCI controllers by calling
the <a class="reference internal" href="#c.edac_pci_alloc_ctl_info" title="edac_pci_alloc_ctl_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_pci_alloc_ctl_info()</span></code></a>. It will use the struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> to describe the PCI controllers.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_alloc_ctl_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_pci_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_alloc_ctl_info</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sz_pvt</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edac_pci_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_alloc_ctl_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>The alloc() function for the ‘edac_pci’ control info structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz_pvt</span></code></dt><dd><p>size of the private info at struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*edac_pci_name</span></code></dt><dd><p>name of the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The chip driver will allocate one of these for each
edac_pci it is going to control/register with the EDAC CORE.</p>
<p><strong>Return</strong></p>
<p>a pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> on success; <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_free_ctl_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_free_ctl_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_pci_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pci</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_free_ctl_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Last action on the pci control structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the remove sysfs information, which will unregister
this control struct’s kobj. When that kobj’s ref count
goes to zero, its release function will be call and then
<a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> the memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_alloc_index">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_alloc_index</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_alloc_index" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate a unique PCI index number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>allocated index number</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_add_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_add_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_pci_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pci</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">edac_idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_add_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Insert the ‘edac_dev’ structure into the edac_pci global list and create sysfs entries associated with edac_pci structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to the edac_device structure to be added to the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">edac_idx</span></code></dt><dd><p>A unique numeric identifier to be assigned to the
‘edac_pci’ structure.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on Success, or an error code on failure</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_del_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_pci_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_del_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_del_device" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></p>
<blockquote>
<div><p>Pointer to ‘<a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>’ representing edac_pci structure
to remove</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove sysfs entries for specified edac_pci structure and
then remove edac_pci structure from global list</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to removed edac_pci structure,
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_create_generic_ctl">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_pci_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_create_generic_ctl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mod_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_create_generic_ctl" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a>;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>name of the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A generic constructor for a PCI parity polling device
Some systems have more than one domain of PCI busses.
For systems with one domain, then this API will
provide for a generic poller.</p>
</div></blockquote>
<p>This routine calls the <a class="reference internal" href="#c.edac_pci_alloc_ctl_info" title="edac_pci_alloc_ctl_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_pci_alloc_ctl_info()</span></code></a> for
the generic device, with default values</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on</dt><dd><p>failure.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_release_generic_ctl">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_release_generic_ctl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_pci_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pci</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_release_generic_ctl" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The release function of a generic EDAC PCI polling device</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_create_sysfs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_create_sysfs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_pci_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pci</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_create_sysfs" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Create the controls/attributes for the specified EDAC PCI device</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_pci_remove_sysfs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_pci_remove_sysfs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_pci_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pci</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_remove_sysfs" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>remove the controls and attributes for this EDAC PCI device</p>
</div></blockquote>
</div>
</section>
<section id="edac-blocks">
<h2>EDAC Blocks<a class="headerlink" href="#edac-blocks" title="Link to this heading">¶</a></h2>
<p>The EDAC subsystem also provides a generic mechanism to report errors on
other parts of the hardware via <code class="xref c c-func docutils literal notranslate"><span class="pre">edac_device_alloc_ctl_info()</span></code> function.</p>
<p>The structures <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_dev_sysfs_block_attribute</span></code>,
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_block</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_instance</span></code> and
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code> provide a generic or abstract ‘edac_device’
representation at sysfs.</p>
<p>This set of structures and the code that implements the APIs for the same, provide for registering EDAC type devices which are NOT standard memory or
PCI, like:</p>
<ul class="simple">
<li><p>CPU caches (L1 and L2)</p></li>
<li><p>DMA engines</p></li>
<li><p>Core CPU switches</p></li>
<li><p>Fabric switch units</p></li>
<li><p>PCIe interface controllers</p></li>
<li><p>other EDAC/ECC type devices that can be monitored for
errors, etc.</p></li>
</ul>
<p>It allows for a 2 level set of hierarchy.</p>
<p>For example, a cache could be composed of L1, L2 and L3 levels of cache.
Each CPU core would have its own L1 cache, while sharing L2 and maybe L3
caches. On such case, those can be represented via the following sysfs
nodes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/edac/..

pci/            &lt;existing pci directory (if available)&gt;
mc/             &lt;existing memory device directory&gt;
cpu/cpu0/..     &lt;L1 and L2 block directory&gt;
        /L1-cache/ce_count
                 /ue_count
        /L2-cache/ce_count
                 /ue_count
cpu/cpu1/..     &lt;L1 and L2 block directory&gt;
        /L1-cache/ce_count
                 /ue_count
        /L2-cache/ce_count
                 /ue_count
...

the L1 and L2 directories would be &quot;edac_device_block&#39;s&quot;
</pre></div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_device_add_device">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_device_add_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_device_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edac_dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_add_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Insert the ‘edac_dev’ structure into the edac_device global list and create sysfs entries associated with edac_device structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to edac_device structure to be added to the list
‘edac_device’ structure.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on Success, or an error code on failure</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_device_del_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_device_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">edac_device_del_device</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_del_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove sysfs entries for specified edac_device structure and then remove edac_device structure from global list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></p>
<blockquote>
<div><p>Pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> representing the edac device
structure to remove.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to removed edac_device structure,
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_device_handle_ce_count">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_device_handle_ce_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_device_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edac_dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">inst_nr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">block_nr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ce_count" title="Link to this definition">¶</a><br /></dt>
<dd><p>Log correctable errors.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of errors to log.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_device_handle_ue_count">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_device_handle_ue_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_device_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edac_dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">inst_nr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">block_nr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ue_count" title="Link to this definition">¶</a><br /></dt>
<dd><p>Log uncorrectable errors.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of errors to log.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_device_handle_ce">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_device_handle_ce</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_device_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edac_dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">inst_nr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">block_nr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ce" title="Link to this definition">¶</a><br /></dt>
<dd><p>Log a single correctable error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_device_handle_ue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_device_handle_ue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">edac_device_ctl_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edac_dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">inst_nr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">block_nr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ue" title="Link to this definition">¶</a><br /></dt>
<dd><p>Log a single uncorrectable error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the UE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the UE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.edac_device_alloc_index">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">edac_device_alloc_index</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_alloc_index" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate a unique device index number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>allocated index number</p>
</div></blockquote>
</div>
</section>
<section id="heterogeneous-system-support">
<h2>Heterogeneous system support<a class="headerlink" href="#heterogeneous-system-support" title="Link to this heading">¶</a></h2>
<p>An AMD heterogeneous system is built by connecting the data fabrics of
both CPUs and GPUs via custom xGMI links. Thus, the data fabric on the
GPU nodes can be accessed the same way as the data fabric on CPU nodes.</p>
<p>The MI200 accelerators are data center GPUs. They have 2 data fabrics,
and each GPU data fabric contains four Unified Memory Controllers (UMC).
Each UMC contains eight channels. Each UMC channel controls one 128-bit
HBM2e (2GB) channel (equivalent to 8 X 2GB ranks).  This creates a total
of 4096-bits of DRAM data bus.</p>
<p>While the UMC is interfacing a 16GB (8high X 2GB DRAM) HBM stack, each UMC
channel is interfacing 2GB of DRAM (represented as rank).</p>
<p>Memory controllers on AMD GPU nodes can be represented in EDAC thusly:</p>
<blockquote>
<div><p>GPU DF / GPU Node -&gt; EDAC MC
GPU UMC           -&gt; EDAC CSROW
GPU UMC channel   -&gt; EDAC CHANNEL</p>
</div></blockquote>
<p>For example: a heterogeneous system with 1 AMD CPU is connected to
4 MI200 (Aldebaran) GPUs using xGMI.</p>
<p>Some more heterogeneous hardware details:</p>
<ul class="simple">
<li><p>The CPU UMC (Unified Memory Controller) is mostly the same as the GPU UMC.
They have chip selects (csrows) and channels. However, the layouts are different
for performance, physical layout, or other reasons.</p></li>
<li><p>CPU UMCs use 1 channel, In this case UMC = EDAC channel. This follows the
marketing speak. CPU has X memory channels, etc.</p></li>
<li><p>CPU UMCs use up to 4 chip selects, So UMC chip select = EDAC CSROW.</p></li>
<li><p>GPU UMCs use 1 chip select, So UMC = EDAC CSROW.</p></li>
<li><p>GPU UMCs use 8 channels, So UMC channel = EDAC channel.</p></li>
</ul>
<p>The EDAC subsystem provides a mechanism to handle AMD heterogeneous
systems by calling system specific ops for both CPUs and GPUs.</p>
<p>AMD GPU nodes are enumerated in sequential order based on the PCI
hierarchy, and the first GPU node is assumed to have a Node ID value
following those of the CPU nodes after latter are fully populated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls /sys/devices/system/edac/mc/
        mc0   - CPU MC node 0
        mc1  |
        mc2  |- GPU card[0] =&gt; node 0(mc1), node 1(mc2)
        mc3  |
        mc4  |- GPU card[1] =&gt; node 0(mc3), node 1(mc4)
        mc5  |
        mc6  |- GPU card[2] =&gt; node 0(mc5), node 1(mc6)
        mc7  |
        mc8  |- GPU card[3] =&gt; node 0(mc7), node 1(mc8)
</pre></div>
</div>
<p>For example, a heterogeneous system with one AMD CPU is connected to
four MI200 (Aldebaran) GPUs using xGMI. This topology can be represented
via the following sysfs entries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/edac/mc/..

CPU                     # CPU node
├── mc 0

GPU Nodes are enumerated sequentially after CPU nodes have been populated
GPU card 1              # Each MI200 GPU has 2 nodes/mcs
├── mc 1                # GPU node 0 == mc1, Each MC node has 4 UMCs/CSROWs
│   ├── csrow 0         # UMC 0
│   │   ├── channel 0   # Each UMC has 8 channels
│   │   ├── channel 1   # size of each channel is 2 GB, so each UMC has 16 GB
│   │   ├── channel 2
│   │   ├── channel 3
│   │   ├── channel 4
│   │   ├── channel 5
│   │   ├── channel 6
│   │   ├── channel 7
│   ├── csrow 1         # UMC 1
│   │   ├── channel 0
│   │   ├── ..
│   │   ├── channel 7
│   ├── ..              ..
│   ├── csrow 3         # UMC 3
│   │   ├── channel 0
│   │   ├── ..
│   │   ├── channel 7
│   ├── rank 0
│   ├── ..              ..
│   ├── rank 31         # total 32 ranks/dimms from 4 UMCs
├
├── mc 2                # GPU node 1 == mc2
│   ├── ..              # each GPU has total 64 GB

GPU card 2
├── mc 3
│   ├── ..
├── mc 4
│   ├── ..

GPU card 3
├── mc 5
│   ├── ..
├── mc 6
│   ├── ..

GPU card 4
├── mc 7
│   ├── ..
├── mc 8
│   ├── ..
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/edac.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>