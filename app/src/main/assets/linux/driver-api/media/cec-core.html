<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>6. CEC Kernel Support &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="7. Pixel data transmitter and receiver drivers" href="tx-rx.html" />
    <link rel="prev" title="5. Media Controller devices" href="mc-core.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.11.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/media/cec-core.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="cec-kernel-support">
<h1><span class="section-number">6. </span>CEC Kernel Support<a class="headerlink" href="#cec-kernel-support" title="Link to this heading">¶</a></h1>
<p>The CEC framework provides a unified kernel interface for use with HDMI CEC
hardware. It is designed to handle a multiple types of hardware (receivers,
transmitters, USB dongles). The framework also gives the option to decide
what to do in the kernel driver and what should be handled by userspace
applications. In addition it integrates the remote control passthrough
feature into the kernel’s remote control framework.</p>
<section id="the-cec-protocol">
<h2><span class="section-number">6.1. </span>The CEC Protocol<a class="headerlink" href="#the-cec-protocol" title="Link to this heading">¶</a></h2>
<p>The CEC protocol enables consumer electronic devices to communicate with each
other through the HDMI connection. The protocol uses logical addresses in the
communication. The logical address is strictly connected with the functionality
provided by the device. The TV acting as the communication hub is always
assigned address 0. The physical address is determined by the physical
connection between devices.</p>
<p>The CEC framework described here is up to date with the CEC 2.0 specification.
It is documented in the HDMI 1.4 specification with the new 2.0 bits documented
in the HDMI 2.0 specification. But for most of the features the freely available
HDMI 1.3a specification is sufficient:</p>
<p><a class="reference external" href="https://www.hdmi.org/spec/index">https://www.hdmi.org/spec/index</a></p>
</section>
<section id="cec-adapter-interface">
<h2><span class="section-number">6.2. </span>CEC Adapter Interface<a class="headerlink" href="#cec-adapter-interface" title="Link to this heading">¶</a></h2>
<p>The struct cec_adapter represents the CEC adapter hardware. It is created by
calling <a class="reference internal" href="#c.cec_allocate_adapter" title="cec_allocate_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_allocate_adapter()</span></code></a> and deleted by calling <a class="reference internal" href="#c.cec_delete_adapter" title="cec_delete_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_delete_adapter()</span></code></a>:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_allocate_adapter">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">cec_allocate_adapter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.cec_adap_ops" title="cec_adap_ops"><span class="n"><span class="pre">cec_adap_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">priv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">caps</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">available_las</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_allocate_adapter" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.cec_delete_adapter">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_delete_adapter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_delete_adapter" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>To create an adapter you need to pass the following information:</p>
<dl class="simple">
<dt>ops:</dt><dd><p>adapter operations which are called by the CEC framework and that you
have to implement.</p>
</dd>
<dt>priv:</dt><dd><p>will be stored in adap-&gt;priv and can be used by the adapter ops.
Use cec_get_drvdata(adap) to get the priv pointer.</p>
</dd>
<dt>name:</dt><dd><p>the name of the CEC adapter. Note: this name will be copied.</p>
</dd>
<dt>caps:</dt><dd><p>capabilities of the CEC adapter. These capabilities determine the
capabilities of the hardware and which parts are to be handled
by userspace and which parts are handled by kernelspace. The
capabilities are returned by CEC_ADAP_G_CAPS.</p>
</dd>
<dt>available_las:</dt><dd><p>the number of simultaneous logical addresses that this
adapter can handle. Must be 1 &lt;= available_las &lt;= CEC_MAX_LOG_ADDRS.</p>
</dd>
</dl>
<p>To obtain the priv pointer use this helper function:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_get_drvdata">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">cec_get_drvdata</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_get_drvdata" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>To register the /dev/cecX device node and the remote control device (if
CEC_CAP_RC is set) you call:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_register_adapter">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_register_adapter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_register_adapter" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>where parent is the parent device.</p>
<p>To unregister the devices call:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_unregister_adapter">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_unregister_adapter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_unregister_adapter" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Note: if <a class="reference internal" href="#c.cec_register_adapter" title="cec_register_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_register_adapter()</span></code></a> fails, then call <a class="reference internal" href="#c.cec_delete_adapter" title="cec_delete_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_delete_adapter()</span></code></a> to
clean up. But if <a class="reference internal" href="#c.cec_register_adapter" title="cec_register_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_register_adapter()</span></code></a> succeeded, then only call
<a class="reference internal" href="#c.cec_unregister_adapter" title="cec_unregister_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_unregister_adapter()</span></code></a> to clean up, never <a class="reference internal" href="#c.cec_delete_adapter" title="cec_delete_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_delete_adapter()</span></code></a>. The
unregister function will delete the adapter automatically once the last user
of that /dev/cecX device has closed its file handle.</p>
</section>
<section id="implementing-the-low-level-cec-adapter">
<h2><span class="section-number">6.3. </span>Implementing the Low-Level CEC Adapter<a class="headerlink" href="#implementing-the-low-level-cec-adapter" title="Link to this heading">¶</a></h2>
<p>The following low-level adapter operations have to be implemented in
your driver:</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.cec_adap_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_adap_ops</span></span></span><a class="headerlink" href="#c.cec_adap_ops" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cec_adap_ops
{
        /* Low-level callbacks */
        int (*adap_enable)(struct cec_adapter *adap, bool enable);
        int (*adap_monitor_all_enable)(struct cec_adapter *adap, bool enable);
        int (*adap_monitor_pin_enable)(struct cec_adapter *adap, bool enable);
        int (*adap_log_addr)(struct cec_adapter *adap, u8 logical_addr);
        void (*adap_unconfigured)(struct cec_adapter *adap);
        int (*adap_transmit)(struct cec_adapter *adap, u8 attempts,
                              u32 signal_free_time, struct cec_msg *msg);
        void (*adap_nb_transmit_canceled)(struct cec_adapter *adap,
                                          const struct cec_msg *msg);
        void (*adap_status)(struct cec_adapter *adap, struct seq_file *file);
        void (*adap_free)(struct cec_adapter *adap);

        /* Error injection callbacks */
        ...

        /* High-level callback */
        ...
};
</pre></div>
</div>
<p>These low-level ops deal with various aspects of controlling the CEC adapter
hardware. They are all called with the mutex adap-&gt;lock held.</p>
<p>To enable/disable the hardware:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*adap_enable)(struct cec_adapter *adap, bool enable);
</pre></div>
</div>
<p>This callback enables or disables the CEC hardware. Enabling the CEC hardware
means powering it up in a state where no logical addresses are claimed. The
physical address will always be valid if CEC_CAP_NEEDS_HPD is set. If that
capability is not set, then the physical address can change while the CEC
hardware is enabled. CEC drivers should not set CEC_CAP_NEEDS_HPD unless
the hardware design requires that as this will make it impossible to wake
up displays that pull the HPD low when in standby mode.  The initial
state of the CEC adapter after calling <a class="reference internal" href="#c.cec_allocate_adapter" title="cec_allocate_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_allocate_adapter()</span></code></a> is disabled.</p>
<p>Note that adap_enable must return 0 if enable is false.</p>
<p>To enable/disable the ‘monitor all’ mode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*adap_monitor_all_enable)(struct cec_adapter *adap, bool enable);
</pre></div>
</div>
<p>If enabled, then the adapter should be put in a mode to also monitor messages
that are not for us. Not all hardware supports this and this function is only
called if the CEC_CAP_MONITOR_ALL capability is set. This callback is optional
(some hardware may always be in ‘monitor all’ mode).</p>
<p>Note that adap_monitor_all_enable must return 0 if enable is false.</p>
<p>To enable/disable the ‘monitor pin’ mode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*adap_monitor_pin_enable)(struct cec_adapter *adap, bool enable);
</pre></div>
</div>
<p>If enabled, then the adapter should be put in a mode to also monitor CEC pin
changes. Not all hardware supports this and this function is only called if
the CEC_CAP_MONITOR_PIN capability is set. This callback is optional
(some hardware may always be in ‘monitor pin’ mode).</p>
<p>Note that adap_monitor_pin_enable must return 0 if enable is false.</p>
<p>To program a new logical address:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*adap_log_addr)(struct cec_adapter *adap, u8 logical_addr);
</pre></div>
</div>
<p>If logical_addr == CEC_LOG_ADDR_INVALID then all programmed logical addresses
are to be erased. Otherwise the given logical address should be programmed.
If the maximum number of available logical addresses is exceeded, then it
should return -ENXIO. Once a logical address is programmed the CEC hardware
can receive directed messages to that address.</p>
<p>Note that adap_log_addr must return 0 if logical_addr is CEC_LOG_ADDR_INVALID.</p>
<p>Called when the adapter is unconfigured:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*adap_unconfigured)(struct cec_adapter *adap);
</pre></div>
</div>
<p>The adapter is unconfigured. If the driver has to take specific actions after
unconfiguration, then that can be done through this optional callback.</p>
<p>To transmit a new message:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*adap_transmit)(struct cec_adapter *adap, u8 attempts,
                     u32 signal_free_time, struct cec_msg *msg);
</pre></div>
</div>
<p>This transmits a new message. The attempts argument is the suggested number of
attempts for the transmit.</p>
<p>The signal_free_time is the number of data bit periods that the adapter should
wait when the line is free before attempting to send a message. This value
depends on whether this transmit is a retry, a message from a new initiator or
a new message for the same initiator. Most hardware will handle this
automatically, but in some cases this information is needed.</p>
<p>The CEC_FREE_TIME_TO_USEC macro can be used to convert signal_free_time to
microseconds (one data bit period is 2.4 ms).</p>
<p>To pass on the result of a canceled non-blocking transmit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*adap_nb_transmit_canceled)(struct cec_adapter *adap,
                                  const struct cec_msg *msg);
</pre></div>
</div>
<p>This optional callback can be used to obtain the result of a canceled
non-blocking transmit with sequence number msg-&gt;sequence. This is
called if the transmit was aborted, the transmit timed out (i.e. the
hardware never signaled that the transmit finished), or the transmit
was successful, but the wait for the expected reply was either aborted
or it timed out.</p>
<p>To log the current CEC hardware status:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*adap_status)(struct cec_adapter *adap, struct seq_file *file);
</pre></div>
</div>
<p>This optional callback can be used to show the status of the CEC hardware.
The status is available through debugfs: cat /sys/kernel/debug/cec/cecX/status</p>
<p>To free any resources when the adapter is deleted:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*adap_free)(struct cec_adapter *adap);
</pre></div>
</div>
<p>This optional callback can be used to free any resources that might have been
allocated by the driver. It’s called from cec_delete_adapter.</p>
<p>Your adapter driver will also have to react to events (typically interrupt
driven) by calling into the framework in the following situations:</p>
<p>When a transmit finished (successfully or otherwise):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void cec_transmit_done(struct cec_adapter *adap, u8 status,
                       u8 arb_lost_cnt,  u8 nack_cnt, u8 low_drive_cnt,
                       u8 error_cnt);
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void cec_transmit_attempt_done(struct cec_adapter *adap, u8 status);
</pre></div>
</div>
<p>The status can be one of:</p>
<dl class="simple">
<dt>CEC_TX_STATUS_OK:</dt><dd><p>the transmit was successful.</p>
</dd>
<dt>CEC_TX_STATUS_ARB_LOST:</dt><dd><p>arbitration was lost: another CEC initiator
took control of the CEC line and you lost the arbitration.</p>
</dd>
<dt>CEC_TX_STATUS_NACK:</dt><dd><p>the message was nacked (for a directed message) or
acked (for a broadcast message). A retransmission is needed.</p>
</dd>
<dt>CEC_TX_STATUS_LOW_DRIVE:</dt><dd><p>low drive was detected on the CEC bus. This indicates that
a follower detected an error on the bus and requested a
retransmission.</p>
</dd>
<dt>CEC_TX_STATUS_ERROR:</dt><dd><p>some unspecified error occurred: this can be one of ARB_LOST
or LOW_DRIVE if the hardware cannot differentiate or something
else entirely. Some hardware only supports OK and FAIL as the
result of a transmit, i.e. there is no way to differentiate
between the different possible errors. In that case map FAIL
to CEC_TX_STATUS_NACK and not to CEC_TX_STATUS_ERROR.</p>
</dd>
<dt>CEC_TX_STATUS_MAX_RETRIES:</dt><dd><p>could not transmit the message after trying multiple times.
Should only be set by the driver if it has hardware support for
retrying messages. If set, then the framework assumes that it
doesn’t have to make another attempt to transmit the message
since the hardware did that already.</p>
</dd>
</dl>
<p>The hardware must be able to differentiate between OK, NACK and ‘something
else’.</p>
<p>The *_cnt arguments are the number of error conditions that were seen.
This may be 0 if no information is available. Drivers that do not support
hardware retry can just set the counter corresponding to the transmit error
to 1, if the hardware does support retry then either set these counters to
0 if the hardware provides no feedback of which errors occurred and how many
times, or fill in the correct values as reported by the hardware.</p>
<p>Be aware that calling these functions can immediately start a new transmit
if there is one pending in the queue. So make sure that the hardware is in
a state where new transmits can be started <em>before</em> calling these functions.</p>
<p>The cec_transmit_attempt_done() function is a helper for cases where the
hardware never retries, so the transmit is always for just a single
attempt. It will call cec_transmit_done() in turn, filling in 1 for the
count argument corresponding to the status. Or all 0 if the status was OK.</p>
<p>When a CEC message was received:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_received_msg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_received_msg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_received_msg" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Speaks for itself.</p>
</section>
<section id="implementing-the-interrupt-handler">
<h2><span class="section-number">6.4. </span>Implementing the interrupt handler<a class="headerlink" href="#implementing-the-interrupt-handler" title="Link to this heading">¶</a></h2>
<p>Typically the CEC hardware provides interrupts that signal when a transmit
finished and whether it was successful or not, and it provides and interrupt
when a CEC message was received.</p>
<p>The CEC driver should always process the transmit interrupts first before
handling the receive interrupt. The framework expects to see the cec_transmit_done
call before the cec_received_msg call, otherwise it can get confused if the
received message was in reply to the transmitted message.</p>
</section>
<section id="optional-implementing-error-injection-support">
<h2><span class="section-number">6.5. </span>Optional: Implementing Error Injection Support<a class="headerlink" href="#optional-implementing-error-injection-support" title="Link to this heading">¶</a></h2>
<p>If the CEC adapter supports Error Injection functionality, then that can
be exposed through the Error Injection callbacks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cec_adap_ops {
        /* Low-level callbacks */
        ...

        /* Error injection callbacks */
        int (*error_inj_show)(struct cec_adapter *adap, struct seq_file *sf);
        bool (*error_inj_parse_line)(struct cec_adapter *adap, char *line);

        /* High-level CEC message callback */
        ...
};
</pre></div>
</div>
<p>If both callbacks are set, then an <code class="docutils literal notranslate"><span class="pre">error-inj</span></code> file will appear in debugfs.
The basic syntax is as follows:</p>
<p>Leading spaces/tabs are ignored. If the next character is a <code class="docutils literal notranslate"><span class="pre">#</span></code> or the end of the
line was reached, then the whole line is ignored. Otherwise a command is expected.</p>
<p>This basic parsing is done in the CEC Framework. It is up to the driver to decide
what commands to implement. The only requirement is that the command <code class="docutils literal notranslate"><span class="pre">clear</span></code> without
any arguments must be implemented and that it will remove all current error injection
commands.</p>
<p>This ensures that you can always do <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">clear</span> <span class="pre">&gt;error-inj</span></code> to clear any error
injections without having to know the details of the driver-specific commands.</p>
<p>Note that the output of <code class="docutils literal notranslate"><span class="pre">error-inj</span></code> shall be valid as input to <code class="docutils literal notranslate"><span class="pre">error-inj</span></code>.
So this must work:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat error-inj &gt;einj.txt
$ cat einj.txt &gt;error-inj
</pre></div>
</div>
<p>The first callback is called when this file is read and it should show the
current error injection state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*error_inj_show)(struct cec_adapter *adap, struct seq_file *sf);
</pre></div>
</div>
<p>It is recommended that it starts with a comment block with basic usage
information. It returns 0 for success and an error otherwise.</p>
<p>The second callback will parse commands written to the <code class="docutils literal notranslate"><span class="pre">error-inj</span></code> file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool (*error_inj_parse_line)(struct cec_adapter *adap, char *line);
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">line</span></code> argument points to the start of the command. Any leading
spaces or tabs have already been skipped. It is a single line only (so there
are no embedded newlines) and it is 0-terminated. The callback is free to
modify the contents of the buffer. It is only called for lines containing a
command, so this callback is never called for empty lines or comment lines.</p>
<p>Return true if the command was valid or false if there were syntax errors.</p>
</section>
<section id="implementing-the-high-level-cec-adapter">
<h2><span class="section-number">6.6. </span>Implementing the High-Level CEC Adapter<a class="headerlink" href="#implementing-the-high-level-cec-adapter" title="Link to this heading">¶</a></h2>
<p>The low-level operations drive the hardware, the high-level operations are
CEC protocol driven. The high-level callbacks are called without the adap-&gt;lock
mutex being held. The following high-level callbacks are available:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cec_adap_ops {
        /* Low-level callbacks */
        ...

        /* Error injection callbacks */
        ...

        /* High-level CEC message callback */
        void (*configured)(struct cec_adapter *adap);
        int (*received)(struct cec_adapter *adap, struct cec_msg *msg);
};
</pre></div>
</div>
<p>Called when the adapter is configured:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*configured)(struct cec_adapter *adap);
</pre></div>
</div>
<p>The adapter is fully configured, i.e. all logical addresses have been
successfully claimed. If the driver has to take specific actions after
configuration, then that can be done through this optional callback.</p>
<p>The received() callback allows the driver to optionally handle a newly
received CEC message:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*received)(struct cec_adapter *adap, struct cec_msg *msg);
</pre></div>
</div>
<p>If the driver wants to process a CEC message, then it can implement this
callback. If it doesn’t want to handle this message, then it should return
-ENOMSG, otherwise the CEC framework assumes it processed this message and
it will not do anything with it.</p>
</section>
<section id="cec-framework-functions">
<h2><span class="section-number">6.7. </span>CEC framework functions<a class="headerlink" href="#cec-framework-functions" title="Link to this heading">¶</a></h2>
<p>CEC Adapter drivers can call the following CEC framework functions:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_transmit_msg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_transmit_msg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">block</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_transmit_msg" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Transmit a CEC message. If block is true, then wait until the message has been
transmitted, otherwise just queue it and return.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_s_phys_addr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_s_phys_addr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span>, <span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">phys_addr</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">block</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_s_phys_addr" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Change the physical address. This function will set adap-&gt;phys_addr and
send an event if it has changed. If <a class="reference internal" href="#c.cec_s_log_addrs" title="cec_s_log_addrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_s_log_addrs()</span></code></a> has been called and
the physical address has become valid, then the CEC framework will start
claiming the logical addresses. If block is true, then this function won’t
return until this process has finished.</p>
<p>When the physical address is set to a valid value the CEC adapter will
be enabled (see the adap_enable op). When it is set to CEC_PHYS_ADDR_INVALID,
then the CEC adapter will be disabled. If you change a valid physical address
to another valid physical address, then this function will first set the
address to CEC_PHYS_ADDR_INVALID before enabling the new physical address.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_s_phys_addr_from_edid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_s_phys_addr_from_edid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.cec_s_phys_addr_from_edid" title="edid"><span class="n"><span class="pre">edid</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edid</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_s_phys_addr_from_edid" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>A helper function that extracts the physical address from the edid struct
and calls <a class="reference internal" href="#c.cec_s_phys_addr" title="cec_s_phys_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">cec_s_phys_addr()</span></code></a> with that address, or CEC_PHYS_ADDR_INVALID
if the EDID did not contain a physical address or edid was a NULL pointer.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_s_log_addrs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_s_log_addrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_log_addrs</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">log_addrs</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">block</span></span><span class="sig-paren">)</span><span class="p"><span class="pre">;</span></span><a class="headerlink" href="#c.cec_s_log_addrs" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Claim the CEC logical addresses. Should never be called if CEC_CAP_LOG_ADDRS
is set. If block is true, then wait until the logical addresses have been
claimed, otherwise just queue it and return. To unconfigure all logical
addresses call this function with log_addrs set to NULL or with
log_addrs-&gt;num_log_addrs set to 0. The block argument is ignored when
unconfiguring. This function will just return if the physical address is
invalid. Once the physical address becomes valid, then the framework will
attempt to claim these logical addresses.</p>
</section>
<section id="cec-pin-framework">
<h2><span class="section-number">6.8. </span>CEC Pin framework<a class="headerlink" href="#cec-pin-framework" title="Link to this heading">¶</a></h2>
<p>Most CEC hardware operates on full CEC messages where the software provides
the message and the hardware handles the low-level CEC protocol. But some
hardware only drives the CEC pin and software has to handle the low-level
CEC protocol. The CEC pin framework was created to handle such devices.</p>
<p>Note that due to the close-to-realtime requirements it can never be guaranteed
to work 100%. This framework uses highres timers internally, but if a
timer goes off too late by more than 300 microseconds wrong results can
occur. In reality it appears to be fairly reliable.</p>
<p>One advantage of this low-level implementation is that it can be used as
a cheap CEC analyser, especially if interrupts can be used to detect
CEC pin transitions from low to high or vice versa.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.cec_pin_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_pin_ops</span></span></span><a class="headerlink" href="#c.cec_pin_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>low-level CEC pin operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cec_pin_ops {
    int (*read)(struct cec_adapter *adap);
    void (*low)(struct cec_adapter *adap);
    void (*high)(struct cec_adapter *adap);
    bool (*enable_irq)(struct cec_adapter *adap);
    void (*disable_irq)(struct cec_adapter *adap);
    void (*free)(struct cec_adapter *adap);
    void (*status)(struct cec_adapter *adap, struct seq_file *file);
    int (*read_hpd)(struct cec_adapter *adap);
    int (*read_5v)(struct cec_adapter *adap);
    int (*received)(struct cec_adapter *adap, struct cec_msg *msg);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>read the CEC pin. Returns &gt; 0 if high, 0 if low, or an error
if negative.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">low</span></code></dt><dd><p>drive the CEC pin low.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">high</span></code></dt><dd><p>stop driving the CEC pin. The pull-up will drive the pin
high, unless someone else is driving the pin low.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_irq</span></code></dt><dd><p>optional, enable the interrupt to detect pin voltage changes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_irq</span></code></dt><dd><p>optional, disable the interrupt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt><dd><p>optional. Free any allocated resources. Called when the
adapter is deleted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>optional, log status information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_hpd</span></code></dt><dd><p>optional. Read the HPD pin. Returns &gt; 0 if high, 0 if low or
an error if negative.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_5v</span></code></dt><dd><p>optional. Read the 5V pin. Returns &gt; 0 if high, 0 if low or
an error if negative.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">received</span></code></dt><dd><p>optional. High-level CEC message callback. Allows the driver
to process CEC messages.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These operations (except for the <strong>received</strong> op) are used by the
cec pin framework to manipulate the CEC pin.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_pin_changed">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_pin_changed</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_pin_changed" title="Link to this definition">¶</a><br /></dt>
<dd><p>update pin state from interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cec_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>pointer to the cec adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">value</span></code></dt><dd><p>when true the pin is high, otherwise it is low</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If changes of the CEC voltage are detected via an interrupt, then
cec_pin_changed is called from the interrupt with the new value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_pin_allocate_adapter">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">cec_pin_allocate_adapter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.cec_pin_ops" title="cec_pin_ops"><span class="n"><span class="pre">cec_pin_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pin_ops</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">priv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">caps</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_pin_allocate_adapter" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a pin-based cec adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cec_pin_ops</span> <span class="pre">*pin_ops</span></code></dt><dd><p>low-level pin operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>will be stored in adap-&gt;priv and can be used by the adapter ops.
Use cec_get_drvdata(adap) to get the priv pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name of the CEC adapter. Note: this name will be copied.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">caps</span></code></dt><dd><p>capabilities of the CEC adapter. This will be ORed with
CEC_CAP_MONITOR_ALL and CEC_CAP_MONITOR_PIN.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a cec adapter using the cec pin framework.</p>
<p><strong>Return</strong></p>
<p>a pointer to the cec adapter or an error pointer</p>
</div>
</section>
<section id="cec-notifier-framework">
<h2><span class="section-number">6.9. </span>CEC Notifier framework<a class="headerlink" href="#cec-notifier-framework" title="Link to this heading">¶</a></h2>
<p>Most drm HDMI implementations have an integrated CEC implementation and no
notifier support is needed. But some have independent CEC implementations
that have their own driver. This could be an IP block for an SoC or a
completely separate chip that deals with the CEC pin. For those cases a
drm driver can install a notifier and use the notifier to inform the
CEC driver about changes in the physical address.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_notifier_conn_register">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">cec_notifier_conn_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hdmi_dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port_name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_connector_info</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conn_info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_conn_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>find or create a new cec_notifier for the given HDMI device and connector tuple.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*hdmi_dev</span></code></dt><dd><p>HDMI device that sends the events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*port_name</span></code></dt><dd><p>the connector name from which the event occurs. May be NULL
if there is always only one HDMI connector created by the HDMI device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cec_connector_info</span> <span class="pre">*conn_info</span></code></dt><dd><p>the connector info from which the event occurs (may be NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a notifier for device <strong>dev</strong> and connector <strong>port_name</strong> already exists, then
increase the refcount and return that notifier.</p>
<p>If it doesn’t exist, then allocate a new notifier struct and return a
pointer to that new struct.</p>
<p>Return NULL if the memory could not be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_notifier_conn_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_notifier_conn_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_conn_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrease refcount and delete when the refcount reaches 0.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*n</span></code></dt><dd><p>notifier. If NULL, then this function does nothing.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_notifier_cec_adap_register">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">cec_notifier_cec_adap_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hdmi_dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">port_name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_cec_adap_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>find or create a new cec_notifier for the given device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*hdmi_dev</span></code></dt><dd><p>HDMI device that sends the events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*port_name</span></code></dt><dd><p>the connector name from which the event occurs. May be NULL
if there is always only one HDMI connector created by the HDMI device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cec_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>the cec adapter that registered this notifier.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a notifier for device <strong>dev</strong> and connector <strong>port_name</strong> already exists, then
increase the refcount and return that notifier.</p>
<p>If it doesn’t exist, then allocate a new notifier struct and return a
pointer to that new struct.</p>
<p>Return NULL if the memory could not be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_notifier_cec_adap_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_notifier_cec_adap_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_adapter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">adap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_cec_adap_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>decrease refcount and delete when the refcount reaches 0.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*n</span></code></dt><dd><p>notifier. If NULL, then this function does nothing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cec_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>the cec adapter that registered this notifier.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_notifier_set_phys_addr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_notifier_set_phys_addr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">pa</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_set_phys_addr" title="Link to this definition">¶</a><br /></dt>
<dd><p>set a new physical address.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*n</span></code></dt><dd><p>the CEC notifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">pa</span></code></dt><dd><p>the CEC physical address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a new CEC physical address.
Does nothing if <strong>n</strong> == NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_notifier_set_phys_addr_from_edid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_notifier_set_phys_addr_from_edid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.cec_notifier_set_phys_addr_from_edid" title="edid"><span class="n"><span class="pre">edid</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">edid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_set_phys_addr_from_edid" title="Link to this definition">¶</a><br /></dt>
<dd><p>set parse the PA from the EDID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*n</span></code></dt><dd><p>the CEC notifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>the struct edid pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses the EDID to obtain the new CEC physical address and set it.
Does nothing if <strong>n</strong> == NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_notifier_parse_hdmi_phandle">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">cec_notifier_parse_hdmi_phandle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_parse_hdmi_phandle" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the hdmi device from “hdmi-phandle”</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device with the “hdmi-phandle” device tree property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the device pointer referenced by the “hdmi-phandle” property.
Note that the refcount of the returned device is not incremented.
This device pointer is only used as a key value in the notifier
list, but it is never accessed by the CEC driver.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cec_notifier_phys_addr_invalidate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cec_notifier_phys_addr_invalidate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cec_notifier</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_phys_addr_invalidate" title="Link to this definition">¶</a><br /></dt>
<dd><p>set the physical address to INVALID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*n</span></code></dt><dd><p>the CEC notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simple helper function to invalidate the physical
address. Does nothing if <strong>n</strong> == NULL.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/media/cec-core.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>