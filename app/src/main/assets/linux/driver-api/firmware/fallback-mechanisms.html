<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Fallback mechanisms &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Firmware lookup order" href="lookup-order.html" />
    <link rel="prev" title="Direct filesystem lookup" href="direct-fs-lookup.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.9.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/firmware/fallback-mechanisms.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="fallback-mechanisms">
<h1>Fallback mechanisms<a class="headerlink" href="#fallback-mechanisms" title="Link to this heading">¶</a></h1>
<p>A fallback mechanism is supported to allow to overcome failures to do a direct
filesystem lookup on the root filesystem or when the firmware simply cannot be
installed for practical reasons on the root filesystem. The kernel
configuration options related to supporting the firmware fallback mechanism are:</p>
<blockquote>
<div><ul class="simple">
<li><p>CONFIG_FW_LOADER_USER_HELPER: enables building the firmware fallback
mechanism. Most distributions enable this option today. If enabled but
CONFIG_FW_LOADER_USER_HELPER_FALLBACK is disabled, only the custom fallback
mechanism is available and for the <a class="reference internal" href="request_firmware.html#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> call.</p></li>
<li><p>CONFIG_FW_LOADER_USER_HELPER_FALLBACK: force enables each request to
enable the kobject uevent fallback mechanism on all firmware API calls
except <a class="reference internal" href="request_firmware.html#c.request_firmware_direct" title="request_firmware_direct"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_direct()</span></code></a>. Most distributions disable this option
today. The call <a class="reference internal" href="request_firmware.html#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> allows for one alternative
fallback mechanism: if this kconfig option is enabled and your second
argument to <a class="reference internal" href="request_firmware.html#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a>, uevent, is set to false you are
informing the kernel that you have a custom fallback mechanism and it will
manually load the firmware. Read below for more details.</p></li>
</ul>
</div></blockquote>
<p>Note that this means when having this configuration:</p>
<p>CONFIG_FW_LOADER_USER_HELPER=y
CONFIG_FW_LOADER_USER_HELPER_FALLBACK=n</p>
<p>the kobject uevent fallback mechanism will never take effect even
for <a class="reference internal" href="request_firmware.html#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> when uevent is set to true.</p>
<section id="justifying-the-firmware-fallback-mechanism">
<h2>Justifying the firmware fallback mechanism<a class="headerlink" href="#justifying-the-firmware-fallback-mechanism" title="Link to this heading">¶</a></h2>
<p>Direct filesystem lookups may fail for a variety of reasons. Known reasons for
this are worth itemizing and documenting as it justifies the need for the
fallback mechanism:</p>
<ul>
<li><p>Race against access with the root filesystem upon bootup.</p></li>
<li><p>Races upon resume from suspend. This is resolved by the firmware cache, but
the firmware cache is only supported if you use uevents, and its not
supported for <a class="reference internal" href="request_firmware.html#c.request_firmware_into_buf" title="request_firmware_into_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_into_buf()</span></code></a>.</p></li>
<li><p>Firmware is not accessible through typical means:</p>
<blockquote>
<div><ul class="simple">
<li><p>It cannot be installed into the root filesystem</p></li>
<li><p>The firmware provides very unique device specific data tailored for
the unit gathered with local information. An example is calibration
data for WiFi chipsets for mobile devices. This calibration data is
not common to all units, but tailored per unit.  Such information may
be installed on a separate flash partition other than where the root
filesystem is provided.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="types-of-fallback-mechanisms">
<h2>Types of fallback mechanisms<a class="headerlink" href="#types-of-fallback-mechanisms" title="Link to this heading">¶</a></h2>
<p>There are really two fallback mechanisms available using one shared sysfs
interface as a loading facility:</p>
<ul class="simple">
<li><p>Kobject uevent fallback mechanism</p></li>
<li><p>Custom fallback mechanism</p></li>
</ul>
<p>First lets document the shared sysfs loading facility.</p>
</section>
<section id="firmware-sysfs-loading-facility">
<h2>Firmware sysfs loading facility<a class="headerlink" href="#firmware-sysfs-loading-facility" title="Link to this heading">¶</a></h2>
<p>In order to help device drivers upload firmware using a fallback mechanism
the firmware infrastructure creates a sysfs interface to enable userspace
to load and indicate when firmware is ready. The sysfs directory is created
via fw_create_instance(). This call creates a new <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> named after
the firmware requested, and establishes it in the device hierarchy by
associating the device used to make the request as the device’s parent.
The sysfs directory’s file attributes are defined and controlled through
the new device’s class (firmware_class) and group (fw_dev_attr_groups).
This is actually where the original firmware_class module name came from,
given that originally the only firmware loading mechanism available was the
mechanism we now use as a fallback mechanism, which registers a <a class="reference internal" href="../infrastructure.html#c.class" title="class"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code></a>
firmware_class. Because the attributes exposed are part of the module name, the
module name firmware_class cannot be renamed in the future, to ensure backward
compatibility with old userspace.</p>
<p>To load firmware using the sysfs interface we expose a loading indicator,
and a file upload firmware into:</p>
<blockquote>
<div><ul class="simple">
<li><p>/sys/$DEVPATH/loading</p></li>
<li><p>/sys/$DEVPATH/data</p></li>
</ul>
</div></blockquote>
<p>To upload firmware you will echo 1 onto the loading file to indicate
you are loading firmware. You then write the firmware into the data file,
and you notify the kernel the firmware is ready by echo’ing 0 onto
the loading file.</p>
<p>The firmware device used to help load firmware using sysfs is only created if
direct firmware loading fails and if the fallback mechanism is enabled for your
firmware request, this is set up with <a class="reference internal" href="#c.firmware_fallback_sysfs" title="firmware_fallback_sysfs"><code class="xref c c-func docutils literal notranslate"><span class="pre">firmware_fallback_sysfs()</span></code></a>. It is
important to re-iterate that no device is created if a direct filesystem lookup
succeeded.</p>
<p>Using:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 1 &gt; /sys/$DEVPATH/loading
</pre></div>
</div>
<p>Will clean any previous partial load at once and make the firmware API
return an error. When loading firmware the firmware_class grows a buffer
for the firmware in PAGE_SIZE increments to hold the image as it comes in.</p>
<p>firmware_data_read() and firmware_loading_show() are just provided for the
test_firmware driver for testing, they are not called in normal use or
expected to be used regularly by userspace.</p>
<section id="firmware-fallback-sysfs">
<h3>firmware_fallback_sysfs<a class="headerlink" href="#firmware-fallback-sysfs" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.firmware_fallback_sysfs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">firmware_fallback_sysfs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">firmware</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fw</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.firmware_fallback_sysfs" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">opt_flags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ret</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_fallback_sysfs" title="Link to this definition">¶</a><br /></dt>
<dd><p>use the fallback mechanism to find firmware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">*fw</span></code></dt><dd><p>pointer to firmware image</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of firmware file to look for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>device for which firmware is being loaded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">opt_flags</span></code></dt><dd><p>options to control firmware loading behaviour, as defined by
<code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fw_opt</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ret</span></code></dt><dd><p>return value from direct lookup which triggered the fallback mechanism</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called if direct lookup for the firmware failed, it enables
a fallback mechanism through userspace by exposing a sysfs loading
interface. Userspace is in charge of loading the firmware through the sysfs
loading interface. This sysfs fallback mechanism may be disabled completely
on a system by setting the proc sysctl value ignore_sysfs_fallback to true.
If this is false we check if the internal API caller set the
<strong>FW_OPT_NOFALLBACK_SYSFS</strong> flag, if so it would also disable the fallback
mechanism. A system may want to enforce the sysfs fallback mechanism at all
times, it can do this by setting ignore_sysfs_fallback to false and
force_sysfs_fallback to true.
Enabling force_sysfs_fallback is functionally equivalent to build a kernel
with CONFIG_FW_LOADER_USER_HELPER_FALLBACK.</p>
</div>
</section>
</section>
<section id="firmware-kobject-uevent-fallback-mechanism">
<h2>Firmware kobject uevent fallback mechanism<a class="headerlink" href="#firmware-kobject-uevent-fallback-mechanism" title="Link to this heading">¶</a></h2>
<p>Since a device is created for the sysfs interface to help load firmware as a
fallback mechanism userspace can be informed of the addition of the device by
relying on kobject uevents. The addition of the device into the device
hierarchy means the fallback mechanism for firmware loading has been initiated.
For details of implementation refer to fw_load_sysfs_fallback(), in particular
on the use of dev_set_uevent_suppress() and kobject_uevent().</p>
<p>The kernel’s kobject uevent mechanism is implemented in lib/kobject_uevent.c,
it issues uevents to userspace. As a supplement to kobject uevents Linux
distributions could also enable CONFIG_UEVENT_HELPER_PATH, which makes use of
core kernel’s usermode helper (UMH) functionality to call out to a userspace
helper for kobject uevents. In practice though no standard distribution has
ever used the CONFIG_UEVENT_HELPER_PATH. If CONFIG_UEVENT_HELPER_PATH is
enabled this binary would be called each time kobject_uevent_env() gets called
in the kernel for each kobject uevent triggered.</p>
<p>Different implementations have been supported in userspace to take advantage of
this fallback mechanism. When firmware loading was only possible using the
sysfs mechanism the userspace component “hotplug” provided the functionality of
monitoring for kobject events. Historically this was superseded be systemd’s
udev, however firmware loading support was removed from udev as of systemd
<a class="reference external" href="https://git.kernel.org/torvalds/c/be2ea723b1d0">commit be2ea723b1d0</a> (“udev: remove userspace firmware loading support”)
as of v217 on August, 2014. This means most Linux distributions today are
not using or taking advantage of the firmware fallback mechanism provided
by kobject uevents. This is specially exacerbated due to the fact that most
distributions today disable CONFIG_FW_LOADER_USER_HELPER_FALLBACK.</p>
<p>Refer to do_firmware_uevent() for details of the kobject event variables
setup. The variables currently passed to userspace with a “kobject add”
event are:</p>
<ul class="simple">
<li><p>FIRMWARE=firmware name</p></li>
<li><p>TIMEOUT=timeout value</p></li>
<li><p>ASYNC=whether or not the API request was asynchronous</p></li>
</ul>
<p>By default DEVPATH is set by the internal kernel kobject infrastructure.
Below is an example simple kobject uevent script:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Both $DEVPATH and $FIRMWARE are already provided in the environment.
MY_FW_DIR=/lib/firmware/
echo 1 &gt; /sys/$DEVPATH/loading
cat $MY_FW_DIR/$FIRMWARE &gt; /sys/$DEVPATH/data
echo 0 &gt; /sys/$DEVPATH/loading
</pre></div>
</div>
</section>
<section id="firmware-custom-fallback-mechanism">
<h2>Firmware custom fallback mechanism<a class="headerlink" href="#firmware-custom-fallback-mechanism" title="Link to this heading">¶</a></h2>
<p>Users of the <a class="reference internal" href="request_firmware.html#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> call have yet another option available
at their disposal: rely on the sysfs fallback mechanism but request that no
kobject uevents be issued to userspace. The original logic behind this
was that utilities other than udev might be required to lookup firmware
in non-traditional paths -- paths outside of the listing documented in the
section ‘Direct filesystem lookup’. This option is not available to any of
the other API calls as uevents are always forced for them.</p>
<p>Since uevents are only meaningful if the fallback mechanism is enabled
in your kernel it would seem odd to enable uevents with kernels that do not
have the fallback mechanism enabled in their kernels. Unfortunately we also
rely on the uevent flag which can be disabled by <a class="reference internal" href="request_firmware.html#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> to
also setup the firmware cache for firmware requests. As documented above,
the firmware cache is only set up if uevent is enabled for an API call.
Although this can disable the firmware cache for <a class="reference internal" href="request_firmware.html#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a>
calls, users of this API should not use it for the purposes of disabling
the cache as that was not the original purpose of the flag. Not setting
the uevent flag means you want to opt-in for the firmware fallback mechanism
but you want to suppress kobject uevents, as you have a custom solution which
will monitor for your device addition into the device hierarchy somehow and
load firmware for you through a custom path.</p>
</section>
<section id="firmware-fallback-timeout">
<h2>Firmware fallback timeout<a class="headerlink" href="#firmware-fallback-timeout" title="Link to this heading">¶</a></h2>
<p>The firmware fallback mechanism has a timeout. If firmware is not loaded
onto the sysfs interface by the timeout value an error is sent to the
driver. By default the timeout is set to 60 seconds if uevents are
desirable, otherwise MAX_JIFFY_OFFSET is used (max timeout possible).
The logic behind using MAX_JIFFY_OFFSET for non-uevents is that a custom
solution will have as much time as it needs to load firmware.</p>
<p>You can customize the firmware timeout by echo’ing your desired timeout into
the following file:</p>
<ul class="simple">
<li><p>/sys/class/firmware/timeout</p></li>
</ul>
<p>If you echo 0 into it means MAX_JIFFY_OFFSET will be used. The data type
for the timeout is an int.</p>
</section>
<section id="efi-embedded-firmware-fallback-mechanism">
<h2>EFI embedded firmware fallback mechanism<a class="headerlink" href="#efi-embedded-firmware-fallback-mechanism" title="Link to this heading">¶</a></h2>
<p>On some devices the system’s EFI code / ROM may contain an embedded copy
of firmware for some of the system’s integrated peripheral devices and
the peripheral’s Linux device-driver needs to access this firmware.</p>
<p>Device drivers which need such firmware can use the
<a class="reference internal" href="request_firmware.html#c.firmware_request_platform" title="firmware_request_platform"><code class="xref c c-func docutils literal notranslate"><span class="pre">firmware_request_platform()</span></code></a> function for this, note that this is a
separate fallback mechanism from the other fallback mechanisms and
this does not use the sysfs interface.</p>
<p>A device driver which needs this can describe the firmware it needs
using an efi_embedded_fw_desc struct:</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.efi_embedded_fw_desc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">efi_embedded_fw_desc</span></span></span><a class="headerlink" href="#c.efi_embedded_fw_desc" title="Link to this definition">¶</a><br /></dt>
<dd><p>This struct is used by the EFI embedded-fw code to search for embedded firmwares.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct efi_embedded_fw_desc {
    const char *name;
    u8 prefix[EFI_EMBEDDED_FW_PREFIX_LEN];
    u32 length;
    u8 sha256[32];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name to register the firmware with if found</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prefix</span></code></dt><dd><p>First 8 bytes of the firmware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of the firmware in bytes including prefix</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sha256</span></code></dt><dd><p>SHA256 of the firmware</p>
</dd>
</dl>
</div>
<p>The EFI embedded-fw code works by scanning all EFI_BOOT_SERVICES_CODE memory
segments for an eight byte sequence matching prefix; if the prefix is found it
then does a sha256 over length bytes and if that matches makes a copy of length
bytes and adds that to its list with found firmwares.</p>
<p>To avoid doing this somewhat expensive scan on all systems, dmi matching is
used. Drivers are expected to export a dmi_system_id array, with each entries’
driver_data pointing to an efi_embedded_fw_desc.</p>
<p>To register this array with the efi-embedded-fw code, a driver needs to:</p>
<ol class="arabic simple">
<li><p>Always be builtin to the kernel or store the dmi_system_id array in a
separate object file which always gets builtin.</p></li>
<li><p>Add an extern declaration for the dmi_system_id array to
include/linux/efi_embedded_fw.h.</p></li>
<li><p>Add the dmi_system_id array to the embedded_fw_table in
drivers/firmware/efi/embedded-firmware.c wrapped in a #ifdef testing that
the driver is being builtin.</p></li>
<li><p>Add “select EFI_EMBEDDED_FIRMWARE if EFI_STUB” to its Kconfig entry.</p></li>
</ol>
<p>The <a class="reference internal" href="request_firmware.html#c.firmware_request_platform" title="firmware_request_platform"><code class="xref c c-func docutils literal notranslate"><span class="pre">firmware_request_platform()</span></code></a> function will always first try to load firmware
with the specified name directly from the disk, so the EFI embedded-fw can
always be overridden by placing a file under /lib/firmware.</p>
<p>Note that:</p>
<ol class="arabic simple">
<li><p>The code scanning for EFI embedded-firmware runs near the end
of start_kernel(), just before calling rest_init(). For normal drivers and
subsystems using subsys_initcall() to register themselves this does not
matter. This means that code running earlier cannot use EFI
embedded-firmware.</p></li>
<li><p>At the moment the EFI embedded-fw code assumes that firmwares always start at
an offset which is a multiple of 8 bytes, if this is not true for your case
send in a patch to fix this.</p></li>
<li><p>At the moment the EFI embedded-fw code only works on x86 because other archs
free EFI_BOOT_SERVICES_CODE before the EFI embedded-fw code gets a chance to
scan it.</p></li>
<li><p>The current brute-force scanning of EFI_BOOT_SERVICES_CODE is an ad-hoc
brute-force solution. There has been discussion to use the UEFI Platform
Initialization (PI) spec’s Firmware Volume protocol. This has been rejected
because the FV Protocol relies on <em>internal</em> interfaces of the PI spec, and:
1. The PI spec does not define peripheral firmware at all
2. The internal interfaces of the PI spec do not guarantee any backward
compatibility. Any implementation details in FV may be subject to change,
and may vary system to system. Supporting the FV Protocol would be
difficult as it is purposely ambiguous.</p></li>
</ol>
<section id="example-how-to-check-for-and-extract-embedded-firmware">
<h3>Example how to check for and extract embedded firmware<a class="headerlink" href="#example-how-to-check-for-and-extract-embedded-firmware" title="Link to this heading">¶</a></h3>
<p>To check for, for example Silead touchscreen controller embedded firmware,
do the following:</p>
<ol class="arabic simple">
<li><p>Boot the system with efi=debug on the kernel commandline</p></li>
<li><p>cp /sys/kernel/debug/efi/boot_services_code? to your home dir</p></li>
<li><p>Open the boot_services_code? files in a hex-editor, search for the
magic prefix for Silead firmware: F0 00 00 00 02 00 00 00, this gives you
the beginning address of the firmware inside the boot_services_code? file.</p></li>
<li><p>The firmware has a specific pattern, it starts with a 8 byte page-address,
typically F0 00 00 00 02 00 00 00 for the first page followed by 32-bit
word-address + 32-bit value pairs. With the word-address incrementing 4
bytes (1 word) for each pair until a page is complete. A complete page is
followed by a new page-address, followed by more word + value pairs. This
leads to a very distinct pattern. Scroll down until this pattern stops,
this gives you the end of the firmware inside the boot_services_code? file.</p></li>
<li><p>“dd if=boot_services_code? of=firmware bs=1 skip=&lt;begin-addr&gt; count=&lt;len&gt;”
will extract the firmware for you. Inspect the firmware file in a
hexeditor to make sure you got the dd parameters correct.</p></li>
<li><p>Copy it to /lib/firmware under the expected name to test it.</p></li>
<li><p>If the extracted firmware works, you can use the found info to fill an
efi_embedded_fw_desc struct to describe it, run “sha256sum firmware”
to get the sha256sum to put in the sha256 field.</p></li>
</ol>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/firmware/fallback-mechanisms.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>