
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>request_firmware API &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Firmware Upload API" href="fw_upload.html" />
    <link rel="prev" title="UEFI Support" href="efi/index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.8.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Driver implementer's API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization (dma-buf)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci/index.html">The Linux PCI driver implementer's API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer's Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas' 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer's Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux Firmware API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="core.html">Firmware API core features</a></li>
<li class="toctree-l3"><a class="reference internal" href="efi/index.html">UEFI Support</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">request_firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fw_upload.html">Firmware Upload API</a></li>
<li class="toctree-l3"><a class="reference internal" href="other_interfaces.html">Other Firmware Interfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio.html">VFIO - &quot;Virtual Function I/O&quot; </a></li>
<li class="toctree-l2"><a class="reference internal" href="../vfio-pci-device-specific-driver-acceptance.html">Acceptance criteria for vfio-pci device specific driver variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../virtio/index.html">Virtio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../wmi.html">WMI Driver API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tee.html">TEE (Trusted Execution Environment) driver API</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Kernel subsystem documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../RAS/ras.html">Reliability, Availability and Serviceability features</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/firmware/request_firmware.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="request-firmware-api">
<h1>request_firmware API<a class="headerlink" href="#request-firmware-api" title="Permalink to this heading">¶</a></h1>
<p>You would typically load firmware and then load it into your device somehow.
The typical firmware work flow is reflected below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if(request_firmware(&amp;fw_entry, $FIRMWARE, device) == 0)
       copy_fw_to_device(fw_entry-&gt;data, fw_entry-&gt;size);
release_firmware(fw_entry);
</pre></div>
</div>
<section id="synchronous-firmware-requests">
<h2>Synchronous firmware requests<a class="headerlink" href="#synchronous-firmware-requests" title="Permalink to this heading">¶</a></h2>
<p>Synchronous firmware requests will wait until the firmware is found or until
an error is returned.</p>
<section id="request-firmware">
<h3>request_firmware<a class="headerlink" href="#request-firmware" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.request_firmware">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">request_firmware</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">firmware</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">firmware_p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.request_firmware" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>send firmware request and wait for it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**firmware_p</span></code></dt><dd><p>pointer to firmware image</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of firmware file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>device for which firmware is being loaded</p>
<p><strong>firmware_p</strong> will be used to return a firmware image by the name
of <strong>name</strong> for device <strong>device</strong>.</p>
<p>Should be called from user context where sleeping is allowed.</p>
<p><strong>name</strong> will be used as $FIRMWARE in the uevent environment and
should be distinctive enough not to be confused with any other
firmware image for this or any other device.</p>
<p>Caller must hold the reference count of <strong>device</strong>.</p>
<p>The function can be called safely inside device's suspend and
resume callback.</p>
</dd>
</dl>
</div>
</section>
<section id="firmware-request-nowarn">
<h3>firmware_request_nowarn<a class="headerlink" href="#firmware-request-nowarn" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.firmware_request_nowarn">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">firmware_request_nowarn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.firmware_request_nowarn" title="firmware"><span class="n"><span class="pre">firmware</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">firmware</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.firmware_request_nowarn" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_nowarn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request for an optional fw module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**firmware</span></code></dt><dd><p>pointer to firmware image</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of firmware file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>device for which firmware is being loaded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar in behaviour to <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, except it
doesn't produce warning messages when the file is not found. The sysfs
fallback mechanism is enabled if direct filesystem lookup fails. However,
failures to find the firmware file with it are still suppressed. It is
therefore up to the driver to check for the return value of this call and to
decide when to inform the users of errors.</p>
</div>
</section>
<section id="firmware-request-platform">
<h3>firmware_request_platform<a class="headerlink" href="#firmware-request-platform" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.firmware_request_platform">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">firmware_request_platform</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.firmware_request_platform" title="firmware"><span class="n"><span class="pre">firmware</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">firmware</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.firmware_request_platform" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_platform" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request firmware with platform-fw fallback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**firmware</span></code></dt><dd><p>pointer to firmware image</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of firmware file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>device for which firmware is being loaded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar in behaviour to request_firmware, except that if
direct filesystem lookup fails, it will fallback to looking for a copy of the
requested firmware embedded in the platform's main (e.g. UEFI) firmware.</p>
</div>
</section>
<section id="request-firmware-direct">
<h3>request_firmware_direct<a class="headerlink" href="#request-firmware-direct" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.request_firmware_direct">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">request_firmware_direct</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">firmware</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">firmware_p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.request_firmware_direct" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_direct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>load firmware directly without usermode helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**firmware_p</span></code></dt><dd><p>pointer to firmware image</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of firmware file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>device for which firmware is being loaded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, but this doesn't
fall back to usermode helper even if the firmware couldn't be loaded
directly from fs.  Hence it's useful for loading optional firmwares, which
aren't always present, without extra long timeouts of udev.</p>
</div>
</section>
<section id="request-firmware-into-buf">
<h3>request_firmware_into_buf<a class="headerlink" href="#request-firmware-into-buf" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.request_firmware_into_buf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">request_firmware_into_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">firmware</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">firmware_p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.request_firmware_into_buf" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_into_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>load firmware into a previously allocated buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**firmware_p</span></code></dt><dd><p>pointer to firmware image</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of firmware file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>device for which firmware is being loaded and DMA region allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>address of buffer to load firmware into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a>, but it doesn't
allocate a buffer to hold the firmware data. Instead, the firmware
is loaded directly into the buffer pointed to by <strong>buf</strong> and the <strong>firmware_p</strong>
data member is pointed at <strong>buf</strong>.</p>
<p>This function doesn't cache firmware either.</p>
</div>
</section>
</section>
<section id="asynchronous-firmware-requests">
<h2>Asynchronous firmware requests<a class="headerlink" href="#asynchronous-firmware-requests" title="Permalink to this heading">¶</a></h2>
<p>Asynchronous firmware requests allow driver code to not have to wait
until the firmware or an error is returned. Function callbacks are
provided so that when the firmware or an error is found the driver is
informed through the callback. <a class="reference internal" href="#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> cannot be called
in atomic contexts.</p>
<section id="request-firmware-nowait">
<h3>request_firmware_nowait<a class="headerlink" href="#request-firmware-nowait" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.request_firmware_nowait">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">request_firmware_nowait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.request_firmware_nowait" title="module"><span class="n"><span class="pre">module</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">module</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">uevent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.request_firmware_nowait" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cont</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">firmware</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fw</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_nowait" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>asynchronous version of request_firmware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>module requesting the firmware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">uevent</span></code></dt><dd><p>sends uevent to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of firmware file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>device for which firmware is being loaded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*context</span></code></dt><dd><p>will be passed over to <strong>cont</strong>, and
<strong>fw</strong> may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if firmware request fails.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*cont)(const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">*fw,</span> <span class="pre">void</span> <span class="pre">*context)</span></code></dt><dd><p>function will be called asynchronously when the firmware
request is over.</p>
<p>Caller must hold the reference count of <strong>device</strong>.</p>
<dl class="simple">
<dt>Asynchronous variant of request_firmware() for user contexts:</dt><dd><ul class="simple">
<li><p>sleep for as small periods as possible since it may
increase kernel boot time of built-in device drivers
requesting firmware in their -&gt;probe() methods, if
<strong>gfp</strong> is GFP_KERNEL.</p></li>
<li><p>can't sleep at all if <strong>gfp</strong> is GFP_ATOMIC.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</div>
</section>
</section>
<section id="special-optimizations-on-reboot">
<h2>Special optimizations on reboot<a class="headerlink" href="#special-optimizations-on-reboot" title="Permalink to this heading">¶</a></h2>
<p>Some devices have an optimization in place to enable the firmware to be
retained during system reboot. When such optimizations are used the driver
author must ensure the firmware is still available on resume from suspend,
this can be done with <a class="reference internal" href="#c.firmware_request_cache" title="firmware_request_cache"><code class="xref c c-func docutils literal notranslate"><span class="pre">firmware_request_cache()</span></code></a> instead of requesting for the
firmware to be loaded.</p>
<section id="firmware-request-cache">
<h3>firmware_request_cache()<a class="headerlink" href="#firmware-request-cache" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.firmware_request_cache">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">firmware_request_cache</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.firmware_request_cache" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_cache" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cache firmware for suspend so resume can use it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>device for which firmware should be cached for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of firmware file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There are some devices with an optimization that enables the device to not
require loading firmware on system reboot. This optimization may still
require the firmware present on resume from suspend. This routine can be
used to ensure the firmware is present on resume from suspend in these
situations. This helper is not compatible with drivers which use
<a class="reference internal" href="#c.request_firmware_into_buf" title="request_firmware_into_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_into_buf()</span></code></a> or <a class="reference internal" href="#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware_nowait()</span></code></a> with no uevent set.</p>
</div>
</section>
</section>
<section id="request-firmware-api-expected-driver-use">
<h2>request firmware API expected driver use<a class="headerlink" href="#request-firmware-api-expected-driver-use" title="Permalink to this heading">¶</a></h2>
<p>Once an API call returns you process the firmware and then release the
firmware. For example if you used <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a> and it returns,
the driver has the firmware image accessible in fw_entry-&gt;{data,size}.
If something went wrong <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_firmware()</span></code></a> returns non-zero and fw_entry
is set to NULL. Once your driver is done with processing the firmware it
can call release_firmware(fw_entry) to release the firmware image
and any related resource.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/firmware/request_firmware.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>