<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>XZ data compression in Linux &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Translations" href="../translations/index.html" />
    <link rel="prev" title="Static Keys" href="static-keys.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.13.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Unsorted documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="crc32.html">Brief tutorial on CRC computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="lzo.html">LZO stream format as understood by Linux’s LZO decompressor</a></li>
<li class="toctree-l2"><a class="reference internal" href="magic-number.html">Linux magic numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="remoteproc.html">Remote Processor Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="rpmsg.html">Remote Processor Messaging (rpmsg) Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="speculation.html">Speculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="speculation.html#mitigating-speculation-side-channels">Mitigating speculation side-channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="static-keys.html">Static Keys</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">XZ data compression in Linux</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xz-related-components-in-the-kernel">XZ related components in the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notes-on-compression-options">Notes on compression options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xz-dec-api">xz_dec API</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/staging/xz.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../translations/zh_CN/staging/xz.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="xz-data-compression-in-linux">
<h1>XZ data compression in Linux<a class="headerlink" href="#xz-data-compression-in-linux" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>XZ is a general purpose data compression format with high compression
ratio. The XZ decompressor in Linux is called XZ Embedded. It supports
the LZMA2 filter and optionally also Branch/Call/Jump (BCJ) filters
for executable code. CRC32 is supported for integrity checking.</p>
<p>See the <a class="reference external" href="https://tukaani.org/xz/embedded.html">XZ Embedded</a> home page for the latest version which includes
a few optional extra features that aren’t required in the Linux kernel
and information about using the code outside the Linux kernel.</p>
<p>For userspace, <a class="reference external" href="https://tukaani.org/xz/">XZ Utils</a> provide a zlib-like compression library
and a gzip-like command line tool.</p>
</section>
<section id="xz-related-components-in-the-kernel">
<h2>XZ related components in the kernel<a class="headerlink" href="#xz-related-components-in-the-kernel" title="Link to this heading">¶</a></h2>
<p>The xz_dec module provides XZ decompressor with single-call (buffer
to buffer) and multi-call (stateful) APIs in include/linux/xz.h.</p>
<p>For decompressing the kernel image, initramfs, and initrd, there
is a wrapper function in lib/decompress_unxz.c. Its API is the
same as in other decompress_*.c files, which is defined in
include/linux/decompress/generic.h.</p>
<p>For kernel makefiles, three commands are provided for use with
<code class="docutils literal notranslate"><span class="pre">$(call</span> <span class="pre">if_changed)</span></code>. They require the xz tool from XZ Utils.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$(call</span> <span class="pre">if_changed,xzkern)</span></code> is for compressing the kernel image.
It runs the script scripts/xz_wrap.sh which uses arch-optimized
options and a big LZMA2 dictionary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$(call</span> <span class="pre">if_changed,xzkern_with_size)</span></code> is like <code class="docutils literal notranslate"><span class="pre">xzkern</span></code> above but
this also appends a four-byte trailer containing the uncompressed size
of the file. The trailer is needed by the boot code on some archs.</p></li>
<li><p>Other things can be compressed with <code class="docutils literal notranslate"><span class="pre">$(call</span> <span class="pre">if_needed,xzmisc)</span></code>
which will use no BCJ filter and 1 MiB LZMA2 dictionary.</p></li>
</ul>
</section>
<section id="notes-on-compression-options">
<h2>Notes on compression options<a class="headerlink" href="#notes-on-compression-options" title="Link to this heading">¶</a></h2>
<p>Since the XZ Embedded supports only streams with CRC32 or no integrity
check, make sure that you don’t use some other integrity check type
when encoding files that are supposed to be decoded by the kernel.
With liblzma from XZ Utils, you need to use either <code class="docutils literal notranslate"><span class="pre">LZMA_CHECK_CRC32</span></code>
or <code class="docutils literal notranslate"><span class="pre">LZMA_CHECK_NONE</span></code> when encoding. With the <code class="docutils literal notranslate"><span class="pre">xz</span></code> command line tool,
use <code class="docutils literal notranslate"><span class="pre">--check=crc32</span></code> or <code class="docutils literal notranslate"><span class="pre">--check=none</span></code> to override the default
<code class="docutils literal notranslate"><span class="pre">--check=crc64</span></code>.</p>
<p>Using CRC32 is strongly recommended unless there is some other layer
which will verify the integrity of the uncompressed data anyway.
Double checking the integrity would probably be waste of CPU cycles.
Note that the headers will always have a CRC32 which will be validated
by the decoder; you can only change the integrity check type (or
disable it) for the actual uncompressed data.</p>
<p>In userspace, LZMA2 is typically used with dictionary sizes of several
megabytes. The decoder needs to have the dictionary in RAM:</p>
<ul class="simple">
<li><p>In multi-call mode the dictionary is allocated as part of the
decoder state. The reasonable maximum dictionary size for in-kernel
use will depend on the target hardware: a few megabytes is fine for
desktop systems while 64 KiB to 1 MiB might be more appropriate on
some embedded systems.</p></li>
<li><p>In single-call mode the output buffer is used as the dictionary
buffer. That is, the size of the dictionary doesn’t affect the
decompressor memory usage at all. Only the base data structures
are allocated which take a little less than 30 KiB of memory.
For the best compression, the dictionary should be at least
as big as the uncompressed data. A notable example of single-call
mode is decompressing the kernel itself (except on PowerPC).</p></li>
</ul>
<p>The compression presets in XZ Utils may not be optimal when creating
files for the kernel, so don’t hesitate to use custom settings to,
for example, set the dictionary size. Also, xz may produce a smaller
file in single-threaded mode so setting that explicitly is recommended.
Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xz --threads=1 --check=crc32 --lzma2=dict=512KiB inputfile
</pre></div>
</div>
</section>
<section id="xz-dec-api">
<h2>xz_dec API<a class="headerlink" href="#xz-dec-api" title="Link to this heading">¶</a></h2>
<p>This is available with <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;linux/xz.h&gt;</span></code>.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.xz_mode">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_mode</span></span></span><a class="headerlink" href="#c.xz_mode" title="Link to this definition">¶</a><br /></dt>
<dd><p>Operation mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">XZ_SINGLE</span></code></dt><dd><p>Single-call mode. This uses less RAM than
multi-call modes, because the LZMA2
dictionary doesn’t need to be allocated as
part of the decoder state. All required data
structures are allocated at initialization,
so <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a> cannot return XZ_MEM_ERROR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_PREALLOC</span></code></dt><dd><p>Multi-call mode with preallocated LZMA2
dictionary buffer. All data structures are
allocated at initialization, so <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a>
cannot return XZ_MEM_ERROR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_DYNALLOC</span></code></dt><dd><p>Multi-call mode. The LZMA2 dictionary is
allocated once the required size has been
parsed from the stream headers. If the
allocation fails, <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a> will return
XZ_MEM_ERROR.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>It is possible to enable support only for a subset of the above
modes at compile time by defining XZ_DEC_SINGLE, XZ_DEC_PREALLOC,
or XZ_DEC_DYNALLOC. The xz_dec kernel module is always compiled
with support for all operation modes, but the preboot code may
be built with fewer features to minimize code size.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.xz_ret">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_ret</span></span></span><a class="headerlink" href="#c.xz_ret" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return codes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">XZ_OK</span></code></dt><dd><p>Everything is OK so far. More input or more
output space is required to continue. This
return code is possible only in multi-call mode
(XZ_PREALLOC or XZ_DYNALLOC).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_STREAM_END</span></code></dt><dd><p>Operation finished successfully.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_UNSUPPORTED_CHECK</span></code></dt><dd><p>Integrity check type is not supported. Decoding
is still possible in multi-call mode by simply
calling <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a> again.
Note that this return value is used only if
XZ_DEC_ANY_CHECK was defined at build time,
which is not used in the kernel. Unsupported
check types return XZ_OPTIONS_ERROR if
XZ_DEC_ANY_CHECK was not defined at build time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_MEM_ERROR</span></code></dt><dd><p>Allocating memory failed. This return code is
possible only if the decoder was initialized
with XZ_DYNALLOC. The amount of memory that was
tried to be allocated was no more than the
dict_max argument given to <a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_MEMLIMIT_ERROR</span></code></dt><dd><p>A bigger LZMA2 dictionary would be needed than
allowed by the dict_max argument given to
<a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a>. This return value is possible
only in multi-call mode (XZ_PREALLOC or
XZ_DYNALLOC); the single-call mode (XZ_SINGLE)
ignores the dict_max argument.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_FORMAT_ERROR</span></code></dt><dd><p>File format was not recognized (wrong magic
bytes).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_OPTIONS_ERROR</span></code></dt><dd><p>This implementation doesn’t support the requested
compression options. In the decoder this means
that the header CRC32 matches, but the header
itself specifies something that we don’t support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_DATA_ERROR</span></code></dt><dd><p>Compressed data is corrupt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">XZ_BUF_ERROR</span></code></dt><dd><p>Cannot make any progress. Details are slightly
different between multi-call and single-call
mode; more information below.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>In multi-call mode, XZ_BUF_ERROR is returned when two consecutive calls
to XZ code cannot consume any input and cannot produce any new output.
This happens when there is no new input available, or the output buffer
is full while at least one output byte is still pending. Assuming your
code is not buggy, you can get this error only when decoding a compressed
stream that is truncated or otherwise corrupt.</p>
<p>In single-call mode, XZ_BUF_ERROR is returned only when the output buffer
is too small or the compressed input is corrupt in a way that makes the
decoder produce more output than the caller expected. When it is
(relatively) clear that the compressed input is truncated, XZ_DATA_ERROR
is used instead of XZ_BUF_ERROR.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.xz_buf">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_buf</span></span></span><a class="headerlink" href="#c.xz_buf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Passing input and output buffers to XZ code</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xz_buf {
    const uint8_t *in;
    size_t in_pos;
    size_t in_size;
    uint8_t *out;
    size_t out_pos;
    size_t out_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">in</span></code></dt><dd><p>Beginning of the input buffer. This may be NULL if and only
if in_pos is equal to in_size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in_pos</span></code></dt><dd><p>Current position in the input buffer. This must not exceed
in_size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in_size</span></code></dt><dd><p>Size of the input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out</span></code></dt><dd><p>Beginning of the output buffer. This may be NULL if and only
if out_pos is equal to out_size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_pos</span></code></dt><dd><p>Current position in the output buffer. This must not exceed
out_size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_size</span></code></dt><dd><p>Size of the output buffer</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Only the contents of the output buffer from out[out_pos] onward, and
the variables in_pos and out_pos are modified by the XZ code.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.xz_dec_init">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xz_dec</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">xz_dec_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.xz_mode" title="xz_mode"><span class="n"><span class="pre">xz_mode</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">dict_max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xz_dec_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate and initialize a XZ decoder state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xz_mode</span> <span class="pre">mode</span></code></dt><dd><p>Operation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">dict_max</span></code></dt><dd><p>Maximum size of the LZMA2 dictionary (history buffer) for
multi-call decoding. This is ignored in single-call mode
(mode == XZ_SINGLE). LZMA2 dictionary is always 2^n bytes
or 2^n + 2^(n-1) bytes (the latter sizes are less common
in practice), so other values for dict_max don’t make sense.
In the kernel, dictionary sizes of 64 KiB, 128 KiB, 256 KiB,
512 KiB, and 1 MiB are probably the only reasonable values,
except for kernel and initramfs images where a bigger
dictionary can be fine and useful.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Single-call mode (XZ_SINGLE): <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a> decodes the whole stream at
once. The caller must provide enough output space or the decoding will
fail. The output space is used as the dictionary buffer, which is why
there is no need to allocate the dictionary as part of the decoder’s
internal state.</p>
<p>Because the output buffer is used as the workspace, streams encoded using
a big dictionary are not a problem in single-call mode. It is enough that
the output buffer is big enough to hold the actual uncompressed data; it
can be smaller than the dictionary size stored in the stream headers.</p>
<p>Multi-call mode with preallocated dictionary (XZ_PREALLOC): dict_max bytes
of memory is preallocated for the LZMA2 dictionary. This way there is no
risk that <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a> could run out of memory, since <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a> will
never allocate any memory. Instead, if the preallocated dictionary is too
small for decoding the given input stream, <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a> will return
XZ_MEMLIMIT_ERROR. Thus, it is important to know what kind of data will be
decoded to avoid allocating excessive amount of memory for the dictionary.</p>
<p>Multi-call mode with dynamically allocated dictionary (XZ_DYNALLOC):
dict_max specifies the maximum allowed dictionary size that <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a>
may allocate once it has parsed the dictionary size from the stream
headers. This way excessive allocations can be avoided while still
limiting the maximum memory usage to a sane value to prevent running the
system out of memory when decompressing streams from untrusted sources.</p>
<p>On success, <a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a> returns a pointer to struct xz_dec, which is
ready to be used with <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a>. If memory allocation fails,
<a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a> returns NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xz_dec_run">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.xz_ret" title="xz_ret"><span class="n"><span class="pre">xz_ret</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_dec_run</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xz_dec</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xz_buf" title="xz_buf"><span class="n"><span class="pre">xz_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xz_dec_run" title="Link to this definition">¶</a><br /></dt>
<dd><p>Run the XZ decoder</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xz_dec</span> <span class="pre">*s</span></code></dt><dd><p>Decoder state allocated using <a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xz_buf</span> <span class="pre">*b</span></code></dt><dd><p>Input and output buffers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The possible return values depend on build options and operation mode.
See <a class="reference internal" href="#c.xz_ret" title="xz_ret"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xz_ret</span></code></a> for details.</p>
<p>Note that if an error occurs in single-call mode (return value is not
XZ_STREAM_END), b-&gt;in_pos and b-&gt;out_pos are not modified and the
contents of the output buffer from b-&gt;out[b-&gt;out_pos] onward are
undefined. This is true even after XZ_BUF_ERROR, because with some filter
chains, there may be a second pass over the output buffer, and this pass
cannot be properly done if the output buffer is truncated. Thus, you
cannot give the single-call decoder a too small buffer and then expect to
get that amount valid data from the beginning of the stream. You must use
the multi-call decoder if you don’t want to uncompress the whole stream.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xz_dec_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_dec_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xz_dec</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xz_dec_reset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reset an already allocated decoder state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xz_dec</span> <span class="pre">*s</span></code></dt><dd><p>Decoder state allocated using <a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to reset the multi-call decoder state without
freeing and reallocating memory with <a class="reference internal" href="#c.xz_dec_end" title="xz_dec_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_end()</span></code></a> and <a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a>.</p>
<p>In single-call mode, <a class="reference internal" href="#c.xz_dec_reset" title="xz_dec_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_reset()</span></code></a> is always called in the beginning of
<a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a>. Thus, explicit call to <a class="reference internal" href="#c.xz_dec_reset" title="xz_dec_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_reset()</span></code></a> is useful only in
multi-call mode.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xz_dec_end">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_dec_end</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xz_dec</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xz_dec_end" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free the memory allocated for the decoder state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xz_dec</span> <span class="pre">*s</span></code></dt><dd><p>Decoder state allocated using <a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a>. If s is NULL,
this function does nothing.</p>
</dd>
</dl>
</div>
<p id="microlzma-decompressor"><strong>MicroLZMA decompressor</strong></p>
<p>This MicroLZMA header format was created for use in EROFS but may be used
by others too. <strong>In most cases one needs the XZ APIs above instead.</strong></p>
<p>The compressed format supported by this decoder is a raw LZMA stream
whose first byte (always 0x00) has been replaced with bitwise-negation
of the LZMA properties (lc/lp/pb) byte. For example, if lc/lp/pb is
3/0/2, the first byte is 0xA2. This way the first byte can never be 0x00.
Just like with LZMA2, lc + lp &lt;= 4 must be true. The LZMA end-of-stream
marker must not be used. The unused values are reserved for future use.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.xz_dec_microlzma_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xz_dec_microlzma</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">xz_dec_microlzma_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.xz_mode" title="xz_mode"><span class="n"><span class="pre">xz_mode</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">dict_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xz_dec_microlzma_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate memory for the MicroLZMA decoder</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xz_mode</span> <span class="pre">mode</span></code></dt><dd><p>XZ_SINGLE or XZ_PREALLOC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">dict_size</span></code></dt><dd><p>LZMA dictionary size. This must be at least 4 KiB and
at most 3 GiB.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In contrast to <a class="reference internal" href="#c.xz_dec_init" title="xz_dec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_init()</span></code></a>, this function only allocates the memory
and remembers the dictionary size. <a class="reference internal" href="#c.xz_dec_microlzma_reset" title="xz_dec_microlzma_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_microlzma_reset()</span></code></a> must be used
before calling <a class="reference internal" href="#c.xz_dec_microlzma_run" title="xz_dec_microlzma_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_microlzma_run()</span></code></a>.</p>
<p>The amount of allocated memory is a little less than 30 KiB with XZ_SINGLE.
With XZ_PREALLOC also a dictionary buffer of dict_size bytes is allocated.</p>
<p>On success, <a class="reference internal" href="#c.xz_dec_microlzma_alloc" title="xz_dec_microlzma_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_microlzma_alloc()</span></code></a> returns a pointer to
struct xz_dec_microlzma. If memory allocation fails or
dict_size is invalid, NULL is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xz_dec_microlzma_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_dec_microlzma_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xz_dec_microlzma</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">comp_size</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">uncomp_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">uncomp_size_is_exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xz_dec_microlzma_reset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reset the MicroLZMA decoder state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xz_dec_microlzma</span> <span class="pre">*s</span></code></dt><dd><p>Decoder state allocated using <a class="reference internal" href="#c.xz_dec_microlzma_alloc" title="xz_dec_microlzma_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_microlzma_alloc()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">comp_size</span></code></dt><dd><p>Compressed size of the input stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">uncomp_size</span></code></dt><dd><p>Uncompressed size of the input stream. A value smaller
than the real uncompressed size of the input stream can
be specified if uncomp_size_is_exact is set to false.
uncomp_size can never be set to a value larger than the
expected real uncompressed size because it would eventually
result in XZ_DATA_ERROR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">uncomp_size_is_exact</span></code></dt><dd><p>This is an int instead of bool to avoid
requiring stdbool.h. This should normally be set to true.
When this is set to false, error detection is weaker.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xz_dec_microlzma_run">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.xz_ret" title="xz_ret"><span class="n"><span class="pre">xz_ret</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_dec_microlzma_run</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xz_dec_microlzma</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.xz_buf" title="xz_buf"><span class="n"><span class="pre">xz_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xz_dec_microlzma_run" title="Link to this definition">¶</a><br /></dt>
<dd><p>Run the MicroLZMA decoder</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xz_dec_microlzma</span> <span class="pre">*s</span></code></dt><dd><p>Decoder state initialized using <a class="reference internal" href="#c.xz_dec_microlzma_reset" title="xz_dec_microlzma_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_microlzma_reset()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xz_buf</span> <span class="pre">*b</span></code></dt><dd><p>Input and output buffers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This works similarly to <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a> with a few important differences.
Only the differences are documented here.</p>
<p>The only possible return values are XZ_OK, XZ_STREAM_END, and
XZ_DATA_ERROR. This function cannot return XZ_BUF_ERROR: if no progress
is possible due to lack of input data or output space, this function will
keep returning XZ_OK. Thus, the calling code must be written so that it
will eventually provide input and output space matching (or exceeding)
comp_size and uncomp_size arguments given to <a class="reference internal" href="#c.xz_dec_microlzma_reset" title="xz_dec_microlzma_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_microlzma_reset()</span></code></a>.
If the caller cannot do this (for example, if the input file is truncated
or otherwise corrupt), the caller must detect this error by itself to
avoid an infinite loop.</p>
<p>If the compressed data seems to be corrupt, XZ_DATA_ERROR is returned.
This can happen also when incorrect dictionary, uncompressed, or
compressed sizes have been specified.</p>
<p>With XZ_PREALLOC only: As an extra feature, b-&gt;out may be NULL to skip over
uncompressed data. This way the caller doesn’t need to provide a temporary
output buffer for the bytes that will be ignored.</p>
<p>With XZ_SINGLE only: In contrast to <a class="reference internal" href="#c.xz_dec_run" title="xz_dec_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_run()</span></code></a>, the return value XZ_OK
is also possible and thus XZ_SINGLE is actually a limited multi-call mode.
After XZ_OK the bytes decoded so far may be read from the output buffer.
It is possible to continue decoding but the variables b-&gt;out and b-&gt;out_pos
MUST NOT be changed by the caller. Increasing the value of b-&gt;out_size is
allowed to make more output space available; one doesn’t need to provide
space for the whole uncompressed data on the first call. The input buffer
may be changed normally like with XZ_PREALLOC. This way input data can be
provided from non-contiguous memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.xz_dec_microlzma_end">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">xz_dec_microlzma_end</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xz_dec_microlzma</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.xz_dec_microlzma_end" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free the memory allocated for the decoder state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xz_dec_microlzma</span> <span class="pre">*s</span></code></dt><dd><p>Decoder state allocated using <a class="reference internal" href="#c.xz_dec_microlzma_alloc" title="xz_dec_microlzma_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">xz_dec_microlzma_alloc()</span></code></a>.
If s is NULL, this function does nothing.</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/staging/xz.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>