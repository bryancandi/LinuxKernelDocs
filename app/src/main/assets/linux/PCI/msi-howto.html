<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4. The MSI Driver Guide HOWTO &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. Accessing PCI device resources through sysfs" href="sysfs-pci.html" />
    <link rel="prev" title="3. PCI Express I/O Virtualization Howto" href="pci-iov-howto.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.10.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpu-freq/index.html">CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pcmcia/index.html">PCMCIA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../watchdog/index.html">Watchdog Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../virt/index.html">Virtualization Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hwmon/index.html">Hardware Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accel/index.html">Compute Accelerators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">PCI Bus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../peci/index.html">PECI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi/index.html">WMI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tee/index.html">TEE Subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/PCI/msi-howto.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../translations/zh_CN/PCI/msi-howto.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="the-msi-driver-guide-howto">
<h1><span class="section-number">4. </span>The MSI Driver Guide HOWTO<a class="headerlink" href="#the-msi-driver-guide-howto" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Authors<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tom L Nguyen; Martine Silbermann; Matthew Wilcox</p>
</dd>
<dt class="field-even">Copyright<span class="colon">:</span></dt>
<dd class="field-even"><p>2003, 2008 Intel Corporation</p>
</dd>
</dl>
<section id="about-this-guide">
<h2><span class="section-number">4.1. </span>About this guide<a class="headerlink" href="#about-this-guide" title="Link to this heading">¶</a></h2>
<p>This guide describes the basics of Message Signaled Interrupts (MSIs),
the advantages of using MSI over traditional interrupt mechanisms, how
to change your driver to use MSI or MSI-X and some basic diagnostics to
try if a device doesn’t support MSIs.</p>
</section>
<section id="what-are-msis">
<h2><span class="section-number">4.2. </span>What are MSIs?<a class="headerlink" href="#what-are-msis" title="Link to this heading">¶</a></h2>
<p>A Message Signaled Interrupt is a write from the device to a special
address which causes an interrupt to be received by the CPU.</p>
<p>The MSI capability was first specified in PCI 2.2 and was later enhanced
in PCI 3.0 to allow each interrupt to be masked individually.  The MSI-X
capability was also introduced with PCI 3.0.  It supports more interrupts
per device than MSI and allows interrupts to be independently configured.</p>
<p>Devices may support both MSI and MSI-X, but only one can be enabled at
a time.</p>
</section>
<section id="why-use-msis">
<h2><span class="section-number">4.3. </span>Why use MSIs?<a class="headerlink" href="#why-use-msis" title="Link to this heading">¶</a></h2>
<p>There are three reasons why using MSIs can give an advantage over
traditional pin-based interrupts.</p>
<p>Pin-based PCI interrupts are often shared amongst several devices.
To support this, the kernel must call each interrupt handler associated
with an interrupt, which leads to reduced performance for the system as
a whole.  MSIs are never shared, so this problem cannot arise.</p>
<p>When a device writes data to memory, then raises a pin-based interrupt,
it is possible that the interrupt may arrive before all the data has
arrived in memory (this becomes more likely with devices behind PCI-PCI
bridges).  In order to ensure that all the data has arrived in memory,
the interrupt handler must read a register on the device which raised
the interrupt.  PCI transaction ordering rules require that all the data
arrive in memory before the value may be returned from the register.
Using MSIs avoids this problem as the interrupt-generating write cannot
pass the data writes, so by the time the interrupt is raised, the driver
knows that all the data has arrived in memory.</p>
<p>PCI devices can only support a single pin-based interrupt per function.
Often drivers have to query the device to find out what event has
occurred, slowing down interrupt handling for the common case.  With
MSIs, a device can support more interrupts, allowing each interrupt
to be specialised to a different purpose.  One possible design gives
infrequent conditions (such as errors) their own interrupt which allows
the driver to handle the normal interrupt handling path more efficiently.
Other possible designs include giving one interrupt to each packet queue
in a network card or each port in a storage controller.</p>
</section>
<section id="how-to-use-msis">
<h2><span class="section-number">4.4. </span>How to use MSIs<a class="headerlink" href="#how-to-use-msis" title="Link to this heading">¶</a></h2>
<p>PCI devices are initialised to use pin-based interrupts.  The device
driver has to set up the device to use MSI or MSI-X.  Not all machines
support MSIs correctly, and for those machines, the APIs described below
will simply fail and the device will continue to use pin-based interrupts.</p>
<section id="include-kernel-support-for-msis">
<h3><span class="section-number">4.4.1. </span>Include kernel support for MSIs<a class="headerlink" href="#include-kernel-support-for-msis" title="Link to this heading">¶</a></h3>
<p>To support MSI or MSI-X, the kernel must be built with the CONFIG_PCI_MSI
option enabled.  This option is only available on some architectures,
and it may depend on some other options also being set.  For example,
on x86, you must also enable X86_UP_APIC or SMP in order to see the
CONFIG_PCI_MSI option.</p>
</section>
<section id="using-msi">
<h3><span class="section-number">4.4.2. </span>Using MSI<a class="headerlink" href="#using-msi" title="Link to this heading">¶</a></h3>
<p>Most of the hard work is done for the driver in the PCI layer.  The driver
simply has to request that the PCI layer set up the MSI capability for this
device.</p>
<p>To automatically use MSI or MSI-X interrupt vectors, use the following
function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs,
              unsigned int max_vecs, unsigned int flags);
</pre></div>
</div>
<p>which allocates up to max_vecs interrupt vectors for a PCI device.  It
returns the number of vectors allocated or a negative error.  If the device
has a requirements for a minimum number of vectors the driver can pass a
min_vecs argument set to this limit, and the PCI core will return -ENOSPC
if it can’t meet the minimum number of vectors.</p>
<p>The flags argument is used to specify which type of interrupt can be used
by the device and the driver (PCI_IRQ_INTX, PCI_IRQ_MSI, PCI_IRQ_MSIX).
A convenient short-hand (PCI_IRQ_ALL_TYPES) is also available to ask for
any possible kind of interrupt.  If the PCI_IRQ_AFFINITY flag is set,
<a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> will spread the interrupts around the available CPUs.</p>
<p>To get the Linux IRQ numbers passed to <a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> and <a class="reference internal" href="../core-api/genericirq.html#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a> and the
vectors, use the following function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pci_irq_vector(struct pci_dev *dev, unsigned int nr);
</pre></div>
</div>
<p>Any allocated resources should be freed before removing the device using
the following function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void pci_free_irq_vectors(struct pci_dev *dev);
</pre></div>
</div>
<p>If a device supports both MSI-X and MSI capabilities, this API will use the
MSI-X facilities in preference to the MSI facilities.  MSI-X supports any
number of interrupts between 1 and 2048.  In contrast, MSI is restricted to
a maximum of 32 interrupts (and must be a power of two).  In addition, the
MSI interrupt vectors must be allocated consecutively, so the system might
not be able to allocate as many vectors for MSI as it could for MSI-X.  On
some platforms, MSI interrupts must all be targeted at the same set of CPUs
whereas MSI-X interrupts can all be targeted at different CPUs.</p>
<p>If a device supports neither MSI-X or MSI it will fall back to a single
legacy IRQ vector.</p>
<p>The typical usage of MSI or MSI-X interrupts is to allocate as many vectors
as possible, likely up to the limit supported by the device.  If nvec is
larger than the number supported by the device it will automatically be
capped to the supported limit, so there is no need to query the number of
vectors supported beforehand:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nvec = pci_alloc_irq_vectors(pdev, 1, nvec, PCI_IRQ_ALL_TYPES)
if (nvec &lt; 0)
        goto out_err;
</pre></div>
</div>
<p>If a driver is unable or unwilling to deal with a variable number of MSI
interrupts it can request a particular number of interrupts by passing that
number to <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> function as both ‘min_vecs’ and
‘max_vecs’ parameters:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ret = pci_alloc_irq_vectors(pdev, nvec, nvec, PCI_IRQ_ALL_TYPES);
if (ret &lt; 0)
        goto out_err;
</pre></div>
</div>
<p>The most notorious example of the request type described above is enabling
the single MSI mode for a device.  It could be done by passing two 1s as
‘min_vecs’ and ‘max_vecs’:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);
if (ret &lt; 0)
        goto out_err;
</pre></div>
</div>
<p>Some devices might not support using legacy line interrupts, in which case
the driver can specify that only MSI or MSI-X is acceptable:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nvec = pci_alloc_irq_vectors(pdev, 1, nvec, PCI_IRQ_MSI | PCI_IRQ_MSIX);
if (nvec &lt; 0)
        goto out_err;
</pre></div>
</div>
</section>
<section id="legacy-apis">
<h3><span class="section-number">4.4.3. </span>Legacy APIs<a class="headerlink" href="#legacy-apis" title="Link to this heading">¶</a></h3>
<p>The following old APIs to enable and disable MSI or MSI-X interrupts should
not be used in new code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pci_enable_msi()              /* deprecated */
pci_disable_msi()             /* deprecated */
pci_enable_msix_range()       /* deprecated */
pci_enable_msix_exact()       /* deprecated */
pci_disable_msix()            /* deprecated */
</pre></div>
</div>
<p>Additionally there are APIs to provide the number of supported MSI or MSI-X
vectors: <a class="reference internal" href="../driver-api/pci/pci.html#c.pci_msi_vec_count" title="pci_msi_vec_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_msi_vec_count()</span></code></a> and <a class="reference internal" href="#c.pci_msix_vec_count" title="pci_msix_vec_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_msix_vec_count()</span></code></a>.  In general these
should be avoided in favor of letting <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> cap the
number of vectors.  If you have a legitimate special use case for the count
of vectors we might have to revisit that decision and add a
pci_nr_irq_vectors() helper that handles MSI and MSI-X transparently.</p>
</section>
<section id="considerations-when-using-msis">
<h3><span class="section-number">4.4.4. </span>Considerations when using MSIs<a class="headerlink" href="#considerations-when-using-msis" title="Link to this heading">¶</a></h3>
<section id="spinlocks">
<h4><span class="section-number">4.4.4.1. </span>Spinlocks<a class="headerlink" href="#spinlocks" title="Link to this heading">¶</a></h4>
<p>Most device drivers have a per-device spinlock which is taken in the
interrupt handler.  With pin-based interrupts or a single MSI, it is not
necessary to disable interrupts (Linux guarantees the same interrupt will
not be re-entered).  If a device uses multiple interrupts, the driver
must disable interrupts while the lock is held.  If the device sends
a different interrupt, the driver will deadlock trying to recursively
acquire the spinlock.  Such deadlocks can be avoided by using
spin_lock_irqsave() or spin_lock_irq() which disable local interrupts
and acquire the lock (see <a class="reference internal" href="../kernel-hacking/locking.html"><span class="doc">Unreliable Guide To Locking</span></a>).</p>
</section>
</section>
<section id="how-to-tell-whether-msi-msi-x-is-enabled-on-a-device">
<h3><span class="section-number">4.4.5. </span>How to tell whether MSI/MSI-X is enabled on a device<a class="headerlink" href="#how-to-tell-whether-msi-msi-x-is-enabled-on-a-device" title="Link to this heading">¶</a></h3>
<p>Using ‘lspci -v’ (as root) may show some devices with “MSI”, “Message
Signalled Interrupts” or “MSI-X” capabilities.  Each of these capabilities
has an ‘Enable’ flag which is followed with either “+” (enabled)
or “-” (disabled).</p>
</section>
</section>
<section id="msi-quirks">
<h2><span class="section-number">4.5. </span>MSI quirks<a class="headerlink" href="#msi-quirks" title="Link to this heading">¶</a></h2>
<p>Several PCI chipsets or devices are known not to support MSIs.
The PCI stack provides three ways to disable MSIs:</p>
<ol class="arabic simple">
<li><p>globally</p></li>
<li><p>on all devices behind a specific bridge</p></li>
<li><p>on a single device</p></li>
</ol>
<section id="disabling-msis-globally">
<h3><span class="section-number">4.5.1. </span>Disabling MSIs globally<a class="headerlink" href="#disabling-msis-globally" title="Link to this heading">¶</a></h3>
<p>Some host chipsets simply don’t support MSIs properly.  If we’re
lucky, the manufacturer knows this and has indicated it in the ACPI
FADT table.  In this case, Linux automatically disables MSIs.
Some boards don’t include this information in the table and so we have
to detect them ourselves.  The complete list of these is found near the
quirk_disable_all_msi() function in drivers/pci/quirks.c.</p>
<p>If you have a board which has problems with MSIs, you can pass pci=nomsi
on the kernel command line to disable MSIs on all devices.  It would be
in your best interests to report the problem to <a class="reference external" href="mailto:linux-pci&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-pci<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>
including a full ‘lspci -v’ so we can add the quirks to the kernel.</p>
</section>
<section id="disabling-msis-below-a-bridge">
<h3><span class="section-number">4.5.2. </span>Disabling MSIs below a bridge<a class="headerlink" href="#disabling-msis-below-a-bridge" title="Link to this heading">¶</a></h3>
<p>Some PCI bridges are not able to route MSIs between buses properly.
In this case, MSIs must be disabled on all devices behind the bridge.</p>
<p>Some bridges allow you to enable MSIs by changing some bits in their
PCI configuration space (especially the Hypertransport chipsets such
as the nVidia nForce and Serverworks HT2000).  As with host chipsets,
Linux mostly knows about them and automatically enables MSIs if it can.
If you have a bridge unknown to Linux, you can enable
MSIs in configuration space using whatever method you know works, then
enable MSIs on that bridge by doing:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 1 &gt; /sys/bus/pci/devices/$bridge/msi_bus
</pre></div>
</div>
<p>where $bridge is the PCI address of the bridge you’ve enabled (eg
0000:00:0e.0).</p>
<p>To disable MSIs, echo 0 instead of 1.  Changing this value should be
done with caution as it could break interrupt handling for all devices
below this bridge.</p>
<p>Again, please notify <a class="reference external" href="mailto:linux-pci&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-pci<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a> of any bridges that need
special handling.</p>
</section>
<section id="disabling-msis-on-a-single-device">
<h3><span class="section-number">4.5.3. </span>Disabling MSIs on a single device<a class="headerlink" href="#disabling-msis-on-a-single-device" title="Link to this heading">¶</a></h3>
<p>Some devices are known to have faulty MSI implementations.  Usually this
is handled in the individual device driver, but occasionally it’s necessary
to handle this with a quirk.  Some drivers have an option to disable use
of MSI.  While this is a convenient workaround for the driver author,
it is not good practice, and should not be emulated.</p>
</section>
<section id="finding-why-msis-are-disabled-on-a-device">
<h3><span class="section-number">4.5.4. </span>Finding why MSIs are disabled on a device<a class="headerlink" href="#finding-why-msis-are-disabled-on-a-device" title="Link to this heading">¶</a></h3>
<p>From the above three sections, you can see that there are many reasons
why MSIs may not be enabled for a given device.  Your first step should
be to examine your dmesg carefully to determine whether MSIs are enabled
for your machine.  You should also check your .config to be sure you
have enabled CONFIG_PCI_MSI.</p>
<p>Then, ‘lspci -t’ gives the list of bridges above a device. Reading
<cite>/sys/bus/pci/devices/*/msi_bus</cite> will tell you whether MSIs are enabled (1)
or disabled (0).  If 0 is found in any of the msi_bus files belonging
to bridges between the PCI root and the device, MSIs are disabled.</p>
<p>It is also worth checking the device driver to see whether it supports MSIs.
For example, it may contain calls to <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> with the
PCI_IRQ_MSI or PCI_IRQ_MSIX flags.</p>
</section>
</section>
<section id="list-of-device-drivers-msi-x-apis">
<h2><span class="section-number">4.6. </span>List of device drivers MSI(-X) APIs<a class="headerlink" href="#list-of-device-drivers-msi-x-apis" title="Link to this heading">¶</a></h2>
<p>The PCI/MSI subsystem has a dedicated C file for its exported device driver
APIs — <cite>drivers/pci/msi/api.c</cite>. The following functions are exported:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_enable_msi">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_enable_msi</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_msi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Enable MSI interrupt mode on device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Legacy device driver API to enable MSI interrupts mode on device and
allocate a single interrupt vector. On success, the allocated vector
Linux IRQ will be saved at <strong>dev-&gt;irq</strong>. The driver must invoke
<a class="reference internal" href="#c.pci_disable_msi" title="pci_disable_msi"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_disable_msi()</span></code></a> on cleanup.</p>
<p><strong>NOTE</strong></p>
<p>The newer <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> / <a class="reference internal" href="#c.pci_free_irq_vectors" title="pci_free_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_free_irq_vectors()</span></code></a> API
pair should, in general, be used instead.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_disable_msi">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_disable_msi</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_msi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disable MSI interrupt mode on device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Legacy device driver API to disable MSI interrupt mode on device,
free earlier allocated interrupt vectors, and restore INTx emulation.
The PCI device Linux IRQ (<strong>dev-&gt;irq</strong>) is restored to its default
pin-assertion IRQ. This is the cleanup pair of <a class="reference internal" href="#c.pci_enable_msi" title="pci_enable_msi"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_msi()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>The newer <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> / <a class="reference internal" href="#c.pci_free_irq_vectors" title="pci_free_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_free_irq_vectors()</span></code></a> API
pair should, in general, be used instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_msix_vec_count">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_msix_vec_count</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msix_vec_count" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get number of MSI-X interrupt vectors on device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of MSI-X interrupt vectors available on this device
(i.e., the device’s MSI-X capability structure “table size”), -EINVAL
if the device is not MSI-X capable, other errnos otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_enable_msix_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_enable_msix_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msix_entry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entries</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">minvec</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">maxvec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_msix_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Enable MSI-X interrupt mode on device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msix_entry</span> <span class="pre">*entries</span></code></dt><dd><p>input/output parameter, array of MSI-X configuration entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">minvec</span></code></dt><dd><p>minimum required number of MSI-X vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">maxvec</span></code></dt><dd><p>maximum desired number of MSI-X vectors</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Legacy device driver API to enable MSI-X interrupt mode on device and
configure its MSI-X capability structure as appropriate.  The passed
<strong>entries</strong> array must have each of its members “entry” field set to a
desired (valid) MSI-X vector number, where the range of valid MSI-X
vector numbers can be queried through <a class="reference internal" href="#c.pci_msix_vec_count" title="pci_msix_vec_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_msix_vec_count()</span></code></a>.  If
successful, the driver must invoke <a class="reference internal" href="#c.pci_disable_msix" title="pci_disable_msix"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_disable_msix()</span></code></a> on cleanup.</p>
<p><strong>NOTE</strong></p>
<p>The newer <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> / <a class="reference internal" href="#c.pci_free_irq_vectors" title="pci_free_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_free_irq_vectors()</span></code></a> API
pair should, in general, be used instead.</p>
<p><strong>Return</strong></p>
<p>number of MSI-X vectors allocated (which might be smaller
than <strong>maxvecs</strong>), where Linux IRQ numbers for such allocated vectors
are saved back in the <strong>entries</strong> array elements’ “vector” field. Return
-ENOSPC if less than <strong>minvecs</strong> interrupt vectors are available.
Return -EINVAL if one of the passed <strong>entries</strong> members “entry” field
was invalid or a duplicate, or if plain MSI interrupts mode was
earlier enabled on device. Return other errnos otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_msix_can_alloc_dyn">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_msix_can_alloc_dyn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msix_can_alloc_dyn" title="Link to this definition">¶</a><br /></dt>
<dd><p>Query whether dynamic allocation after enabling MSI-X is supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if supported, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_msix_alloc_irq_at">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msi_map</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_msix_alloc_irq_at</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../core-api/genericirq.html#c.irq_affinity_desc" title="irq_affinity_desc"><span class="n"><span class="pre">irq_affinity_desc</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">affdesc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msix_alloc_irq_at" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate an MSI-X interrupt after enabling MSI-X at a given MSI-X vector index or any free vector index</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>Index to allocate. If <strong>index</strong> == MSI_ANY_INDEX this allocates
the next free index in the MSI-X table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_affinity_desc</span> <span class="pre">*affdesc</span></code></dt><dd><p>Optional pointer to an affinity descriptor structure. NULL otherwise</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A struct msi_map</p>
<blockquote>
<div><p>On success msi_map::index contains the allocated index (&gt;= 0) and
msi_map::virq contains the allocated Linux interrupt number (&gt; 0).</p>
<p>On fail msi_map::index contains the error code and msi_map::virq
is set to 0.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_msix_free_irq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_msix_free_irq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msi_map</span></span><span class="w"> </span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msix_free_irq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free an interrupt on a PCI/MSIX interrupt domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>The PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msi_map</span> <span class="pre">map</span></code></dt><dd><p>A struct msi_map describing the interrupt to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo an interrupt vector allocation. Does not disable MSI-X.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_disable_msix">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_disable_msix</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_msix" title="Link to this definition">¶</a><br /></dt>
<dd><p>Disable MSI-X interrupt mode on device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Legacy device driver API to disable MSI-X interrupt mode on device,
free earlier-allocated interrupt vectors, and restore INTx.
The PCI device Linux IRQ (<strong>dev-&gt;irq</strong>) is restored to its default pin
assertion IRQ. This is the cleanup pair of <a class="reference internal" href="#c.pci_enable_msix_range" title="pci_enable_msix_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_msix_range()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>The newer <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> / <a class="reference internal" href="#c.pci_free_irq_vectors" title="pci_free_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_free_irq_vectors()</span></code></a> API
pair should, in general, be used instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_alloc_irq_vectors">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_alloc_irq_vectors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min_vecs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_vecs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_alloc_irq_vectors" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate multiple device interrupt vectors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min_vecs</span></code></dt><dd><p>minimum required number of vectors (must be &gt;= 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_vecs</span></code></dt><dd><p>maximum desired number of vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>One or more of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PCI_IRQ_MSIX</span></code>      Allow trying MSI-X vector allocations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PCI_IRQ_MSI</span></code>       Allow trying MSI vector allocations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PCI_IRQ_INTX</span></code>      Allow trying INTx interrupts, if and
only if <strong>min_vecs</strong> == 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PCI_IRQ_AFFINITY</span></code>  Auto-manage IRQs affinity by spreading
the vectors around available CPUs</p></li>
</ul>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate up to <strong>max_vecs</strong> interrupt vectors on device. MSI-X irq
vector allocation has a higher precedence over plain MSI, which has a
higher precedence over legacy INTx emulation.</p>
<p>Upon a successful allocation, the caller should use <a class="reference internal" href="#c.pci_irq_vector" title="pci_irq_vector"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_irq_vector()</span></code></a>
to get the Linux IRQ number to be passed to <a class="reference internal" href="../core-api/genericirq.html#c.request_threaded_irq" title="request_threaded_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_threaded_irq()</span></code></a>.
The driver must call <a class="reference internal" href="#c.pci_free_irq_vectors" title="pci_free_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_free_irq_vectors()</span></code></a> on cleanup.</p>
<p><strong>Return</strong></p>
<p>number of allocated vectors (which might be smaller than
<strong>max_vecs</strong>), -ENOSPC if less than <strong>min_vecs</strong> interrupt vectors are
available, other errnos otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_alloc_irq_vectors_affinity">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_alloc_irq_vectors_affinity</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min_vecs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_vecs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../core-api/genericirq.html#c.irq_affinity" title="irq_affinity"><span class="n"><span class="pre">irq_affinity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">affd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_alloc_irq_vectors_affinity" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate multiple device interrupt vectors with affinity requirements</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min_vecs</span></code></dt><dd><p>minimum required number of vectors (must be &gt;= 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_vecs</span></code></dt><dd><p>maximum desired number of vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>allocation flags, as in <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_affinity</span> <span class="pre">*affd</span></code></dt><dd><p>affinity requirements (can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a>, but with the extra <strong>affd</strong> parameter.
Check that function docs, and <a class="reference internal" href="../core-api/genericirq.html#c.irq_affinity" title="irq_affinity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_affinity</span></code></a>, for more details.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_irq_vector">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_irq_vector</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_irq_vector" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get Linux IRQ number of a device interrupt vector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>device-relative interrupt vector index (0-based); has different
meanings, depending on interrupt mode:</p>
<blockquote>
<div><ul class="simple">
<li><p>MSI-X     the index in the MSI-X vector table</p></li>
<li><p>MSI       the index of the enabled MSI vectors</p></li>
<li><p>INTx      must be 0</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the Linux IRQ number, or -EINVAL if <strong>nr</strong> is out of range</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_irq_get_affinity">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cpumask</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pci_irq_get_affinity</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_irq_get_affinity" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a device interrupt vector affinity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>device-relative interrupt vector index (0-based); has different
meanings, depending on interrupt mode:</p>
<blockquote>
<div><ul class="simple">
<li><p>MSI-X     the index in the MSI-X vector table</p></li>
<li><p>MSI       the index of the enabled MSI vectors</p></li>
<li><p>INTx      must be 0</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>MSI/MSI-X vector affinity, NULL if <strong>nr</strong> is out of range or if
the MSI(-X) vector was allocated without explicit affinity
requirements (e.g., by <a class="reference internal" href="#c.pci_enable_msi" title="pci_enable_msi"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_msi()</span></code></a>, <a class="reference internal" href="#c.pci_enable_msix_range" title="pci_enable_msix_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_msix_range()</span></code></a>, or
<a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a> without the <code class="docutils literal notranslate"><span class="pre">PCI_IRQ_AFFINITY</span></code> flag). Return a
generic set of CPU IDs representing all possible CPUs available
during system boot if the device is in legacy INTx mode.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_free_irq_vectors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_free_irq_vectors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_free_irq_vectors" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free previously allocated IRQs for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo the interrupt vector allocations and possible device MSI/MSI-X
enablement earlier done through <a class="reference internal" href="#c.pci_alloc_irq_vectors_affinity" title="pci_alloc_irq_vectors_affinity"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors_affinity()</span></code></a> or
<a class="reference internal" href="#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_restore_msi_state">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_restore_msi_state</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pci_dev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_restore_msi_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>Restore cached MSI(-X) state on device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write the Linux-cached MSI(-X) state back on device. This is
typically useful upon system resume, or after an error-recovery PCI
adapter reset.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pci_msi_enabled">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pci_msi_enabled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_enabled" title="Link to this definition">¶</a><br /></dt>
<dd><p>Are MSI(-X) interrupts enabled system-wide?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if MSI has not been globally disabled through ACPI FADT,
PCI bridge quirks, or the “pci=nomsi” kernel command-line option.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/PCI/msi-howto.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>