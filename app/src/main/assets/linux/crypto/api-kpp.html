<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Key-agreement Protocol Primitives (KPP) Cipher Algorithm Definitions &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Code Examples" href="api-samples.html" />
    <link rel="prev" title="Asymmetric Cipher Algorithm Definitions" href="api-akcipher.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.11.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpu-freq/index.html">CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pcmcia/index.html">PCMCIA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../watchdog/index.html">Watchdog Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../virt/index.html">Virtualization Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hwmon/index.html">Hardware Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accel/index.html">Compute Accelerators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Crypto API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PCI/index.html">PCI Bus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../peci/index.html">PECI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi/index.html">WMI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tee/index.html">TEE Subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/crypto/api-kpp.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="key-agreement-protocol-primitives-kpp-cipher-algorithm-definitions">
<h1>Key-agreement Protocol Primitives (KPP) Cipher Algorithm Definitions<a class="headerlink" href="#key-agreement-protocol-primitives-kpp-cipher-algorithm-definitions" title="Link to this heading">¶</a></h1>
<dl class="c struct">
<dt class="sig sig-object c" id="c.kpp_request">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kpp_request</span></span></span><a class="headerlink" href="#c.kpp_request" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kpp_request {
    struct crypto_async_request base;
    struct scatterlist *src;
    struct scatterlist *dst;
    unsigned int src_len;
    unsigned int dst_len;
    void *__ctx[] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Common attributes for async crypto requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src</span></code></dt><dd><p>Source data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst</span></code></dt><dd><p>Destination data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_len</span></code></dt><dd><p>Size of the input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst_len</span></code></dt><dd><p>Size of the output buffer. It needs to be at least
as big as the expected result depending on the operation
After operation it will be updated with the actual size of the
result. In case of error where the dst sgl size was insufficient,
it will be updated to the size required for the operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__ctx</span></code></dt><dd><p>Start of private context data</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.crypto_kpp">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_kpp</span></span></span><a class="headerlink" href="#c.crypto_kpp" title="Link to this definition">¶</a><br /></dt>
<dd><p>user-instantiated object which encapsulate algorithms and core processing logic</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct crypto_kpp {
    unsigned int reqsize;
    struct crypto_tfm base;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">reqsize</span></code></dt><dd><p>Request context size required by algorithm
implementation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Common crypto API algorithm data structure</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.kpp_alg">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kpp_alg</span></span></span><a class="headerlink" href="#c.kpp_alg" title="Link to this definition">¶</a><br /></dt>
<dd><p>generic key-agreement protocol primitives</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kpp_alg {
    int (*set_secret)(struct crypto_kpp *tfm, const void *buffer, unsigned int len);
    int (*generate_public_key)(struct kpp_request *req);
    int (*compute_shared_secret)(struct kpp_request *req);
    unsigned int (*max_size)(struct crypto_kpp *tfm);
    int (*init)(struct crypto_kpp *tfm);
    void (*exit)(struct crypto_kpp *tfm);
    struct crypto_alg base;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">set_secret</span></code></dt><dd><p>Function invokes the protocol specific function to
store the secret private key along with parameters.
The implementation knows how to decode the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generate_public_key</span></code></dt><dd><p>Function generate the public key to be sent to the
counterpart. In case of error, where output is not big
enough req-&gt;dst_len will be updated to the size
required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compute_shared_secret</span></code></dt><dd><p>Function compute the shared secret as defined by
the algorithm. The result is given back to the user.
In case of error, where output is not big enough,
req-&gt;dst_len will be updated to the size required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_size</span></code></dt><dd><p>Function returns the size of the output buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init</span></code></dt><dd><p>Initialize the object. This is called only once at
instantiation time. In case the cryptographic hardware
needs to be initialized. Software fallback should be
put in place here.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exit</span></code></dt><dd><p>Undo everything <strong>init</strong> did.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Common crypto API algorithm data structure</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.kpp_secret">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kpp_secret</span></span></span><a class="headerlink" href="#c.kpp_secret" title="Link to this definition">¶</a><br /></dt>
<dd><p>small header for packing secret buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kpp_secret {
    unsigned short type;
    unsigned short len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>define type of secret. Each kpp type will define its own</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>specify the len of the secret, include the header, that
follows the struct</p>
</dd>
</dl>
</div>
</section>
<section id="key-agreement-protocol-primitives-kpp-cipher-api">
<h1>Key-agreement Protocol Primitives (KPP) Cipher API<a class="headerlink" href="#key-agreement-protocol-primitives-kpp-cipher-api" title="Link to this heading">¶</a></h1>
<p>The KPP API is used with the algorithm type
CRYPTO_ALG_TYPE_KPP (listed as type “kpp” in /proc/crypto)</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_alloc_kpp">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp"><span class="n"><span class="pre">crypto_kpp</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">crypto_alloc_kpp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">alg_name</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_alloc_kpp" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate KPP tfm handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*alg_name</span></code></dt><dd><p>is the name of the kpp algorithm (e.g. “dh”, “ecdh”)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt><dd><p>specifies the type of the algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>specifies the mask for the algorithm</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a handle for kpp algorithm. The returned <a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span></code></a>
is required for any following API invocation</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>allocated handle in case of success; IS_ERR() is true in case of</dt><dd><p>an error, <a class="reference internal" href="../core-api/kernel-api.html#c.PTR_ERR" title="PTR_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">PTR_ERR()</span></code></a> returns the error code.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_free_kpp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_free_kpp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp"><span class="n"><span class="pre">crypto_kpp</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tfm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_free_kpp" title="Link to this definition">¶</a><br /></dt>
<dd><p>free KPP tfm handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span> <span class="pre">*tfm</span></code></dt><dd><p>KPP tfm handle allocated with <a class="reference internal" href="#c.crypto_alloc_kpp" title="crypto_alloc_kpp"><code class="xref c c-func docutils literal notranslate"><span class="pre">crypto_alloc_kpp()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>tfm</strong> is a NULL or error pointer, this function does nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_kpp_set_secret">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_kpp_set_secret</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp"><span class="n"><span class="pre">crypto_kpp</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tfm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_kpp_set_secret" title="Link to this definition">¶</a><br /></dt>
<dd><p>Invoke kpp operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span> <span class="pre">*tfm</span></code></dt><dd><p>tfm handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>Buffer holding the packet representation of the private
key. The structure of the packet key depends on the particular
KPP implementation. Packing and unpacking helpers are provided
for ECDH and DH (see the respective header files for those
implementations).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function invokes the specific kpp operation for a given alg.</p>
<p><strong>Return</strong></p>
<p>zero on success; error code in case of error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_kpp_generate_public_key">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_kpp_generate_public_key</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kpp_request" title="kpp_request"><span class="n"><span class="pre">kpp_request</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_kpp_generate_public_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>Invoke kpp operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>kpp key request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function invokes the specific kpp operation for generating the public part
for a given kpp algorithm.</p>
<p>To generate a private key, the caller should use a random number generator.
The output of the requested length serves as the private key.</p>
<p><strong>Return</strong></p>
<p>zero on success; error code in case of error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_kpp_compute_shared_secret">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_kpp_compute_shared_secret</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kpp_request" title="kpp_request"><span class="n"><span class="pre">kpp_request</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_kpp_compute_shared_secret" title="Link to this definition">¶</a><br /></dt>
<dd><p>Invoke kpp operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>kpp key request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function invokes the specific kpp operation for computing the shared secret
for a given kpp algorithm.</p>
<p><strong>Return</strong></p>
<p>zero on success; error code in case of error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_kpp_maxsize">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_kpp_maxsize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp"><span class="n"><span class="pre">crypto_kpp</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tfm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_kpp_maxsize" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get len for output buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span> <span class="pre">*tfm</span></code></dt><dd><p>KPP tfm handle allocated with <a class="reference internal" href="#c.crypto_alloc_kpp" title="crypto_alloc_kpp"><code class="xref c c-func docutils literal notranslate"><span class="pre">crypto_alloc_kpp()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns the output buffer size required for a given key.
Function assumes that the key is already set in the transformation. If this
function is called without a setkey or with a failed setkey, you will end up
in a NULL dereference.</p>
</div>
</section>
<section id="key-agreement-protocol-primitives-kpp-cipher-request-handle">
<h1>Key-agreement Protocol Primitives (KPP) Cipher Request Handle<a class="headerlink" href="#key-agreement-protocol-primitives-kpp-cipher-request-handle" title="Link to this heading">¶</a></h1>
<dl class="c function">
<dt class="sig sig-object c" id="c.kpp_request_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kpp_request" title="kpp_request"><span class="n"><span class="pre">kpp_request</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kpp_request_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp"><span class="n"><span class="pre">crypto_kpp</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tfm</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocates kpp request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span> <span class="pre">*tfm</span></code></dt><dd><p>KPP tfm handle allocated with <a class="reference internal" href="#c.crypto_alloc_kpp" title="crypto_alloc_kpp"><code class="xref c c-func docutils literal notranslate"><span class="pre">crypto_alloc_kpp()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>allocated handle in case of success or NULL in case of an error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kpp_request_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kpp_request_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kpp_request" title="kpp_request"><span class="n"><span class="pre">kpp_request</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>zeroize and free kpp request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>request to free</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kpp_request_set_callback">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kpp_request_set_callback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kpp_request" title="kpp_request"><span class="n"><span class="pre">kpp_request</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">flgs</span></span>, <span class="n"><span class="pre">crypto_completion_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmpl</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_set_callback" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets an asynchronous callback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>request that the callback will be set for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flgs</span></code></dt><dd><p>specify for instance if the operation may backlog</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crypto_completion_t</span> <span class="pre">cmpl</span></code></dt><dd><p>callback which will be called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>private data used by the caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback will be called when an asynchronous operation on a given
request is finished.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kpp_request_set_input">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kpp_request_set_input</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kpp_request" title="kpp_request"><span class="n"><span class="pre">kpp_request</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scatterlist</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">input</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">input_len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_set_input" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets input buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>kpp request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*input</span></code></dt><dd><p>ptr to input scatter list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">input_len</span></code></dt><dd><p>size of the input scatter list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets parameters required by generate_public_key</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kpp_request_set_output">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kpp_request_set_output</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.kpp_request" title="kpp_request"><span class="n"><span class="pre">kpp_request</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scatterlist</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">output</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">output_len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_set_output" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets output buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>kpp request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*output</span></code></dt><dd><p>ptr to output scatter list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">output_len</span></code></dt><dd><p>size of the output scatter list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets parameters required by kpp operation</p>
</div>
</section>
<section id="ecdh-helper-functions">
<h1>ECDH Helper Functions<a class="headerlink" href="#ecdh-helper-functions" title="Link to this heading">¶</a></h1>
<p>To use ECDH with the KPP cipher API, the following data structure and
functions should be used.</p>
<p>The ECC curves known to the ECDH implementation are specified in this
header file.</p>
<p>To use ECDH with KPP, the following functions should be used to operate on
an ECDH private key. The packet private key that can be set with
the KPP API function call of crypto_kpp_set_secret.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ecdh">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ecdh</span></span></span><a class="headerlink" href="#c.ecdh" title="Link to this definition">¶</a><br /></dt>
<dd><p>define an ECDH private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ecdh {
    char *key;
    unsigned short key_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>Private ECDH key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_size</span></code></dt><dd><p>Size of the private ECDH key</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_ecdh_key_len">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_ecdh_key_len</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ecdh" title="ecdh"><span class="n"><span class="pre">ecdh</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ecdh_key_len" title="Link to this definition">¶</a><br /></dt>
<dd><p>Obtain the size of the private ECDH key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ecdh</span> <span class="pre">*params</span></code></dt><dd><p>private ECDH key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the packet ECDH key size. A caller can use that
with the provided ECDH private key reference to obtain the required
memory size to hold a packet key.</p>
<p><strong>Return</strong></p>
<p>size of the key in bytes</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_ecdh_encode_key">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_ecdh_encode_key</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ecdh" title="ecdh"><span class="n"><span class="pre">ecdh</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ecdh_encode_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>encode the private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer allocated by the caller to hold the packet ECDH
private key. The buffer should be at least crypto_ecdh_key_len
bytes in size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ecdh</span> <span class="pre">*p</span></code></dt><dd><p>Buffer with the caller-specified private key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The ECDH implementations operate on a packet representation of the private
key.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if buffer has insufficient size, 0 on success</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_ecdh_decode_key">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_ecdh_decode_key</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ecdh" title="ecdh"><span class="n"><span class="pre">ecdh</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ecdh_decode_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>decode a private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer holding a packet key that should be decoded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ecdh</span> <span class="pre">*p</span></code></dt><dd><p>Buffer allocated by the caller that is filled with the
unpacked ECDH private key.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The unpacking obtains the private key by pointing <strong>p</strong> to the correct location
in <strong>buf</strong>. Thus, both pointers refer to the same memory.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if buffer has insufficient size, 0 on success</p>
</div>
</section>
<section id="dh-helper-functions">
<h1>DH Helper Functions<a class="headerlink" href="#dh-helper-functions" title="Link to this heading">¶</a></h1>
<p>To use DH with the KPP cipher API, the following data structure and
functions should be used.</p>
<p>To use DH with KPP, the following functions should be used to operate on
a DH private key. The packet private key that can be set with
the KPP API function call of crypto_kpp_set_secret.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dh">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dh</span></span></span><a class="headerlink" href="#c.dh" title="Link to this definition">¶</a><br /></dt>
<dd><p>define a DH private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dh {
    const void *key;
    const void *p;
    const void *g;
    unsigned int key_size;
    unsigned int p_size;
    unsigned int g_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>Private DH key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Diffie-Hellman parameter P</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g</span></code></dt><dd><p>Diffie-Hellman generator G</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_size</span></code></dt><dd><p>Size of the private DH key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_size</span></code></dt><dd><p>Size of DH parameter P</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_size</span></code></dt><dd><p>Size of DH generator G</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_dh_key_len">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_dh_key_len</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dh" title="dh"><span class="n"><span class="pre">dh</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_dh_key_len" title="Link to this definition">¶</a><br /></dt>
<dd><p>Obtain the size of the private DH key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dh</span> <span class="pre">*params</span></code></dt><dd><p>private DH key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the packet DH key size. A caller can use that
with the provided DH private key reference to obtain the required
memory size to hold a packet key.</p>
<p><strong>Return</strong></p>
<p>size of the key in bytes</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_dh_encode_key">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_dh_encode_key</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dh" title="dh"><span class="n"><span class="pre">dh</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_dh_encode_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>encode the private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer allocated by the caller to hold the packet DH
private key. The buffer should be at least crypto_dh_key_len
bytes in size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dh</span> <span class="pre">*params</span></code></dt><dd><p>Buffer with the caller-specified private key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The DH implementations operate on a packet representation of the private
key.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if buffer has insufficient size, 0 on success</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crypto_dh_decode_key">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crypto_dh_decode_key</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.dh" title="dh"><span class="n"><span class="pre">dh</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_dh_decode_key" title="Link to this definition">¶</a><br /></dt>
<dd><p>decode a private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer holding a packet key that should be decoded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dh</span> <span class="pre">*params</span></code></dt><dd><p>Buffer allocated by the caller that is filled with the
unpacked DH private key.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The unpacking obtains the private key by pointing <strong>p</strong> to the correct location
in <strong>buf</strong>. Thus, both pointers refer to the same memory.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if buffer has insufficient size, 0 on success</p>
</div>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/crypto/api-kpp.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>