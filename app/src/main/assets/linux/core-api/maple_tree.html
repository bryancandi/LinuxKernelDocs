<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Maple Tree &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ID Allocation" href="idr.html" />
    <link rel="prev" title="XArray" href="xarray.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.11.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kobject.html">Everything you never wanted to know about kobjects, ksets, and ktypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="kref.html">Adding reference counters (krefs) to kernel objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="xarray.html">XArray</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Maple Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="idr.html">ID Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="circular-buffers.html">Circular Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="rbtree.html">Red-black Trees (rbtree) in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-radix-tree.html">Generic radix trees/sparse arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="packing.html">Generic bitfield packing and unpacking functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="this_cpu_ops.html">this_cpu operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="timekeeping.html">ktime accessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="errseq.html">The errseq_t datatype</a></li>
<li class="toctree-l3"><a class="reference internal" href="wrappers/atomic_t.html">Atomic types</a></li>
<li class="toctree-l3"><a class="reference internal" href="wrappers/atomic_bitops.html">Atomic bitops</a></li>
<li class="toctree-l3"><a class="reference internal" href="floating-point.html">Floating-point API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/maple_tree.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="maple-tree">
<h1>Maple Tree<a class="headerlink" href="#maple-tree" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Liam R. Howlett</p>
</dd>
</dl>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>The Maple Tree is a B-Tree data type which is optimized for storing
non-overlapping ranges, including ranges of size 1.  The tree was designed to
be simple to use and does not require a user written search method.  It
supports iterating over a range of entries and going to the previous or next
entry in a cache-efficient manner.  The tree can also be put into an RCU-safe
mode of operation which allows reading and writing concurrently.  Writers must
synchronize on a lock, which can be the default spinlock, or the user can set
the lock to an external lock of a different type.</p>
<p>The Maple Tree maintains a small memory footprint and was designed to use
modern processor cache efficiently.  The majority of the users will be able to
use the normal API.  An <a class="reference internal" href="#maple-tree-advanced-api"><span class="std std-ref">Advanced API</span></a> exists for more complex
scenarios.  The most important usage of the Maple Tree is the tracking of the
virtual memory areas.</p>
<p>The Maple Tree can store values between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">ULONG_MAX</span></code>.  The Maple
Tree reserves values with the bottom two bits set to ‘10’ which are below 4096
(ie 2, 6, 10 .. 4094) for internal use.  If the entries may use reserved
entries then the users can convert the entries using <a class="reference internal" href="xarray.html#c.xa_mk_value" title="xa_mk_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_mk_value()</span></code></a> and convert
them back by calling <a class="reference internal" href="xarray.html#c.xa_to_value" title="xa_to_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">xa_to_value()</span></code></a>.  If the user needs to use a reserved
value, then the user can convert the value when using the
<a class="reference internal" href="#maple-tree-advanced-api"><span class="std std-ref">Advanced API</span></a>, but are blocked by the normal API.</p>
<p>The Maple Tree can also be configured to support searching for a gap of a given
size (or larger).</p>
<p>Pre-allocating of nodes is also supported using the
<a class="reference internal" href="#maple-tree-advanced-api"><span class="std std-ref">Advanced API</span></a>.  This is useful for users who must guarantee a
successful store operation within a given
code segment when allocating cannot be done.  Allocations of nodes are
relatively small at around 256 bytes.</p>
</section>
<section id="normal-api">
<span id="maple-tree-normal-api"></span><h2>Normal API<a class="headerlink" href="#normal-api" title="Link to this heading">¶</a></h2>
<p>Start by initialising a maple tree, either with DEFINE_MTREE() for statically
allocated maple trees or <a class="reference internal" href="#c.mt_init" title="mt_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_init()</span></code></a> for dynamically allocated ones.  A
freshly-initialised maple tree contains a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer for the range <code class="docutils literal notranslate"><span class="pre">0</span></code>
- <code class="docutils literal notranslate"><span class="pre">ULONG_MAX</span></code>.  There are currently two types of maple trees supported: the
allocation tree and the regular tree.  The regular tree has a higher branching
factor for internal nodes.  The allocation tree has a lower branching factor
but allows the user to search for a gap of a given size or larger from either
<code class="docutils literal notranslate"><span class="pre">0</span></code> upwards or <code class="docutils literal notranslate"><span class="pre">ULONG_MAX</span></code> down.  An allocation tree can be used by
passing in the <code class="docutils literal notranslate"><span class="pre">MT_FLAGS_ALLOC_RANGE</span></code> flag when initialising the tree.</p>
<p>You can then set entries using <a class="reference internal" href="#c.mtree_store" title="mtree_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_store()</span></code></a> or <a class="reference internal" href="#c.mtree_store_range" title="mtree_store_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_store_range()</span></code></a>.
<a class="reference internal" href="#c.mtree_store" title="mtree_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_store()</span></code></a> will overwrite any entry with the new entry and return 0 on
success or an error code otherwise.  <a class="reference internal" href="#c.mtree_store_range" title="mtree_store_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_store_range()</span></code></a> works in the same way
but takes a range.  <a class="reference internal" href="#c.mtree_load" title="mtree_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_load()</span></code></a> is used to retrieve the entry stored at a
given index.  You can use <a class="reference internal" href="#c.mtree_erase" title="mtree_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_erase()</span></code></a> to erase an entire range by only
knowing one value within that range, or <a class="reference internal" href="#c.mtree_store" title="mtree_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_store()</span></code></a> call with an entry of
NULL may be used to partially erase a range or many ranges at once.</p>
<p>If you want to only store a new entry to a range (or index) if that range is
currently <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, you can use <a class="reference internal" href="#c.mtree_insert_range" title="mtree_insert_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_insert_range()</span></code></a> or <a class="reference internal" href="#c.mtree_insert" title="mtree_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_insert()</span></code></a> which
return -EEXIST if the range is not empty.</p>
<p>You can search for an entry from an index upwards by using <a class="reference internal" href="#c.mt_find" title="mt_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_find()</span></code></a>.</p>
<p>You can walk each entry within a range by calling <a class="reference internal" href="#c.mt_for_each" title="mt_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_for_each()</span></code></a>.  You must
provide a temporary variable to store a cursor.  If you want to walk each
element of the tree then <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">ULONG_MAX</span></code> may be used as the range.  If
the caller is going to hold the lock for the duration of the walk then it is
worth looking at the <a class="reference internal" href="#c.mas_for_each" title="mas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_for_each()</span></code></a> API in the <a class="reference internal" href="#maple-tree-advanced-api"><span class="std std-ref">Advanced API</span></a>
section.</p>
<p>Sometimes it is necessary to ensure the next call to store to a maple tree does
not allocate memory, please see <a class="reference internal" href="#maple-tree-advanced-api"><span class="std std-ref">Advanced API</span></a> for this use case.</p>
<p>You can use <a class="reference internal" href="#c.mtree_dup" title="mtree_dup"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_dup()</span></code></a> to duplicate an entire maple tree. It is a more
efficient way than inserting all elements one by one into a new tree.</p>
<p>Finally, you can remove all entries from a maple tree by calling
<a class="reference internal" href="#c.mtree_destroy" title="mtree_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_destroy()</span></code></a>.  If the maple tree entries are pointers, you may wish to free
the entries first.</p>
<section id="allocating-nodes">
<h3>Allocating Nodes<a class="headerlink" href="#allocating-nodes" title="Link to this heading">¶</a></h3>
<p>The allocations are handled by the internal tree code.  See
<a class="reference internal" href="#maple-tree-advanced-alloc"><span class="std std-ref">Advanced Allocating Nodes</span></a> for other options.</p>
</section>
<section id="locking">
<h3>Locking<a class="headerlink" href="#locking" title="Link to this heading">¶</a></h3>
<p>You do not have to worry about locking.  See <a class="reference internal" href="#maple-tree-advanced-locks"><span class="std std-ref">Advanced Locking</span></a>
for other options.</p>
<p>The Maple Tree uses RCU and an internal spinlock to synchronise access:</p>
<dl class="simple">
<dt>Takes RCU read lock:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#c.mtree_load" title="mtree_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_load()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mt_find" title="mt_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_find()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mt_for_each" title="mt_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_for_each()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mt_next" title="mt_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_next()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mt_prev" title="mt_prev"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_prev()</span></code></a></p></li>
</ul>
</dd>
<dt>Takes ma_lock internally:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#c.mtree_store" title="mtree_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_store()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mtree_store_range" title="mtree_store_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_store_range()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mtree_insert" title="mtree_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_insert()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mtree_insert_range" title="mtree_insert_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_insert_range()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mtree_erase" title="mtree_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_erase()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mtree_dup" title="mtree_dup"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_dup()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mtree_destroy" title="mtree_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_destroy()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mt_set_in_rcu" title="mt_set_in_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_set_in_rcu()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.mt_clear_in_rcu" title="mt_clear_in_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_clear_in_rcu()</span></code></a></p></li>
</ul>
</dd>
</dl>
<p>If you want to take advantage of the internal lock to protect the data
structures that you are storing in the Maple Tree, you can call mtree_lock()
before calling <a class="reference internal" href="#c.mtree_load" title="mtree_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">mtree_load()</span></code></a>, then take a reference count on the object you
have found before calling mtree_unlock().  This will prevent stores from
removing the object from the tree between looking up the object and
incrementing the refcount.  You can also use RCU to avoid dereferencing
freed memory, but an explanation of that is beyond the scope of this
document.</p>
</section>
</section>
<section id="advanced-api">
<span id="maple-tree-advanced-api"></span><h2>Advanced API<a class="headerlink" href="#advanced-api" title="Link to this heading">¶</a></h2>
<p>The advanced API offers more flexibility and better performance at the
cost of an interface which can be harder to use and has fewer safeguards.
You must take care of your own locking while using the advanced API.
You can use the ma_lock, RCU or an external lock for protection.
You can mix advanced and normal operations on the same array, as long
as the locking is compatible.  The <a class="reference internal" href="#maple-tree-normal-api"><span class="std std-ref">Normal API</span></a> is implemented
in terms of the advanced API.</p>
<p>The advanced API is based around the ma_state, this is where the ‘mas’
prefix originates.  The ma_state struct keeps track of tree operations to make
life easier for both internal and external tree users.</p>
<p>Initialising the maple tree is the same as in the <a class="reference internal" href="#maple-tree-normal-api"><span class="std std-ref">Normal API</span></a>.
Please see above.</p>
<p>The maple state keeps track of the range start and end in mas-&gt;index and
mas-&gt;last, respectively.</p>
<p><a class="reference internal" href="#c.mas_walk" title="mas_walk"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_walk()</span></code></a> will walk the tree to the location of mas-&gt;index and set the
mas-&gt;index and mas-&gt;last according to the range for the entry.</p>
<p>You can set entries using <a class="reference internal" href="#c.mas_store" title="mas_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_store()</span></code></a>.  <a class="reference internal" href="#c.mas_store" title="mas_store"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_store()</span></code></a> will overwrite any entry
with the new entry and return the first existing entry that is overwritten.
The range is passed in as members of the maple state: index and last.</p>
<p>You can use <a class="reference internal" href="#c.mas_erase" title="mas_erase"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_erase()</span></code></a> to erase an entire range by setting index and
last of the maple state to the desired range to erase.  This will erase
the first range that is found in that range, set the maple state index
and last as the range that was erased and return the entry that existed
at that location.</p>
<p>You can walk each entry within a range by using <a class="reference internal" href="#c.mas_for_each" title="mas_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_for_each()</span></code></a>.  If you want
to walk each element of the tree then <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">ULONG_MAX</span></code> may be used as
the range.  If the lock needs to be periodically dropped, see the locking
section <a class="reference internal" href="#c.mas_pause" title="mas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_pause()</span></code></a>.</p>
<p>Using a maple state allows <a class="reference internal" href="#c.mas_next" title="mas_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_next()</span></code></a> and <a class="reference internal" href="#c.mas_prev" title="mas_prev"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_prev()</span></code></a> to function as if the
tree was a linked list.  With such a high branching factor the amortized
performance penalty is outweighed by cache optimization.  <a class="reference internal" href="#c.mas_next" title="mas_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_next()</span></code></a> will
return the next entry which occurs after the entry at index.  <a class="reference internal" href="#c.mas_prev" title="mas_prev"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_prev()</span></code></a>
will return the previous entry which occurs before the entry at index.</p>
<p><a class="reference internal" href="#c.mas_find" title="mas_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_find()</span></code></a> will find the first entry which exists at or above index on
the first call, and the next entry from every subsequent calls.</p>
<p><a class="reference internal" href="#c.mas_find_rev" title="mas_find_rev"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_find_rev()</span></code></a> will find the first entry which exists at or below the last on
the first call, and the previous entry from every subsequent calls.</p>
<p>If the user needs to yield the lock during an operation, then the maple state
must be paused using <a class="reference internal" href="#c.mas_pause" title="mas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_pause()</span></code></a>.</p>
<p>There are a few extra interfaces provided when using an allocation tree.
If you wish to search for a gap within a range, then mas_empty_area()
or mas_empty_area_rev() can be used.  mas_empty_area() searches for a gap
starting at the lowest index given up to the maximum of the range.
mas_empty_area_rev() searches for a gap starting at the highest index given
and continues downward to the lower bound of the range.</p>
<section id="advanced-allocating-nodes">
<span id="maple-tree-advanced-alloc"></span><h3>Advanced Allocating Nodes<a class="headerlink" href="#advanced-allocating-nodes" title="Link to this heading">¶</a></h3>
<p>Allocations are usually handled internally to the tree, however if allocations
need to occur before a write occurs then calling mas_expected_entries() will
allocate the worst-case number of needed nodes to insert the provided number of
ranges.  This also causes the tree to enter mass insertion mode.  Once
insertions are complete calling mas_destroy() on the maple state will free the
unused allocations.</p>
</section>
<section id="advanced-locking">
<span id="maple-tree-advanced-locks"></span><h3>Advanced Locking<a class="headerlink" href="#advanced-locking" title="Link to this heading">¶</a></h3>
<p>The maple tree uses a spinlock by default, but external locks can be used for
tree updates as well.  To use an external lock, the tree must be initialized
with the <code class="docutils literal notranslate"><span class="pre">MT_FLAGS_LOCK_EXTERN</span> <span class="pre">flag</span></code>, this is usually done with the
<a class="reference internal" href="#c.MTREE_INIT_EXT" title="MTREE_INIT_EXT"><code class="xref c c-func docutils literal notranslate"><span class="pre">MTREE_INIT_EXT()</span></code></a> #define, which takes an external lock as an argument.</p>
</section>
</section>
<section id="functions-and-structures">
<h2>Functions and structures<a class="headerlink" href="#functions-and-structures" title="Link to this heading">¶</a></h2>
<p id="maple-tree-flags"><strong>Maple tree flags</strong></p>
<ul class="simple">
<li><p>MT_FLAGS_ALLOC_RANGE       - Track gaps in this tree</p></li>
<li><p>MT_FLAGS_USE_RCU           - Operate in RCU mode</p></li>
<li><p>MT_FLAGS_HEIGHT_OFFSET     - The position of the tree height in the flags</p></li>
<li><p>MT_FLAGS_HEIGHT_MASK       - The mask for the maple tree height value</p></li>
<li><p>MT_FLAGS_LOCK_MASK         - How the mt_lock is used</p></li>
<li><p>MT_FLAGS_LOCK_IRQ          - Acquired irq-safe</p></li>
<li><p>MT_FLAGS_LOCK_BH           - Acquired bh-safe</p></li>
<li><p>MT_FLAGS_LOCK_EXTERN       - mt_lock is not used</p></li>
</ul>
<p>MAPLE_HEIGHT_MAX     The largest height that can be stored</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.MTREE_INIT">
<span class="sig-name descname"><span class="n"><span class="pre">MTREE_INIT</span></span></span><a class="headerlink" href="#c.MTREE_INIT" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">MTREE_INIT</span> <span class="pre">(name,</span> <span class="pre">__flags)</span></code></p>
<blockquote>
<div><p>Initialize a maple tree</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The maple tree name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__flags</span></code></dt><dd><p>The maple tree flags</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.MTREE_INIT_EXT">
<span class="sig-name descname"><span class="n"><span class="pre">MTREE_INIT_EXT</span></span></span><a class="headerlink" href="#c.MTREE_INIT_EXT" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">MTREE_INIT_EXT</span> <span class="pre">(name,</span> <span class="pre">__flags,</span> <span class="pre">__lock)</span></code></p>
<blockquote>
<div><p>Initialize a maple tree with an external lock.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The tree name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__flags</span></code></dt><dd><p>The maple tree flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__lock</span></code></dt><dd><p>The external lock</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_empty">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mtree_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_empty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determine if a tree has any present entries.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>Maple Tree.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the tree contains only NULL pointers.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_reset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reset a Maple Tree operation state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>Maple Tree operation state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the error or walk state of the <strong>mas</strong> so future walks of the
array will start from the root.  Use this if you have dropped the
lock and want to reuse the ma_state.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.mas_for_each">
<span class="sig-name descname"><span class="n"><span class="pre">mas_for_each</span></span></span><a class="headerlink" href="#c.mas_for_each" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">mas_for_each</span> <span class="pre">(__mas,</span> <span class="pre">__entry,</span> <span class="pre">__max)</span></code></p>
<blockquote>
<div><p>Iterate over a range of the maple tree.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__mas</span></code></dt><dd><p>Maple Tree operation state (maple_state)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__entry</span></code></dt><dd><p>Entry retrieved from the tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__max</span></code></dt><dd><p>maximum index to retrieve from the tree</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When returned, mas-&gt;index and mas-&gt;last will hold the entire range for the
entry.</p>
<p><strong>Note</strong></p>
<p>may return the zero entry.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__mas_set_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__mas_set_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">last</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__mas_set_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set up Maple Tree operation state to a sub-range of the current location.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>Maple Tree operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>New start of range in the Maple Tree.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">last</span></code></dt><dd><p>New end of range in the Maple Tree.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>set the internal maple state values to a sub-range.
Please use <a class="reference internal" href="#c.mas_set_range" title="mas_set_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_set_range()</span></code></a> if you do not know where you are in the tree.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_set_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_set_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">last</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_set_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set up Maple Tree operation state for a different index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>Maple Tree operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>New start of range in the Maple Tree.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">last</span></code></dt><dd><p>New end of range in the Maple Tree.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move the operation state to refer to a different range.  This will
have the effect of starting a walk from the top; see <a class="reference internal" href="#c.mas_next" title="mas_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_next()</span></code></a>
to move to an adjacent index.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_set</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set up Maple Tree operation state for a different index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>Maple Tree operation state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>New index into the Maple Tree.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move the operation state to refer to a different index.  This will
have the effect of starting a walk from the top; see <a class="reference internal" href="#c.mas_next" title="mas_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_next()</span></code></a>
to move to an adjacent index.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_init_flags">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mt_init_flags</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_init_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialise an empty maple tree with flags.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>Maple Tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>maple tree flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you need to initialise a Maple Tree with special flags (eg, an
allocation tree), use this function.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mt_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialise an empty maple tree.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>Maple Tree</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An empty Maple Tree.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_clear_in_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mt_clear_in_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_clear_in_rcu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Switch the tree to non-RCU mode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The Maple Tree</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_set_in_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mt_set_in_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_set_in_rcu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Switch the tree to RCU safe mode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The Maple Tree</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.mt_for_each">
<span class="sig-name descname"><span class="n"><span class="pre">mt_for_each</span></span></span><a class="headerlink" href="#c.mt_for_each" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">mt_for_each</span> <span class="pre">(__tree,</span> <span class="pre">__entry,</span> <span class="pre">__index,</span> <span class="pre">__max)</span></code></p>
<blockquote>
<div><p>Iterate over each entry starting at index until max.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__tree</span></code></dt><dd><p>The Maple Tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__entry</span></code></dt><dd><p>The current entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__index</span></code></dt><dd><p>The index to start the search from. Subsequently used as iterator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__max</span></code></dt><dd><p>The maximum limit for <strong>index</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator skips all entries, which resolve to a NULL pointer,
e.g. entries which has been reserved with XA_ZERO_ENTRY.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_insert">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_insert</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_insert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Internal call to insert a value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> or the contents that already exists at the requested index
otherwise.  The maple state needs to be checked for error conditions.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_alloc_cyclic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_alloc_cyclic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">startp</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">range_lo</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">range_hi</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">next</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_alloc_cyclic" title="Link to this definition">¶</a><br /></dt>
<dd><p>Internal call to find somewhere to store an entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*startp</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">range_lo</span></code></dt><dd><p>Lower bound of range to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">range_hi</span></code></dt><dd><p>Upper bound of range to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*next</span></code></dt><dd><p>Pointer to next ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if the allocation succeeded without wrapping, 1 if the
allocation succeeded after wrapping, or -EBUSY if there are no
free entries.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_walk">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_walk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_walk" title="Link to this definition">¶</a><br /></dt>
<dd><p>Search for <strong>mas-&gt;index</strong> in the tree.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>mas-&gt;index and mas-&gt;last will be set to the range if there is a value.  If
mas-&gt;status is ma_none, reset to ma_start</p>
<p><strong>Return</strong></p>
<p>the entry at the location or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mte_dead_walk">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__rcu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mte_dead_walk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_enode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">enode</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mte_dead_walk" title="Link to this definition">¶</a><br /></dt>
<dd><p>Walk down a dead tree to just before the leaves</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_enode</span> <span class="pre">**enode</span></code></dt><dd><p>The maple encoded node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">offset</span></code></dt><dd><p>The starting offset</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This can only be used from the RCU callback context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_free_walk">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mt_free_walk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_free_walk" title="Link to this definition">¶</a><br /></dt>
<dd><p>Walk &amp; free a tree in the RCU callback context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*head</span></code></dt><dd><p>The RCU head that’s within the node.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This can only be used from the RCU callback context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_store">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_store</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_store" title="Link to this definition">¶</a><br /></dt>
<dd><p>Store an <strong>entry</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>mas-&gt;index</strong> and <strong>mas-&gt;last</strong> is used to set the range for the <strong>entry</strong>.</p>
<p><strong>Note</strong></p>
<p>The <strong>mas</strong> should have pre-allocated entries to ensure there is memory to
store the entry.  Please see mas_expected_entries()/mas_destroy() for more details.</p>
<p><strong>Return</strong></p>
<p>the first entry between mas-&gt;index and mas-&gt;last or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_store_gfp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_store_gfp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_store_gfp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Store a value into the tree.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations if necessary.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL on invalid request, -ENOMEM if memory could not
be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_store_prealloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_store_prealloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_store_prealloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Store a value into the tree using memory preallocated in the maple state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_preallocate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_preallocate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_preallocate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Preallocate enough nodes for a store operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry that will be stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM if memory could not be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_next">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_next" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the next entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum index to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next entry after <strong>mas-&gt;index</strong>.
Must hold rcu_read_lock or the write lock.
Can return the zero entry.</p>
<p><strong>Return</strong></p>
<p>The next entry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_next_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_next_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_next_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Advance the maple state to the next range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum index to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <strong>mas-&gt;index</strong> and <strong>mas-&gt;last</strong> to the range.
Must hold rcu_read_lock or the write lock.
Can return the zero entry.</p>
<p><strong>Return</strong></p>
<p>The next entry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_next">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mt_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_next" title="Link to this definition">¶</a><br /></dt>
<dd><p>get the next value in the maple tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>The start index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum index to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes RCU read lock internally to protect the search, which does not
protect the returned pointer after dropping RCU read lock.
See also: <a class="reference internal" href="#"><span class="doc">Maple Tree</span></a></p>
<p><strong>Return</strong></p>
<p>The entry higher than <strong>index</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if nothing is found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_prev">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_prev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_prev" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the previous entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>The minimum value to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must hold rcu_read_lock or the write lock.
Will reset mas to ma_start if the status is ma_none.  Will stop on not
searchable nodes.</p>
<p><strong>Return</strong></p>
<p>the previous value or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_prev_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_prev_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_prev_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Advance to the previous range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>The minimum value to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <strong>mas-&gt;index</strong> and <strong>mas-&gt;last</strong> to the range.
Must hold rcu_read_lock or the write lock.
Will reset mas to ma_start if the node is ma_none.  Will stop on not
searchable nodes.</p>
<p><strong>Return</strong></p>
<p>the previous value or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_prev">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mt_prev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_prev" title="Link to this definition">¶</a><br /></dt>
<dd><p>get the previous value in the maple tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>The start index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>The minimum index to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes RCU read lock internally to protect the search, which does not
protect the returned pointer after dropping RCU read lock.
See also: <a class="reference internal" href="#"><span class="doc">Maple Tree</span></a></p>
<p><strong>Return</strong></p>
<p>The entry before <strong>index</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if nothing is found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_pause">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_pause</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_pause" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pause a mas_find/mas_for_each to drop the lock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state to pause</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some users need to pause a walk and drop the lock they’re holding in
order to yield to a higher priority thread or carry out an operation
on an entry.  Those users should call this function before they drop
the lock.  It resets the <strong>mas</strong> to be suitable for the next iteration
of the loop after the user has reacquired the lock.  If most entries
found during a walk require you to call <a class="reference internal" href="#c.mas_pause" title="mas_pause"><code class="xref c c-func docutils literal notranslate"><span class="pre">mas_pause()</span></code></a>, the <a class="reference internal" href="#c.mt_for_each" title="mt_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_for_each()</span></code></a>
iterator may be more appropriate.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_find_setup">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_find_setup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_find_setup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Internal function to set up mas_find*().</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**entry</span></code></dt><dd><p>Pointer to the entry</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if entry is the answer, false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_find">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>On the first call, find the entry at or after mas-&gt;index up to <code class="docutils literal notranslate"><span class="pre">max</span></code>. Otherwise, find the entry after mas-&gt;index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum value to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must hold rcu_read_lock or the write lock.
If an entry exists, last and index are updated accordingly.
May set <strong>mas-&gt;status</strong> to ma_overflow.</p>
<p><strong>Return</strong></p>
<p>The entry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_find_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_find_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_find_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>On the first call, find the entry at or after mas-&gt;index up to <code class="docutils literal notranslate"><span class="pre">max</span></code>. Otherwise, advance to the next slot mas-&gt;index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum value to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must hold rcu_read_lock or the write lock.
If an entry exists, last and index are updated accordingly.
May set <strong>mas-&gt;status</strong> to ma_overflow.</p>
<p><strong>Return</strong></p>
<p>The entry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_find_rev_setup">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_find_rev_setup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_find_rev_setup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Internal function to set up mas_find_*_rev()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>The minimum index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**entry</span></code></dt><dd><p>Pointer to the entry</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if entry is the answer, false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_find_rev">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_find_rev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_find_rev" title="Link to this definition">¶</a><br /></dt>
<dd><p>On the first call, find the first non-null entry at or below mas-&gt;index down to <code class="docutils literal notranslate"><span class="pre">min</span></code>. Otherwise find the first non-null entry below mas-&gt;index down to <code class="docutils literal notranslate"><span class="pre">min</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>The minimum value to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must hold rcu_read_lock or the write lock.
If an entry exists, last and index are updated accordingly.
May set <strong>mas-&gt;status</strong> to ma_underflow.</p>
<p><strong>Return</strong></p>
<p>The entry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_find_range_rev">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_find_range_rev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_find_range_rev" title="Link to this definition">¶</a><br /></dt>
<dd><p>On the first call, find the first non-null entry at or below mas-&gt;index down to <code class="docutils literal notranslate"><span class="pre">min</span></code>. Otherwise advance to the previous slot after mas-&gt;index down to <code class="docutils literal notranslate"><span class="pre">min</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>The minimum value to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must hold rcu_read_lock or the write lock.
If an entry exists, last and index are updated accordingly.
May set <strong>mas-&gt;status</strong> to ma_underflow.</p>
<p><strong>Return</strong></p>
<p>The entry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_erase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mas_erase</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_erase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find the range in which index resides and erase the entire range.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must hold the write lock.
Searches for <strong>mas-&gt;index</strong>, sets <strong>mas-&gt;index</strong> and <strong>mas-&gt;last</strong> to the range and
erases that range.</p>
<p><strong>Return</strong></p>
<p>the entry that was erased or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <strong>mas-&gt;index</strong> and <strong>mas-&gt;last</strong> are updated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mas_nomem">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mas_nomem</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ma_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mas</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mas_nomem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check if there was an error allocating and do the allocation if necessary If there are allocations, then free them.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ma_state</span> <span class="pre">*mas</span></code></dt><dd><p>The maple state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true on allocation, false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_load">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mtree_load</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_load" title="Link to this definition">¶</a><br /></dt>
<dd><p>Load a value stored in a maple tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>The index to load</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the entry or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_store_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mtree_store_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">last</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_store_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Store an entry at a given range.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>The start of the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">last</span></code></dt><dd><p>The end of the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL on invalid request, -ENOMEM if memory could not
be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_store">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mtree_store</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_store" title="Link to this definition">¶</a><br /></dt>
<dd><p>Store an entry at a given index.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>The index to store the value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL on invalid request, -ENOMEM if memory could not
be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_insert_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mtree_insert_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">first</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">last</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_insert_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Insert an entry at a given range if there is no value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">first</span></code></dt><dd><p>The start of the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">last</span></code></dt><dd><p>The end of the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -EEXISTS if the range is occupied, -EINVAL on invalid
request, -ENOMEM if memory could not be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_insert">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mtree_insert</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_insert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Insert an entry at a given index if there is no value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>The index to store the value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -EEXISTS if the range is occupied, -EINVAL on invalid
request, -ENOMEM if memory could not be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_alloc_cyclic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mtree_alloc_cyclic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">startp</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">range_lo</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">range_hi</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">next</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_alloc_cyclic" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find somewhere to store this entry in the tree.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*startp</span></code></dt><dd><p>Pointer to ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*entry</span></code></dt><dd><p>The entry to store.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">range_lo</span></code></dt><dd><p>Lower bound of range to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">range_hi</span></code></dt><dd><p>Upper bound of range to search.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*next</span></code></dt><dd><p>Pointer to next ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds an empty entry in <strong>mt</strong> after <strong>next</strong>, stores the new index into
the <strong>id</strong> pointer, stores the entry at that index, then updates <strong>next</strong>.</p>
<p><strong>mt</strong> must be initialized with the MT_FLAGS_ALLOC_RANGE flag.</p>
<p><strong>Context</strong></p>
<p>Any context.  Takes and releases the mt.lock.  May sleep if
the <strong>gfp</strong> flags permit.</p>
<p><strong>Return</strong></p>
<p>0 if the allocation succeeded without wrapping, 1 if the
allocation succeeded after wrapping, -ENOMEM if memory could not be
allocated, -EINVAL if <strong>mt</strong> cannot be used, or -EBUSY if there are no
free entries.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_erase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mtree_erase</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_erase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find an index and erase the entire range.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>The index to erase</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Erasing is the same as a walk to an entry then a store of a NULL to that
ENTIRE range.  In fact, it is implemented as such using the advanced API.</p>
<p><strong>Return</strong></p>
<p>The entry stored at the <strong>index</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__mt_dup">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__mt_dup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__mt_dup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Duplicate an entire maple tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The source maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*new</span></code></dt><dd><p>The new maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function duplicates a maple tree in Depth-First Search (DFS) pre-order
traversal. It uses <a class="reference internal" href="kernel-api.html#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code></a> to copy nodes in the source tree and allocate
new child nodes in non-leaf nodes. The new node is exactly the same as the
source node except for all the addresses stored in it. It will be faster than
traversing all elements in the source tree and inserting them one by one into
the new tree.
The user needs to ensure that the attributes of the source tree and the new
tree are the same, and the new tree needs to be an empty tree, otherwise
-EINVAL will be returned.
Note that the user needs to manually lock the source tree and the new tree.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM if memory could not be allocated, -EINVAL If
the attributes of the two trees are different or the new tree is not an empty
tree.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_dup">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mtree_dup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_dup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Duplicate an entire maple tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The source maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*new</span></code></dt><dd><p>The new maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The GFP_FLAGS to use for allocations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function duplicates a maple tree in Depth-First Search (DFS) pre-order
traversal. It uses <a class="reference internal" href="kernel-api.html#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code></a> to copy nodes in the source tree and allocate
new child nodes in non-leaf nodes. The new node is exactly the same as the
source node except for all the addresses stored in it. It will be faster than
traversing all elements in the source tree and inserting them one by one into
the new tree.
The user needs to ensure that the attributes of the source tree and the new
tree are the same, and the new tree needs to be an empty tree, otherwise
-EINVAL will be returned.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM if memory could not be allocated, -EINVAL If
the attributes of the two trees are different or the new tree is not an empty
tree.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__mt_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__mt_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__mt_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Walk and free all nodes of a locked maple tree.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Does not handle locking.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mtree_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mtree_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mtree_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Destroy a maple tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees all resources used by the tree.  Handles locking.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_find">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mt_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>Search from the start up until an entry is found.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*index</span></code></dt><dd><p>Pointer which contains the start location of the search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum value of the search range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes RCU read lock internally to protect the search, which does not
protect the returned pointer after dropping RCU read lock.
See also: <a class="reference internal" href="#"><span class="doc">Maple Tree</span></a></p>
<p>In case that an entry is found <strong>index</strong> is updated to point to the next
possible entry independent whether the found entry is occupying a
single index or a range if indices.</p>
<p><strong>Return</strong></p>
<p>The entry at or after the <strong>index</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mt_find_after">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">mt_find_after</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">maple_tree</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mt</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mt_find_after" title="Link to this definition">¶</a><br /></dt>
<dd><p>Search from the start up until an entry is found.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">maple_tree</span> <span class="pre">*mt</span></code></dt><dd><p>The maple tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*index</span></code></dt><dd><p>Pointer which contains the start location of the search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum value to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.mt_find" title="mt_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">mt_find()</span></code></a> except that it checks <strong>index</strong> for 0 before
searching. If <strong>index</strong> == 0, the search is aborted. This covers a wrap
around of <strong>index</strong> to 0 in an iterator loop.</p>
<p><strong>Return</strong></p>
<p>The entry at or after the <strong>index</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/maple_tree.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>