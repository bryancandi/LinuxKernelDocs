
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>The Linux Kernel API &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Workqueue" href="workqueue.html" />
    <link rel="prev" title="Core API Documentation" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.6.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">The Linux Kernel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Workqueue</a></li>
<li class="toctree-l3"><a class="reference internal" href="watch_queue.html">General notification mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-basics.html">Message logging with printk</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-formats.html">How to get printk format specifiers right</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-index.html">Printk Index</a></li>
<li class="toctree-l3"><a class="reference internal" href="symbol-namespaces.html">Symbol Namespaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="asm-annotations.html">Assembler Annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Kernel subsystem documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  sbar.scrollTop = currents[currents.length - 1].offsetTop;
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/kernel-api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-linux-kernel-api">
<h1>The Linux Kernel API<a class="headerlink" href="#the-linux-kernel-api" title="Permalink to this heading">¶</a></h1>
<section id="list-management-functions">
<h2>List Management Functions<a class="headerlink" href="#list-management-functions" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.INIT_LIST_HEAD">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">INIT_LIST_HEAD</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.INIT_LIST_HEAD" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a list_head structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>list_head structure to be initialized.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the list_head to point to itself.  If it is a list header,
the result is an empty list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a new entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list head to add it after</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_add_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_add_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a new entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list head to add it before</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty()</span></code></a> on entry does not return true after this, the entry is
in an undefined state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_replace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_replace</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_replace_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_replace_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace old entry by new one and initialize the old one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_swap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_swap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry1</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_swap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace entry1 with entry2 and re-add entry1 at entry2's position</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry1</span></code></dt><dd><p>the location to place entry2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry2</span></code></dt><dd><p>the location to place entry1</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_del_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_del_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from list and reinitialize it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_move">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_move</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>delete from one list and add as another's head</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head that will precede our entry</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_move_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_move_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move_tail" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>delete from one list and add as another's tail</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head that will follow our entry</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_bulk_move_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_bulk_move_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">first</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">last</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_bulk_move_tail" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>move a subsection of a list to its tail</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head that will follow our entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*first</span></code></dt><dd><p>first entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*last</span></code></dt><dd><p>last entry to move, can be the same as first</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move all entries between <strong>first</strong> and including <strong>last</strong> before <strong>head</strong>.
All three entries must belong to the same linked list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_is_first">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_is_first</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_first" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>tests whether <strong>list</strong> is the first entry in list <strong>head</strong></p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_is_last">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_is_last</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_last" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tests whether <strong>list</strong> is the last entry in list <strong>head</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_is_head">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_is_head</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_head" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tests whether <strong>list</strong> is the list <strong>head</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_empty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tests whether a list is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the list to test.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_del_init_careful">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_del_init_careful</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_init_careful" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from list and reinitialize it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_init()</span></code></a>, except designed to be used
together with <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty_careful()</span></code></a> in a way to guarantee ordering
of other memory operations.</p>
<p>Any memory operations done before a <a class="reference internal" href="#c.list_del_init_careful" title="list_del_init_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_init_careful()</span></code></a> are
guaranteed to be visible after a <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty_careful()</span></code></a> test.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_empty_careful">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_empty_careful</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty_careful" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tests whether a list is empty and not being modified</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the list to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>tests whether a list is empty _and_ checks that no other CPU might be
in the process of modifying either member (next or prev)</p>
<p><strong>NOTE</strong></p>
<p>using <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty_careful()</span></code></a> without synchronization
can only be safe if the only activity that can happen
to the list entry is <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_init()</span></code></a>. Eg. it cannot be used
if another CPU could re-<a class="reference internal" href="#c.list_add" title="list_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add()</span></code></a> it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_rotate_left">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_rotate_left</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_left" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>rotate the list to the left</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_rotate_to_front">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_rotate_to_front</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_to_front" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Rotate list to specific item.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>The desired new front of the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>The head of the list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rotates list so that <strong>list</strong> becomes the new front of the list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_is_singular">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_is_singular</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_singular" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tests whether a list has just one entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the list to test.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_cut_position">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_cut_position</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_position" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cut a list into two</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>a new list to add all removed entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>a list with entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>an entry within head, could be the head itself
and if so we won't cut the list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to and
including <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>. You should
pass on <strong>entry</strong> an element you know is on <strong>head</strong>. <strong>list</strong>
should be an empty list or a list you do not care about
losing its data.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_cut_before">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_cut_before</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_before" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cut a list into two, before given entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>a new list to add all removed entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>a list with entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>an entry within head, could be the head itself</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to but
excluding <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>.  You should pass
in <strong>entry</strong> an element you know is on <strong>head</strong>.  <strong>list</strong> should
be an empty list or a list you do not care about losing
its data.
If <strong>entry</strong> == <strong>head</strong>, all entries on <strong>head</strong> are moved to
<strong>list</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>join two lists, this is designed for stacks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>join two lists, each list being a queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>join two lists and reinitialise the emptied list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list at <strong>list</strong> is reinitialised</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice_tail_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice_tail_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>join two lists and reinitialise the emptied list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_entry</span></span></span><a class="headerlink" href="#c.list_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_entry</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the struct for this entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_first_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_first_entry</span></span></span><a class="headerlink" href="#c.list_first_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_first_entry</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the first element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_last_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_last_entry</span></span></span><a class="headerlink" href="#c.list_last_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_last_entry</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the last element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_first_entry_or_null">
<span class="sig-name descname"><span class="n"><span class="pre">list_first_entry_or_null</span></span></span><a class="headerlink" href="#c.list_first_entry_or_null" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_first_entry_or_null</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the first element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_next_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_next_entry</span></span></span><a class="headerlink" href="#c.list_next_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_next_entry</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the next element in list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_next_entry_circular">
<span class="sig-name descname"><span class="n"><span class="pre">list_next_entry_circular</span></span></span><a class="headerlink" href="#c.list_next_entry_circular" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_next_entry_circular</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the next element in list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wraparound if pos is the last element (return the first element).
Note, that list is expected to be not empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_prev_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_prev_entry</span></span></span><a class="headerlink" href="#c.list_prev_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_prev_entry</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the prev element in list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_prev_entry_circular">
<span class="sig-name descname"><span class="n"><span class="pre">list_prev_entry_circular</span></span></span><a class="headerlink" href="#c.list_prev_entry_circular" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_prev_entry_circular</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the prev element in list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wraparound if pos is the first element (return the last element).
Note, that list is expected to be not empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each</span></span></span><a class="headerlink" href="#c.list_for_each" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each</span> <span class="pre">(pos,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_rcu</span></span></span><a class="headerlink" href="#c.list_for_each_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_rcu</span> <span class="pre">(pos,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>Iterate over a list in an RCU-safe fashion</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_continue">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_continue</span></span></span><a class="headerlink" href="#c.list_for_each_continue" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_continue</span> <span class="pre">(pos,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>continue iteration over a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over a list, continuing after the current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_prev">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_prev</span></span></span><a class="headerlink" href="#c.list_for_each_prev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_prev</span> <span class="pre">(pos,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over a list backwards</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_safe">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_safe</span></span></span><a class="headerlink" href="#c.list_for_each_safe" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_safe</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over a list safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_prev_safe">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_prev_safe</span></span></span><a class="headerlink" href="#c.list_for_each_prev_safe" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_prev_safe</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over a list backwards safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_count_nodes">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_count_nodes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_count_nodes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>count nodes in the list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_entry_is_head">
<span class="sig-name descname"><span class="n"><span class="pre">list_entry_is_head</span></span></span><a class="headerlink" href="#c.list_entry_is_head" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_entry_is_head</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>test if the entry points to the head of the list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry</span></span></span><a class="headerlink" href="#c.list_for_each_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_reverse</span></span></span><a class="headerlink" href="#c.list_for_each_entry_reverse" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_reverse</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate backwards over list of given type.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_prepare_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_prepare_entry</span></span></span><a class="headerlink" href="#c.list_prepare_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_prepare_entry</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>prepare a pos entry for use in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_continue()</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a start point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a pos entry for use as a start point in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_continue()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_continue">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_continue</span></span></span><a class="headerlink" href="#c.list_for_each_entry_continue" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_continue</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>continue iteration over list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_continue_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_continue_reverse</span></span></span><a class="headerlink" href="#c.list_for_each_entry_continue_reverse" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_continue_reverse</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate backwards from the given point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start to iterate over list of given type backwards, continuing after
the current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_from">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_from</span></span></span><a class="headerlink" href="#c.list_for_each_entry_from" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_from</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type from the current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing from current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_from_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_from_reverse</span></span></span><a class="headerlink" href="#c.list_for_each_entry_from_reverse" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_from_reverse</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate backwards over list of given type from the current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, continuing from current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_safe">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_safe</span></span></span><a class="headerlink" href="#c.list_for_each_entry_safe" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_safe</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_safe_continue">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_safe_continue</span></span></span><a class="headerlink" href="#c.list_for_each_entry_safe_continue" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_safe_continue</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>continue list iteration safe against removal</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing after current point,
safe against removal of list entry.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_safe_from">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_safe_from</span></span></span><a class="headerlink" href="#c.list_for_each_entry_safe_from" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_safe_from</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list from current point safe against removal</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type from current point, safe against
removal of list entry.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_safe_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_safe_reverse</span></span></span><a class="headerlink" href="#c.list_for_each_entry_safe_reverse" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_safe_reverse</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate backwards over list safe against removal</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, safe against removal
of list entry.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_safe_reset_next">
<span class="sig-name descname"><span class="n"><span class="pre">list_safe_reset_next</span></span></span><a class="headerlink" href="#c.list_safe_reset_next" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_safe_reset_next</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>reset a stale list_for_each_entry_safe loop</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the loop cursor used in the list_for_each_entry_safe loop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>temporary storage used in list_for_each_entry_safe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>list_safe_reset_next is not safe to use in general if the list may be
modified concurrently (eg. the lock is dropped in the loop body). An
exception to this is if the cursor element (pos) is pinned in the list,
and list_safe_reset_next is called after re-taking the lock and before
completing the current iteration of the loop body.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_unhashed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_unhashed</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_unhashed" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Has node been removed from list and reinitialized?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*h</span></code></dt><dd><p>Node to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not that not all removal functions will leave a node in unhashed
state.  For example, <a class="reference internal" href="#c.hlist_nulls_del_init_rcu" title="hlist_nulls_del_init_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_init_rcu()</span></code></a> does leave the
node in unhashed state, but hlist_nulls_del() does not.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_unhashed_lockless">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_unhashed_lockless</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_unhashed_lockless" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Version of hlist_unhashed for lockless use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*h</span></code></dt><dd><p>Node to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.hlist_unhashed" title="hlist_unhashed"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_unhashed()</span></code></a> must be used in lockless contexts
to avoid potential load-tearing.  The READ_ONCE() is paired with the
various WRITE_ONCE() in hlist helpers that are defined below.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_empty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_empty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Is the specified hlist_head structure an empty hlist?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*h</span></code></dt><dd><p>Structure to check.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete the specified hlist_node from its list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>Node to delete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function leaves the node in hashed state.  Use
<a class="reference internal" href="#c.hlist_del_init" title="hlist_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_init()</span></code></a> or similar instead to unhash <strong>n</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_del_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_del_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete the specified hlist_node from its list and initialize</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>Node to delete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function leaves the node in unhashed state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_head">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_head</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_head" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a new entry at the beginning of the hlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*h</span></code></dt><dd><p>hlist head to add it after</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_before">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_before</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">next</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_before" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a new entry before the one specified</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*next</span></code></dt><dd><p>hlist node to add it before, which must be non-NULL</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_behind">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_behind</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_behind" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a new entry after the one specified</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*prev</span></code></dt><dd><p>hlist node to add it after, which must be non-NULL</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_fake">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_fake</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_fake" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a fake hlist consisting of a single headless node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>Node to make a fake list out of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This makes <strong>n</strong> appear to be its own predecessor on a headless hlist.
The point of this is to allow things like <a class="reference internal" href="#c.hlist_del" title="hlist_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del()</span></code></a> to work correctly
in cases where there is no list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_fake">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_fake</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_fake" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Is this node a fake hlist?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*h</span></code></dt><dd><p>Node to check for being a self-referential fake hlist.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_is_singular_node">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_is_singular_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_is_singular_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>is node the only element of the specified hlist?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>Node to check for singularity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*h</span></code></dt><dd><p>Header for potentially singular list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the node is the only node of the head without
accessing head, thus avoiding unnecessary cache misses.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_move_list">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_move_list</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_move_list" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move an hlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*old</span></code></dt><dd><p>hlist_head for old list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*new</span></code></dt><dd><p>hlist_head for new list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move a list from one list head to another. Fixup the pprev
reference of the first entry if it exists.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_continue">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_continue</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_continue" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_continue</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over a hlist continuing after current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_from">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_from</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_from" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_from</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over a hlist continuing from current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_safe">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_safe</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_safe" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_safe</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
</section>
<section id="basic-c-library-functions">
<h2>Basic C Library Functions<a class="headerlink" href="#basic-c-library-functions" title="Permalink to this heading">¶</a></h2>
<p>When writing drivers, you cannot in general use routines which are from
the C Library. Some of the functions have been found generally useful
and they are listed below. The behaviour of these functions may vary
slightly from those defined by ANSI, and these deviations are noted in
the text.</p>
<section id="string-conversions">
<h3>String Conversions<a class="headerlink" href="#string-conversions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.simple_strtoull">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">simple_strtoull</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoull" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cp</span></code></dt><dd><p>The start of the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**endp</span></code></dt><dd><p>A pointer to the end of the parsed string will be placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function has caveats. Please use kstrtoull instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.simple_strtoul">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">simple_strtoul</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cp</span></code></dt><dd><p>The start of the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**endp</span></code></dt><dd><p>A pointer to the end of the parsed string will be placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function has caveats. Please use kstrtoul instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.simple_strtol">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">simple_strtol</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtol" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to a signed long</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cp</span></code></dt><dd><p>The start of the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**endp</span></code></dt><dd><p>A pointer to the end of the parsed string will be placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function has caveats. Please use kstrtol instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.simple_strtoll">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">simple_strtoll</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">endp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to a signed long long</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cp</span></code></dt><dd><p>The start of the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**endp</span></code></dt><dd><p>A pointer to the end of the parsed string will be placed here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function has caveats. Please use kstrtoll instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vsnprintf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vsnprintf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vsnprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function generally follows C99 vsnprintf, but has some
extensions and a few limitations:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">``n``</span></code> is unsupported</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">``p``*</span></code> is handled by pointer()</p></li>
</ul>
</div></blockquote>
<p>See pointer() or <a class="reference internal" href="printk-formats.html"><span class="doc">How to get printk format specifiers right</span></a> for more
extensive description.</p>
<p><strong>Please update the documentation in both places when making changes</strong></p>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
'0', as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing '0'), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<p>If you're not already dealing with a va_list consider using <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vscnprintf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vscnprintf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vscnprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which have been written into
the <strong>buf</strong> not including the trailing '0'. If <strong>size</strong> is == 0 the function
returns 0.</p>
<p>If you're not already dealing with a va_list consider using <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">scnprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.snprintf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">snprintf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.snprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which would be
generated for the given input, excluding the trailing null,
as per ISO C99.  If the return is greater than or equal to
<strong>size</strong>, the resulting string is truncated.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.scnprintf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">scnprintf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.scnprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters written into <strong>buf</strong> not including
the trailing '0'. If <strong>size</strong> is == 0 the function returns 0.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vsprintf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vsprintf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vsprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> or <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vscnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>If you're not already dealing with a va_list consider using <a class="reference internal" href="#c.sprintf" title="sprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sprintf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sprintf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code></a> or <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">scnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vbin_printf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vbin_printf</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bin_buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vbin_printf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse a format string and place args' binary value in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*bin_buf</span></code></dt><dd><p>The buffer to place args' binary value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer(by words(32bits), not characters)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format follows C99 vsnprintf, except <code class="docutils literal notranslate"><span class="pre">n</span></code> is ignored, and its argument
is skipped.</p>
<p>The return value is the number of words(32bits) which would be generated for
the given input.</p>
<p><strong>NOTE</strong></p>
<p>If the return value is greater than <strong>size</strong>, the resulting bin_buf is NOT
valid for <a class="reference internal" href="#c.bstr_printf" title="bstr_printf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bstr_printf()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bstr_printf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bstr_printf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bin_buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bstr_printf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Format a string from binary arguments and place it in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>The buffer to place the result into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer, including the trailing null space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*bin_buf</span></code></dt><dd><p>Binary arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function like C99 vsnprintf, but the difference is that vsnprintf gets
arguments from stack, and bstr_printf gets arguments from <strong>bin_buf</strong> which is
a binary buffer that generated by vbin_printf.</p>
<dl class="simple">
<dt>The format follows C99 vsnprintf, but has some extensions:</dt><dd><p>see vsnprintf comment for details.</p>
</dd>
</dl>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
'0', as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing '0'), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bprintf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bprintf</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bin_buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bprintf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse a format string and place args' binary value in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*bin_buf</span></code></dt><dd><p>The buffer to place args' binary value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the buffer(by words(32bits), not characters)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of words(u32) written
into <strong>bin_buf</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vsscanf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vsscanf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vsscanf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">args</span></code></dt><dd><p>arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sscanf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sscanf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sscanf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>formatting of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>resulting arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrtoul">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kstrtoul</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Preferred over <a class="reference internal" href="#c.simple_strtoul" title="simple_strtoul"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtoul()</span></code></a>. Return code must be checked.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrtol">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kstrtol</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtol" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to a long</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Preferred over <a class="reference internal" href="#c.simple_strtol" title="simple_strtol"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtol()</span></code></a>. Return code must be checked.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrtoull">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kstrtoull</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoull" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Preferred over <a class="reference internal" href="#c.simple_strtoull" title="simple_strtoull"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtoull()</span></code></a>. Return code must be checked.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrtoll">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kstrtoll</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to a long long</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span> <span class="pre">*res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Preferred over <a class="reference internal" href="#c.simple_strtoll" title="simple_strtoll"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtoll()</span></code></a>. Return code must be checked.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrtouint">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kstrtouint</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtouint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to an unsigned int</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Preferred over <a class="reference internal" href="#c.simple_strtoul" title="simple_strtoul"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtoul()</span></code></a>. Return code must be checked.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrtoint">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kstrtoint</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert a string to an int</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*res</span></code></dt><dd><p>Where to write the result of the conversion on success.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Preferred over <a class="reference internal" href="#c.simple_strtol" title="simple_strtol"><code class="xref c c-func docutils literal notranslate"><span class="pre">simple_strtol()</span></code></a>. Return code must be checked.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrtobool">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kstrtobool</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtobool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert common user inputs into boolean values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>input string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*res</span></code></dt><dd><p>result</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns 0 iff the first character is one of 'YyTt1NnFf0', or
[oO][NnFf] for &quot;on&quot; and &quot;off&quot;. Otherwise it will return -EINVAL.  Value
pointed to by res is updated upon finding a match.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.string_get_size">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">string_get_size</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">blk_size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">string_size_units</span></span><span class="w"> </span><span class="n"><span class="pre">units</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.string_get_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the size in the specified units</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>The size to be converted in blocks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">blk_size</span></code></dt><dd><p>Size of the block (use 1 for size in bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">string_size_units</span> <span class="pre">units</span></code></dt><dd><p>units to use (powers of 1000 or 1024)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to format to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a string formatted to 3 significant figures
giving the size in the required units.  <strong>buf</strong> should have room for
at least 9 bytes and will always be zero terminated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parse_int_array_user">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parse_int_array_user</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">array</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parse_int_array_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Split string into a sequence of integers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*from</span></code></dt><dd><p>The user space buffer to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The maximum number of bytes to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">**array</span></code></dt><dd><p>Returned pointer to sequence of integers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>On success <strong>array</strong> is allocated and initialized with a sequence of
integers extracted from the <strong>from</strong> plus an additional element that
begins the sequence and specifies the integers count.</p>
<p>Caller takes responsibility for freeing <strong>array</strong> when it is no longer
needed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.string_unescape">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">string_unescape</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.string_unescape" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unquote characters in the given string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*src</span></code></dt><dd><p>source buffer (escaped)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*dst</span></code></dt><dd><p>destination buffer (unescaped)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the destination buffer (0 to unlimit)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>combination of the flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function unquotes characters in the given string.</p>
<p>Because the size of the output will be the same as or less than the size of
the input, the transformation may be performed in place.</p>
<p>Caller must provide valid source and destination pointers. Be aware that
destination buffer will always be NULL-terminated. Source string must be
NULL-terminated as well.  The supported flags are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>UNESCAPE_SPACE:
        &#39;\f&#39; - form feed
        &#39;\n&#39; - new line
        &#39;\r&#39; - carriage return
        &#39;\t&#39; - horizontal tab
        &#39;\v&#39; - vertical tab
UNESCAPE_OCTAL:
        &#39;\NNN&#39; - byte with octal value NNN (1 to 3 digits)
UNESCAPE_HEX:
        &#39;\xHH&#39; - byte with hexadecimal value HH (1 to 2 digits)
UNESCAPE_SPECIAL:
        &#39;\&quot;&#39; - double quote
        &#39;\\&#39; - backslash
        &#39;\a&#39; - alert (BEL)
        &#39;\e&#39; - escape
UNESCAPE_ANY:
        all previous together
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>The amount of the characters processed to the destination buffer excluding
trailing '0' is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.string_escape_mem">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">string_escape_mem</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">isz</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">osz</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">only</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.string_escape_mem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>quote characters in the given memory buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*src</span></code></dt><dd><p>source buffer (unescaped)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">isz</span></code></dt><dd><p>source buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*dst</span></code></dt><dd><p>destination buffer (escaped)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">osz</span></code></dt><dd><p>destination buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>combination of the flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*only</span></code></dt><dd><p>NULL-terminated string containing characters used to limit
the selected escape class. If characters are included in <strong>only</strong>
that would not normally be escaped by the classes selected
in <strong>flags</strong>, they will be copied to <strong>dst</strong> unescaped.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process of escaping byte buffer includes several parts. They are applied
in the following sequence.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The character is not matched to the one from <strong>only</strong> string and thus
must go as-is to the output.</p></li>
<li><p>The character is matched to the printable and ASCII classes, if asked,
and in case of match it passes through to the output.</p></li>
<li><p>The character is matched to the printable or ASCII class, if asked,
and in case of match it passes through to the output.</p></li>
<li><p>The character is checked if it falls into the class given by <strong>flags</strong>.
<code class="docutils literal notranslate"><span class="pre">ESCAPE_OCTAL</span></code> and <code class="docutils literal notranslate"><span class="pre">ESCAPE_HEX</span></code> are going last since they cover any
character. Note that they actually can't go together, otherwise
<code class="docutils literal notranslate"><span class="pre">ESCAPE_HEX</span></code> will be ignored.</p></li>
</ol>
</div></blockquote>
<p>Caller must provide valid source and destination pointers. Be aware that
destination buffer will not be NULL-terminated, thus caller have to append
it if needs. The supported flags are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%ESCAPE_SPACE: (special white space, not space itself)
        &#39;\f&#39; - form feed
        &#39;\n&#39; - new line
        &#39;\r&#39; - carriage return
        &#39;\t&#39; - horizontal tab
        &#39;\v&#39; - vertical tab
%ESCAPE_SPECIAL:
        &#39;\&quot;&#39; - double quote
        &#39;\\&#39; - backslash
        &#39;\a&#39; - alert (BEL)
        &#39;\e&#39; - escape
%ESCAPE_NULL:
        &#39;\0&#39; - null
%ESCAPE_OCTAL:
        &#39;\NNN&#39; - byte with octal value NNN (3 digits)
%ESCAPE_ANY:
        all previous together
%ESCAPE_NP:
        escape only non-printable characters, checked by isprint()
%ESCAPE_ANY_NP:
        all previous together
%ESCAPE_HEX:
        &#39;\xHH&#39; - byte with hexadecimal value HH (2 digits)
%ESCAPE_NA:
        escape only non-ascii characters, checked by isascii()
%ESCAPE_NAP:
        escape only non-printable or non-ascii characters
%ESCAPE_APPEND:
        append characters from @only to be escaped by the given classes
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ESCAPE_APPEND</span></code> would help to pass additional characters to the escaped, when
one of <code class="docutils literal notranslate"><span class="pre">ESCAPE_NP</span></code>, <code class="docutils literal notranslate"><span class="pre">ESCAPE_NA</span></code>, or <code class="docutils literal notranslate"><span class="pre">ESCAPE_NAP</span></code> is provided.</p>
<p>One notable caveat, the <code class="docutils literal notranslate"><span class="pre">ESCAPE_NAP</span></code>, <code class="docutils literal notranslate"><span class="pre">ESCAPE_NP</span></code> and <code class="docutils literal notranslate"><span class="pre">ESCAPE_NA</span></code> have the
higher priority than the rest of the flags (<code class="docutils literal notranslate"><span class="pre">ESCAPE_NAP</span></code> is the highest).
It doesn't make much sense to use either of them without <code class="docutils literal notranslate"><span class="pre">ESCAPE_OCTAL</span></code>
or <code class="docutils literal notranslate"><span class="pre">ESCAPE_HEX</span></code>, because they cover most of the other character classes.
<code class="docutils literal notranslate"><span class="pre">ESCAPE_NAP</span></code> can utilize <code class="docutils literal notranslate"><span class="pre">ESCAPE_SPACE</span></code> or <code class="docutils literal notranslate"><span class="pre">ESCAPE_SPECIAL</span></code> in addition to
the above.</p>
<p><strong>Return</strong></p>
<p>The total size of the escaped output that would be generated for
the given input and flags. To check whether the output was
truncated, compare the return value to osz. There is room left in
dst for a '0' terminator if and only if ret &lt; osz.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kasprintf_strarray">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kasprintf_strarray</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prefix</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kasprintf_strarray" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate and fill array of sequential strings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>flags for the slab allocator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*prefix</span></code></dt><dd><p>prefix to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>amount of lines to be allocated and filled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and fills <strong>n</strong> strings using pattern &quot;<code class="docutils literal notranslate"><span class="pre">s-````zu</span></code>&quot;, where prefix
is provided by caller. The caller is responsible to free them with
<a class="reference internal" href="#c.kfree_strarray" title="kfree_strarray"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_strarray()</span></code></a> after use.</p>
<p>Returns array of strings or NULL when memory can't be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kfree_strarray">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree_strarray</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">array</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_strarray" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free a number of dynamically allocated strings contained in an array and the array itself</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**array</span></code></dt><dd><p>Dynamically allocated array of strings to free.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>Number of strings (starting from the beginning of the array) to free.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Passing a non-NULL <strong>array</strong> and <strong>n</strong> == 0 as well as NULL <strong>array</strong> are valid
use-cases. If <strong>array</strong> is NULL, the function does nothing.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strscpy_pad">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strscpy_pad</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strscpy_pad" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*dest</span></code></dt><dd><p>Where to copy the string to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*src</span></code></dt><dd><p>Where to copy the string from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>Size of destination buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the string, or as much of it as fits, into the dest buffer.  The
behavior is undefined if the string buffers overlap.  The destination
buffer is always <code class="docutils literal notranslate"><span class="pre">NUL</span></code> terminated, unless it's zero-sized.</p>
<p>If the source string is shorter than the destination buffer, zeros
the tail of the destination buffer.</p>
<p>For full explanation of why you may want to consider using the
'strscpy' functions please see the function docstring for <a class="reference internal" href="#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a>.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>The number of characters copied (not including the trailing <code class="docutils literal notranslate"><span class="pre">NUL</span></code>)</p></li>
<li><p>-E2BIG if count is 0 or <strong>src</strong> was truncated.</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.skip_spaces">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">skip_spaces</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.skip_spaces" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes leading whitespace from <strong>str</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>The string to be stripped.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the first non-whitespace character in <strong>str</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strim">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strim</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strim" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes leading and trailing whitespace from <strong>s</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The string to be stripped.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the first trailing whitespace is replaced with a <code class="docutils literal notranslate"><span class="pre">NUL-terminator</span></code>
in the given string <strong>s</strong>. Returns a pointer to the first non-whitespace
character in <strong>s</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sysfs_streq">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sysfs_streq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_streq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return true if strings are equal, modulo trailing newline</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s1</span></code></dt><dd><p>one string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s2</span></code></dt><dd><p>another string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns true iff two strings are equal, treating both
NUL and newline-then-NUL as equivalent string terminations.  It's
geared for use with sysfs input strings, which generally terminate
with newlines but are compared against values without newlines.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.match_string">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">match_string</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">array</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">string</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.match_string" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*array</span></code></dt><dd><p>array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>number of strings in the array or -1 for NULL terminated arrays</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*string</span></code></dt><dd><p>string to match with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine will look for a string in an array of strings up to the
n-th element in the array or until the first NULL element.</p>
<p>Historically the value of -1 for <strong>n</strong>, was used to search in arrays that
are NULL terminated. However, the function does not make a distinction
when finishing the search: either <strong>n</strong> elements have been compared OR
the first NULL element was found.</p>
<p><strong>Return</strong></p>
<p>index of a <strong>string</strong> in the <strong>array</strong> if matches, or <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__sysfs_match_string">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__sysfs_match_string</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">array</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__sysfs_match_string" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*array</span></code></dt><dd><p>array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>number of strings in the array or -1 for NULL terminated arrays</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>string to match with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns index of <strong>str</strong> in the <strong>array</strong> or -EINVAL, just like <a class="reference internal" href="#c.match_string" title="match_string"><code class="xref c c-func docutils literal notranslate"><span class="pre">match_string()</span></code></a>.
Uses sysfs_streq instead of strcmp for matching.</p>
<p>This routine will look for a string in an array of strings up to the
n-th element in the array or until the first NULL element.</p>
<p>Historically the value of -1 for <strong>n</strong>, was used to search in arrays that
are NULL terminated. However, the function does not make a distinction
when finishing the search: either <strong>n</strong> elements have been compared OR
the first NULL element was found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strreplace">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strreplace</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strreplace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replace all occurrences of character in string.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>The string to operate on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">old</span></code></dt><dd><p>The character being replaced.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">new</span></code></dt><dd><p>The character <strong>old</strong> is replaced with.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replaces the each <strong>old</strong> character with a <strong>new</strong> one in the given string <strong>str</strong>.</p>
<p><strong>Return</strong></p>
<p>pointer to the string <strong>str</strong> itself.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memcpy_and_pad">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">memcpy_and_pad</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">dest_len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">pad</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memcpy_and_pad" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy one buffer to another with padding</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dest</span></code></dt><dd><p>Where to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dest_len</span></code></dt><dd><p>The destination buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>Where to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of bytes to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>Character to use for padding if space is left in destination.</p>
</dd>
</dl>
</div>
</section>
<section id="string-manipulation">
<h3>String Manipulation<a class="headerlink" href="#string-manipulation" title="Permalink to this heading">¶</a></h3>
<dl class="c macro">
<dt class="sig sig-object c" id="c.unsafe_memcpy">
<span class="sig-name descname"><span class="n"><span class="pre">unsafe_memcpy</span></span></span><a class="headerlink" href="#c.unsafe_memcpy" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">unsafe_memcpy</span> <span class="pre">(dst,</span> <span class="pre">src,</span> <span class="pre">bytes,</span> <span class="pre">justification)</span></code></p>
<blockquote>
<div><p>memcpy implementation with no FORTIFY bounds checking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dst</span></code></dt><dd><p>Destination memory address to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src</span></code></dt><dd><p>Source memory address to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code></dt><dd><p>How many bytes to write to <strong>dst</strong> from <strong>src</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">justification</span></code></dt><dd><p>Free-form text or comment describing why the use is needed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be used for corner cases where the compiler cannot do the
right thing, or during transitions between APIs, etc. It should be used
very rarely, and includes a place for justification detailing where bounds
checking has happened, and why existing solutions cannot be employed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strncpy">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strncpy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">__kernel_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strncpy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a string to memory with non-guaranteed NUL padding</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code></dt><dd><p>pointer to destination of copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*q</span></code></dt><dd><p>pointer to NUL-terminated source string to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__kernel_size_t</span> <span class="pre">size</span></code></dt><dd><p>bytes to write at <strong>p</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If strlen(<strong>q</strong>) &gt;= <strong>size</strong>, the copy of <strong>q</strong> will stop after <strong>size</strong> bytes,
and <strong>p</strong> will NOT be NUL-terminated</p>
<p>If strlen(<strong>q</strong>) &lt; <strong>size</strong>, following the copy of <strong>q</strong>, trailing NUL bytes
will be written to <strong>p</strong> until <strong>size</strong> total bytes have been written.</p>
<p>Do not use this function. While FORTIFY_SOURCE tries to avoid
over-reads of <strong>q</strong>, it cannot defend against writing unterminated
results to <strong>p</strong>. Using <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a> remains ambiguous and fragile.
Instead, please choose an alternative, so that the expectation
of <strong>p</strong>'s contents is unambiguous:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>p</strong> needs to be:</p></th>
<th class="head"><p>padded to <strong>size</strong></p></th>
<th class="head"><p>not padded</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NUL-terminated</p></td>
<td><p><a class="reference internal" href="#c.strscpy_pad" title="strscpy_pad"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy_pad()</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>not NUL-terminated</p></td>
<td><p><a class="reference internal" href="#c.strtomem_pad" title="strtomem_pad"><code class="xref c c-func docutils literal notranslate"><span class="pre">strtomem_pad()</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.strtomem" title="strtomem"><code class="xref c c-func docutils literal notranslate"><span class="pre">strtomem()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>Note strscpy*()'s differing return values for detecting truncation,
and strtomem*()'s expectation that the destination is marked with
__nonstring when it is a character array.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strnlen">
<span class="n"><span class="pre">__kernel_size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strnlen</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">__kernel_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">maxlen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strnlen" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return bounded count of characters in a NUL-terminated string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code></dt><dd><p>pointer to NUL-terminated string to count.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__kernel_size_t</span> <span class="pre">maxlen</span></code></dt><dd><p>maximum number of characters to count.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of characters in <strong>p</strong> (NOT including the final NUL), or
<strong>maxlen</strong>, if no NUL has been found up to there.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.strlen">
<span class="sig-name descname"><span class="n"><span class="pre">strlen</span></span></span><a class="headerlink" href="#c.strlen" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">strlen</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>Return count of characters in a NUL-terminated string</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>pointer to NUL-terminated string to count.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not use this function unless the string length is known at
compile-time. When <strong>p</strong> is unterminated, this function may crash
or return unexpected counts that could lead to memory content
exposures. Prefer <a class="reference internal" href="#c.strnlen" title="strnlen"><code class="xref c c-func docutils literal notranslate"><span class="pre">strnlen()</span></code></a>.</p>
<p>Returns number of characters in <strong>p</strong> (NOT including the final NUL).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strlcpy">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strlcpy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcpy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a string into another string buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code></dt><dd><p>pointer to destination of copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">q</span></code></dt><dd><p>pointer to NUL-terminated source string to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>maximum number of bytes to write at <strong>p</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If strlen(<strong>q</strong>) &gt;= <strong>size</strong>, the copy of <strong>q</strong> will be truncated at
<strong>size</strong> - 1 bytes. <strong>p</strong> will always be NUL-terminated.</p>
<p>Do not use this function. While FORTIFY_SOURCE tries to avoid
over-reads when calculating strlen(<strong>q</strong>), it is still possible.
Prefer <a class="reference internal" href="#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a>, though note its different return values for
detecting truncation.</p>
<p>Returns total number of bytes written to <strong>p</strong>, including terminating NUL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strscpy">
<span class="n"><span class="pre">ssize_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strscpy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strscpy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code></dt><dd><p>Where to copy the string to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">q</span></code></dt><dd><p>Where to copy the string from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of destination buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the source string <strong>q</strong>, or as much of it as fits, into the destination
<strong>p</strong> buffer. The behavior is undefined if the string buffers overlap. The
destination <strong>p</strong> buffer is always NUL terminated, unless it's zero-sized.</p>
<p>Preferred to <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strlcpy()</span></code></a> since the API doesn't require reading memory
from the source <strong>q</strong> string beyond the specified <strong>size</strong> bytes, and since
the return value is easier to error-check than <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strlcpy()</span></code></a>'s.
In addition, the implementation is robust to the string changing out
from underneath it, unlike the current <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strlcpy()</span></code></a> implementation.</p>
<p>Preferred to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a> since it always returns a valid string, and
doesn't unnecessarily force the tail of the destination buffer to be
zero padded. If padding is desired please use <a class="reference internal" href="#c.strscpy_pad" title="strscpy_pad"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy_pad()</span></code></a>.</p>
<p>Returns the number of characters copied in <strong>p</strong> (not including the
trailing <code class="docutils literal notranslate"><span class="pre">NUL</span></code>) or -E2BIG if <strong>size</strong> is 0 or the copy of <strong>q</strong> was truncated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strlcat">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strlcat</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">avail</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcat" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append a string to an existing string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code></dt><dd><p>pointer to <code class="docutils literal notranslate"><span class="pre">NUL-terminated</span></code> string to append to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">q</span></code></dt><dd><p>pointer to <code class="docutils literal notranslate"><span class="pre">NUL-terminated</span></code> string to append from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">avail</span></code></dt><dd><p>Maximum bytes available in <strong>p</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends <code class="docutils literal notranslate"><span class="pre">NUL-terminated</span></code> string <strong>q</strong> after the <code class="docutils literal notranslate"><span class="pre">NUL-terminated</span></code>
string at <strong>p</strong>, but will not write beyond <strong>avail</strong> bytes total,
potentially truncating the copy from <strong>q</strong>. <strong>p</strong> will stay
<code class="docutils literal notranslate"><span class="pre">NUL-terminated</span></code> only if a <code class="docutils literal notranslate"><span class="pre">NUL</span></code> already existed within
the <strong>avail</strong> bytes of <strong>p</strong>. If so, the resulting number of
bytes copied from <strong>q</strong> will be at most &quot;<strong>avail</strong> - strlen(<strong>p</strong>) - 1&quot;.</p>
<p>Do not use this function. While FORTIFY_SOURCE tries to avoid
read and write overflows, this is only possible when the sizes
of <strong>p</strong> and <strong>q</strong> are known to the compiler. Prefer building the
string with formatting, via <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">scnprintf()</span></code></a>, seq_buf, or similar.</p>
<p>Returns total bytes that _would_ have been contained by <strong>p</strong>
regardless of truncation, similar to <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code></a>. If return
value is &gt;= <strong>avail</strong>, the string has been truncated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strcat">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strcat</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strcat" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append a string to an existing string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code></dt><dd><p>pointer to NUL-terminated string to append to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*q</span></code></dt><dd><p>pointer to NUL-terminated source string to append from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not use this function. While FORTIFY_SOURCE tries to avoid
read and write overflows, this is only possible when the
destination buffer size is known to the compiler. Prefer
building the string with formatting, via <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">scnprintf()</span></code></a> or similar.
At the very least, use <a class="reference internal" href="#c.strncat" title="strncat"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncat()</span></code></a>.</p>
<p>Returns <strong>p</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strncat">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strncat</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">__kernel_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strncat" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append a string to an existing string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code></dt><dd><p>pointer to NUL-terminated string to append to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">q</span></code></dt><dd><p>pointer to source string to append from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__kernel_size_t</span> <span class="pre">count</span></code></dt><dd><p>Maximum bytes to read from <strong>q</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends at most <strong>count</strong> bytes from <strong>q</strong> (stopping at the first
NUL byte) after the NUL-terminated string at <strong>p</strong>. <strong>p</strong> will be
NUL-terminated.</p>
<p>Do not use this function. While FORTIFY_SOURCE tries to avoid
read and write overflows, this is only possible when the sizes
of <strong>p</strong> and <strong>q</strong> are known to the compiler. Prefer building the
string with formatting, via <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">scnprintf()</span></code></a> or similar.</p>
<p>Returns <strong>p</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strcpy">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strcpy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strcpy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a string into another string buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code></dt><dd><p>pointer to destination of copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">q</span></code></dt><dd><p>pointer to NUL-terminated source string to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not use this function. While FORTIFY_SOURCE tries to avoid
overflows, this is only possible when the sizes of <strong>q</strong> and <strong>p</strong> are
known to the compiler. Prefer <a class="reference internal" href="#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strscpy()</span></code></a>, though note its different
return values for detecting truncation.</p>
<p>Returns <strong>p</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strncasecmp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strncasecmp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s2</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strncasecmp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Case insensitive, length-limited string comparison</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s1</span></code></dt><dd><p>One string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s2</span></code></dt><dd><p>The other string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>the maximum number of characters to compare</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.stpcpy">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">stpcpy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="pre">__restrict__</span><span class="w"> </span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="pre">__restrict__</span><span class="w"> </span><span class="n"><span class="pre">src</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.stpcpy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy a string from src to dest returning a pointer to the new end of dest, including src's <code class="docutils literal notranslate"><span class="pre">NUL-terminator</span></code>. May overrun dest.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*__restrict__</span> <span class="pre">dest</span></code></dt><dd><p>pointer to end of string being copied into. Must be large enough
to receive copy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*__restrict__</span> <span class="pre">src</span></code></dt><dd><p>pointer to the beginning of string being copied from. Must not overlap
dest.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>stpcpy differs from strcpy in a key way: the return value is a pointer
to the new <code class="docutils literal notranslate"><span class="pre">NUL-terminating</span></code> character in <strong>dest</strong>. (For strcpy, the return
value is a pointer to the start of <strong>dest</strong>). This interface is considered
unsafe as it doesn't perform bounds checking of the inputs. As such it's
not recommended for usage. Instead, its definition is provided in case
the compiler lowers other libcalls to stpcpy.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strcmp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strcmp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strcmp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compare two strings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cs</span></code></dt><dd><p>One string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*ct</span></code></dt><dd><p>Another string</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strncmp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strncmp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ct</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strncmp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compare two length-limited strings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cs</span></code></dt><dd><p>One string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*ct</span></code></dt><dd><p>Another string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The maximum number of bytes to compare</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strchr">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strchr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strchr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the first occurrence of a character in a string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The character to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">NUL-terminator</span></code> is considered part of the string, and can
be searched for.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strchrnul">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strchrnul</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strchrnul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find and return a character in a string, or end of string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The character to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to first occurrence of 'c' in s. If c is not found, then
return a pointer to the null byte at the end of s.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strrchr">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strrchr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strrchr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the last occurrence of a character in a string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The character to search for</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strnchr">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strnchr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strnchr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a character in a length limited string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of characters to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The character to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">NUL-terminator</span></code> is considered part of the string, and can
be searched for.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strspn">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strspn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">accept</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strspn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which only contain letters in <strong>accept</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*accept</span></code></dt><dd><p>The string to search for</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strcspn">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strcspn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reject</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strcspn" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which does not contain letters in <strong>reject</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*reject</span></code></dt><dd><p>The string to avoid</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strpbrk">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strpbrk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strpbrk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the first occurrence of a set of characters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cs</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*ct</span></code></dt><dd><p>The characters to search for</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strsep">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strsep</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strsep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Split a string into tokens</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**s</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*ct</span></code></dt><dd><p>The characters to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.strsep" title="strsep"><code class="xref c c-func docutils literal notranslate"><span class="pre">strsep()</span></code></a> updates <strong>s</strong> to point after the token, ready for the next call.</p>
<p>It returns empty tokens, too, behaving exactly like the libc function
of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
Same semantics, slimmer shape. ;)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memset</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill a region of memory with the given value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The byte to fill the area with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not use <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> to access IO space, use memset_io() instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memset16">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memset16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">uint16_t</span></span><span class="w"> </span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memset16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill a memory area with a uint16_t</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">*s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">v</span></code></dt><dd><p>The value to fill the area with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of values to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> in that it fills with a uint16_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint16_ts to
store, not the number of bytes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memset32">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memset32</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memset32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill a memory area with a uint32_t</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">v</span></code></dt><dd><p>The value to fill the area with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of values to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> in that it fills with a uint32_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint32_ts to
store, not the number of bytes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memset64">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memset64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memset64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill a memory area with a uint64_t</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">*s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">v</span></code></dt><dd><p>The value to fill the area with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The number of values to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> in that it fills with a uint64_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint64_ts to
store, not the number of bytes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memcpy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memcpy</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memcpy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dest</span></code></dt><dd><p>Where to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>Where to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>You should not use this function to access IO space, use memcpy_toio()
or memcpy_fromio() instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memmove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memmove</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memmove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dest</span></code></dt><dd><p>Where to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>Where to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code></a>, <a class="reference internal" href="#c.memmove" title="memmove"><code class="xref c c-func docutils literal notranslate"><span class="pre">memmove()</span></code></a> copes with overlapping areas.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memcmp">
<span class="pre">__visible</span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">memcmp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ct</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memcmp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compare two areas of memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*cs</span></code></dt><dd><p>One area of memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ct</span></code></dt><dd><p>Another area of memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bcmp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bcmp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bcmp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns 0 if and only if the buffers have identical contents.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*a</span></code></dt><dd><p>pointer to first buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*b</span></code></dt><dd><p>pointer to second buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>size of buffers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sign or magnitude of a non-zero return value has no particular
meaning, and architectures may implement their own more efficient <a class="reference internal" href="#c.bcmp" title="bcmp"><code class="xref c c-func docutils literal notranslate"><span class="pre">bcmp()</span></code></a>. So
while this particular implementation is a simple (tail) call to memcmp, do
not rely on anything but whether the return value is zero or non-zero.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memscan">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memscan</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memscan" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>The memory area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The byte to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or 1 byte past
the area if <strong>c</strong> is not found</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strstr">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strstr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strstr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the first substring in a <code class="docutils literal notranslate"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s1</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s2</span></code></dt><dd><p>The string to search for</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strnstr">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strnstr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s2</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strnstr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find the first substring in a length-limited string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s1</span></code></dt><dd><p>The string to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s2</span></code></dt><dd><p>The string to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>the maximum number of characters to search</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memchr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memchr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*s</span></code></dt><dd><p>The memory area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>The byte to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
if <strong>c</strong> is not found</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memchr_inv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memchr_inv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">bytes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr_inv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find an unmatching character in an area of memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*start</span></code></dt><dd><p>The memory area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">c</span></code></dt><dd><p>Find a character other than c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">bytes</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first character other than <strong>c</strong>, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
if the whole buffer contains just <strong>c</strong>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.sysfs_match_string">
<span class="sig-name descname"><span class="n"><span class="pre">sysfs_match_string</span></span></span><a class="headerlink" href="#c.sysfs_match_string" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">sysfs_match_string</span> <span class="pre">(_a,</span> <span class="pre">_s)</span></code></p>
<blockquote>
<div><p>matches given string in an array</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_a</span></code></dt><dd><p>array of strings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_s</span></code></dt><dd><p>string to match with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for <a class="reference internal" href="#c.__sysfs_match_string" title="__sysfs_match_string"><code class="xref c c-func docutils literal notranslate"><span class="pre">__sysfs_match_string()</span></code></a>. Calculates the size of <strong>a</strong> automatically.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strstarts">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">strstarts</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prefix</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strstarts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>does <strong>str</strong> start with <strong>prefix</strong>?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>string to examine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*prefix</span></code></dt><dd><p>prefix to look for.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memzero_explicit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">memzero_explicit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memzero_explicit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill a region of memory (e.g. sensitive keying data) with 0s.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*s</span></code></dt><dd><p>Pointer to the start of the area.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>The size of the area.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>usually using <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> is just fine (!), but in cases
where clearing out _local_ data at the end of a scope is
necessary, <a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal notranslate"><span class="pre">memzero_explicit()</span></code></a> should be used instead in
order to prevent the compiler from optimising away zeroing.</p>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal notranslate"><span class="pre">memzero_explicit()</span></code></a> doesn't need an arch-specific version as
it just invokes the one of <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a> implicitly.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kbasename">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kbasename</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kbasename" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the last part of a pathname.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*path</span></code></dt><dd><p>path to extract the filename from.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.strtomem_pad">
<span class="sig-name descname"><span class="n"><span class="pre">strtomem_pad</span></span></span><a class="headerlink" href="#c.strtomem_pad" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">strtomem_pad</span> <span class="pre">(dest,</span> <span class="pre">src,</span> <span class="pre">pad)</span></code></p>
<blockquote>
<div><p>Copy NUL-terminated string to non-NUL-terminated buffer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dest</span></code></dt><dd><p>Pointer of destination character array (marked as __nonstring)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src</span></code></dt><dd><p>Pointer to NUL-terminated string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding character to fill any remaining bytes of <strong>dest</strong> after copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a replacement for <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a> uses where the destination is not
a NUL-terminated string, but with bounds checking on the source size, and
an explicit padding character. If padding is not required, use <a class="reference internal" href="#c.strtomem" title="strtomem"><code class="xref c c-func docutils literal notranslate"><span class="pre">strtomem()</span></code></a>.</p>
<p>Note that the size of <strong>dest</strong> is not an argument, as the length of <strong>dest</strong>
must be discoverable by the compiler.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.strtomem">
<span class="sig-name descname"><span class="n"><span class="pre">strtomem</span></span></span><a class="headerlink" href="#c.strtomem" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">strtomem</span> <span class="pre">(dest,</span> <span class="pre">src)</span></code></p>
<blockquote>
<div><p>Copy NUL-terminated string to non-NUL-terminated buffer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dest</span></code></dt><dd><p>Pointer of destination character array (marked as __nonstring)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src</span></code></dt><dd><p>Pointer to NUL-terminated string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a replacement for <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">strncpy()</span></code></a> uses where the destination is not
a NUL-terminated string, but with bounds checking on the source size, and
without trailing padding. If padding is required, use <a class="reference internal" href="#c.strtomem_pad" title="strtomem_pad"><code class="xref c c-func docutils literal notranslate"><span class="pre">strtomem_pad()</span></code></a>.</p>
<p>Note that the size of <strong>dest</strong> is not an argument, as the length of <strong>dest</strong>
must be discoverable by the compiler.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.memset_after">
<span class="sig-name descname"><span class="n"><span class="pre">memset_after</span></span></span><a class="headerlink" href="#c.memset_after" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">memset_after</span> <span class="pre">(obj,</span> <span class="pre">v,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>Set a value after a struct member to the end of a struct</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>Address of target struct instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>Byte value to repeatedly write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>after which struct member to start writing bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is good for clearing padding following the given member.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.memset_startat">
<span class="sig-name descname"><span class="n"><span class="pre">memset_startat</span></span></span><a class="headerlink" href="#c.memset_startat" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">memset_startat</span> <span class="pre">(obj,</span> <span class="pre">v,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>Set a value starting at a member to the end of a struct</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>Address of target struct instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>Byte value to repeatedly write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>struct member to start writing at</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if there is padding between the prior member and the target
member, <a class="reference internal" href="#c.memset_after" title="memset_after"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset_after()</span></code></a> should be used to clear the prior padding.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.str_has_prefix">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">str_has_prefix</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prefix</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.str_has_prefix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if a string has a given prefix</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>The string to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*prefix</span></code></dt><dd><p>The string to see if <strong>str</strong> starts with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>A common way to test a prefix of a string is to do:</dt><dd><p>strncmp(str, prefix, sizeof(prefix) - 1)</p>
</dd>
</dl>
<p>But this can lead to bugs due to typos, or if prefix is a pointer
and not a constant. Instead use <a class="reference internal" href="#c.str_has_prefix" title="str_has_prefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">str_has_prefix()</span></code></a>.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>strlen(<strong>prefix</strong>) if <strong>str</strong> starts with <strong>prefix</strong></p></li>
<li><p>0 if <strong>str</strong> does not start with <strong>prefix</strong></p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrdup">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kstrdup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>s</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrdup_const">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kstrdup_const</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup_const" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>conditionally duplicate an existing const string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Strings allocated by kstrdup_const should be freed by kfree_const and
must not be passed to <a class="reference internal" href="mm-api.html#c.krealloc" title="krealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">krealloc()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>source string if it is in .rodata section otherwise
fallback to kstrdup.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kstrndup">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kstrndup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrndup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>read at most <strong>max</strong> chars from <strong>s</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Use <a class="reference internal" href="#c.kmemdup_nul" title="kmemdup_nul"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmemdup_nul()</span></code></a> instead if the size is known exactly.</p>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>s</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemdup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmemdup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>duplicate region of memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>memory region to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>memory region length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>src</strong> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case of error,
result is physically contiguous. Use <a class="reference internal" href="mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> to free.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kmemdup_nul">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">kmemdup_nul</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup_nul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a NUL-terminated string from unterminated data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>The data to stringify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The size of the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>s</strong> with NUL-termination or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in
case of error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memdup_user">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memdup_user</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>duplicate memory region from user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*src</span></code></dt><dd><p>source address in user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>an <a class="reference internal" href="#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on failure.  Result is physically
contiguous, to be freed by <a class="reference internal" href="mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.vmemdup_user">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">vmemdup_user</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.vmemdup_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>duplicate memory region from user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*src</span></code></dt><dd><p>source address in user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>an <a class="reference internal" href="#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on failure.  Result may be not
physically contiguous.  Use <a class="reference internal" href="mm-api.html#c.kvfree" title="kvfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kvfree()</span></code></a> to free.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.strndup_user">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strndup_user</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.strndup_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>duplicate an existing string from user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*s</span></code></dt><dd><p>The string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>Maximum number of bytes to copy, including the trailing NUL.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>newly allocated copy of <strong>s</strong> or an <a class="reference internal" href="#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> in case of error</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memdup_user_nul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">memdup_user_nul</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user_nul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>duplicate memory region from user space and NUL-terminate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*src</span></code></dt><dd><p>source address in user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>an <a class="reference internal" href="#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> on failure.</p>
</div>
</section>
</section>
<section id="basic-kernel-library-functions">
<h2>Basic Kernel Library Functions<a class="headerlink" href="#basic-kernel-library-functions" title="Permalink to this heading">¶</a></h2>
<p>The Linux kernel provides more basic utility functions.</p>
<section id="bit-operations">
<h3>Bit Operations<a class="headerlink" href="#bit-operations" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_bit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically set a bit in memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a relaxed atomic operation (no implied memory barriers).</p>
<p>Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clear_bit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a relaxed atomic operation (no implied memory barriers).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.change_bit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">change_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.change_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a relaxed atomic operation (no implied memory barriers).</p>
<p>Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.test_and_set_bit">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">test_and_set_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an atomic fully-ordered operation (implied full memory barrier).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.test_and_clear_bit">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">test_and_clear_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_clear_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an atomic fully-ordered operation (implied full memory barrier).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.test_and_change_bit">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">test_and_change_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_change_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Change a bit and return its old value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an atomic fully-ordered operation (implied full memory barrier).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.___set_bit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">___set_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.___set_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a bit in memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.set_bit" title="set_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">set_bit()</span></code></a>, this function is non-atomic. If it is called on the same
region of memory concurrently, the effect may be that only one operation
succeeds.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.___clear_bit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">___clear_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.___clear_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.clear_bit" title="clear_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">clear_bit()</span></code></a>, this function is non-atomic. If it is called on the same
region of memory concurrently, the effect may be that only one operation
succeeds.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.___change_bit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">___change_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.___change_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">change_bit()</span></code></a>, this function is non-atomic. If it is called on the same
region of memory concurrently, the effect may be that only one operation
succeeds.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.___test_and_set_bit">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">___test_and_set_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.___test_and_set_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic. If two instances of this operation race, one
can appear to succeed but actually fail.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.___test_and_clear_bit">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">___test_and_clear_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.___test_and_clear_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic. If two instances of this operation race, one
can appear to succeed but actually fail.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.___test_and_change_bit">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">___test_and_change_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.___test_and_change_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Change a bit and return its old value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic. If two instances of this operation race, one
can appear to succeed but actually fail.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c._test_bit">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_test_bit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._test_bit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine whether a bit is set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>bit number to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c._test_bit_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_test_bit_acquire</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._test_bit_acquire" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine, with acquire semantics, whether a bit is set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>bit number to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clear_bit_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_bit_unlock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear a bit in memory, for unlock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and provides release barrier semantics.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__clear_bit_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__clear_bit_unlock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__clear_bit_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a non-atomic operation but implies a release barrier before the
memory operation. It can be used for an unlock if no other CPUs can
concurrently modify other bits in the word.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.test_and_set_bit_lock">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">test_and_set_bit_lock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a bit and return its old value, for lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>Bit to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>Address to count from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and provides acquire barrier semantics if
the returned value is 0.
It can be used to implement bit locks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clear_bit_unlock_is_negative_byte">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_bit_unlock_is_negative_byte</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">volatile</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit_unlock_is_negative_byte" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear a bit in memory and test if bottom byte is negative, for unlock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">nr</span></code></dt><dd><p>the bit to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*addr</span></code></dt><dd><p>the address to start counting from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and provides release barrier semantics.</p>
<p>This is a bit of a one-trick-pony for the filemap code, which clears
PG_locked and tests PG_waiters,</p>
</div>
</section>
<section id="bitmap-operations">
<h3>Bitmap Operations<a class="headerlink" href="#bitmap-operations" title="Permalink to this heading">¶</a></h3>
<p>bitmaps provide an array of bits, implemented using an
array of unsigned longs.  The number of valid bits in a
given bitmap does _not_ need to be an exact multiple of
BITS_PER_LONG.</p>
<p>The possible unused bits in the last, partially used word
of a bitmap are 'don't care'.  The implementation makes
no particular effort to keep them zero.  It ensures that
their value will not affect the results of any operation.
The bitmap operations that return Boolean (bitmap_empty,
for example) or scalar (bitmap_weight, for example) results
carefully filter out these unused bits from impacting their
results.</p>
<p>The byte ordering of bitmaps is more natural on little
endian architectures.  See the big-endian headers
include/asm-ppc64/bitops.h and include/asm-s390/bitops.h
for the best explanations of this ordering.</p>
<p>The DECLARE_BITMAP(name,bits) macro, in linux/types.h, can be used
to declare an array named 'name' of just enough unsigned longs to
contain all bit positions from 0 to 'bits' - 1.</p>
<p>The available bitmap operations and their rough meaning in the
case that the bitmap is a single unsigned long are thus:</p>
<p>The generated code is more efficient when nbits is known at
compile-time and at most BITS_PER_LONG.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bitmap_zero(dst, nbits)                     *dst = 0UL
bitmap_fill(dst, nbits)                     *dst = ~0UL
bitmap_copy(dst, src, nbits)                *dst = *src
bitmap_and(dst, src1, src2, nbits)          *dst = *src1 &amp; *src2
bitmap_or(dst, src1, src2, nbits)           *dst = *src1 | *src2
bitmap_xor(dst, src1, src2, nbits)          *dst = *src1 ^ *src2
bitmap_andnot(dst, src1, src2, nbits)       *dst = *src1 &amp; ~(*src2)
bitmap_complement(dst, src, nbits)          *dst = ~(*src)
bitmap_equal(src1, src2, nbits)             Are *src1 and *src2 equal?
bitmap_intersects(src1, src2, nbits)        Do *src1 and *src2 overlap?
bitmap_subset(src1, src2, nbits)            Is *src1 a subset of *src2?
bitmap_empty(src, nbits)                    Are all bits zero in *src?
bitmap_full(src, nbits)                     Are all bits set in *src?
bitmap_weight(src, nbits)                   Hamming Weight: number set bits
bitmap_weight_and(src1, src2, nbits)        Hamming Weight of and&#39;ed bitmap
bitmap_set(dst, pos, nbits)                 Set specified bit area
bitmap_clear(dst, pos, nbits)               Clear specified bit area
bitmap_find_next_zero_area(buf, len, pos, n, mask)  Find bit free area
bitmap_find_next_zero_area_off(buf, len, pos, n, mask, mask_off)  as above
bitmap_shift_right(dst, src, n, nbits)      *dst = *src &gt;&gt; n
bitmap_shift_left(dst, src, n, nbits)       *dst = *src &lt;&lt; n
bitmap_cut(dst, src, first, n, nbits)       Cut n bits from first, copy rest
bitmap_replace(dst, old, new, mask, nbits)  *dst = (*old &amp; ~(*mask)) | (*new &amp; *mask)
bitmap_remap(dst, src, old, new, nbits)     *dst = map(old, new)(src)
bitmap_bitremap(oldbit, old, new, nbits)    newbit = map(old, new)(oldbit)
bitmap_onto(dst, orig, relmap, nbits)       *dst = orig relative to relmap
bitmap_fold(dst, orig, sz, nbits)           dst bits = orig bits mod sz
bitmap_parse(buf, buflen, dst, nbits)       Parse bitmap dst from kernel buf
bitmap_parse_user(ubuf, ulen, dst, nbits)   Parse bitmap dst from user buf
bitmap_parselist(buf, dst, nbits)           Parse bitmap dst from kernel buf
bitmap_parselist_user(buf, dst, nbits)      Parse bitmap dst from user buf
bitmap_find_free_region(bitmap, bits, order)  Find and allocate bit region
bitmap_release_region(bitmap, pos, order)   Free specified bit region
bitmap_allocate_region(bitmap, pos, order)  Allocate specified bit region
bitmap_from_arr32(dst, buf, nbits)          Copy nbits from u32[] buf to dst
bitmap_from_arr64(dst, buf, nbits)          Copy nbits from u64[] buf to dst
bitmap_to_arr32(buf, src, nbits)            Copy nbits from buf to u32[] dst
bitmap_to_arr64(buf, src, nbits)            Copy nbits from buf to u64[] dst
bitmap_get_value8(map, start)               Get 8bit value from map at start
bitmap_set_value8(map, value, start)        Set 8bit value to map at start
</pre></div>
</div>
<p>Note, bitmap_zero() and bitmap_fill() operate over the region of
unsigned longs, that is, bits behind bitmap till the unsigned long
boundary will be zeroed or filled as well. Consider to use
bitmap_clear() or bitmap_set() to make explicit zeroing or filling
respectively.</p>
<p>Also the following operations in asm/bitops.h apply to bitmaps.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set_bit(bit, addr)                  *addr |= bit
clear_bit(bit, addr)                *addr &amp;= ~bit
change_bit(bit, addr)               *addr ^= bit
test_bit(bit, addr)                 Is bit set in *addr?
test_and_set_bit(bit, addr)         Set bit and return old value
test_and_clear_bit(bit, addr)       Clear bit and return old value
test_and_change_bit(bit, addr)      Change bit and return old value
find_first_zero_bit(addr, nbits)    Position first zero bit in *addr
find_first_bit(addr, nbits)         Position first set bit in *addr
find_next_zero_bit(addr, nbits, bit)
                                    Position next zero bit in *addr &gt;= bit
find_next_bit(addr, nbits, bit)     Position next set bit in *addr &gt;= bit
find_next_and_bit(addr1, addr2, nbits, bit)
                                    Same as find_next_bit, but in
                                    (*addr1 &amp; *addr2)
</pre></div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__bitmap_shift_right">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__bitmap_shift_right</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">shift</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_right" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>logical right shift of the bits in a bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst</span></code></dt><dd><p>destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src</span></code></dt><dd><p>source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">shift</span></code></dt><dd><p>shift by this many bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">nbits</span></code></dt><dd><p>bitmap size, in bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting right (dividing) means moving bits in the MS -&gt; LS bit
direction.  Zeros are fed into the vacated MS positions and the
LS bits shifted off the bottom are lost.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__bitmap_shift_left">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__bitmap_shift_left</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">shift</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_left" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>logical left shift of the bits in a bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst</span></code></dt><dd><p>destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src</span></code></dt><dd><p>source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">shift</span></code></dt><dd><p>shift by this many bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>bitmap size, in bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting left (multiplying) means moving bits in the LS -&gt; MS
direction.  Zeros are fed into the vacated LS bit positions
and those MS bits shifted off the top are lost.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_cut">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_cut</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">first</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cut</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_cut" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove bit region from bitmap and right shift remaining bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst</span></code></dt><dd><p>destination bitmap, might overlap with src</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src</span></code></dt><dd><p>source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">first</span></code></dt><dd><p>start bit of region to be removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cut</span></code></dt><dd><p>number of bits to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>bitmap size, in bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the n-th bit of <strong>dst</strong> iff the n-th bit of <strong>src</strong> is set and
n is less than <strong>first</strong>, or the m-th bit of <strong>src</strong> is set for any
m such that <strong>first</strong> &lt;= n &lt; nbits, and m = n + <strong>cut</strong>.</p>
<p>In pictures, example for a big-endian 32-bit architecture:</p>
<p>The <strong>src</strong> bitmap is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>31                                   63
|                                    |
10000000 11000001 11110010 00010101  10000000 11000001 01110010 00010101
                |  |              |                                    |
               16  14             0                                   32
</pre></div>
</div>
<p>if <strong>cut</strong> is 3, and <strong>first</strong> is 14, bits 14-16 in <strong>src</strong> are cut and <strong>dst</strong> is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>31                                   63
|                                    |
10110000 00011000 00110010 00010101  00010000 00011000 00101110 01000010
                   |              |                                    |
                   14 (bit 17     0                                   32
                       from @src)
</pre></div>
</div>
<p>Note that <strong>dst</strong> and <strong>src</strong> might overlap partially or entirely.</p>
<p>This is implemented in the obvious way, with a shift and carry
step for each moved bit. Optimisation is left as an exercise
for the compiler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_find_next_zero_area_off">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_find_next_zero_area_off</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">align_mask</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">align_offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_next_zero_area_off" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find a contiguous aligned zero area</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*map</span></code></dt><dd><p>The address to base the search on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>The bitmap size in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>The bitnumber to start searching at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>The number of zeroed bits we're looking for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_mask</span></code></dt><dd><p>Alignment mask for zero area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_offset</span></code></dt><dd><p>Alignment offset for zero area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>align_mask</strong> should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds plus <strong>align_offset</strong>
is multiple of that power of 2.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_parse_user">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_parse_user</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ubuf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ulen</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">maskp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmaskbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parse_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert an ASCII hex string in a user buffer into a bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*ubuf</span></code></dt><dd><p>pointer to user buffer containing string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt><dd><p>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*maskp</span></code></dt><dd><p>pointer to bitmap array that will contain result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_print_to_pagebuf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_print_to_pagebuf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">maskp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmaskbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_print_to_pagebuf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert bitmap to list or hex format ASCII string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">list</span></code></dt><dd><p>indicates whether the bitmap must be list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>page aligned buffer into which string is placed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*maskp</span></code></dt><dd><p>pointer to bitmap to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Output format is a comma-separated list of decimal numbers and
ranges if list is specified or hex digits grouped into comma-separated
sets of 8 digits/set. Returns the number of characters written to buf.</p>
<p>It is assumed that <strong>buf</strong> is a pointer into a PAGE_SIZE, page-aligned
area and that sufficient storage remains at <strong>buf</strong> to accommodate the
<a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_to_pagebuf()</span></code></a> output. Returns the number of characters
actually printed to <strong>buf</strong>, excluding terminating '0'.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_print_bitmask_to_buf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_print_bitmask_to_buf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">maskp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmaskbits</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">off</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_print_bitmask_to_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert bitmap to hex bitmask format ASCII string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer into which string is placed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*maskp</span></code></dt><dd><p>pointer to bitmap to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>in the string from which we are copying, We copy to <strong>buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the maximum number of bytes to print</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_to_pagebuf()</span></code></a> is used indirectly via its cpumap wrapper
cpumap_print_to_pagebuf() or directly by drivers to export hexadecimal
bitmask and decimal list to userspace by sysfs ABI.
Drivers might be using a normal attribute for this kind of ABIs. A
normal attribute typically has show entry as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static ssize_t example_attribute_show(struct device *dev,
           struct device_attribute *attr, char *buf)
{
   ...
   return bitmap_print_to_pagebuf(true, buf, &amp;mask, nr_trig_max);
}
</pre></div>
</div>
<p>show entry of attribute has no offset and count parameters and this
means the file is limited to one page only.
<a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_to_pagebuf()</span></code></a> API works terribly well for this kind of
normal attribute with buf parameter and without offset, count:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bitmap_print_to_pagebuf(bool list, char *buf, const unsigned long *maskp,
                      int nmaskbits)
{
}
</pre></div>
</div>
<p>The problem is once we have a large bitmap, we have a chance to get a
bitmask or list more than one page. Especially for list, it could be
as complex as 0,3,5,7,9,... We have no simple way to know it exact size.
It turns out bin_attribute is a way to break this limit. bin_attribute
has show entry as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static ssize_t
example_bin_attribute_show(struct file *filp, struct kobject *kobj,
           struct bin_attribute *attr, char *buf,
           loff_t offset, size_t count)
{
   ...
}
</pre></div>
</div>
<p>With the new offset and count parameters, this makes sysfs ABI be able
to support file size more than one page. For example, offset could be
&gt;= 4096.
<a class="reference internal" href="#c.bitmap_print_bitmask_to_buf" title="bitmap_print_bitmask_to_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_bitmask_to_buf()</span></code></a>, <a class="reference internal" href="#c.bitmap_print_list_to_buf" title="bitmap_print_list_to_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_list_to_buf()</span></code></a> wit their
cpumap wrapper cpumap_print_bitmask_to_buf(), cpumap_print_list_to_buf()
make those drivers be able to support large bitmask and list after they
move to use bin_attribute. In result, we have to pass the corresponding
parameters such as off, count from bin_attribute show entry to this API.</p>
<p>The role of cpumap_print_bitmask_to_buf() and cpumap_print_list_to_buf()
is similar with cpumap_print_to_pagebuf(),  the difference is that
<a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_to_pagebuf()</span></code></a> mainly serves sysfs attribute with the assumption
the destination buffer is exactly one page and won't be more than one page.
cpumap_print_bitmask_to_buf() and cpumap_print_list_to_buf(), on the other
hand, mainly serves bin_attribute which doesn't work with exact one page,
and it can break the size limit of converted decimal list and hexadecimal
bitmask.</p>
<p>WARNING!</p>
<p>This function is not a replacement for <a class="reference internal" href="#c.sprintf" title="sprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code></a> or <a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_to_pagebuf()</span></code></a>.
It is intended to workaround sysfs limitations discussed above and should be
used carefully in general case for the following reasons:</p>
<blockquote>
<div><ul class="simple">
<li><p>Time complexity is O(nbits^2/count), comparing to O(nbits) for <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code></a>.</p></li>
<li><p>Memory complexity is O(nbits), comparing to O(1) for <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code></a>.</p></li>
<li><p><strong>off</strong> and <strong>count</strong> are NOT offset and number of bits to print.</p></li>
<li><p>If printing part of bitmap as list, the resulting string is not a correct
list representation of bitmap. Particularly, some bits within or out of
related interval may be erroneously set or unset. The format of the string
may be broken, so bitmap_parselist-like parser may fail parsing it.</p></li>
<li><p>If printing the whole bitmap as list by parts, user must ensure the order
of calls of the function such that the offset is incremented linearly.</p></li>
<li><p>If printing the whole bitmap as list by parts, user must keep bitmap
unchanged between the very first and very last call. Otherwise concatenated
result may be incorrect, and format may be broken.</p></li>
</ul>
</div></blockquote>
<p>Returns the number of characters actually printed to <strong>buf</strong></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_print_list_to_buf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_print_list_to_buf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">maskp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmaskbits</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">off</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_print_list_to_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert bitmap to decimal list format ASCII string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer into which string is placed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*maskp</span></code></dt><dd><p>pointer to bitmap to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>in the string from which we are copying, We copy to <strong>buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the maximum number of bytes to print</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Everything is same with the above <a class="reference internal" href="#c.bitmap_print_bitmask_to_buf" title="bitmap_print_bitmask_to_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_print_bitmask_to_buf()</span></code></a> except
the print format.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_parselist">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_parselist</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">maskp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmaskbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parselist" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert list format ASCII string to bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>read user string from this buffer; must be terminated
with a 0 or n.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*maskp</span></code></dt><dd><p>write resulting mask here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>number of bits in mask to be written</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Input format is a comma-separated list of decimal numbers and
ranges.  Consecutively set bits are shown as two hyphen-separated
decimal numbers, the smallest and largest bit numbers set in
the range.
Optionally each range can be postfixed to denote that only parts of it
should be set. The range will divided to groups of specific size.
From each group will be used only defined amount of bits.
Syntax: range:used_size/group_size</p>
<p><strong>Example</strong></p>
<p>0-1023:2/256 ==&gt; 0,1,256,257,512,513,768,769
The value 'N' can be used as a dynamically substituted token for the
maximum allowed value; i.e (nmaskbits - 1).  Keep in mind that it is
dynamic, so if system changes cause the bitmap width to change, such
as more cores in a CPU list, then any ranges using N will also change.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on invalid input strings. Error values:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code>: wrong region format</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code>: invalid character in string</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ERANGE</span></code>: bit number specified too large for mask</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EOVERFLOW</span></code>: integer overflow in the input parameters</p></li>
</ul>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_parselist_user">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_parselist_user</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ubuf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ulen</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">maskp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmaskbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parselist_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert user buffer's list format ASCII string to bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*ubuf</span></code></dt><dd><p>pointer to user buffer containing string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt><dd><p>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*maskp</span></code></dt><dd><p>pointer to bitmap array that will contain result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper for <a class="reference internal" href="#c.bitmap_parselist" title="bitmap_parselist"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_parselist()</span></code></a>, providing it with user buffer.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_parse">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_parse</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">buflen</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">maskp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmaskbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parse" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert an ASCII hex string into a bitmap.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*start</span></code></dt><dd><p>pointer to buffer containing string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt><dd><p>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0 or n. In that case,
UINT_MAX may be provided instead of string length.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*maskp</span></code></dt><dd><p>pointer to bitmap array that will contain result.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Commas group hex digits into chunks.  Each chunk defines exactly 32
bits of the resultant bitmask.  No chunk may specify a value larger
than 32 bits (<code class="docutils literal notranslate"><span class="pre">-EOVERFLOW</span></code>), and if a chunk specifies a smaller value
then leading 0-bits are prepended.  <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> is returned for illegal
characters. Grouping such as &quot;1,,5&quot;, &quot;,44&quot;, &quot;,&quot; or &quot;&quot; is allowed.
Leading, embedded and trailing whitespace accepted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_remap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_remap</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_remap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply map defined by a pair of bitmaps to another bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst</span></code></dt><dd><p>remapped result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src</span></code></dt><dd><p>subset to be remapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>defines domain of map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*new</span></code></dt><dd><p>defines range of map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight 'w' of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>If either of the <strong>old</strong> and <strong>new</strong> bitmaps are empty, or if <strong>src</strong> and
<strong>dst</strong> point to the same location, then this routine copies <strong>src</strong>
to <strong>dst</strong>.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to <strong>src</strong>, placing the result in
<strong>dst</strong>, clearing any bits previously set in <strong>dst</strong>.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>src</strong> comes into this routine
with bits 1, 5 and 7 set, then <strong>dst</strong> should leave with bits 1,
13 and 15 set.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_bitremap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_bitremap</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">oldbit</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_bitremap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply map defined by a pair of bitmaps to a single bit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oldbit</span></code></dt><dd><p>bit position to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*old</span></code></dt><dd><p>defines domain of map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*new</span></code></dt><dd><p>defines range of map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight 'w' of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to bit position <strong>oldbit</strong>, returning
the new bit position.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>oldbit</strong> is 5, then this routine
returns 13.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_find_free_region">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_find_free_region</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bitmap</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_free_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find a contiguous aligned mem region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*bitmap</span></code></dt><dd><p>array of unsigned longs corresponding to the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of bits in the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>region size (log base 2 of number of bits) to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a region of free (zero) bits in a <strong>bitmap</strong> of <strong>bits</strong> bits and
allocate them (set them to one).  Only consider regions of length
a power (<strong>order</strong>) of two, aligned to that power of two, which
makes the search algorithm much faster.</p>
<p>Return the bit offset in bitmap of the allocated region,
or -errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_release_region">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_release_region</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bitmap</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">pos</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_release_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release allocated bitmap region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*bitmap</span></code></dt><dd><p>array of unsigned longs corresponding to the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt><dd><p>beginning of bit region to release</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>region size (log base 2 of number of bits) to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the complement to __bitmap_find_free_region() and releases
the found region (by clearing it in the bitmap).</p>
<p>No return value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_allocate_region">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_allocate_region</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bitmap</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">pos</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_allocate_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate bitmap region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*bitmap</span></code></dt><dd><p>array of unsigned longs corresponding to the bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt><dd><p>beginning of bit region to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>region size (log base 2 of number of bits) to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate (set bits in) a specified region of a bitmap.</p>
<p>Return 0 on success, or <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> if specified region wasn't
free (not all bits were zero).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_copy_le">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_copy_le</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_copy_le" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy a bitmap, putting the bits into little-endian order.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src</span></code></dt><dd><p>bitmap to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in the bitmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Require nbits % BITS_PER_LONG == 0.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_from_arr32">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_from_arr32</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bitmap</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_arr32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy the contents of u32 array of bits to bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*bitmap</span></code></dt><dd><p>array of unsigned longs, the destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*buf</span></code></dt><dd><p>array of u32 (in host byte order), the source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in <strong>bitmap</strong></p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_to_arr32">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_to_arr32</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bitmap</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_to_arr32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy the contents of bitmap to a u32 array of bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*buf</span></code></dt><dd><p>array of u32 (in host byte order), the dest bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*bitmap</span></code></dt><dd><p>array of unsigned longs, the source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in <strong>bitmap</strong></p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_from_arr64">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_from_arr64</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bitmap</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_arr64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy the contents of u64 array of bits to bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*bitmap</span></code></dt><dd><p>array of unsigned longs, the destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u64</span> <span class="pre">*buf</span></code></dt><dd><p>array of u64 (in host byte order), the source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in <strong>bitmap</strong></p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_to_arr64">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_to_arr64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bitmap</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_to_arr64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>copy the contents of bitmap to a u64 array of bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*buf</span></code></dt><dd><p>array of u64 (in host byte order), the dest bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*bitmap</span></code></dt><dd><p>array of unsigned longs, the source bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in <strong>bitmap</strong></p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_print_to_buf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_print_to_buf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">maskp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nmaskbits</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">off</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_print_to_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert bitmap to list or hex format ASCII string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">list</span></code></dt><dd><p>indicates whether the bitmap must be list
true:  print in decimal list format
false: print in hexadecimal bitmask format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer into which string is placed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*maskp</span></code></dt><dd><p>pointer to bitmap to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt><dd><p>size of bitmap, in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>in the string from which we are copying, We copy to <strong>buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the maximum number of bytes to print</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_pos_to_ord">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_pos_to_ord</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">pos</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_pos_to_ord" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find ordinal of set bit at given position in bitmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to a bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt><dd><p>a bit position in <strong>buf</strong> (0 &lt;= <strong>pos</strong> &lt; <strong>nbits</strong>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of valid bit positions in <strong>buf</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the bit at position <strong>pos</strong> in <strong>buf</strong> (of length <strong>nbits</strong>) to the
ordinal of which set bit it is.  If it is not set or if <strong>pos</strong>
is not a valid bit position, map to -1.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>pos</strong>
values 4 through 7 will get mapped to 0 through 3, respectively,
and other <strong>pos</strong> values will get mapped to -1.  When <strong>pos</strong> value 7
gets mapped to (returns) <strong>ord</strong> value 3 in this example, that means
that bit 7 is the 3rd (starting with 0th) set bit in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>bits</strong> are valid positions in <strong>buf</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_onto">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_onto</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">orig</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">relmap</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_onto" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>translate one bitmap relative to another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst</span></code></dt><dd><p>resulting translated bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*orig</span></code></dt><dd><p>original untranslated bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*relmap</span></code></dt><dd><p>bitmap relative to which translated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the n-th bit of <strong>dst</strong> iff there exists some m such that the
n-th bit of <strong>relmap</strong> is set, the m-th bit of <strong>orig</strong> is set, and
the n-th bit of <strong>relmap</strong> is also the m-th _set_ bit of <strong>relmap</strong>.
(If you understood the previous sentence the first time your
read it, you're overqualified for your current job.)</p>
<p>In other words, <strong>orig</strong> is mapped onto (surjectively) <strong>dst</strong>,
using the map { &lt;n, m&gt; | the n-th bit of <strong>relmap</strong> is the
m-th set bit of <strong>relmap</strong> }.</p>
<p>Any set bits in <strong>orig</strong> above bit number W, where W is the
weight of (number of set bits in) <strong>relmap</strong> are mapped nowhere.
In particular, if for all bits m set in <strong>orig</strong>, m &gt;= W, then
<strong>dst</strong> will end up empty.  In situations where the possibility
of such an empty result is not desired, one way to avoid it is
to use the <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a> operator, below, to first fold the
<strong>orig</strong> bitmap over itself so that all its set bits x are in the
range 0 &lt;= x &lt; W.  The <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a> operator does this by
setting the bit (m % W) in <strong>dst</strong>, for each bit (m) set in <strong>orig</strong>.</p>
<dl>
<dt>Example [1] for bitmap_onto():</dt><dd><p>Let's say <strong>relmap</strong> has bits 30-39 set, and <strong>orig</strong> has bits
1, 3, 5, 7, 9 and 11 set.  Then on return from this routine,
<strong>dst</strong> will have bits 31, 33, 35, 37 and 39 set.</p>
<p>When bit 0 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the first bit (if any)
that is turned on in <strong>relmap</strong>.  Since bit 0 was off in the
above example, we leave off that bit (bit 30) in <strong>dst</strong>.</p>
<p>When bit 1 is set in <strong>orig</strong> (as in the above example), it
means turn on the bit in <strong>dst</strong> corresponding to whatever
is the second bit that is turned on in <strong>relmap</strong>.  The second
bit in <strong>relmap</strong> that was turned on in the above example was
bit 31, so we turned on bit 31 in <strong>dst</strong>.</p>
<p>Similarly, we turned on bits 33, 35, 37 and 39 in <strong>dst</strong>,
because they were the 4th, 6th, 8th and 10th set bits
set in <strong>relmap</strong>, and the 4th, 6th, 8th and 10th bits of
<strong>orig</strong> (i.e. bits 3, 5, 7 and 9) were also set.</p>
<p>When bit 11 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the twelfth bit that is
turned on in <strong>relmap</strong>.  In the above example, there were
only ten bits turned on in <strong>relmap</strong> (30..39), so that bit
11 was set in <strong>orig</strong> had no affect on <strong>dst</strong>.</p>
</dd>
<dt>Example [2] for bitmap_fold() + bitmap_onto():</dt><dd><p>Let's say <strong>relmap</strong> has these ten bits set:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>40 41 42 43 45 48 53 61 74 95
</pre></div>
</div>
<p>(for the curious, that's 40 plus the first ten terms of the
Fibonacci sequence.)</p>
<p>Further lets say we use the following code, invoking
<a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a> then bitmap_onto, as suggested above to
avoid the possibility of an empty <strong>dst</strong> result:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned long *tmp;     // a temporary bitmap&#39;s bits

bitmap_fold(tmp, orig, bitmap_weight(relmap, bits), bits);
bitmap_onto(dst, tmp, relmap, bits);
</pre></div>
</div>
<p>Then this table shows what various values of <strong>dst</strong> would be, for
various <strong>orig</strong>'s.  I list the zero-based positions of each set bit.
The tmp column shows the intermediate result, as computed by
using <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a> to fold the <strong>orig</strong> bitmap modulo ten
(the weight of <strong>relmap</strong>):</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>orig</strong></p></td>
<td><p>tmp</p></td>
<td><p><strong>dst</strong></p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>40</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>41</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>9</p></td>
<td><p>95</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>0</p></td>
<td><p>40 <a class="footnote-reference brackets" href="#f1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p>1 3 5 7</p></td>
<td><p>1 3 5 7</p></td>
<td><p>41 43 48 61</p></td>
</tr>
<tr class="row-odd"><td><p>0 1 2 3 4</p></td>
<td><p>0 1 2 3 4</p></td>
<td><p>40 41 42 43 45</p></td>
</tr>
<tr class="row-even"><td><p>0 9 18 27</p></td>
<td><p>0 9 8 7</p></td>
<td><p>40 61 74 95</p></td>
</tr>
<tr class="row-odd"><td><p>0 10 20 30</p></td>
<td><p>0</p></td>
<td><p>40</p></td>
</tr>
<tr class="row-even"><td><p>0 11 22 33</p></td>
<td><p>0 1 2 3</p></td>
<td><p>40 41 42 43</p></td>
</tr>
<tr class="row-odd"><td><p>0 12 24 36</p></td>
<td><p>0 2 4 6</p></td>
<td><p>40 42 45 53</p></td>
</tr>
<tr class="row-even"><td><p>78 102 211</p></td>
<td><p>1 2 8</p></td>
<td><p>41 42 74 <a class="footnote-reference brackets" href="#f1" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
</dl>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>)</span>
<p>For these marked lines, if we hadn't first done <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_fold()</span></code></a>
into tmp, then the <strong>dst</strong> result would have been empty.</p>
</aside>
</aside>
<p>If either of <strong>orig</strong> or <strong>relmap</strong> is empty (no set bits), then <strong>dst</strong>
will be returned empty.</p>
<p>If (as explained above) the only set bits in <strong>orig</strong> are in positions
m where m &gt;= W, (where W is the weight of <strong>relmap</strong>) then <strong>dst</strong> will
once again be returned empty.</p>
<p>All bits in <strong>dst</strong> not set by the above rule are cleared.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_fold">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_fold</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">orig</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sz</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_fold" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fold larger bitmap into smaller, modulo specified size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst</span></code></dt><dd><p>resulting smaller bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*orig</span></code></dt><dd><p>original larger bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz</span></code></dt><dd><p>specified size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each bit oldbit in <strong>orig</strong>, set bit oldbit mod <strong>sz</strong> in <strong>dst</strong>.
Clear all other bits in <strong>dst</strong>.  See further the comment and
Example [2] for <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal notranslate"><span class="pre">bitmap_onto()</span></code></a> for why and how to use this.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_find_next_zero_area">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_find_next_zero_area</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">align_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_next_zero_area" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find a contiguous aligned zero area</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*map</span></code></dt><dd><p>The address to base the search on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>The bitmap size in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>The bitnumber to start searching at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>The number of zeroed bits we're looking for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_mask</span></code></dt><dd><p>Alignment mask for zero area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>align_mask</strong> should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds is multiples of that
power of 2. A <strong>align_mask</strong> of 0 means no alignment is required.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_or_equal">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_or_equal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src3</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_or_equal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check whether the or of two bitmaps is equal to a third</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src1</span></code></dt><dd><p>Pointer to bitmap 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src2</span></code></dt><dd><p>Pointer to bitmap 2 will be or'ed with bitmap 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src3</span></code></dt><dd><p>Pointer to bitmap 3. Compare to the result of <strong>*src1</strong> | <strong>*src2</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits in each of these bitmaps</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if (<strong>*src1</strong> | <strong>*src2</strong>) == <strong>*src3</strong>, false otherwise</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.BITMAP_FROM_U64">
<span class="sig-name descname"><span class="n"><span class="pre">BITMAP_FROM_U64</span></span></span><a class="headerlink" href="#c.BITMAP_FROM_U64" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">BITMAP_FROM_U64</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>Represent u64 value in the format suitable for bitmap.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>u64 value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Linux bitmaps are internally arrays of unsigned longs, i.e. 32-bit
integers in 32-bit environment, and 64-bit integers in 64-bit one.</p>
<p>There are four combinations of endianness and length of the word in linux
ABIs: LE64, BE64, LE32 and BE32.</p>
<p>On 64-bit kernels 64-bit LE and BE numbers are naturally ordered in
bitmaps and therefore don't require any special handling.</p>
<p>On 32-bit kernels 32-bit LE ABI orders lo word of 64-bit number in memory
prior to hi, and 32-bit BE orders hi word prior to lo. The bitmap on the
other hand is represented as an array of 32-bit words and the position of
bit N may therefore be calculated as: word #(N/32) and bit #(N``32``) in that
word.  For example, bit #42 is located at 10th position of 2nd word.
It matches 32-bit LE ABI, and we can simply let the compiler store 64-bit
values in memory as it usually does. But for BE we need to swap hi and lo
words manually.</p>
<p>With all that, the macro <a class="reference internal" href="#c.BITMAP_FROM_U64" title="BITMAP_FROM_U64"><code class="xref c c-func docutils literal notranslate"><span class="pre">BITMAP_FROM_U64()</span></code></a> does explicit reordering of hi and
lo parts of u64.  For LE32 it does nothing, and for BE environment it swaps
hi and lo words, as is expected by bitmap.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_from_u64">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_from_u64</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_u64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check and swap words within u64.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*dst</span></code></dt><dd><p>destination bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">mask</span></code></dt><dd><p>source bitmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In 32-bit Big Endian kernel, when using <code class="docutils literal notranslate"><span class="pre">(u32</span> <span class="pre">*)(:c:type:`val`)[*]</span></code>
to read u64 mask, we will get the wrong word.
That is <code class="docutils literal notranslate"><span class="pre">(u32</span> <span class="pre">*)(:c:type:`val`)[0]</span></code> gets the upper 32 bits,
but we expect the lower 32-bits of u64.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_get_value8">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_get_value8</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_get_value8" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get an 8-bit value within a memory region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*map</span></code></dt><dd><p>address to the bitmap memory region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>bit offset of the 8-bit value; must be a multiple of 8</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the 8-bit value located at the <strong>start</strong> bit offset within the <strong>src</strong>
memory region.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bitmap_set_value8">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitmap_set_value8</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">value</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_set_value8" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set an 8-bit value within a memory region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*map</span></code></dt><dd><p>address to the bitmap memory region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">value</span></code></dt><dd><p>the 8-bit value; values wider than 8 bits may clobber bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>bit offset of the 8-bit value; must be a multiple of 8</p>
</dd>
</dl>
</div>
</section>
<section id="command-line-parsing">
<h3>Command-line Parsing<a class="headerlink" href="#command-line-parsing" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_option">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_option</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pint</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_option" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse integer from an option string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**str</span></code></dt><dd><p>option string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*pint</span></code></dt><dd><p>(optional output) integer value parsed from <strong>str</strong></p>
<p>Read an int from an option string; if available accept a subsequent
comma as well.</p>
<p>When <strong>pint</strong> is NULL the function can be used as a validator of
the current option in the string.</p>
<p>Return values:
0 - no int in string
1 - int found, no subsequent comma
2 - int found including a subsequent comma
3 - hyphen found to denote a range</p>
<p>Leading hyphen without integer is no integer case, but we consume it
for the sake of simplification.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_options">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_options</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nints</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ints</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_options" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Parse a string into a list of integers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>String to be parsed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nints</span></code></dt><dd><p>size of integer array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*ints</span></code></dt><dd><p>integer array (must have room for at least one element)</p>
<p>This function parses a string containing a comma-separated
list of integers, a hyphen-separated range of _positive_ integers,
or a combination of both.  The parse halts when the array is
full, or when no more numbers can be retrieved from the
string.</p>
<p>When <strong>nints</strong> is 0, the function just validates the given <strong>str</strong> and
returns the amount of parseable integers as described below.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>The first element is filled by the number of collected integers
in the range. The rest is what was parsed from the <strong>str</strong>.</p>
<p>Return value is the character in the string which caused
the parse to end (typically a null terminator, if <strong>str</strong> is
completely parseable).</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.memparse">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">memparse</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">retptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.memparse" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>parse a string with mem suffixes into a number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*ptr</span></code></dt><dd><p>Where parse begins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**retptr</span></code></dt><dd><p>(output) Optional pointer to next char after parse completes</p>
<p>Parses a string into a number.  The number stored at <strong>ptr</strong> is
potentially suffixed with K, M, G, T, P, E.</p>
</dd>
</dl>
</div>
</section>
<section id="error-pointers">
<h3>Error Pointers<a class="headerlink" href="#error-pointers" title="Permalink to this heading">¶</a></h3>
<dl class="c macro">
<dt class="sig sig-object c" id="c.IS_ERR_VALUE">
<span class="sig-name descname"><span class="n"><span class="pre">IS_ERR_VALUE</span></span></span><a class="headerlink" href="#c.IS_ERR_VALUE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">IS_ERR_VALUE</span> <span class="pre">(x)</span></code></p>
<blockquote>
<div><p>Detect an error pointer.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>The pointer to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a>, but does not generate a compiler warning if result is unused.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ERR_PTR">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ERR_PTR</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">error</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ERR_PTR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an error pointer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">error</span></code></dt><dd><p>A negative error code.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encodes <strong>error</strong> into a pointer value. Users should consider the result
opaque and not assume anything about how the error is encoded.</p>
<p><strong>Return</strong></p>
<p>A pointer with <strong>error</strong> encoded within its value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PTR_ERR">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PTR_ERR</span></span></span><span class="sig-paren">(</span><span class="pre">__force</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PTR_ERR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract the error code from an error pointer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__force</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>An error pointer.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The error code within <strong>ptr</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.IS_ERR">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IS_ERR</span></span></span><span class="sig-paren">(</span><span class="pre">__force</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.IS_ERR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Detect an error pointer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__force</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>The pointer to check.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if <strong>ptr</strong> is an error pointer, false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.IS_ERR_OR_NULL">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IS_ERR_OR_NULL</span></span></span><span class="sig-paren">(</span><span class="pre">__force</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.IS_ERR_OR_NULL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Detect an error pointer or a null pointer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__force</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>The pointer to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a>, but also returns true for a null pointer.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ERR_CAST">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ERR_CAST</span></span></span><span class="sig-paren">(</span><span class="pre">__force</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ERR_CAST" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Explicitly cast an error-valued pointer to another pointer type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__force</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>The pointer to cast.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Explicitly cast an error-valued pointer to another pointer type in such a
way as to make it clear that's what's going on.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PTR_ERR_OR_ZERO">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PTR_ERR_OR_ZERO</span></span></span><span class="sig-paren">(</span><span class="pre">__force</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PTR_ERR_OR_ZERO" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract the error code from a pointer if it has one.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__force</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>A potential error pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenience function that can be used inside a function that returns
an error code to propagate errors received as error pointers.
For example, <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">PTR_ERR_OR_ZERO(ptr);</span></code> replaces:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>The error code within <strong>ptr</strong> if it is an error pointer; 0 otherwise.</p>
</div>
</section>
<section id="sorting">
<h3>Sorting<a class="headerlink" href="#sorting" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.sort_r">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sort_r</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">base</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">cmp_r_func_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmp_func</span></span>, <span class="n"><span class="pre">swap_r_func_t</span></span><span class="w"> </span><span class="n"><span class="pre">swap_func</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">priv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sort_r" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sort an array of elements</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*base</span></code></dt><dd><p>pointer to data to sort</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>number of elements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of each element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmp_r_func_t</span> <span class="pre">cmp_func</span></code></dt><dd><p>pointer to comparison function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swap_r_func_t</span> <span class="pre">swap_func</span></code></dt><dd><p>pointer to swap function or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>third argument passed to comparison function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does a heapsort on the given array.  You may provide
a swap_func function if you need to do something more than a memory
copy (e.g. fix up pointers or auxiliary data), but the built-in swap
avoids a slow retpoline and so is significantly faster.</p>
<p>Sorting time is O(n log n) both on average and worst-case. While
quicksort is slightly faster on average, it suffers from exploitable
O(n*n) worst-case behavior and extra memory requirements that make
it less suitable for kernel use.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_sort">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_sort</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">priv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="n"><span class="pre">list_cmp_func_t</span></span><span class="w"> </span><span class="n"><span class="pre">cmp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_sort" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>sort a list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>private data, opaque to <a class="reference internal" href="#c.list_sort" title="list_sort"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_sort()</span></code></a>, passed to <strong>cmp</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the list to sort</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list_cmp_func_t</span> <span class="pre">cmp</span></code></dt><dd><p>the elements comparison function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The comparison function <strong>cmp</strong> must return &gt; 0 if <strong>a</strong> should sort after
<strong>b</strong> (&quot;<strong>a</strong> &gt; <strong>b</strong>&quot; if you want an ascending sort), and &lt;= 0 if <strong>a</strong> should
sort before <strong>b</strong> <em>or</em> their original order should be preserved.  It is
always called with the element that came first in the input in <strong>a</strong>,
and list_sort is a stable sort, so it is not necessary to distinguish
the <strong>a</strong> &lt; <strong>b</strong> and <strong>a</strong> == <strong>b</strong> cases.</p>
<p>This is compatible with two styles of <strong>cmp</strong> function:
- The traditional style which returns &lt;0 / =0 / &gt;0, or
- Returning a boolean 0/1.
The latter offers a chance to save a few cycles in the comparison
(which is used by e.g. plug_ctx_cmp() in block/blk-mq.c).</p>
<p>A good way to write a multi-word comparison is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (a-&gt;high != b-&gt;high)
        return a-&gt;high &gt; b-&gt;high;
if (a-&gt;middle != b-&gt;middle)
        return a-&gt;middle &gt; b-&gt;middle;
return a-&gt;low &gt; b-&gt;low;
</pre></div>
</div>
<p>This mergesort is as eager as possible while always performing at least
2:1 balanced merges.  Given two pending sublists of size 2^k, they are
merged to a size-2^(k+1) list as soon as we have 2^k following elements.</p>
<p>Thus, it will avoid cache thrashing as long as 3*2^k elements can
fit into the cache.  Not quite as good as a fully-eager bottom-up
mergesort, but it does use 0.2*n fewer comparisons, so is faster in
the common case that everything fits into L1.</p>
<p>The merging is controlled by &quot;count&quot;, the number of elements in the
pending lists.  This is beautifully simple code, but rather subtle.</p>
<p>Each time we increment &quot;count&quot;, we set one bit (bit k) and clear
bits k-1 .. 0.  Each time this happens (except the very first time
for each bit, when count increments to 2^k), we merge two lists of
size 2^k into one list of size 2^(k+1).</p>
<p>This merge happens exactly when the count reaches an odd multiple of
2^k, which is when we have 2^k elements pending in smaller lists,
so it's safe to merge away two lists of size 2^k.</p>
<p>After this happens twice, we have created two lists of size 2^(k+1),
which will be merged into a list of size 2^(k+2) before we create
a third list of size 2^(k+1), so there are never more than two pending.</p>
<p>The number of pending lists of size 2^k is determined by the
state of bit k of &quot;count&quot; plus two extra pieces of information:</p>
<ul class="simple">
<li><p>The state of bit k-1 (when k == 0, consider bit -1 always set), and</p></li>
<li><p>Whether the higher-order bits are zero or non-zero (i.e.
is count &gt;= 2^(k+1)).</p></li>
</ul>
<p>There are six states we distinguish.  &quot;x&quot; represents some arbitrary
bits, and &quot;y&quot; represents some arbitrary non-zero bits:
0:  00x: 0 pending of size 2^k;           x pending of sizes &lt; 2^k
1:  01x: 0 pending of size 2^k; 2^(k-1) + x pending of sizes &lt; 2^k
2: x10x: 0 pending of size 2^k; 2^k     + x pending of sizes &lt; 2^k
3: x11x: 1 pending of size 2^k; 2^(k-1) + x pending of sizes &lt; 2^k
4: y00x: 1 pending of size 2^k; 2^k     + x pending of sizes &lt; 2^k
5: y01x: 2 pending of size 2^k; 2^(k-1) + x pending of sizes &lt; 2^k
(merge and loop back to state 2)</p>
<p>We gain lists of size 2^k in the 2-&gt;3 and 4-&gt;5 transitions (because
bit k-1 is set while the more significant bits are non-zero) and
merge them away in the 5-&gt;2 transition.  Note in particular that just
before the 5-&gt;2 transition, all lower-order bits are 11 (state 3),
so there is one list of each smaller size.</p>
<p>When we reach the end of the input, we merge all the pending
lists, from smallest to largest.  If you work through cases 2 to
5 above, you can see that the number of elements we merge with a list
of size 2^k varies from 2^(k-1) (cases 3 and 5 when x == 0) to
2^(k+1) - 1 (second merge of case 5 when x == 2^(k-1) - 1).</p>
</div>
</section>
<section id="text-searching">
<h3>Text Searching<a class="headerlink" href="#text-searching" title="Permalink to this heading">¶</a></h3>
<p>INTRODUCTION</p>
<blockquote>
<div><p>The textsearch infrastructure provides text searching facilities for
both linear and non-linear data. Individual search algorithms are
implemented in modules and chosen by the user.</p>
</div></blockquote>
<p>ARCHITECTURE</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  User
  +----------------+
  |        finish()|&lt;--------------(6)-----------------+
  |get_next_block()|&lt;--------------(5)---------------+ |
  |                |                     Algorithm   | |
  |                |                    +------------------------------+
  |                |                    |  init()   find()   destroy() |
  |                |                    +------------------------------+
  |                |       Core API           ^       ^          ^
  |                |      +---------------+  (2)     (4)        (8)
  |             (1)|-----&gt;| prepare()     |---+       |          |
  |             (3)|-----&gt;| find()/next() |-----------+          |
  |             (7)|-----&gt;| destroy()     |----------------------+
  +----------------+      +---------------+

(1) User configures a search by calling textsearch_prepare() specifying
    the search parameters such as the pattern and algorithm name.
(2) Core requests the algorithm to allocate and initialize a search
    configuration according to the specified parameters.
(3) User starts the search(es) by calling textsearch_find() or
    textsearch_next() to fetch subsequent occurrences. A state variable
    is provided to the algorithm to store persistent variables.
(4) Core eventually resets the search offset and forwards the find()
    request to the algorithm.
(5) Algorithm calls get_next_block() provided by the user continuously
    to fetch the data to be searched in block by block.
(6) Algorithm invokes finish() after the last call to get_next_block
    to clean up any leftovers from get_next_block. (Optional)
(7) User destroys the configuration by calling textsearch_destroy().
(8) Core notifies the algorithm to destroy algorithm specific
    allocations. (Optional)
</pre></div>
</div>
<p>USAGE</p>
<blockquote>
<div><p>Before a search can be performed, a configuration must be created
by calling <a class="reference internal" href="#c.textsearch_prepare" title="textsearch_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_prepare()</span></code></a> specifying the searching algorithm,
the pattern to look for and flags. As a flag, you can set TS_IGNORECASE
to perform case insensitive matching. But it might slow down
performance of algorithm, so you should use it at own your risk.
The returned configuration may then be used for an arbitrary
amount of times and even in parallel as long as a separate struct
ts_state variable is provided to every instance.</p>
<p>The actual search is performed by either calling
<a class="reference internal" href="#c.textsearch_find_continuous" title="textsearch_find_continuous"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_find_continuous()</span></code></a> for linear data or by providing
an own get_next_block() implementation and
calling <a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_find()</span></code></a>. Both functions return
the position of the first occurrence of the pattern or UINT_MAX if
no match was found. Subsequent occurrences can be found by calling
<a class="reference internal" href="#c.textsearch_next" title="textsearch_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_next()</span></code></a> regardless of the linearity of the data.</p>
<p>Once you're done using a configuration it must be given back via
textsearch_destroy.</p>
</div></blockquote>
<p>EXAMPLE:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pos;
struct ts_config *conf;
struct ts_state state;
const char *pattern = &quot;chicken&quot;;
const char *example = &quot;We dance the funky chicken&quot;;

conf = textsearch_prepare(&quot;kmp&quot;, pattern, strlen(pattern),
                          GFP_KERNEL, TS_AUTOLOAD);
if (IS_ERR(conf)) {
    err = PTR_ERR(conf);
    goto errout;
}

pos = textsearch_find_continuous(conf, &amp;state, example, strlen(example));
if (pos != UINT_MAX)
    panic(&quot;Oh my god, dancing chickens at %d\n&quot;, pos);

textsearch_destroy(conf);
</pre></div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a textsearch module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_ops</span> <span class="pre">*ops</span></code></dt><dd><p>operations lookup table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by textsearch modules to announce
their presence. The specified &amp;**ops** must have <code class="docutils literal notranslate"><span class="pre">name</span></code> set to a
unique identifier and the callbacks find(), init(), get_pattern(),
and get_pattern_len() must be implemented.</p>
<p>Returns 0 or -EEXISTS if another module has already registered
with same name.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_unregister">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a textsearch module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_ops</span> <span class="pre">*ops</span></code></dt><dd><p>operations lookup table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by textsearch modules to announce
their disappearance for examples when the module gets unloaded.
The <code class="xref c c-type docutils literal notranslate"><span class="pre">ops</span></code> parameter must be the same as the one during the
registration.</p>
<p>Returns 0 on success or -ENOENT if no matching textsearch
registration was found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_find_continuous">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_find_continuous</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_find_continuous" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>search a pattern in continuous/linear data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*conf</span></code></dt><dd><p>search configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*state</span></code></dt><dd><p>search state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A simplified version of <a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_find()</span></code></a> for continuous/linear data.
Call <a class="reference internal" href="#c.textsearch_next" title="textsearch_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_next()</span></code></a> to retrieve subsequent matches.</p>
<p>Returns the position of first occurrence of the pattern or
<code class="docutils literal notranslate"><span class="pre">UINT_MAX</span></code> if no occurrence was found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_prepare">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_prepare</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">algo</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pattern</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_prepare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Prepare a search</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*algo</span></code></dt><dd><p>name of search algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*pattern</span></code></dt><dd><p>pattern data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of pattern</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>search flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the search algorithm module and creates a new textsearch
configuration for the specified pattern.</p>
<p>Returns a new textsearch configuration according to the specified
parameters or a <a class="reference internal" href="#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>. If a zero length pattern is passed, this
function returns EINVAL.</p>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>The format of the pattern may not be compatible between</dt><dd><p>the various search algorithms.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroy a search configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*conf</span></code></dt><dd><p>search configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all references of the configuration and frees
up the memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_next">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_next" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>continue searching for a pattern</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*conf</span></code></dt><dd><p>search configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*state</span></code></dt><dd><p>search state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continues a search looking for more occurrences of the pattern.
<a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_find()</span></code></a> must be called to find the first occurrence
in order to reset the state.</p>
<p>Returns the position of the next occurrence of the pattern or
UINT_MAX if not match was found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_find">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start searching for a pattern</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*conf</span></code></dt><dd><p>search configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*state</span></code></dt><dd><p>search state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the position of first occurrence of the pattern or
UINT_MAX if no match was found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_get_pattern">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_get_pattern</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_get_pattern" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return head of the pattern</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*conf</span></code></dt><dd><p>search configuration</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.textsearch_get_pattern_len">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">textsearch_get_pattern_len</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ts_config</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">conf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_get_pattern_len" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return length of the pattern</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*conf</span></code></dt><dd><p>search configuration</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="crc-and-math-functions-in-linux">
<h2>CRC and Math Functions in Linux<a class="headerlink" href="#crc-and-math-functions-in-linux" title="Permalink to this heading">¶</a></h2>
<section id="arithmetic-overflow-checking">
<h3>Arithmetic Overflow Checking<a class="headerlink" href="#arithmetic-overflow-checking" title="Permalink to this heading">¶</a></h3>
<dl class="c macro">
<dt class="sig sig-object c" id="c.check_add_overflow">
<span class="sig-name descname"><span class="n"><span class="pre">check_add_overflow</span></span></span><a class="headerlink" href="#c.check_add_overflow" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">check_add_overflow</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">d)</span></code></p>
<blockquote>
<div><p>Calculate addition with overflow checking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first addend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second addend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code></dt><dd><p>pointer to store sum</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success.</p>
<p><strong>*d</strong> holds the results of the attempted addition, but is not considered
&quot;safe for use&quot; on a non-zero return value, which indicates that the
sum has overflowed or been truncated.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.check_sub_overflow">
<span class="sig-name descname"><span class="n"><span class="pre">check_sub_overflow</span></span></span><a class="headerlink" href="#c.check_sub_overflow" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">check_sub_overflow</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">d)</span></code></p>
<blockquote>
<div><p>Calculate subtraction with overflow checking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>minuend; value to subtract from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>subtrahend; value to subtract from <strong>a</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code></dt><dd><p>pointer to store difference</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success.</p>
<p><strong>*d</strong> holds the results of the attempted subtraction, but is not considered
&quot;safe for use&quot; on a non-zero return value, which indicates that the
difference has underflowed or been truncated.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.check_mul_overflow">
<span class="sig-name descname"><span class="n"><span class="pre">check_mul_overflow</span></span></span><a class="headerlink" href="#c.check_mul_overflow" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">check_mul_overflow</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">d)</span></code></p>
<blockquote>
<div><p>Calculate multiplication with overflow checking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>first factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>second factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code></dt><dd><p>pointer to store product</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success.</p>
<p><strong>*d</strong> holds the results of the attempted multiplication, but is not
considered &quot;safe for use&quot; on a non-zero return value, which indicates
that the product has overflowed or been truncated.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.check_shl_overflow">
<span class="sig-name descname"><span class="n"><span class="pre">check_shl_overflow</span></span></span><a class="headerlink" href="#c.check_shl_overflow" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">check_shl_overflow</span> <span class="pre">(a,</span> <span class="pre">s,</span> <span class="pre">d)</span></code></p>
<blockquote>
<div><p>Calculate a left-shifted value and check overflow</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>Value to be shifted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt><dd><p>How many bits left to shift</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code></dt><dd><p>Pointer to where to store the result</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes <strong>*d</strong> = (<strong>a</strong> &lt;&lt; <strong>s</strong>)</p>
<p>Returns true if '<strong>*d</strong>' cannot hold the result or when '<strong>a</strong> &lt;&lt; <strong>s</strong>' doesn't
make sense. Example conditions:</p>
<ul class="simple">
<li><p>'<strong>a</strong> &lt;&lt; <strong>s</strong>' causes bits to be lost when stored in <strong>*d</strong>.</p></li>
<li><p>'<strong>s</strong>' is garbage (e.g. negative) or so large that the result of
'<strong>a</strong> &lt;&lt; <strong>s</strong>' is guaranteed to be 0.</p></li>
<li><p>'<strong>a</strong>' is negative.</p></li>
<li><p>'<strong>a</strong> &lt;&lt; <strong>s</strong>' sets the sign bit, if any, in '<strong>*d</strong>'.</p></li>
</ul>
<p>'<strong>*d</strong>' will hold the results of the attempted shift, but is not
considered &quot;safe for use&quot; if true is returned.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.overflows_type">
<span class="sig-name descname"><span class="n"><span class="pre">overflows_type</span></span></span><a class="headerlink" href="#c.overflows_type" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">overflows_type</span> <span class="pre">(n,</span> <span class="pre">T)</span></code></p>
<blockquote>
<div><p>helper for checking the overflows between value, variables, or data type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>source constant value or variable to be checked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">T</span></code></dt><dd><p>destination variable or data type proposed to store <strong>x</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compares the <strong>x</strong> expression for whether or not it can safely fit in
the storage of the type in <strong>T</strong>. <strong>x</strong> and <strong>T</strong> can have different types.
If <strong>x</strong> is a constant expression, this will also resolve to a constant
expression.</p>
<p><strong>Return</strong></p>
<p>true if overflow can occur, false otherwise.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.castable_to_type">
<span class="sig-name descname"><span class="n"><span class="pre">castable_to_type</span></span></span><a class="headerlink" href="#c.castable_to_type" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">castable_to_type</span> <span class="pre">(n,</span> <span class="pre">T)</span></code></p>
<blockquote>
<div><p>like __same_type(), but also allows for casted literals</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>variable or constant value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">T</span></code></dt><dd><p>variable or data type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike the __same_type() macro, this allows a constant value as the
first argument. If this value would not overflow into an assignment
of the second argument's type, it returns true. Otherwise, this falls
back to __same_type().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.size_mul">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size_mul</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">factor1</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">factor2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.size_mul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate size_t multiplication with saturation at SIZE_MAX</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">factor1</span></code></dt><dd><p>first factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">factor2</span></code></dt><dd><p>second factor</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>calculate <strong>factor1</strong> * <strong>factor2</strong>, both promoted to size_t,
with any overflow causing the return value to be SIZE_MAX. The
lvalue must be size_t to avoid implicit type conversion.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.size_add">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size_add</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">addend1</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">addend2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.size_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate size_t addition with saturation at SIZE_MAX</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">addend1</span></code></dt><dd><p>first addend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">addend2</span></code></dt><dd><p>second addend</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>calculate <strong>addend1</strong> + <strong>addend2</strong>, both promoted to size_t,
with any overflow causing the return value to be SIZE_MAX. The
lvalue must be size_t to avoid implicit type conversion.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.size_sub">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size_sub</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">minuend</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">subtrahend</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.size_sub" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate size_t subtraction with saturation at SIZE_MAX</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">minuend</span></code></dt><dd><p>value to subtract from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">subtrahend</span></code></dt><dd><p>value to subtract from <strong>minuend</strong></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>calculate <strong>minuend</strong> - <strong>subtrahend</strong>, both promoted to size_t,
with any overflow causing the return value to be SIZE_MAX. For
composition with the <a class="reference internal" href="#c.size_add" title="size_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">size_add()</span></code></a> and <a class="reference internal" href="#c.size_mul" title="size_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">size_mul()</span></code></a> helpers, neither
argument may be SIZE_MAX (or the result with be forced to SIZE_MAX).
The lvalue must be size_t to avoid implicit type conversion.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.array_size">
<span class="sig-name descname"><span class="n"><span class="pre">array_size</span></span></span><a class="headerlink" href="#c.array_size" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">array_size</span> <span class="pre">(a,</span> <span class="pre">b)</span></code></p>
<blockquote>
<div><p>Calculate size of 2-dimensional array.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>dimension one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>dimension two</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of 2-dimensional array: <strong>a</strong> * <strong>b</strong>.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed to represent the array or SIZE_MAX on
overflow.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.array3_size">
<span class="sig-name descname"><span class="n"><span class="pre">array3_size</span></span></span><a class="headerlink" href="#c.array3_size" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">array3_size</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>Calculate size of 3-dimensional array.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">a</span></code></dt><dd><p>dimension one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code></dt><dd><p>dimension two</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>dimension three</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of 3-dimensional array: <strong>a</strong> * <strong>b</strong> * <strong>c</strong>.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed to represent the array or SIZE_MAX on
overflow.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.flex_array_size">
<span class="sig-name descname"><span class="n"><span class="pre">flex_array_size</span></span></span><a class="headerlink" href="#c.flex_array_size" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">flex_array_size</span> <span class="pre">(p,</span> <span class="pre">member,</span> <span class="pre">count)</span></code></p>
<blockquote>
<div><p>Calculate size of a flexible array member within an enclosing structure.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Pointer to the structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>Name of the flexible array member.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of a flexible array of <strong>count</strong> number of <strong>member</strong>
elements, at the end of structure <strong>p</strong>.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed or SIZE_MAX on overflow.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.struct_size">
<span class="sig-name descname"><span class="n"><span class="pre">struct_size</span></span></span><a class="headerlink" href="#c.struct_size" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">struct_size</span> <span class="pre">(p,</span> <span class="pre">member,</span> <span class="pre">count)</span></code></p>
<blockquote>
<div><p>Calculate size of structure with trailing flexible array.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Pointer to the structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>Name of the array member.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of memory needed for structure of <strong>p</strong> followed by an
array of <strong>count</strong> number of <strong>member</strong> elements.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed or SIZE_MAX on overflow.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.struct_size_t">
<span class="sig-name descname"><span class="n"><span class="pre">struct_size_t</span></span></span><a class="headerlink" href="#c.struct_size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">struct_size_t</span> <span class="pre">(type,</span> <span class="pre">member,</span> <span class="pre">count)</span></code></p>
<blockquote>
<div><p>Calculate size of structure with trailing flexible array</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>structure type name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>Name of the array member.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates size of memory needed for structure <strong>type</strong> followed by an
array of <strong>count</strong> number of <strong>member</strong> elements. Prefer using <a class="reference internal" href="#c.struct_size" title="struct_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">struct_size()</span></code></a>
when possible instead, to keep calculations associated with a specific
instance variable of type <strong>type</strong>.</p>
<p><strong>Return</strong></p>
<p>number of bytes needed or SIZE_MAX on overflow.</p>
</div>
</section>
<section id="crc-functions">
<h3>CRC Functions<a class="headerlink" href="#crc-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc4">
<span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc4</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">uint8_t</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc4" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>calculate the 4-bit crc of a value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">c</span></code></dt><dd><p>starting crc4</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">x</span></code></dt><dd><p>value to checksum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bits</span></code></dt><dd><p>number of bits in <strong>x</strong> to checksum</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the crc4 value of <strong>x</strong>, using polynomial 0b10111.</p>
<p>The <strong>x</strong> value is treated as left-aligned, and bits above <strong>bits</strong> are ignored
in the crc calculations.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc7_be">
<span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc7_be</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc7_be" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the CRC7 for the data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC7 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>any</p>
<p><strong>Description</strong></p>
<p>Returns the updated CRC7 value.
The CRC7 is left-aligned in the byte (the lsbit is always 0), as that
makes the computation easier, and all callers want it in that form.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc8_populate_msb">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc8_populate_msb</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">table</span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">CRC8_TABLE_SIZE</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">polynomial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8_populate_msb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fill crc table for given polynomial in reverse bit order.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">table[CRC8_TABLE_SIZE]</span></code></dt><dd><p>table to be filled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">polynomial</span></code></dt><dd><p>polynomial for which table is to be filled.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc8_populate_lsb">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc8_populate_lsb</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">table</span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">CRC8_TABLE_SIZE</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">polynomial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8_populate_lsb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fill crc table for given polynomial in regular bit order.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">table[CRC8_TABLE_SIZE]</span></code></dt><dd><p>table to be filled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">polynomial</span></code></dt><dd><p>polynomial for which table is to be filled.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc8">
<span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc8</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">table</span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">CRC8_TABLE_SIZE</span></span><span class="p"><span class="pre">]</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pdata</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nbytes</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>calculate a crc8 over the given input data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">table[CRC8_TABLE_SIZE]</span></code></dt><dd><p>crc table used for calculation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*pdata</span></code></dt><dd><p>pointer to data buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt><dd><p>number of bytes in data buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">crc</span></code></dt><dd><p>previous returned crc8 value.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc16">
<span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>compute the CRC-16 for the data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc32_le_generic">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="pre">__pure</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc32_le_generic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tab</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">256</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">polynomial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_le_generic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate bitwise little-endian Ethernet AUTODIN II CRC32/CRC32C</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">crc</span></code></dt><dd><p>seed value for computation.  ~0 for Ethernet, sometimes 0 for other
uses, or the previous crc32/crc32c value if computing incrementally.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*p</span></code></dt><dd><p>pointer to buffer over which CRC32/CRC32C is run</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of buffer <strong>p</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(*tab)[256]</span></code></dt><dd><p>little-endian Ethernet table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt><dd><p>CRC32/CRC32c LE polynomial</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc32_generic_shift">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc32_generic_shift</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">polynomial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_generic_shift" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append <strong>len</strong> 0 bytes to crc, in logarithmic time</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">crc</span></code></dt><dd><p>The original little-endian CRC (i.e. lsbit is x^31 coefficient)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The number of bytes. <strong>crc</strong> is multiplied by x^(8***len**)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt><dd><p>The modulus used to reduce the result to 32 bits.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It's possible to parallelize CRC computations by computing a CRC
over separate ranges of a buffer, then summing them.
This shifts the given CRC by 8*len bits (i.e. produces the same effect
as appending len bytes of zero to the data), in time proportional
to log(len).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc32_be_generic">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="pre">__pure</span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc32_be_generic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tab</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">256</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">polynomial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_be_generic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate bitwise big-endian Ethernet AUTODIN II CRC32</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">crc</span></code></dt><dd><p>seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*p</span></code></dt><dd><p>pointer to buffer over which CRC32 is run</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of buffer <strong>p</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(*tab)[256]</span></code></dt><dd><p>big-endian Ethernet table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt><dd><p>CRC32 BE polynomial</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc_ccitt">
<span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc_ccitt</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_ccitt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>recompute the CRC (CRC-CCITT variant) for the data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc_ccitt_false">
<span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc_ccitt_false</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span>, <span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_ccitt_false" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>recompute the CRC (CRC-CCITT-FALSE variant) for the data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.crc_itu_t">
<span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">crc_itu_t</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">crc</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_itu_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute the CRC-ITU-T for the data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">crc</span></code></dt><dd><p>previous CRC value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*buffer</span></code></dt><dd><p>data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes in the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value</p>
</div>
</section>
<section id="base-2-log-and-power-functions">
<h3>Base 2 log and power Functions<a class="headerlink" href="#base-2-log-and-power-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.is_power_of_2">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">is_power_of_2</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.is_power_of_2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if a value is a power of two</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>the value to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether some value is a power of two, where zero is
<em>not</em> considered a power of two.</p>
<p><strong>Return</strong></p>
<p>true if <strong>n</strong> is a power of 2, otherwise false.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__roundup_pow_of_two">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__roundup_pow_of_two</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__roundup_pow_of_two" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>round up to nearest power of two</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>value to round up</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__rounddown_pow_of_two">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__rounddown_pow_of_two</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__rounddown_pow_of_two" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>round down to nearest power of two</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt><dd><p>value to round down</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.const_ilog2">
<span class="sig-name descname"><span class="n"><span class="pre">const_ilog2</span></span></span><a class="headerlink" href="#c.const_ilog2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">const_ilog2</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>log base 2 of 32-bit or a 64-bit constant unsigned value</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this where sparse expects a true constant expression, e.g. for array
indices.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.ilog2">
<span class="sig-name descname"><span class="n"><span class="pre">ilog2</span></span></span><a class="headerlink" href="#c.ilog2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">ilog2</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>log base 2 of 32-bit or a 64-bit unsigned value</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>constant-capable log of base 2 calculation
- this can be used to initialise global variables from constant data, hence
the massive ternary operator construction</p>
<p>selects the appropriately-sized optimised version depending on sizeof(n)</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.roundup_pow_of_two">
<span class="sig-name descname"><span class="n"><span class="pre">roundup_pow_of_two</span></span></span><a class="headerlink" href="#c.roundup_pow_of_two" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">roundup_pow_of_two</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>round the given value up to nearest power of two</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>round the given value up to the nearest power of two
- the result is undefined when n == 0
- this can be used to initialise global variables from constant data</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rounddown_pow_of_two">
<span class="sig-name descname"><span class="n"><span class="pre">rounddown_pow_of_two</span></span></span><a class="headerlink" href="#c.rounddown_pow_of_two" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rounddown_pow_of_two</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>round the given value down to nearest power of two</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>round the given value down to the nearest power of two
- the result is undefined when n == 0
- this can be used to initialise global variables from constant data</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.order_base_2">
<span class="sig-name descname"><span class="n"><span class="pre">order_base_2</span></span></span><a class="headerlink" href="#c.order_base_2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">order_base_2</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>calculate the (rounded up) base 2 order of the argument</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The first few values calculated by this routine:</dt><dd><p>ob2(0) = 0
ob2(1) = 0
ob2(2) = 1
ob2(3) = 2
ob2(4) = 2
ob2(5) = 3
... and so on.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.bits_per">
<span class="sig-name descname"><span class="n"><span class="pre">bits_per</span></span></span><a class="headerlink" href="#c.bits_per" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">bits_per</span> <span class="pre">(n)</span></code></p>
<blockquote>
<div><p>calculate the number of bits required for the argument</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is constant-capable and can be used for compile time
initializations, e.g bitfields.</p>
<p>The first few values calculated by this routine:
bf(0) = 1
bf(1) = 1
bf(2) = 2
bf(3) = 2
bf(4) = 3
... and so on.</p>
</div>
</section>
<section id="integer-log-and-power-functions">
<h3>Integer log and power Functions<a class="headerlink" href="#integer-log-and-power-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.intlog2">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intlog2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.intlog2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>computes log2 of a value; the result is shifted left by 24 bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">value</span></code></dt><dd><p>The value (must be != 0)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>to use rational values you can use the following method:</p>
<blockquote>
<div><p>intlog2(value) = intlog2(value * 2^x) - x * 2^24</p>
</div></blockquote>
<p>Some usecase examples:</p>
<blockquote>
<div><p>intlog2(8) will give 3 &lt;&lt; 24 = 3 * 2^24</p>
<p>intlog2(9) will give 3 &lt;&lt; 24 + ... = 3.16... * 2^24</p>
<p>intlog2(1.5) = intlog2(3) - 2^24 = 0.584... * 2^24</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>log2(value) * 2^24</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.intlog10">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">intlog10</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.intlog10" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>computes log10 of a value; the result is shifted left by 24 bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">value</span></code></dt><dd><p>The value (must be != 0)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>to use rational values you can use the following method:</p>
<blockquote>
<div><p>intlog10(value) = intlog10(value * 10^x) - x * 2^24</p>
</div></blockquote>
<p>An usecase example:</p>
<blockquote>
<div><blockquote>
<div><p>intlog10(1000) will give 3 &lt;&lt; 24 = 3 * 2^24</p>
</div></blockquote>
<p>due to the implementation intlog10(1000) might be not exactly 3 * 2^24</p>
</div></blockquote>
<p>look at intlog2 for similar examples</p>
<p><strong>Return</strong></p>
<p>log10(value) * 2^24</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.int_pow">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">int_pow</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.int_pow" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>computes the exponentiation of the given base and exponent</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">base</span></code></dt><dd><p>base which will be raised to the given power</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">exp</span></code></dt><dd><p>power to be raised to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes: pow(base, exp), i.e. <strong>base</strong> raised to the <strong>exp</strong> power</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.int_sqrt">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">int_sqrt</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.int_sqrt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>computes the integer square root</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">x</span></code></dt><dd><p>integer of which to calculate the sqrt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes: floor(sqrt(x))</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.int_sqrt64">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">int_sqrt64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.int_sqrt64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>strongly typed int_sqrt function when minimum 64 bit input is expected.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">x</span></code></dt><dd><p>64bit integer of which to calculate the sqrt</p>
</dd>
</dl>
</div>
</section>
<section id="division-functions">
<h3>Division Functions<a class="headerlink" href="#division-functions" title="Permalink to this heading">¶</a></h3>
<dl class="c macro">
<dt class="sig sig-object c" id="c.do_div">
<span class="sig-name descname"><span class="n"><span class="pre">do_div</span></span></span><a class="headerlink" href="#c.do_div" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">do_div</span> <span class="pre">(n,</span> <span class="pre">base)</span></code></p>
<blockquote>
<div><p>returns 2 values: calculate remainder and update new dividend</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>uint64_t dividend (will be updated)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>uint32_t divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Summary:
<code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">remainder</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">%</span> <span class="pre">base;</span></code>
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">/</span> <span class="pre">base;</span></code></p>
<p><strong>Return</strong></p>
<p>(uint32_t)remainder</p>
<p><strong>NOTE</strong></p>
<p>macro parameter <strong>n</strong> is evaluated multiple times,
beware of side effects!</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.div_u64_rem">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">div_u64_rem</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">dividend</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">divisor</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">remainder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.div_u64_rem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unsigned 64bit divide with 32bit divisor with remainder</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">divisor</span></code></dt><dd><p>unsigned 32bit divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*remainder</span></code></dt><dd><p>pointer to unsigned 32bit remainder</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal notranslate"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
<p><strong>Description</strong></p>
<p>This is commonly provided by 32bit archs to provide an optimized 64bit
divide.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.div_s64_rem">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">div_s64_rem</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">dividend</span></span>, <span class="n"><span class="pre">s32</span></span><span class="w"> </span><span class="n"><span class="pre">divisor</span></span>, <span class="n"><span class="pre">s32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">remainder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.div_s64_rem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>signed 64bit divide with 32bit divisor with remainder</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt><dd><p>signed 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">divisor</span></code></dt><dd><p>signed 32bit divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">*remainder</span></code></dt><dd><p>pointer to signed 32bit remainder</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal notranslate"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.div64_u64_rem">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">div64_u64_rem</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">dividend</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">divisor</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">remainder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_u64_rem" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unsigned 64bit divide with 64bit divisor and remainder</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt><dd><p>unsigned 64bit divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*remainder</span></code></dt><dd><p>pointer to unsigned 64bit remainder</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal notranslate"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.div64_u64">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">div64_u64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">dividend</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">divisor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_u64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unsigned 64bit divide with 64bit divisor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt><dd><p>unsigned 64bit divisor</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>dividend / divisor</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.div64_s64">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">div64_s64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">dividend</span></span>, <span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">divisor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_s64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>signed 64bit divide with 64bit divisor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt><dd><p>signed 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">divisor</span></code></dt><dd><p>signed 64bit divisor</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>dividend / divisor</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.div_u64">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">div_u64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">dividend</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">divisor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.div_u64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unsigned 64bit divide with 32bit divisor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">divisor</span></code></dt><dd><p>unsigned 32bit divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the most common 64bit divide and should be used if possible,
as many 32bit archs can optimize this variant better than a full 64bit
divide.</p>
<p><strong>Return</strong></p>
<p>dividend / divisor</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.div_s64">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">div_s64</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="n"><span class="pre">dividend</span></span>, <span class="n"><span class="pre">s32</span></span><span class="w"> </span><span class="n"><span class="pre">divisor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.div_s64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>signed 64bit divide with 32bit divisor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt><dd><p>signed 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s32</span> <span class="pre">divisor</span></code></dt><dd><p>signed 32bit divisor</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>dividend / divisor</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DIV64_U64_ROUND_UP">
<span class="sig-name descname"><span class="n"><span class="pre">DIV64_U64_ROUND_UP</span></span></span><a class="headerlink" href="#c.DIV64_U64_ROUND_UP" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DIV64_U64_ROUND_UP</span> <span class="pre">(ll,</span> <span class="pre">d)</span></code></p>
<blockquote>
<div><p>unsigned 64bit divide with 64bit divisor rounded up</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ll</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code></dt><dd><p>unsigned 64bit divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide unsigned 64bit dividend by unsigned 64bit divisor
and round up.</p>
<p><strong>Return</strong></p>
<p>dividend / divisor rounded up</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DIV64_U64_ROUND_CLOSEST">
<span class="sig-name descname"><span class="n"><span class="pre">DIV64_U64_ROUND_CLOSEST</span></span></span><a class="headerlink" href="#c.DIV64_U64_ROUND_CLOSEST" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DIV64_U64_ROUND_CLOSEST</span> <span class="pre">(dividend,</span> <span class="pre">divisor)</span></code></p>
<blockquote>
<div><p>unsigned 64bit divide with 64bit divisor rounded to nearest integer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">divisor</span></code></dt><dd><p>unsigned 64bit divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide unsigned 64bit dividend by unsigned 64bit divisor
and round to closest integer.</p>
<p><strong>Return</strong></p>
<p>dividend / divisor rounded to nearest integer</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DIV_U64_ROUND_CLOSEST">
<span class="sig-name descname"><span class="n"><span class="pre">DIV_U64_ROUND_CLOSEST</span></span></span><a class="headerlink" href="#c.DIV_U64_ROUND_CLOSEST" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DIV_U64_ROUND_CLOSEST</span> <span class="pre">(dividend,</span> <span class="pre">divisor)</span></code></p>
<blockquote>
<div><p>unsigned 64bit divide with 32bit divisor rounded to nearest integer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dividend</span></code></dt><dd><p>unsigned 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">divisor</span></code></dt><dd><p>unsigned 32bit divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide unsigned 64bit dividend by unsigned 32bit divisor
and round to closest integer.</p>
<p><strong>Return</strong></p>
<p>dividend / divisor rounded to nearest integer</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DIV_S64_ROUND_CLOSEST">
<span class="sig-name descname"><span class="n"><span class="pre">DIV_S64_ROUND_CLOSEST</span></span></span><a class="headerlink" href="#c.DIV_S64_ROUND_CLOSEST" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DIV_S64_ROUND_CLOSEST</span> <span class="pre">(dividend,</span> <span class="pre">divisor)</span></code></p>
<blockquote>
<div><p>signed 64bit divide with 32bit divisor rounded to nearest integer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dividend</span></code></dt><dd><p>signed 64bit dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">divisor</span></code></dt><dd><p>signed 32bit divisor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide signed 64bit dividend by signed 32bit divisor
and round to closest integer.</p>
<p><strong>Return</strong></p>
<p>dividend / divisor rounded to nearest integer</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.gcd">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gcd</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.gcd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>calculate and return the greatest common divisor of 2 unsigned longs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a</span></code></dt><dd><p>first value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">b</span></code></dt><dd><p>second value</p>
</dd>
</dl>
</div>
</section>
<section id="uuid-guid">
<h3>UUID/GUID<a class="headerlink" href="#uuid-guid" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.generate_random_uuid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generate_random_uuid</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">uuid</span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">16</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generate_random_uuid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generate a random UUID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">uuid[16]</span></code></dt><dd><p>where to put the generated UUID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Random UUID interface</p>
<p>Used to create a Boot ID or a filesystem UUID/GUID, but can be
useful for other kernel drivers.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.uuid_is_valid">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">uuid_is_valid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uuid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.uuid_is_valid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>checks if a UUID string is valid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*uuid</span></code></dt><dd><p>UUID string to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>It checks if the UUID string is following the format:</dt><dd><p>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</p>
</dd>
</dl>
<p>where x is a hex digit.</p>
<p><strong>Return</strong></p>
<p>true if input is valid UUID string.</p>
</div>
</section>
</section>
<section id="kernel-ipc-facilities">
<h2>Kernel IPC facilities<a class="headerlink" href="#kernel-ipc-facilities" title="Permalink to this heading">¶</a></h2>
<section id="ipc-utilities">
<h3>IPC utilities<a class="headerlink" href="#ipc-utilities" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialise ipc subsystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The various sysv ipc resources (semaphores, messages and shared
memory) are initialised.</p>
<p>A callback routine is registered into the memory hotplug notifier
chain: since msgmni scales to lowmem this callback routine will be
called upon successful memory add / remove to recompute msmgni.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_init_ids">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_init_ids</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_ids" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialise ipc identifiers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up the sequence range to use for the ipc identifier range (limited
below ipc_mni) then initialise the keys hashtable and ids idr.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_init_proc_interface">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_init_proc_interface</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">header</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ids</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">show</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">seq_file</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_proc_interface" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a proc interface for sysipc types using a seq_file interface.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*path</span></code></dt><dd><p>Path in procfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*header</span></code></dt><dd><p>Banner to be printed at the beginning of the file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ids</span></code></dt><dd><p>ipc id table to iterate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*show)(struct</span> <span class="pre">seq_file</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>show routine.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_findkey">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ipc_findkey</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="n"><span class="pre">key_t</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_findkey" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find a key in an ipc identifier set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_t</span> <span class="pre">key</span></code></dt><dd><p>key to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the locked pointer to the ipc structure if found or NULL
otherwise. If key is found ipc points to the owning ipc structure</p>
<p>Called with writer ipc_ids.rwsem held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_addid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_addid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_addid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add an ipc identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*new</span></code></dt><dd><p>new ipc permission set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">limit</span></code></dt><dd><p>limit for the number of used ids</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an entry 'new' to the ipc ids idr. The permissions object is
initialised and the first free entry is set up and the index assigned
is returned. The 'new' entry is returned in a locked state on success.</p>
<p>On failure the entry is not locked and a negative err-code is returned.
The caller must use ipc_rcu_putref() to free the identifier.</p>
<p>Called with writer ipc_ids.rwsem held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipcget_new">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipcget_new</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_namespace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ns</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_params</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_new" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new ipc object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the actual creation routine to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*params</span></code></dt><dd><p>its parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, sys_semget() and sys_shmget()
when the key is IPC_PRIVATE.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_check_perms">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_check_perms</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_namespace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ns</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ipcp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_params</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_check_perms" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check security and permissions for an ipc object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*ipcp</span></code></dt><dd><p>ipc permission set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the actual security routine to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*params</span></code></dt><dd><p>its parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget(), sys_semget() and sys_shmget()
when the key is not IPC_PRIVATE and that key already exists in the
ds IDR.</p>
<p>On success, the ipc id is returned.</p>
<p>It is called with ipc_ids.rwsem and ipcp-&gt;lock held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipcget_public">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipcget_public</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_namespace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ns</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_params</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_public" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get an ipc object or create a new one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the actual creation routine to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*params</span></code></dt><dd><p>its parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, sys_semget() and sys_shmget()
when the key is not IPC_PRIVATE.
It adds a new entry if the key is not found and does some permission
/ security checkings if the key is found.</p>
<p>On success, the ipc id is returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_kht_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_kht_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ipcp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_kht_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove an ipc from the key hashtable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*ipcp</span></code></dt><dd><p>ipc perm structure containing the key to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_search_maxidx">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_search_maxidx</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_search_maxidx" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>search for the highest assigned index</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">limit</span></code></dt><dd><p>known upper limit for highest assigned index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function determines the highest assigned index in <strong>ids</strong>. It is intended
to be called when ids-&gt;max_idx needs to be updated.
Updating ids-&gt;max_idx is necessary when the current highest index ipc
object is deleted.
If no ipc object is allocated, then -1 is returned.</p>
<p>ipc_ids.rwsem needs to be held by the caller.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_rmid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_rmid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ipcp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_rmid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove an ipc identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*ipcp</span></code></dt><dd><p>ipc perm structure containing the identifier to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_set_key_private">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_set_key_private</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ipcp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_set_key_private" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>switch the key of an existing ipc to IPC_PRIVATE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*ipcp</span></code></dt><dd><p>ipc perm structure containing the key to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipcperms">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipcperms</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_namespace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ns</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ipcp</span></span>, <span class="kt"><span class="pre">short</span></span><span class="w"> </span><span class="n"><span class="pre">flag</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcperms" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check ipc permissions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*ipcp</span></code></dt><dd><p>ipc permission set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">short</span> <span class="pre">flag</span></code></dt><dd><p>desired permission set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check user, group, other permissions for access
to ipc resources. return 0 if allowed</p>
<p><strong>flag</strong> will most probably be 0 or <code class="docutils literal notranslate"><span class="pre">S_...UGO</span></code> from &lt;linux/stat.h&gt;</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.kernel_to_ipc64_perm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kernel_to_ipc64_perm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">in</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc64_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_to_ipc64_perm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert kernel ipc permissions to user</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*in</span></code></dt><dd><p>kernel permissions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*out</span></code></dt><dd><p>new style ipc permissions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the kernel object <strong>in</strong> into a set of permissions descriptions
for returning to userspace (<strong>out</strong>).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc64_perm_to_ipc_perm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc64_perm_to_ipc_perm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc64_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">in</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc64_perm_to_ipc_perm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>convert new ipc permissions to old</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*in</span></code></dt><dd><p>new style ipc permissions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_perm</span> <span class="pre">*out</span></code></dt><dd><p>old style ipc permissions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the new style permissions object <strong>in</strong> into a compatibility
object and store it into the <strong>out</strong> pointer.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_obtain_object_idr">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ipc_obtain_object_idr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_idr" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>ipc id to look for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for an id in the ipc ids idr and return associated ipc object.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_obtain_object_check">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ipc_obtain_object_check</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_check" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>ipc id to look for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.ipc_obtain_object_idr" title="ipc_obtain_object_idr"><code class="xref c c-func docutils literal notranslate"><span class="pre">ipc_obtain_object_idr()</span></code></a> but also checks the ipc object
sequence number.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipcget">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipcget</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_namespace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ns</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_params</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Common sys_*get() code</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*ns</span></code></dt><dd><p>namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*ops</span></code></dt><dd><p>operations to be called on ipc object creation, permission checks
and further checks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*params</span></code></dt><dd><p>the parameters needed by the previous operations.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Common routine called by sys_msgget(), sys_semget() and sys_shmget().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_update_perm">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_update_perm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc64_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">in</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_update_perm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the permissions of an ipc object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*in</span></code></dt><dd><p>the permission given as input.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*out</span></code></dt><dd><p>the permission of the ipc to set.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipcctl_obtain_check">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ipcctl_obtain_check</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_namespace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ns</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc64_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">perm</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">extra_perm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcctl_obtain_check" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>retrieve an ipc object and check permissions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*ns</span></code></dt><dd><p>ipc namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>the table of ids where to look for the ipc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>the id of the ipc to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>the cmd to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*perm</span></code></dt><dd><p>the permission to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">extra_perm</span></code></dt><dd><p>one extra permission parameter used by msq</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does some common audit and permissions check for some IPC_XXX
cmd and is called from semctl_down, shmctl_down and msgctl_down.</p>
<dl class="simple">
<dt>It:</dt><dd><ul class="simple">
<li><p>retrieves the ipc object with the given id in the given table.</p></li>
<li><p>performs some audit and permission check, depending on the given cmd</p></li>
<li><p>returns a pointer to the ipc object or otherwise, the corresponding
error.</p></li>
</ul>
</dd>
</dl>
<p>Call holding the both the rwsem and the rcu read lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ipc_parse_version">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ipc_parse_version</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_parse_version" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ipc call version</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*cmd</span></code></dt><dd><p>pointer to command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return IPC_64 for new style IPC and IPC_OLD for old style IPC.
The <strong>cmd</strong> value is turned from an encoding command and version into
just the command code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sysvipc_find_ipc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sysvipc_find_ipc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ipc_ids</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ids</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pos</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sysvipc_find_ipc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find and lock the ipc structure based on seq pos</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*ids</span></code></dt><dd><p>ipc identifier set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*pos</span></code></dt><dd><p>expected position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function finds an ipc structure, based on the sequence file
position <strong>pos</strong>. If there is no ipc structure at position <strong>pos</strong>, then
the successor is selected.
If a structure is found, then it is locked (both <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and
ipc_lock_object()) and  <strong>pos</strong> is set to the position needed to locate
the found ipc structure.
If nothing is found (i.e. EOF), <strong>pos</strong> is not modified.</p>
<p>The function returns the found ipc structure, or NULL at EOF.</p>
</div>
</section>
</section>
<section id="fifo-buffer">
<h2>FIFO Buffer<a class="headerlink" href="#fifo-buffer" title="Permalink to this heading">¶</a></h2>
<section id="kfifo-interface">
<h3>kfifo interface<a class="headerlink" href="#kfifo-interface" title="Permalink to this heading">¶</a></h3>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DECLARE_KFIFO_PTR">
<span class="sig-name descname"><span class="n"><span class="pre">DECLARE_KFIFO_PTR</span></span></span><a class="headerlink" href="#c.DECLARE_KFIFO_PTR" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DECLARE_KFIFO_PTR</span> <span class="pre">(fifo,</span> <span class="pre">type)</span></code></p>
<blockquote>
<div><p>macro to declare a fifo pointer object</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>name of the declared fifo</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the fifo elements</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DECLARE_KFIFO">
<span class="sig-name descname"><span class="n"><span class="pre">DECLARE_KFIFO</span></span></span><a class="headerlink" href="#c.DECLARE_KFIFO" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DECLARE_KFIFO</span> <span class="pre">(fifo,</span> <span class="pre">type,</span> <span class="pre">size)</span></code></p>
<blockquote>
<div><p>macro to declare a fifo object</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>name of the declared fifo</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the fifo elements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>the number of elements in the fifo, this must be a power of 2</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.INIT_KFIFO">
<span class="sig-name descname"><span class="n"><span class="pre">INIT_KFIFO</span></span></span><a class="headerlink" href="#c.INIT_KFIFO" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">INIT_KFIFO</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>Initialize a fifo declared by DECLARE_KFIFO</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>name of the declared fifo datatype</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFINE_KFIFO">
<span class="sig-name descname"><span class="n"><span class="pre">DEFINE_KFIFO</span></span></span><a class="headerlink" href="#c.DEFINE_KFIFO" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEFINE_KFIFO</span> <span class="pre">(fifo,</span> <span class="pre">type,</span> <span class="pre">size)</span></code></p>
<blockquote>
<div><p>macro to define and initialize a fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>name of the declared fifo datatype</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the fifo elements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>the number of elements in the fifo, this must be a power of 2</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>the macro can be used for global and local fifo data type variables.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_initialized">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_initialized</span></span></span><a class="headerlink" href="#c.kfifo_initialized" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_initialized</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>Check if the fifo is initialized</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if fifo is initialized, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>.
Assumes the fifo was 0 before.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_esize">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_esize</span></span></span><a class="headerlink" href="#c.kfifo_esize" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_esize</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>returns the size of the element managed by the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_recsize">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_recsize</span></span></span><a class="headerlink" href="#c.kfifo_recsize" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_recsize</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>returns the size of the record length field</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_size">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_size</span></span></span><a class="headerlink" href="#c.kfifo_size" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_size</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>returns the size of the fifo in elements</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_reset">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_reset</span></span></span><a class="headerlink" href="#c.kfifo_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_reset</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>removes the entire fifo content</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>usage of <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_reset()</span></code></a> is dangerous. It should be only called when the
fifo is exclusived locked or when it is secured that no other thread is
accessing the fifo.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_reset_out">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_reset_out</span></span></span><a class="headerlink" href="#c.kfifo_reset_out" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_reset_out</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>skip fifo content</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>The usage of <a class="reference internal" href="#c.kfifo_reset_out" title="kfifo_reset_out"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_reset_out()</span></code></a> is safe until it will be only called
from the reader thread and there is only one concurrent reader. Otherwise
it is dangerous and must be handled in the same way as <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_reset()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_len">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_len</span></span></span><a class="headerlink" href="#c.kfifo_len" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_len</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>returns the number of used elements in the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_is_empty">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_is_empty</span></span></span><a class="headerlink" href="#c.kfifo_is_empty" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_is_empty</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>returns true if the fifo is empty</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_is_empty_spinlocked">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_is_empty_spinlocked</span></span></span><a class="headerlink" href="#c.kfifo_is_empty_spinlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_is_empty_spinlocked</span> <span class="pre">(fifo,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>returns true if the fifo is empty using a spinlock for locking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spinlock to be used for locking</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_is_empty_spinlocked_noirqsave">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_is_empty_spinlocked_noirqsave</span></span></span><a class="headerlink" href="#c.kfifo_is_empty_spinlocked_noirqsave" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_is_empty_spinlocked_noirqsave</span> <span class="pre">(fifo,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>returns true if the fifo is empty using a spinlock for locking, doesn't disable interrupts</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spinlock to be used for locking</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_is_full">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_is_full</span></span></span><a class="headerlink" href="#c.kfifo_is_full" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_is_full</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>returns true if the fifo is full</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_avail">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_avail</span></span></span><a class="headerlink" href="#c.kfifo_avail" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_avail</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>returns the number of unused elements in the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_skip">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_skip</span></span></span><a class="headerlink" href="#c.kfifo_skip" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_skip</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>skip output data</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_peek_len">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_peek_len</span></span></span><a class="headerlink" href="#c.kfifo_peek_len" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_peek_len</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>gets the size of the next fifo record</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the size of the next fifo record in number of bytes.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_alloc">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_alloc</span></span></span><a class="headerlink" href="#c.kfifo_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_alloc</span> <span class="pre">(fifo,</span> <span class="pre">size,</span> <span class="pre">gfp_mask)</span></code></p>
<blockquote>
<div><p>dynamically allocates a new fifo buffer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>pointer to the fifo</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>the number of elements in the fifo, this must be a power of 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_mask</span></code></dt><dd><p>get_free_pages mask, passed to <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro dynamically allocates a new fifo buffer.</p>
<p>The number of elements will be rounded-up to a power of 2.
The fifo will be release with <a class="reference internal" href="#c.kfifo_free" title="kfifo_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_free()</span></code></a>.
Return 0 if no error, otherwise an error code.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_free">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_free</span></span></span><a class="headerlink" href="#c.kfifo_free" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_free</span> <span class="pre">(fifo)</span></code></p>
<blockquote>
<div><p>frees the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>the fifo to be freed</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_init">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_init</span></span></span><a class="headerlink" href="#c.kfifo_init" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_init</span> <span class="pre">(fifo,</span> <span class="pre">buffer,</span> <span class="pre">size)</span></code></p>
<blockquote>
<div><p>initialize a fifo using a preallocated buffer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>the fifo to assign the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>the preallocated buffer to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>the size of the internal buffer, this have to be a power of 2</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro initializes a fifo using a preallocated buffer.</p>
<p>The number of elements will be rounded-up to a power of 2.
Return 0 if no error, otherwise an error code.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_put">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_put</span></span></span><a class="headerlink" href="#c.kfifo_put" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_put</span> <span class="pre">(fifo,</span> <span class="pre">val)</span></code></p>
<blockquote>
<div><p>put data into the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val</span></code></dt><dd><p>the data to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given value into the fifo.
It returns 0 if the fifo was full. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macro.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_get">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_get</span></span></span><a class="headerlink" href="#c.kfifo_get" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_get</span> <span class="pre">(fifo,</span> <span class="pre">val)</span></code></p>
<blockquote>
<div><p>get data from the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val</span></code></dt><dd><p>address where to store the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro reads the data from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macro.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_peek">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_peek</span></span></span><a class="headerlink" href="#c.kfifo_peek" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_peek</span> <span class="pre">(fifo,</span> <span class="pre">val)</span></code></p>
<blockquote>
<div><p>get data from the fifo without removing</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val</span></code></dt><dd><p>address where to store the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reads the data from the fifo without removing it from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macro.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_in">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_in</span></span></span><a class="headerlink" href="#c.kfifo_in" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_in</span> <span class="pre">(fifo,</span> <span class="pre">buf,</span> <span class="pre">n)</span></code></p>
<blockquote>
<div><p>put data into the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>number of elements to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given buffer into the fifo and returns the
number of copied elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macro.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_in_spinlocked">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_in_spinlocked</span></span></span><a class="headerlink" href="#c.kfifo_in_spinlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_in_spinlocked</span> <span class="pre">(fifo,</span> <span class="pre">buf,</span> <span class="pre">n,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>put data into the fifo using a spinlock for locking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>number of elements to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to the spinlock to use for locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given values buffer into the fifo and returns the
number of copied elements.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_in_spinlocked_noirqsave">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_in_spinlocked_noirqsave</span></span></span><a class="headerlink" href="#c.kfifo_in_spinlocked_noirqsave" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_in_spinlocked_noirqsave</span> <span class="pre">(fifo,</span> <span class="pre">buf,</span> <span class="pre">n,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>put data into fifo using a spinlock for locking, don't disable interrupts</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>number of elements to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to the spinlock to use for locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.kfifo_in_spinlocked" title="kfifo_in_spinlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_in_spinlocked()</span></code></a> but uses spin_lock/unlock()
for locking and doesn't disable interrupts.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_out">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_out</span></span></span><a class="headerlink" href="#c.kfifo_out" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_out</span> <span class="pre">(fifo,</span> <span class="pre">buf,</span> <span class="pre">n)</span></code></p>
<blockquote>
<div><p>get data from the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>pointer to the storage buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>max. number of elements to get</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get some data from the fifo and return the numbers of elements
copied.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macro.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_out_spinlocked">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_out_spinlocked</span></span></span><a class="headerlink" href="#c.kfifo_out_spinlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_out_spinlocked</span> <span class="pre">(fifo,</span> <span class="pre">buf,</span> <span class="pre">n,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>get data from the fifo using a spinlock for locking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>pointer to the storage buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>max. number of elements to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to the spinlock to use for locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_out_spinlocked_noirqsave">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_out_spinlocked_noirqsave</span></span></span><a class="headerlink" href="#c.kfifo_out_spinlocked_noirqsave" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_out_spinlocked_noirqsave</span> <span class="pre">(fifo,</span> <span class="pre">buf,</span> <span class="pre">n,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>get data from the fifo using a spinlock for locking, don't disable interrupts</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>pointer to the storage buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>max. number of elements to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to the spinlock to use for locking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.kfifo_out_spinlocked" title="kfifo_out_spinlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfifo_out_spinlocked()</span></code></a> which uses spin_lock/unlock()
for locking and doesn't disable interrupts.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_from_user">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_from_user</span></span></span><a class="headerlink" href="#c.kfifo_from_user" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_from_user</span> <span class="pre">(fifo,</span> <span class="pre">from,</span> <span class="pre">len,</span> <span class="pre">copied)</span></code></p>
<blockquote>
<div><p>puts some data from user space into the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">from</span></code></dt><dd><p>pointer to the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>the length of the data to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copied</span></code></dt><dd><p>pointer to output variable to store the number of copied bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the <strong>from</strong> into the
fifo, depending of the available space and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macro.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_to_user">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_to_user</span></span></span><a class="headerlink" href="#c.kfifo_to_user" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_to_user</span> <span class="pre">(fifo,</span> <span class="pre">to,</span> <span class="pre">len,</span> <span class="pre">copied)</span></code></p>
<blockquote>
<div><p>copies data from the fifo into user space</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">to</span></code></dt><dd><p>where the data must be copied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>the size of the destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copied</span></code></dt><dd><p>pointer to output variable to store the number of copied bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the fifo into the
<strong>to</strong> buffer and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macro.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_dma_in_prepare">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_dma_in_prepare</span></span></span><a class="headerlink" href="#c.kfifo_dma_in_prepare" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_dma_in_prepare</span> <span class="pre">(fifo,</span> <span class="pre">sgl,</span> <span class="pre">nents,</span> <span class="pre">len)</span></code></p>
<blockquote>
<div><p>setup a scatterlist for DMA input</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgl</span></code></dt><dd><p>pointer to the scatterlist array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nents</span></code></dt><dd><p>number of entries in the scatterlist array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of elements to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA input.
It returns the number entries in the scatterlist array.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macros.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_dma_in_finish">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_dma_in_finish</span></span></span><a class="headerlink" href="#c.kfifo_dma_in_finish" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_dma_in_finish</span> <span class="pre">(fifo,</span> <span class="pre">len)</span></code></p>
<blockquote>
<div><p>finish a DMA IN operation</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of bytes to received</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA IN operation. The in counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macros.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_dma_out_prepare">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_dma_out_prepare</span></span></span><a class="headerlink" href="#c.kfifo_dma_out_prepare" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_dma_out_prepare</span> <span class="pre">(fifo,</span> <span class="pre">sgl,</span> <span class="pre">nents,</span> <span class="pre">len)</span></code></p>
<blockquote>
<div><p>setup a scatterlist for DMA output</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgl</span></code></dt><dd><p>pointer to the scatterlist array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nents</span></code></dt><dd><p>number of entries in the scatterlist array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of elements to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA output which at most <strong>len</strong> bytes
to transfer.
It returns the number entries in the scatterlist array.
A zero means there is no space available and the scatterlist is not filled.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macros.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_dma_out_finish">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_dma_out_finish</span></span></span><a class="headerlink" href="#c.kfifo_dma_out_finish" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_dma_out_finish</span> <span class="pre">(fifo,</span> <span class="pre">len)</span></code></p>
<blockquote>
<div><p>finish a DMA OUT operation</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of bytes transferred</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA OUT operation. The out counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macros.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfifo_out_peek">
<span class="sig-name descname"><span class="n"><span class="pre">kfifo_out_peek</span></span></span><a class="headerlink" href="#c.kfifo_out_peek" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfifo_out_peek</span> <span class="pre">(fifo,</span> <span class="pre">buf,</span> <span class="pre">n)</span></code></p>
<blockquote>
<div><p>gets some data from the fifo</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fifo</span></code></dt><dd><p>address of the fifo to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>pointer to the storage buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>max. number of elements to get</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied. The data is not removed from the fifo.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don't need extra locking to use these macro.</p>
</div>
</section>
</section>
<section id="relay-interface-support">
<h2>relay interface support<a class="headerlink" href="#relay-interface-support" title="Permalink to this heading">¶</a></h2>
<p>Relay interface support is designed to provide an efficient mechanism
for tools and facilities to relay large amounts of data from kernel
space to user space.</p>
<section id="relay-interface">
<h3>relay interface<a class="headerlink" href="#relay-interface" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_buf_full">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_buf_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>boolean, is the channel buffer full?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>channel buffer</p>
<p>Returns 1 if the buffer is full, 0 otherwise.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset the channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*chan</span></code></dt><dd><p>the channel</p>
<p>This has the effect of erasing all data from all channel buffers
and restarting the channel in its initial state.  The buffers
are not freed, so any mappings are still in effect.</p>
<p>NOTE. Care should be taken that the channel isn't actually
being used by anything when this call is made.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_open">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">relay_open</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">base_filename</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">subbuf_size</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_subbufs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_callbacks</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cb</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">private_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_open" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new relay channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*base_filename</span></code></dt><dd><p>base name of files to create, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for buffering only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>dentry of parent directory, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for root directory or buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">subbuf_size</span></code></dt><dd><p>size of sub-buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">n_subbufs</span></code></dt><dd><p>number of sub-buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rchan_callbacks</span> <span class="pre">*cb</span></code></dt><dd><p>client callback functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*private_data</span></code></dt><dd><p>user-defined data</p>
<p>Returns channel pointer if successful, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<p>Creates a channel buffer for each cpu using the sizes and
attributes specified.  The created channel buffer files
will be named base_filename0...base_filenameN-1.  File
permissions will be <code class="docutils literal notranslate"><span class="pre">S_IRUSR</span></code>.</p>
<p>If opening a buffer (<strong>parent</strong> = NULL) that you later wish to register
in a filesystem, call <a class="reference internal" href="#c.relay_late_setup_files" title="relay_late_setup_files"><code class="xref c c-func docutils literal notranslate"><span class="pre">relay_late_setup_files()</span></code></a> once the <strong>parent</strong> dentry
is available.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_late_setup_files">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_late_setup_files</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chan</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">base_filename</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_late_setup_files" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>triggers file creation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*chan</span></code></dt><dd><p>channel to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*base_filename</span></code></dt><dd><p>base name of files to create</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>dentry of parent directory, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for root directory</p>
<p>Returns 0 if successful, non-zero otherwise.</p>
<p>Use to setup files for a previously buffer-only channel created
by <a class="reference internal" href="#c.relay_open" title="relay_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">relay_open()</span></code></a> with a NULL parent dentry.</p>
<p>For example, this is useful for perfomring early tracing in kernel,
before VFS is up and then exposing the early results once the dentry
is available.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_switch_subbuf">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_switch_subbuf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_switch_subbuf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>switch to a new sub-buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>channel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>size of current event</p>
<p>Returns either the length passed in or 0 if full.</p>
<p>Performs sub-buffer-switch tasks such as invoking callbacks,
updating padding counts, waking up readers, etc.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_subbufs_consumed">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_subbufs_consumed</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chan</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">subbufs_consumed</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_subbufs_consumed" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update the buffer's sub-buffers-consumed count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*chan</span></code></dt><dd><p>the channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the cpu associated with the channel buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">subbufs_consumed</span></code></dt><dd><p>number of sub-buffers to add to current buf's count</p>
<p>Adds to the channel buffer's consumed sub-buffer count.
subbufs_consumed should be the number of sub-buffers newly consumed,
not the total consumed.</p>
<p>NOTE. Kernel clients don't need to call this function if the channel
mode is 'overwrite'.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_close">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_close</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>close the channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*chan</span></code></dt><dd><p>the channel</p>
<p>Closes all channel buffers and frees the channel.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_flush">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_flush</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>close the channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*chan</span></code></dt><dd><p>the channel</p>
<p>Flushes all channel buffers, i.e. forces buffer switch.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_mmap_buf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_mmap_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_mmap_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>mmap channel buffer to process address space</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>relay channel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vm_area_struct describing memory to be mapped</p>
<p>Returns 0 if ok, negative on error</p>
<p>Caller should already have grabbed mmap_lock.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_alloc_buf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">relay_alloc_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_alloc_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a channel buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*size</span></code></dt><dd><p>total size of the buffer</p>
<p>Returns a pointer to the resulting buffer, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if unsuccessful. The
passed in size will get page aligned, if it isn't already.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_create_buf">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">relay_create_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_create_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate and initialize a channel buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*chan</span></code></dt><dd><p>the relay channel</p>
<p>Returns channel buffer if successful, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_destroy_channel">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_destroy_channel</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.relay_destroy_channel" title="kref"><span class="n"><span class="pre">kref</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_channel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free the channel struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*kref</span></code></dt><dd><p>target kernel reference that contains the relay channel</p>
<p>Should only be called from kref_put().</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_destroy_buf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_destroy_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroy an rchan_buf struct and associated buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer struct</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_remove_buf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_remove_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.relay_remove_buf" title="kref"><span class="n"><span class="pre">kref</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_remove_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove a channel buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*kref</span></code></dt><dd><p>target kernel reference that contains the relay buffer</p>
<p>Removes the file from the filesystem, which also frees the
rchan_buf_struct and the channel buffer.  Should only be called from
kref_put().</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_buf_empty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_buf_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_empty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>boolean, is the channel buffer empty?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>channel buffer</p>
<p>Returns 1 if the buffer is empty, 0 otherwise.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wakeup_readers">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wakeup_readers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">irq_work</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">work</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeup_readers" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wake up readers waiting on a channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_work</span> <span class="pre">*work</span></code></dt><dd><p>contains the channel buffer</p>
<p>This is the function used to defer reader waking</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__relay_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__relay_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">init</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__relay_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset a channel buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>the channel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">init</span></code></dt><dd><p>1 if this is a first-time initialization</p>
<p>See <a class="reference internal" href="#c.relay_reset" title="relay_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">relay_reset()</span></code></a> for description of effect.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_close_buf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_close_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close_buf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>close a channel buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>channel buffer</p>
<p>Marks the buffer finalized and restores the default callbacks.
The channel buffer and channel buffer data structure are then freed
automatically when the last reference is given up.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_file_open">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_file_open</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.relay_file_open" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_open" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>open file op for relay files</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>the file</p>
<p>Increments the channel buffer refcount.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_file_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_file_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_mmap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mmap file op for relay files</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>the vma describing what to map</p>
<p>Calls upon <a class="reference internal" href="#c.relay_mmap_buf" title="relay_mmap_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">relay_mmap_buf()</span></code></a> to map the file into user space.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_file_poll">
<span class="n"><span class="pre">__poll_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_file_poll</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span>, <span class="n"><span class="pre">poll_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">wait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_poll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>poll file op for relay files</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt><dd><p>poll table</p>
<p>Poll implemention.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_file_release">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_file_release</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.relay_file_release" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release file op for relay files</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>the file</p>
<p>Decrements the channel refcount, as the filesystem is
no longer using it.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_file_read_subbuf_avail">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_file_read_subbuf_avail</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">read_pos</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_subbuf_avail" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return bytes available in sub-buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt><dd><p>file read position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>relay channel buffer</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_file_read_start_pos">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_file_read_start_pos</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_start_pos" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the first available byte to read</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>relay channel buffer</p>
<p>If the read_pos is in the middle of padding, return the
position of the first actually available byte, otherwise
return the original value.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.relay_file_read_end_pos">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">relay_file_read_end_pos</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rchan_buf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">read_pos</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_end_pos" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the new read position</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*buf</span></code></dt><dd><p>relay channel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt><dd><p>file read position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to be read</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="module-support">
<h2>Module Support<a class="headerlink" href="#module-support" title="Permalink to this heading">¶</a></h2>
<section id="kernel-module-auto-loading">
<h3>Kernel module auto-loading<a class="headerlink" href="#kernel-module-auto-loading" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.__request_module">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__request_module</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">wait</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_module" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>try to load a kernel module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wait</span></code></dt><dd><p>wait (or not) for the operation to complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>printf style format string for the name of the module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>arguments as specified in the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Load a module using the user mode module loader. The function returns
zero on success or a negative errno code or positive exit code from
&quot;modprobe&quot; on failure. Note that a successful module load does not mean
the module did not then unload and exit on an error of its own. Callers
must check that the service they requested is now available not blindly
invoke it.</p>
<p>If module auto-loading support is disabled then this function
simply returns -ENOENT.</p>
</div>
</section>
<section id="module-debugging">
<h3>Module debugging<a class="headerlink" href="#module-debugging" title="Permalink to this heading">¶</a></h3>
<p>Enabling CONFIG_MODULE_STATS enables module debugging statistics which
are useful to monitor and root cause memory pressure issues with module
loading. These statistics are useful to allow us to improve production
workloads.</p>
<p>The current module debugging statistics supported help keep track of module
loading failures to enable improvements either for kernel module auto-loading
usage (request_module()) or interactions with userspace. Statistics are
provided to track all possible failures in the finit_module() path and memory
wasted in this process space.  Each of the failure counters are associated
to a type of module loading failure which is known to incur a certain amount
of memory allocation loss. In the worst case loading a module will fail after
a 3 step memory allocation process:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>memory allocated with kernel_read_file_from_fd()</p></li>
<li><p>module decompression processes the file read from
kernel_read_file_from_fd(), and <a class="reference internal" href="mm-api.html#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a> is used to map
the decompressed module to a new local buffer which represents
a copy of the decompressed module passed from userspace. The buffer
from kernel_read_file_from_fd() is freed right away.</p></li>
<li><p>layout_and_allocate() allocates space for the final resting
place where we would keep the module if it were to be processed
successfully.</p></li>
</ol>
</div></blockquote>
<p>If a failure occurs after these three different allocations only one
counter will be incremented with the summation of the allocated bytes freed
incurred during this failure. Likewise, if module loading failed only after
step b) a separate counter is used and incremented for the bytes freed and
not used during both of those allocations.</p>
<p>Virtual memory space can be limited, for example on x86 virtual memory size
defaults to 128 MiB. We should strive to limit and avoid wasting virtual
memory allocations when possible. These module debugging statistics help
to evaluate how much memory is being wasted on bootup due to module loading
failures.</p>
<p>All counters are designed to be incremental. Atomic counters are used so to
remain simple and avoid delays and deadlocks.</p>
<section id="dup-failed-modules-tracks-duplicate-failed-modules">
<h4>dup_failed_modules - tracks duplicate failed modules<a class="headerlink" href="#dup-failed-modules-tracks-duplicate-failed-modules" title="Permalink to this heading">¶</a></h4>
<p>Linked list of modules which failed to be loaded because an already existing
module with the same name was already being processed or already loaded.
The finit_module() system call incurs heavy virtual memory allocations. In
the worst case an finit_module() system call can end up allocating virtual
memory 3 times:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>kernel_read_file_from_fd() call uses <a class="reference internal" href="mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a></p></li>
<li><p>optional module decompression uses <a class="reference internal" href="mm-api.html#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a></p></li>
<li><p>layout_and allocate() can use <a class="reference internal" href="mm-api.html#c.vzalloc" title="vzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vzalloc()</span></code></a> or an arch specific variation of
vmalloc to deal with ELF sections requiring special permissions</p></li>
</ol>
</div></blockquote>
<p>In practice on a typical boot today most finit_module() calls fail due to
the module with the same name already being loaded or about to be processed.
All virtual memory allocated to these failed modules will be freed with
no functional use.</p>
<p>To help with this the dup_failed_modules allows us to track modules which
failed to load due to the fact that a module was already loaded or being
processed.  There are only two points at which we can fail such calls,
we list them below along with the number of virtual memory allocation
calls:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>FAIL_DUP_MOD_BECOMING: at the end of early_mod_check() before
layout_and_allocate().
- with module decompression: 2 virtual memory allocation calls
- without module decompression: 1 virtual memory allocation calls</p></li>
<li><p>FAIL_DUP_MOD_LOAD: after layout_and_allocate() on add_unformed_module()
- with module decompression 3 virtual memory allocation calls
- without module decompression 2 virtual memory allocation calls</p></li>
</ol>
</div></blockquote>
<p>We should strive to get this list to be as small as possible. If this list
is not empty it is a reflection of possible work or optimizations possible
either in-kernel or in userspace.</p>
</section>
<section id="module-statistics-debugfs-counters">
<h4>module statistics debugfs counters<a class="headerlink" href="#module-statistics-debugfs-counters" title="Permalink to this heading">¶</a></h4>
<p>The total amount of wasted virtual memory allocation space during module
loading can be computed by adding the total from the summation:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>invalid_kread_bytes</strong> +
<strong>invalid_decompress_bytes</strong> +
<strong>invalid_becoming_bytes</strong> +
<strong>invalid_mod_bytes</strong></p></li>
</ul>
</div></blockquote>
<p>The following debugfs counters are available to inspect module loading
failures:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>total_mod_size: total bytes ever used by all modules we've dealt with on
this system</p></li>
<li><p>total_text_size: total bytes of the .text and .init.text ELF section
sizes we've dealt with on this system</p></li>
<li><p>invalid_kread_bytes: bytes allocated and then freed on failures which
happen due to the initial kernel_read_file_from_fd(). kernel_read_file_from_fd()
uses <a class="reference internal" href="mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>. These should typically not happen unless your system is
under memory pressure.</p></li>
<li><p>invalid_decompress_bytes: number of bytes allocated and freed due to
memory allocations in the module decompression path that use <a class="reference internal" href="mm-api.html#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a>.
These typically should not happen unless your system is under memory
pressure.</p></li>
<li><p>invalid_becoming_bytes: total number of bytes allocated and freed used
used to read the kernel module userspace wants us to read before we
promote it to be processed to be added to our <strong>modules</strong> linked list. These
failures can happen if we had a check in between a successful kernel_read_file_from_fd()
call and right before we allocate the our private memory for the module
which would be kept if the module is successfully loaded. The most common
reason for this failure is when userspace is racing to load a module
which it does not yet see loaded. The first module to succeed in
add_unformed_module() will add a module to our <code class="xref c c-type docutils literal notranslate"><span class="pre">modules</span></code> list and
subsequent loads of modules with the same name will error out at the
end of early_mod_check(). The check for module_patient_check_exists()
at the end of early_mod_check() prevents duplicate allocations
on layout_and_allocate() for modules already being processed. These
duplicate failed modules are non-fatal, however they typically are
indicative of userspace not seeing a module in userspace loaded yet and
unnecessarily trying to load a module before the kernel even has a chance
to begin to process prior requests. Although duplicate failures can be
non-fatal, we should try to reduce <a class="reference internal" href="mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a> pressure proactively, so
ideally after boot this will be close to as 0 as possible.  If module
decompression was used we also add to this counter the cost of the
initial kernel_read_file_from_fd() of the compressed module. If module
decompression was not used the value represents the total allocated and
freed bytes in kernel_read_file_from_fd() calls for these type of
failures. These failures can occur because:</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>module_sig_check() - module signature checks</p></li>
<li><p>elf_validity_cache_copy() - some ELF validation issue</p></li>
<li><p>early_mod_check():</p>
<ul>
<li><p>blacklisting</p></li>
<li><p>failed to rewrite section headers</p></li>
<li><p>version magic</p></li>
<li><p>live patch requirements didn't check out</p></li>
<li><p>the module was detected as being already present</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>invalid_mod_bytes: these are the total number of bytes allocated and
freed due to failures after we did all the sanity checks of the module
which userspace passed to us and after our first check that the module
is unique.  A module can still fail to load if we detect the module is
loaded after we allocate space for it with layout_and_allocate(), we do
this check right before processing the module as live and run its
initialization routines. Note that you have a failure of this type it
also means the respective kernel_read_file_from_fd() memory space was
also freed and not used, and so we increment this counter with twice
the size of the module. Additionally if you used module decompression
the size of the compressed module is also added to this counter.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>modcount: how many modules we've loaded in our kernel life time</p></li>
<li><p>failed_kreads: how many modules failed due to failed kernel_read_file_from_fd()</p></li>
<li><p>failed_decompress: how many failed module decompression attempts we've had.
These really should not happen unless your compression / decompression
might be broken.</p></li>
<li><p>failed_becoming: how many modules failed after we kernel_read_file_from_fd()
it and before we allocate memory for it with layout_and_allocate(). This
counter is never incremented if you manage to validate the module and
call layout_and_allocate() for it.</p></li>
<li><p>failed_load_modules: how many modules failed once we've allocated our
private space for our module using layout_and_allocate(). These failures
should hopefully mostly be dealt with already. Races in theory could
still exist here, but it would just mean the kernel had started processing
two threads concurrently up to early_mod_check() and one thread won.
These failures are good signs the kernel or userspace is doing something
seriously stupid or that could be improved. We should strive to fix these,
but it is perhaps not easy to fix them. A recent example are the modules
requests incurred for frequency modules, a separate module request was
being issued for each CPU on a system.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="inter-module-support">
<h3>Inter Module support<a class="headerlink" href="#inter-module-support" title="Permalink to this heading">¶</a></h3>
<p>Refer to the files in kernel/module/ for more information.</p>
</section>
</section>
<section id="hardware-interfaces">
<h2>Hardware Interfaces<a class="headerlink" href="#hardware-interfaces" title="Permalink to this heading">¶</a></h2>
<section id="dma-channels">
<h3>DMA Channels<a class="headerlink" href="#dma-channels" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.request_dma">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">request_dma</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dmanr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.request_dma" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request and reserve a system DMA channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt><dd><p>DMA channel number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">device_id</span></code></dt><dd><p>reserving device ID string, used in /proc/dma</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.free_dma">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_dma</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">dmanr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.free_dma" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free a reserved system DMA channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt><dd><p>DMA channel number</p>
</dd>
</dl>
</div>
</section>
<section id="resources-management">
<h3>Resources Management<a class="headerlink" href="#resources-management" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.request_resource_conflict">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">request_resource_conflict</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource_conflict" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*new</span></code></dt><dd><p>resource descriptor desired by caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, conflict resource on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.find_next_iomem_res">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_next_iomem_res</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">desc</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.find_next_iomem_res" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the lowest iomem resource that covers part of [<strong>start</strong>..**end**].</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>start address of the resource searched for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">end</span></code></dt><dd><p>end address of same resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>flags which the resource must have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt><dd><p>descriptor the resource must have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>return ptr, if resource found</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a resource is found, returns 0 and <strong>***res is overwritten with the part
of the resource that's within [**start</strong>..**end**]; if none is found, returns
-ENODEV.  Returns -EINVAL for invalid parameters.</p>
<p>The caller must specify <strong>start</strong>, <strong>end</strong>, <strong>flags</strong>, and <strong>desc</strong>
(which may be IORES_DESC_NONE).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.reallocate_resource">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reallocate_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">newsize</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource_constraint</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">constraint</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.reallocate_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a slot in the resource tree given range &amp; alignment. The resource will be relocated if the new size cannot be reallocated in the current location.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*old</span></code></dt><dd><p>resource descriptor desired by caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">newsize</span></code></dt><dd><p>new size of the resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource_constraint</span> <span class="pre">*constraint</span></code></dt><dd><p>the size and alignment constraints to be met.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lookup_resource">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">lookup_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find an existing resource by a resource start address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>resource start address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the resource if found, NULL otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.insert_resource_conflict">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">insert_resource_conflict</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_conflict" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inserts resource in the resource tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*parent</span></code></dt><dd><p>parent of the new resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*new</span></code></dt><dd><p>new resource to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, conflict resource if the resource can't be inserted.</p>
<p>This function is equivalent to request_resource_conflict when no conflict
happens. If a conflict happens, and the conflicting resources
entirely fit within the range of the new resource, then the new
resource is inserted and the conflicting resources become children of
the new resource.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.resource_alignment">
<span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">resource_alignment</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.resource_alignment" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>calculate resource's alignment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>resource pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns alignment on success, 0 (invalid alignment) on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.release_mem_region_adjustable">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">release_mem_region_adjustable</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.release_mem_region_adjustable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a previously reserved memory region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>resource start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>resource region size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface is intended for memory hot-delete.  The requested region
is released from a currently busy memory resource.  The requested region
must either match exactly or fit into a single busy resource entry.  In
the latter case, the remaining resource is adjusted accordingly.
Existing children of the busy memory resource must be immutable in the
request.</p>
<p><strong>Note</strong></p>
<ul class="simple">
<li><p>Additional release conditions, such as overlapping region, can be
supported after they are confirmed as valid cases.</p></li>
<li><p>When a busy memory resource gets split into two entries, the code
assumes that all children remain in the lower address entry for
simplicity.  Enhance this logic when necessary.</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.merge_system_ram_resource">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">merge_system_ram_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.merge_system_ram_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark the System RAM resource mergeable and try to merge it with adjacent, mergeable resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>resource descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface is intended for memory hotplug, whereby lots of contiguous
system ram resources are added (e.g., via add_memory*()) by a driver, and
the actual resource boundaries are not of interest (e.g., it might be
relevant for DIMMs). Only resources that are marked mergeable, that have the
same parent, and that don't have any children are considered. All mergeable
resources must be immutable during the request.</p>
<p><strong>Note</strong></p>
<ul class="simple">
<li><p>The caller has to make sure that no pointers to resources that are
marked mergeable are used anymore after this call - the resource might
be freed and the pointer might be stale!</p></li>
<li><p><a class="reference internal" href="#c.release_mem_region_adjustable" title="release_mem_region_adjustable"><code class="xref c c-func docutils literal notranslate"><span class="pre">release_mem_region_adjustable()</span></code></a> will split on demand on memory hotunplug</p></li>
</ul>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.request_resource">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">request_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*new</span></code></dt><dd><p>resource descriptor desired by caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, negative error code on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.release_resource">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">release_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.release_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a previously reserved resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*old</span></code></dt><dd><p>resource pointer</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.walk_iomem_res_desc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">walk_iomem_res_desc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">desc</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.walk_iomem_res_desc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Walks through iomem resources and calls func() with matching resource ranges. *</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt><dd><p>I/O resource descriptor. Use IORES_DESC_NONE to skip <strong>desc</strong> check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>I/O resource flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>start addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>end addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>function argument for the callback <strong>func</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*func)(struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback function that is called for each qualifying resource area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the memory ranges which overlap start,end and also match flags and
desc are valid candidates.</p>
<p><strong>NOTE</strong></p>
<p>For a new descriptor search, define a new IORES_DESC in
&lt;linux/ioport.h&gt; and set it in 'desc' of a target resource entry.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.region_intersects">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">region_intersects</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">desc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.region_intersects" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>determine intersection of region with known resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>region start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>flags of resource (in iomem_resource)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt><dd><p>descriptor of resource (in iomem_resource) or IORES_DESC_NONE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the specified region partially overlaps or fully eclipses a
resource identified by <strong>flags</strong> and <strong>desc</strong> (optional with IORES_DESC_NONE).
Return REGION_DISJOINT if the region does not overlap <strong>flags</strong>/<strong>desc</strong>,
return REGION_MIXED if the region overlaps <strong>flags</strong>/<strong>desc</strong> and another
resource, and return REGION_INTERSECTS if the region overlaps <strong>flags</strong>/<strong>desc</strong>
and no other defined resource. Note that REGION_INTERSECTS is also
returned in the case when the specified region overlaps RAM and undefined
memory holes.</p>
<p>region_intersect() is used by memory remapping functions to ensure
the user is not remapping RAM and is a vast speed up over walking
through the resource table page by page.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.allocate_resource">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allocate_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">alignf</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">resource_size_t</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">resource_size_t</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">alignf_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.allocate_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate empty slot in the resource tree given range &amp; alignment. The resource will be reallocated with a new size if it was already allocated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*new</span></code></dt><dd><p>resource descriptor desired by caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>requested resource region size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">min</span></code></dt><dd><p>minimum boundary to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">max</span></code></dt><dd><p>maximum boundary to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment requested, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">(*alignf)(void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">resource_size_t,</span> <span class="pre">resource_size_t)</span></code></dt><dd><p>alignment function, optional, called if not NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*alignf_data</span></code></dt><dd><p>arbitrary data to pass to the <strong>alignf</strong> function</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.insert_resource">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">insert_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inserts a resource in the resource tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*parent</span></code></dt><dd><p>parent of the new resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*new</span></code></dt><dd><p>new resource to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EBUSY if the resource can't be inserted.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.insert_resource_expand_to_fit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">insert_resource_expand_to_fit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_expand_to_fit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Insert a resource into the resource tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*root</span></code></dt><dd><p>root resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*new</span></code></dt><dd><p>new resource to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a resource into the resource tree, possibly expanding it in order
to make it encompass any conflicting resources.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.remove_resource">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">remove_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a resource in the resource tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*old</span></code></dt><dd><p>resource to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EINVAL if the resource is not valid.</p>
<p>This function removes a resource previously inserted by <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource()</span></code></a>
or <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource_conflict()</span></code></a>, and moves the children (if any) up to
where they were before.  <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource()</span></code></a> and <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource_conflict()</span></code></a>
insert a new resource, and move any conflicting resources down to the
children of the new resource.</p>
<p><a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource()</span></code></a>, <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal notranslate"><span class="pre">insert_resource_conflict()</span></code></a> and <a class="reference internal" href="#c.remove_resource" title="remove_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">remove_resource()</span></code></a> are
intended for producers of resources, such as FW modules and bus drivers.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.adjust_resource">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">adjust_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.adjust_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>modify a resource's start and size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>resource to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>new start value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>new size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given an existing resource, change its start and size to match the
arguments.  Returns 0 on success, -EBUSY if it can't fit.
Existing children of the resource are assumed to be immutable.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__request_region">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__request_region</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a new busy resource region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*parent</span></code></dt><dd><p>parent resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>resource start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt><dd><p>resource region size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>reserving caller's ID string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>IO resource flags</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__release_region">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__release_region</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__release_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a previously reserved resource region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*parent</span></code></dt><dd><p>parent resource descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>resource start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt><dd><p>resource region size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The described resource region must match a currently busy region.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_request_resource">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_request_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_request_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for which to request the resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*root</span></code></dt><dd><p>root of the resource tree from which to request the resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*new</span></code></dt><dd><p>descriptor of the resource to request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a device-managed version of <a class="reference internal" href="#c.request_resource" title="request_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_resource()</span></code></a>. There is usually
no need to release resources requested by this function explicitly since
that will be taken care of when the device is unbound from its driver.
If for some reason the resource needs to be released explicitly, because
of ordering issues for example, drivers must call <a class="reference internal" href="#c.devm_release_resource" title="devm_release_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_release_resource()</span></code></a>
rather than the regular <a class="reference internal" href="#c.release_resource" title="release_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">release_resource()</span></code></a>.</p>
<p>When a conflict is detected between any existing resources and the newly
requested resource, an error message will be printed.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_release_resource">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_release_resource</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_release_resource" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release a previously requested resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for which to release the resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*new</span></code></dt><dd><p>descriptor of the resource to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a resource previously requested using <a class="reference internal" href="#c.devm_request_resource" title="devm_request_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_request_resource()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_request_free_mem_region">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_request_free_mem_region</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_request_free_mem_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find free region for device private memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device struct to bind the resource to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*base</span></code></dt><dd><p>resource tree to look in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>size in bytes of the device memory to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tries to find an empty range of physical address big enough to
contain the new resource, so that it can later be hotplugged as ZONE_DEVICE
memory, which in turn allocates struct pages.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_free_mem_region">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">alloc_free_mem_region</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">align</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_free_mem_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find a free region relative to <strong>base</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*base</span></code></dt><dd><p>resource that will parent the new resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>size in bytes of memory to allocate from <strong>base</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align</span></code></dt><dd><p>alignment requirements for the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>resource name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Buses like CXL, that can dynamically instantiate new memory regions,
need a method to allocate physical address space for those regions.
Allocate and insert a new resource to cover a free, unclaimed by a
descendant of <strong>base</strong>, range in the span of <strong>base</strong>.</p>
</div>
</section>
<section id="mtrr-handling">
<h3>MTRR Handling<a class="headerlink" href="#mtrr-handling" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.arch_phys_wc_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arch_phys_wc_add</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_phys_wc_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a WC MTRR and handle errors if PAT is unavailable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt><dd><p>Physical base address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>Size of region</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PAT is available, this does nothing.  If PAT is unavailable, it
attempts to add a WC MTRR covering size bytes starting at base and
logs an error if this fails.</p>
<p>The called should provide a power of two size on an equivalent
power of two boundary.</p>
<p>Drivers must store the return value to pass to mtrr_del_wc_if_needed,
but drivers should not try to interpret that return value.</p>
</div>
</section>
</section>
<section id="security-framework">
<h2>Security Framework<a class="headerlink" href="#security-framework" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initializes the security framework</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called early in the kernel initialization sequence.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_add_hooks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_add_hooks</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">security_hook_list</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hooks</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lsm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_add_hooks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a modules hooks to the hook lists.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">security_hook_list</span> <span class="pre">*hooks</span></code></dt><dd><p>the hooks to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of hooks to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*lsm</span></code></dt><dd><p>the name of the security module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each LSM has to register its hooks with the infrastructure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_cred_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_cred_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.lsm_cred_alloc" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_cred_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a composite cred blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>the cred that needs a blob</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the cred blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can't be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_early_cred">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_early_cred</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.lsm_early_cred" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_early_cred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>during initialization allocate a composite cred blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>the cred that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the cred blob for all the modules</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_file_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_file_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.lsm_file_alloc" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_file_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a composite file blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>the file that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the file blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can't be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_inode_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_inode_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.lsm_inode_alloc" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_inode_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a composite inode blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the inode blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can't be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_task_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_task_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_task_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a composite task blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>the task that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the task blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can't be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_ipc_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_ipc_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kip</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_ipc_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a composite ipc blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*kip</span></code></dt><dd><p>the ipc that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the ipc blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can't be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_msg_msg_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_msg_msg_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msg_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_msg_msg_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a composite msg_msg blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msg_msg</span> <span class="pre">*mp</span></code></dt><dd><p>the msg_msg that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the ipc blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can't be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_early_task">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_early_task</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_early_task" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>during initialization allocate a composite task blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>the task that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the task blob for all the modules</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lsm_superblock_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lsm_superblock_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">super_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lsm_superblock_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a composite superblock blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>the superblock that needs a blob</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the superblock blob for all the modules</p>
<p>Returns 0, or -ENOMEM if memory can't be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_binder_set_context_mgr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_binder_set_context_mgr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_binder_set_context_mgr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if becoming binder ctx mgr is ok</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*mgr</span></code></dt><dd><p>task credentials of current binder process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether <strong>mgr</strong> is allowed to be the binder context manager.</p>
<p><strong>Return</strong></p>
<p>Return 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_binder_transaction">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_binder_transaction</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_binder_transaction" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a binder transaction is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*from</span></code></dt><dd><p>sending process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*to</span></code></dt><dd><p>receiving process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether <strong>from</strong> is allowed to invoke a binder transaction call to <strong>to</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_binder_transfer_binder">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_binder_transfer_binder</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_binder_transfer_binder" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a binder transfer is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*from</span></code></dt><dd><p>sending process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*to</span></code></dt><dd><p>receiving process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether <strong>from</strong> is allowed to transfer a binder reference to <strong>to</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_binder_transfer_file">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_binder_transfer_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_binder_transfer_file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_binder_transfer_file" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a binder file xfer is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*from</span></code></dt><dd><p>sending process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*to</span></code></dt><dd><p>receiving process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file being transferred</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether <strong>from</strong> is allowed to transfer <strong>file</strong> to <strong>to</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_ptrace_access_check">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_ptrace_access_check</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">child</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_ptrace_access_check" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if tracing is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*child</span></code></dt><dd><p>target process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>PTRACE_MODE flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before allowing the current process to trace the <strong>child</strong>
process.  Security modules may also want to perform a process tracing check
during an execve in the set_security or apply_creds hooks of tracing check
during an execve in the bprm_set_creds hook of binprm_security_ops if the
process is being traced and its security attributes would be changed by the
execve.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_ptrace_traceme">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_ptrace_traceme</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_ptrace_traceme" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if tracing is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*parent</span></code></dt><dd><p>tracing process</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that the <strong>parent</strong> process has sufficient permission to trace the
current process before allowing the current process to present itself to the
<strong>parent</strong> process for tracing.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_capget">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_capget</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">target</span></span>, <span class="n"><span class="pre">kernel_cap_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">effective</span></span>, <span class="n"><span class="pre">kernel_cap_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inheritable</span></span>, <span class="n"><span class="pre">kernel_cap_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">permitted</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_capget" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the capability sets for a process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*target</span></code></dt><dd><p>target process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_cap_t</span> <span class="pre">*effective</span></code></dt><dd><p>effective capability set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_cap_t</span> <span class="pre">*inheritable</span></code></dt><dd><p>inheritable capability set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_cap_t</span> <span class="pre">*permitted</span></code></dt><dd><p>permitted capability set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the <strong>effective</strong>, <strong>inheritable</strong>, and <strong>permitted</strong> capability sets for the
<strong>target</strong> process.  The hook may also perform permission checking to determine
if the current process is allowed to see the capability sets of the <strong>target</strong>
process.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if the capability sets were successfully obtained.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_capset">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_capset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">kernel_cap_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">effective</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">kernel_cap_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inheritable</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">kernel_cap_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">permitted</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_capset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the capability sets for a process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>new credentials for the target process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*old</span></code></dt><dd><p>current credentials of the target process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">kernel_cap_t</span> <span class="pre">*effective</span></code></dt><dd><p>effective capability set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">kernel_cap_t</span> <span class="pre">*inheritable</span></code></dt><dd><p>inheritable capability set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">kernel_cap_t</span> <span class="pre">*permitted</span></code></dt><dd><p>permitted capability set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the <strong>effective</strong>, <strong>inheritable</strong>, and <strong>permitted</strong> capability sets for the
current process.</p>
<p><strong>Return</strong></p>
<p>Returns 0 and update <strong>new</strong> if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_capable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_capable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_capable" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">user_namespace</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ns</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cap</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">opts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_capable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a process has the necessary capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credentials to examine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*ns</span></code></dt><dd><p>user namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opts</span></code></dt><dd><p>capability check options</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the <strong>tsk</strong> process has the <strong>cap</strong> capability in the indicated
credentials.  <strong>cap</strong> contains the capability &lt;include/linux/capability.h&gt;.
<strong>opts</strong> contains options for the capable check &lt;include/linux/security.h&gt;.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if the capability is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_quotactl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_quotactl</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmds</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">super_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_quotactl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a quotactl() syscall is allowed for this fs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmds</span></code></dt><dd><p>commands</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>filesystem</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the quotactl syscall is allowed for this <strong>sb</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_quota_on">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_quota_on</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_quota_on" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_quota_on" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if QUOTAON is allowed for a dentry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether QUOTAON is allowed for <strong>dentry</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_syslog">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_syslog</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_syslog" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if accessing the kernel message ring is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>SYSLOG_ACTION_* type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before accessing the kernel message ring or changing
logging to the console.  See the syslog(2) manual page for an explanation of
the <strong>type</strong> values.</p>
<p><strong>Return</strong></p>
<p>Return 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_settime64">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_settime64</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ts</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timezone</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_settime64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if changing the system time is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>new time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timezone</span> <span class="pre">*tz</span></code></dt><dd><p>timezone</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission to change the system time, struct timespec64 is defined in
&lt;include/linux/time64.h&gt; and timezone is defined in &lt;include/linux/time.h&gt;.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_vm_enough_memory_mm">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_vm_enough_memory_mm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mm_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_vm_enough_memory_mm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if allocating a new mem map is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>mm struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">pages</span></code></dt><dd><p>number of pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions for allocating a new virtual mapping.  If all LSMs return
a positive value, __vm_enough_memory() will be called with cap_sys_admin
set. If at least one LSM returns 0 or negative, __vm_enough_memory() will be
called with cap_sys_admin cleared.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Returns 0 if permission is granted by the LSM infrastructure to the</dt><dd><p>caller.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bprm_creds_for_exec">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bprm_creds_for_exec</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">linux_binprm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bprm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bprm_creds_for_exec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Prepare the credentials for exec()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*bprm</span></code></dt><dd><p>binary program information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the setup in prepare_exec_creds did not setup <strong>bprm-&gt;cred-&gt;security</strong>
properly for executing <strong>bprm-&gt;file</strong>, update the LSM's portion of
<strong>bprm-&gt;cred-&gt;security</strong> to be what commit_creds needs to install for the new
program.  This hook may also optionally check permissions (e.g. for
transitions between security domains).  The hook must set <strong>bprm-&gt;secureexec</strong>
to 1 if AT_SECURE should be set to request libc enable secure mode.  <strong>bprm</strong>
contains the linux_binprm structure.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if the hook is successful and permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bprm_creds_from_file">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bprm_creds_from_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">linux_binprm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bprm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_bprm_creds_from_file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bprm_creds_from_file" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update linux_binprm creds based on file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*bprm</span></code></dt><dd><p>binary program information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>associated file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>file</strong> is setpcap, suid, sgid or otherwise marked to change privilege upon
exec, update <strong>bprm-&gt;cred</strong> to reflect that change. This is called after
finding the binary that will be executed without an interpreter.  This
ensures that the credentials will not be derived from a script that the
binary will need to reopen, which when reopend may end up being a completely
different file.  This hook may also optionally check permissions (e.g. for
transitions between security domains).  The hook must set <strong>bprm-&gt;secureexec</strong>
to 1 if AT_SECURE should be set to request libc enable secure mode.  The
hook must add to <strong>bprm-&gt;per_clear</strong> any personality flags that should be
cleared from current-&gt;personality.  <strong>bprm</strong> contains the linux_binprm
structure.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if the hook is successful and permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bprm_check">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bprm_check</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">linux_binprm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bprm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bprm_check" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mediate binary handler search</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*bprm</span></code></dt><dd><p>binary program information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This hook mediates the point when a search for a binary handler will begin.
It allows a check against the <strong>bprm-&gt;cred-&gt;security</strong> value which was set in
the preceding creds_for_exec call.  The argv list and envp list are reliably
available in <strong>bprm</strong>.  This hook may be called multiple times during a single
execve.  <strong>bprm</strong> contains the linux_binprm structure.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if the hook is successful and permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bprm_committing_creds">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bprm_committing_creds</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">linux_binprm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bprm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bprm_committing_creds" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install creds for a process during exec()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*bprm</span></code></dt><dd><p>binary program information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepare to install the new security attributes of a process being
transformed by an execve operation, based on the old credentials pointed to
by <strong>current-&gt;cred</strong> and the information set in <strong>bprm-&gt;cred</strong> by the
bprm_creds_for_exec hook.  <strong>bprm</strong> points to the linux_binprm structure.  This
hook is a good place to perform state changes on the process such as closing
open file descriptors to which access will no longer be granted when the
attributes are changed.  This is called immediately before commit_creds().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bprm_committed_creds">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bprm_committed_creds</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">linux_binprm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bprm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bprm_committed_creds" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tidy up after cred install during exec()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*bprm</span></code></dt><dd><p>binary program information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tidy up after the installation of the new security attributes of a process
being transformed by an execve operation.  The new credentials have, by this
point, been set to <strong>current-&gt;cred</strong>.  <strong>bprm</strong> points to the linux_binprm
structure.  This hook is a good place to perform state changes on the
process such as clearing out non-inheritable signal state.  This is called
immediately after commit_creds().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_fs_context_submount">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_fs_context_submount</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fs_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fc</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">super_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">reference</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_fs_context_submount" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise fc-&gt;security</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*fc</span></code></dt><dd><p>new filesystem context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*reference</span></code></dt><dd><p>dentry reference for submount/remount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill out the -&gt;security field for a new fs_context.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success or negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_fs_context_dup">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_fs_context_dup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fs_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fc</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fs_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src_fc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_fs_context_dup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Duplicate a fs_context LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*fc</span></code></dt><dd><p>destination filesystem context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*src_fc</span></code></dt><dd><p>source filesystem context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to sc-&gt;security.  This pointer is
initialised to NULL by the caller.  <strong>fc</strong> indicates the new filesystem context.
<strong>src_fc</strong> indicates the original filesystem context.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_fs_context_parse_param">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_fs_context_parse_param</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fs_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fc</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fs_parameter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">param</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_fs_context_parse_param" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Configure a filesystem context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_context</span> <span class="pre">*fc</span></code></dt><dd><p>filesystem context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fs_parameter</span> <span class="pre">*param</span></code></dt><dd><p>filesystem parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Userspace provided a parameter to configure a superblock.  The LSM can
consume the parameter or return it to the caller for use elsewhere.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>If the parameter is used by the LSM it should return 0, if it is</dt><dd><p>returned to the caller -ENOPARAM is returned, otherwise a negative
error code is returned.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">super_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a super_block LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>filesystem superblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to the sb-&gt;s_security field.  The
s_security field is initialized to NULL when the structure is allocated.
<strong>sb</strong> contains the super_block structure to be modified.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if operation was successful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_delete</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">super_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_delete" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release super_block LSM associated objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>filesystem superblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release objects tied to a superblock (e.g. inodes).  <strong>sb</strong> contains the
super_block structure being released.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">super_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a super_block LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>filesystem superblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate and clear the sb-&gt;s_security field.  <strong>sb</strong> contains the super_block
structure to be modified.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_kern_mount">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_kern_mount</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">super_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_kern_mount" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a kernel mount is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>filesystem superblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mount this <strong>sb</strong> if allowed by permissions.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_show_options">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_show_options</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">seq_file</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">super_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_show_options" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Output the mount options for a superblock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt><dd><p>output file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*sb</span></code></dt><dd><p>filesystem superblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Show (print on <strong>m</strong>) mount options for this <strong>sb</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative values on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_statfs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_statfs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_sb_statfs" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_statfs" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if accessing fs stats is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>superblock handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before obtaining filesystem statistics for the <strong>mnt</strong>
mountpoint.  <strong>dentry</strong> is a handle on the superblock for the filesystem.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_mount">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_mount</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev_name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_sb_mount" title="path"><span class="n"><span class="pre">path</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_mount" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check permission for mounting a filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*dev_name</span></code></dt><dd><p>filesystem backing device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>mount point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*type</span></code></dt><dd><p>filesystem type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>mount flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>filesystem specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before an object specified by <strong>dev_name</strong> is mounted on the
mount point named by <strong>nd</strong>.  For an ordinary mount, <strong>dev_name</strong> identifies a
device if the file system type requires a device.  For a remount
(<strong>flags</strong> &amp; MS_REMOUNT), <strong>dev_name</strong> is irrelevant.  For a loopback/bind mount
(<strong>flags</strong> &amp; MS_BIND), <strong>dev_name</strong> identifies the pathname of the object being
mounted.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_umount">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_umount</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vfsmount</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mnt</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_umount" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check permission for unmounting a filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*mnt</span></code></dt><dd><p>mounted filesystem</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>unmount flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before the <strong>mnt</strong> file system is unmounted.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sb_pivotroot">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sb_pivotroot</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">path</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_path</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">path</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_path</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sb_pivotroot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check permissions for pivoting the rootfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*old_path</span></code></dt><dd><p>new location for current rootfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*new_path</span></code></dt><dd><p>location of the new rootfs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before pivoting the root filesystem.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_move_mount">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_move_mount</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">path</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from_path</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">path</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to_path</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_move_mount" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check permissions for moving a mount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*from_path</span></code></dt><dd><p>source mount point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*to_path</span></code></dt><dd><p>destination mount point</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before a mount is moved.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_path_notify">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_path_notify</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_path_notify" title="path"><span class="n"><span class="pre">path</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">obj_type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_path_notify" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting a watch is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>file path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">mask</span></code></dt><dd><p>event mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">obj_type</span></code></dt><dd><p>file path type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions before setting a watch on events as defined by <strong>mask</strong>, on
an object at <strong>path</strong>, whose type is defined by <strong>obj_type</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_alloc" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an inode LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to <strong>inode-&gt;i_security</strong>.  The
i_security field is initialized to NULL when the inode structure is
allocated.</p>
<p><strong>Return</strong></p>
<p>Return 0 if operation was successful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_free" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an inode's LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate the inode security structure and set <strong>inode-&gt;i_security</strong> to NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_init_security_anon">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_init_security_anon</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_init_security_anon" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">qstr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_init_security_anon" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">context_inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_init_security_anon" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize an anonymous inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>the inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*name</span></code></dt><dd><p>the anonymous inode class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*context_inode</span></code></dt><dd><p>an optional related inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up the incore security field for the new anonymous inode and return
whether the inode creation is permitted by the security module or not.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, -EACCES if the security module denies the
creation of this inode, or another -errno upon other errors.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_path_rmdir">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_path_rmdir</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">path</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_path_rmdir" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_path_rmdir" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if removing a directory is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*dir</span></code></dt><dd><p>parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>directory to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the permission to remove a directory.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_path_symlink">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_path_symlink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">path</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_path_symlink" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_path_symlink" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if creating a symbolic link is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*dir</span></code></dt><dd><p>parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>symbolic link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*old_name</span></code></dt><dd><p>file pathname</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the permission to create a symbolic link to a file.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_path_link">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_path_link</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">path</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_path_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if creating a hard link is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*old_dentry</span></code></dt><dd><p>existing file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*new_dir</span></code></dt><dd><p>new parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*new_dentry</span></code></dt><dd><p>new link</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before creating a new hard link to a file.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_path_truncate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_path_truncate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_path_truncate" title="path"><span class="n"><span class="pre">path</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_path_truncate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if truncating a file is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before truncating the file indicated by path.  Note that
truncation permissions may also be checked based on already opened files,
using the <a class="reference internal" href="#c.security_file_truncate" title="security_file_truncate"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_file_truncate()</span></code></a> hook.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_path_chmod">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_path_chmod</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_path_chmod" title="path"><span class="n"><span class="pre">path</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span>, <span class="n"><span class="pre">umode_t</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_path_chmod" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if changing the file's mode is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>new mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for permission to change a mode of the file <strong>path</strong>. The new mode is
specified in <strong>mode</strong> which is a bitmask of constants from
&lt;include/uapi/linux/stat.h&gt;.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_path_chown">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_path_chown</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_path_chown" title="path"><span class="n"><span class="pre">path</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span>, <span class="n"><span class="pre">kuid_t</span></span><span class="w"> </span><span class="n"><span class="pre">uid</span></span>, <span class="n"><span class="pre">kgid_t</span></span><span class="w"> </span><span class="n"><span class="pre">gid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_path_chown" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if changing the file's owner/group is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kuid_t</span> <span class="pre">uid</span></code></dt><dd><p>file owner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kgid_t</span> <span class="pre">gid</span></code></dt><dd><p>file group</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for permission to change owner/group of a file or directory.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_path_chroot">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_path_chroot</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_path_chroot" title="path"><span class="n"><span class="pre">path</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_path_chroot" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if changing the root directory is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for permission to change root directory.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_link">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_link</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_dentry</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if creating a hard link is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*old_dentry</span></code></dt><dd><p>existing file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>new parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*new_dentry</span></code></dt><dd><p>new link</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before creating a new hard link to a file.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_unlink">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_unlink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_unlink" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_unlink" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if removing a hard link is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the permission to remove a hard link to a file.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_symlink">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_symlink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_symlink" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_symlink" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if creating a symbolic link is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>symbolic link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*old_name</span></code></dt><dd><p>existing filename</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the permission to create a symbolic link to a file.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_rmdir">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_rmdir</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_rmdir" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_rmdir" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if removing a directory is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>directory to be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the permission to remove a directory.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_mknod">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_mknod</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_mknod" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="n"><span class="pre">umode_t</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_mknod" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if creating a special file is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*dir</span></code></dt><dd><p>parent directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>new file mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>device number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions when creating a special file (or a socket or a fifo file
created via the mknod system call).  Note that if mknod operation is being
done for a regular file, then the create hook will be called and not this
hook.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_rename">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_rename</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_dentry</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_dentry</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_rename" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if renaming a file is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*old_dir</span></code></dt><dd><p>parent directory of the old file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*old_dentry</span></code></dt><dd><p>the old file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*new_dir</span></code></dt><dd><p>parent directory of the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*new_dentry</span></code></dt><dd><p>the new file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for permission to rename a file or directory.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_readlink">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_readlink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_readlink" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_readlink" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if reading a symbolic link is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>link</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the permission to read the symbolic link.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_follow_link">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_follow_link</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_follow_link" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_follow_link" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">rcu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_follow_link" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if following a symbolic link is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>link dentry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>link inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">rcu</span></code></dt><dd><p>true if in RCU-walk mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission to follow a symbolic link when looking up a pathname.  If
<strong>rcu</strong> is true, <strong>inode</strong> is not stable.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_permission">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_permission</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_permission" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_permission" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if accessing an inode is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>access mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before accessing an inode.  This hook is called by the
existing Linux permission function, so a security module can use it to
provide additional checking for existing Linux permission checks.  Notice
that this hook is called when a file is opened (as well as many other
operations), whereas the file_security_ops permission hook is called when
the actual read/write operations are performed.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_getattr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_getattr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_getattr" title="path"><span class="n"><span class="pre">path</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_getattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if getting file attributes is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*path</span></code></dt><dd><p>file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before obtaining file attributes.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_setxattr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_setxattr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mnt_idmap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idmap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_setxattr" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_setxattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting file xattrs is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mnt_idmap</span> <span class="pre">*idmap</span></code></dt><dd><p>idmap of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>xattr name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*value</span></code></dt><dd><p>xattr value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of xattr value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before setting the extended attributes.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_set_acl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_set_acl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mnt_idmap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idmap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_set_acl" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">acl_name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">posix_acl</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kacl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_set_acl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting posix acls is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mnt_idmap</span> <span class="pre">*idmap</span></code></dt><dd><p>idmap of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*acl_name</span></code></dt><dd><p>acl name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">posix_acl</span> <span class="pre">*kacl</span></code></dt><dd><p>acl struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before setting posix acls, the posix acls in <strong>kacl</strong> are
identified by <strong>acl_name</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_get_acl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_get_acl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mnt_idmap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idmap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_get_acl" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">acl_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_get_acl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if reading posix acls is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mnt_idmap</span> <span class="pre">*idmap</span></code></dt><dd><p>idmap of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*acl_name</span></code></dt><dd><p>acl name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before getting osix acls, the posix acls are identified by
<strong>acl_name</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_remove_acl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_remove_acl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mnt_idmap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idmap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_remove_acl" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">acl_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_remove_acl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if removing a posix acl is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mnt_idmap</span> <span class="pre">*idmap</span></code></dt><dd><p>idmap of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*acl_name</span></code></dt><dd><p>acl name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before removing posix acls, the posix acls are identified
by <strong>acl_name</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_post_setxattr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_post_setxattr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_post_setxattr" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_post_setxattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update the inode after a setxattr operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>xattr name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*value</span></code></dt><dd><p>xattr value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>xattr value size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update inode security field after successful setxattr operation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_getxattr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_getxattr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_getxattr" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_getxattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if xattr access is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>xattr name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before obtaining the extended attributes identified by
<strong>name</strong> for <strong>dentry</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_listxattr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_listxattr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_listxattr" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_listxattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if listing xattrs is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before obtaining the list of extended attribute names for
<strong>dentry</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_removexattr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_removexattr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mnt_idmap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idmap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_removexattr" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_removexattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if removing an xattr is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mnt_idmap</span> <span class="pre">*idmap</span></code></dt><dd><p>idmap of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>xattr name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before removing the extended attribute identified by <strong>name</strong>
for <strong>dentry</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_need_killpriv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_need_killpriv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_need_killpriv" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_need_killpriv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if <a class="reference internal" href="#c.security_inode_killpriv" title="security_inode_killpriv"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_inode_killpriv()</span></code></a> required</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>associated dentry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when an inode has been changed to determine if
<a class="reference internal" href="#c.security_inode_killpriv" title="security_inode_killpriv"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_inode_killpriv()</span></code></a> should be called.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Return &lt;0 on error to abort the inode change operation, return 0 if</dt><dd><p><a class="reference internal" href="#c.security_inode_killpriv" title="security_inode_killpriv"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_inode_killpriv()</span></code></a> does not need to be called, return &gt;0 if
<a class="reference internal" href="#c.security_inode_killpriv" title="security_inode_killpriv"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_inode_killpriv()</span></code></a> does need to be called.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_killpriv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_killpriv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mnt_idmap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idmap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_killpriv" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_killpriv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The setuid bit is removed, update LSM state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mnt_idmap</span> <span class="pre">*idmap</span></code></dt><dd><p>idmap of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>associated dentry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>dentry</strong>'s setuid bit is being removed.  Remove similar security labels.
Called with the dentry-&gt;d_inode-&gt;i_mutex held.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Return 0 on success.  If error is returned, then the operation</dt><dd><p>causing setuid bit removal is failed.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_getsecurity">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_getsecurity</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mnt_idmap</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idmap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_getsecurity" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">alloc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_getsecurity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the xattr security label of an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mnt_idmap</span> <span class="pre">*idmap</span></code></dt><dd><p>idmap of the mount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>xattr name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**buffer</span></code></dt><dd><p>security label buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">alloc</span></code></dt><dd><p>allocation flag</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve a copy of the extended attribute representation of the security
label associated with <strong>name</strong> for <strong>inode</strong> via <strong>buffer</strong>.  Note that <strong>name</strong> is the
remainder of the attribute name after the security prefix has been removed.
<strong>alloc</strong> is used to specify if the call should return a value via the buffer
or just the value length.</p>
<p><strong>Return</strong></p>
<p>Returns size of buffer on success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_setsecurity">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_setsecurity</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_setsecurity" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_setsecurity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the xattr security label of an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>xattr name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*value</span></code></dt><dd><p>security label</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>length of security label</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the security label associated with <strong>name</strong> for <strong>inode</strong> from the extended
attribute value <strong>value</strong>.  <strong>size</strong> indicates the size of the <strong>value</strong> in bytes.
<strong>flags</strong> may be XATTR_CREATE, XATTR_REPLACE, or 0. Note that <strong>name</strong> is the
remainder of the attribute name after the security. prefix has been removed.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inode_getsecid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inode_getsecid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_inode_getsecid" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">secid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inode_getsecid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get an inode's secid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*secid</span></code></dt><dd><p>secid to return</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the secid associated with the node.  In case of failure, <strong>secid</strong> will be
set to zero.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_kernfs_init_security">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_kernfs_init_security</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kernfs_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kn_dir</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kernfs_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_kernfs_init_security" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Init LSM context for a kernfs node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kernfs_node</span> <span class="pre">*kn_dir</span></code></dt><dd><p>parent kernfs node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kernfs_node</span> <span class="pre">*kn</span></code></dt><dd><p>the kernfs node to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the security context of a newly created kernfs node based on its
own and its parent's attributes.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_permission">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_permission</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_permission" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_permission" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check file permissions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>requested permissions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check file permissions before accessing an open file.  This hook is called
by various operations that read or write files.  A security module can use
this hook to perform additional checking on these operations, e.g. to
revalidate permissions on use to support privilege bracketing or policy
changes.  Notice that this hook is used when the actual read/write
operations are performed, whereas the inode_security_ops hook is called when
a file is opened (as well as many other operations).  Although this hook can
be used to revalidate permissions for various system call operations that
read or write files, it does not address the revalidation of permissions for
memory-mapped files.  Security modules must handle this separately if they
need such revalidation.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_alloc" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate and init a file's LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>the file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to the file-&gt;f_security field.  The
security field is initialized to NULL when the structure is first created.</p>
<p><strong>Return</strong></p>
<p>Return 0 if the hook is successful and permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_free" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a file's LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>the file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate and free any security structures stored in file-&gt;f_security.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_mmap_file">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_mmap_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_mmap_file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_mmap_file" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if mmap'ing a file is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">prot</span></code></dt><dd><p>protection applied by the kernel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions for a mmap operation.  The <strong>file</strong> may be NULL, e.g. if
mapping anonymous memory.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_mmap_addr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_mmap_addr</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_mmap_addr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if mmap'ing an address is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions for a mmap operation at <strong>addr</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_mprotect">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_mprotect</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">reqprot</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">prot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_mprotect" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if changing memory protections is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>memory region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">reqprot</span></code></dt><dd><p>application requested protection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">prot</span></code></dt><dd><p>protection applied by the kernel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions before changing memory access permissions.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_lock">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_lock" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a file lock is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>lock operation (e.g. F_RDLCK, F_WRLCK)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before performing file locking operations.  Note the hook
mediates both flock and fcntl style locks.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_fcntl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_fcntl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_fcntl" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_fcntl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if fcntl() op is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>fcntl command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>command argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before allowing the file operation specified by <strong>cmd</strong> from
being performed on the file <strong>file</strong>.  Note that <strong>arg</strong> sometimes represents a
user space pointer; in other cases, it may be a simple integer value.  When
<strong>arg</strong> represents a user space pointer, it should never be used by the
security module.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_set_fowner">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_set_fowner</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_set_fowner" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_set_fowner" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the file owner info in the LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>the file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Save owner security information (typically from current-&gt;security) in
file-&gt;f_security for later use by the send_sigiotask hook.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_send_sigiotask">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_send_sigiotask</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tsk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">fown_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fown</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sig</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_send_sigiotask" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if sending SIGIO/SIGURG is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fown_struct</span> <span class="pre">*fown</span></code></dt><dd><p>signal sender</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent, SIGIO is sent if 0</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission for the file owner <strong>fown</strong> to send SIGIO or SIGURG to the
process <strong>tsk</strong>.  Note that this hook is sometimes called from interrupt.  Note
that the fown_struct, <strong>fown</strong>, is never outside the context of a struct file,
so the file structure (and associated security information) can always be
obtained: container_of(fown, struct file, f_owner).</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_receive">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_receive</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_receive" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_receive" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check is receiving a file via IPC is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file being received</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This hook allows security modules to control the ability of a process to
receive an open file descriptor via socket IPC.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_open">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_open</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_open" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_open" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save open() time state for late use by the LSM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></p>
<p><strong>Description</strong></p>
<p>Save open-time permission checking state for later use upon file_permission,
and recheck access if anything has changed since inode_permission.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_file_truncate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_file_truncate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_file_truncate" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_file_truncate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if truncating a file is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before truncating a file, i.e. using ftruncate.  Note that
truncation permission may also be checked based on the path, using the
<strong>path_truncate</strong> hook.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">clone_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a task's LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">clone_flags</span></code></dt><dd><p>flags indicating what is being shared</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle allocation of task-related resources.</p>
<p><strong>Return</strong></p>
<p>Returns a zero on success, negative values on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a task's LSM blob and related resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle release of task-related resources.  Note that this can be called from
interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_cred_alloc_blank">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_cred_alloc_blank</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_cred_alloc_blank" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_cred_alloc_blank" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate the min memory to allow cred_transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only allocate sufficient memory and attach to <strong>cred</strong> such that
cred_transfer() will not get ENOMEM.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative values on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_cred_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_cred_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_cred_free" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_cred_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free the cred's LSM blob and associated resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credentials</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate and clear the cred-&gt;security field in a set of credentials.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_prepare_creds">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_prepare_creds</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_prepare_creds" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Prepare a new set of credentials</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>new credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*old</span></code></dt><dd><p>original credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepare a new set of credentials by copying the data from the old set.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative values on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_transfer_creds">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_transfer_creds</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_transfer_creds" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transfer creds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>target credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*old</span></code></dt><dd><p>original credentials</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transfer data from original creds to new creds.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_kernel_act_as">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_kernel_act_as</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">secid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_kernel_act_as" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the kernel credentials to act as secid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">secid</span></code></dt><dd><p>secid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the credentials for a kernel service to act as (subjective context).
The current task must be the one that nominated <strong>secid</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if successful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_kernel_create_files_as">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_kernel_create_files_as</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_kernel_create_files_as" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_kernel_create_files_as" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set file creation context using an inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>target credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>reference inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the file creation context in a set of credentials to be the same as the
objective context of the specified inode.  The current task must be the one
that nominated <strong>inode</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if successful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_kernel_module_request">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_kernel_module_request</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kmod_name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_kernel_module_request" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check is loading a module is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*kmod_name</span></code></dt><dd><p>module name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ability to trigger the kernel to automatically upcall to userspace for
userspace to load a kernel module with the given name.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if successful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_fix_setuid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_fix_setuid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_fix_setuid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update LSM with new user id attributes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>updated credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*old</span></code></dt><dd><p>credentials being replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>LSM_SETID_* flag values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the module's state after setting one or more of the user identity
attributes of the current process.  The <strong>flags</strong> parameter indicates which of
the set*uid system calls invoked this hook.  If <strong>new</strong> is the set of
credentials that will be installed.  Modifications should be made to this
rather than to <strong>current-&gt;cred</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_fix_setgid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_fix_setgid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_fix_setgid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update LSM with new group id attributes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>updated credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*old</span></code></dt><dd><p>credentials being replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>LSM_SETID_* flag value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the module's state after setting one or more of the group identity
attributes of the current process.  The <strong>flags</strong> parameter indicates which of
the set*gid system calls invoked this hook.  <strong>new</strong> is the set of credentials
that will be installed.  Modifications should be made to this rather than to
<strong>current-&gt;cred</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_fix_setgroups">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_fix_setgroups</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_fix_setgroups" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Update LSM with new supplementary groups</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>updated credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*old</span></code></dt><dd><p>credentials being replaced</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the module's state after setting the supplementary group identity
attributes of the current process.  <strong>new</strong> is the set of credentials that will
be installed.  Modifications should be made to this rather than to
<strong>current-&gt;cred</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_setpgid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_setpgid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">pid_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_setpgid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting the pgid is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task being modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pgid</span></code></dt><dd><p>new pgid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before setting the process group identifier of the process
<strong>p</strong> to <strong>pgid</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_getpgid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_getpgid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_getpgid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if getting the pgid is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before getting the process group identifier of the process
<strong>p</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_getsid">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_getsid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_getsid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if getting the session id is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before getting the session identifier of the process <strong>p</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_setnice">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_setnice</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nice</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_setnice" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting a task's nice value is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nice</span></code></dt><dd><p>nice value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before setting the nice value of <strong>p</strong> to <strong>nice</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_setioprio">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_setioprio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ioprio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_setioprio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting a task's ioprio is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ioprio</span></code></dt><dd><p>ioprio value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before setting the ioprio value of <strong>p</strong> to <strong>ioprio</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_getioprio">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_getioprio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_getioprio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if getting a task's ioprio is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before getting the ioprio value of <strong>p</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_prlimit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_prlimit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_task_prlimit" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_task_prlimit" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tcred</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_prlimit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if get/setting resources limits is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>current task credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*tcred</span></code></dt><dd><p>target task credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>LSM_PRLIMIT_* flag bits indicating a get/set/both</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before getting and/or setting the resource limits of
another task.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_setrlimit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_setrlimit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">resource</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rlimit</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_rlim</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_setrlimit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting a new rlimit value is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>target task's group leader</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">resource</span></code></dt><dd><p>resource whose limit is being set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rlimit</span> <span class="pre">*new_rlim</span></code></dt><dd><p>new resource limit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before setting the resource limits of process <strong>p</strong> for
<strong>resource</strong> to <strong>new_rlim</strong>.  The old resource limit values can be examined by
dereferencing (p-&gt;signal-&gt;rlim + resource).</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_setscheduler">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_setscheduler</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_setscheduler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting sched policy/param is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>target task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before setting scheduling policy and/or parameters of
process <strong>p</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_getscheduler">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_getscheduler</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_getscheduler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if getting scheduling info is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>target task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before obtaining scheduling information for process <strong>p</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_movememory">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_movememory</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_movememory" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if moving memory is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before moving memory owned by process <strong>p</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_kill">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_kill</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kernel_siginfo</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">info</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sig</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_task_kill" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_kill" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if sending a signal is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>target process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kernel_siginfo</span> <span class="pre">*info</span></code></dt><dd><p>signal information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credentials of the signal sender, NULL if <strong>current</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before sending signal <strong>sig</strong> to <strong>p</strong>.  <strong>info</strong> can be NULL, the
constant 1, or a pointer to a kernel_siginfo structure.  If <strong>info</strong> is 1 or
SI_FROMKERNEL(info) is true, then the signal should be viewed as coming from
the kernel and should typically be permitted.  SIGIO signals are handled
separately by the send_sigiotask hook in file_security_ops.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_prctl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_prctl</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">option</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">arg2</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">arg3</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">arg4</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">arg5</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_prctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a prctl op is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">option</span></code></dt><dd><p>operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg2</span></code></dt><dd><p>argument</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg3</span></code></dt><dd><p>argument</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg4</span></code></dt><dd><p>argument</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg5</span></code></dt><dd><p>argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before performing a process control operation on the
current process.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Return -ENOSYS if no-one wanted to handle this op, any other value</dt><dd><p>to cause prctl() to return immediately with that value.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_task_to_inode">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_task_to_inode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_task_to_inode" title="inode"><span class="n"><span class="pre">inode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_task_to_inode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the security attributes of a task's inode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>inode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the security attributes for an inode based on an associated task's
security attributes, e.g. for /proc/pid inodes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_create_user_ns">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_create_user_ns</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_create_user_ns" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_create_user_ns" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if creating a new userns is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>prepared creds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission prior to creating a new user namespace.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if successful, otherwise &lt; 0 error code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_ipc_permission">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_ipc_permission</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ipcp</span></span>, <span class="kt"><span class="pre">short</span></span><span class="w"> </span><span class="n"><span class="pre">flag</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_ipc_permission" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if sysv ipc access is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*ipcp</span></code></dt><dd><p>ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">short</span> <span class="pre">flag</span></code></dt><dd><p>requested permissions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions for access to IPC.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_ipc_getsecid">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_ipc_getsecid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ipcp</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">secid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_ipc_getsecid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the sysv ipc object's secid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*ipcp</span></code></dt><dd><p>ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*secid</span></code></dt><dd><p>secid pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the secid associated with the ipc object.  In case of failure, <strong>secid</strong>
will be set to zero.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_msg_msg_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_msg_msg_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msg_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_msg_msg_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a sysv ipc message LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msg_msg</span> <span class="pre">*msg</span></code></dt><dd><p>message structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to the msg-&gt;security field.  The
security field is initialized to NULL when the structure is first created.</p>
<p><strong>Return</strong></p>
<p>Return 0 if operation was successful and permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_msg_msg_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_msg_msg_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msg_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_msg_msg_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a sysv ipc message LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msg_msg</span> <span class="pre">*msg</span></code></dt><dd><p>message structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate the security structure for this message.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_msg_queue_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_msg_queue_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_msg_queue_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a sysv ipc msg queue LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*msq</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to <strong>msg</strong>. The security field is
initialized to NULL when the structure is first created.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if operation was successful and permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_msg_queue_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_msg_queue_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_msg_queue_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a sysv ipc msg queue LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*msq</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate security field <strong>perm-&gt;security</strong> for the message queue.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_msg_queue_associate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_msg_queue_associate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">msqflg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_msg_queue_associate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a msg queue operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*msq</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">msqflg</span></code></dt><dd><p>operation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission when a message queue is requested through the msgget system
call. This hook is only called when returning the message queue identifier
for an existing message queue, not when a new message queue is created.</p>
<p><strong>Return</strong></p>
<p>Return 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_msg_queue_msgctl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_msg_queue_msgctl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msq</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_msg_queue_msgctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a msg queue operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*msq</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission when a message control operation specified by <strong>cmd</strong> is to be
performed on the message queue with permissions.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_msg_queue_msgsnd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_msg_queue_msgsnd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msg_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">msqflg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_msg_queue_msgsnd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if sending a sysv ipc message is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*msq</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msg_msg</span> <span class="pre">*msg</span></code></dt><dd><p>message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">msqflg</span></code></dt><dd><p>operation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before a message, <strong>msg</strong>, is enqueued on the message queue
with permissions specified in <strong>msq</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_msg_queue_msgrcv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_msg_queue_msgrcv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msg_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">target</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_msg_queue_msgrcv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if receiving a sysv ipc msg is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*msq</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msg_msg</span> <span class="pre">*msg</span></code></dt><dd><p>message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*target</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">type</span></code></dt><dd><p>type of message requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>operation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before a message, <strong>msg</strong>, is removed from the message queue.
The <strong>target</strong> task structure contains a pointer to the process that will be
receiving the message (not equal to the current process when inline receives
are being performed).</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_shm_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_shm_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_shm_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a sysv shm LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*shp</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to the <strong>shp</strong> security field.  The
security field is initialized to NULL when the structure is first created.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if operation was successful and permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_shm_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_shm_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_shm_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a sysv shm LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*shp</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate the security structure <strong>perm-&gt;security</strong> for the memory segment.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_shm_associate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_shm_associate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">shmflg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_shm_associate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a sysv shm operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*shp</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">shmflg</span></code></dt><dd><p>operation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission when a shared memory region is requested through the shmget
system call. This hook is only called when returning the shared memory
region identifier for an existing region, not when a new shared memory
region is created.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_shm_shmctl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_shm_shmctl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_shm_shmctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a sysv shm operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*shp</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission when a shared memory control operation specified by <strong>cmd</strong> is
to be performed on the shared memory region with permissions in <strong>shp</strong>.</p>
<p><strong>Return</strong></p>
<p>Return 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_shm_shmat">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_shm_shmat</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shp</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shmaddr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">shmflg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_shm_shmat" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a sysv shm attach operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*shp</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*shmaddr</span></code></dt><dd><p>address of memory region to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">shmflg</span></code></dt><dd><p>operation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions prior to allowing the shmat system call to attach the
shared memory segment with permissions <strong>shp</strong> to the data segment of the
calling process. The attaching address is specified by <strong>shmaddr</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sem_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sem_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sem_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a sysv semaphore LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*sma</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to the <strong>sma</strong> security field. The
security field is initialized to NULL when the structure is first created.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if operation was successful and permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sem_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sem_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sem_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a sysv semaphore LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*sma</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate security structure <strong>sma-&gt;security</strong> for the semaphore.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sem_associate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sem_associate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">semflg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sem_associate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a sysv semaphore operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*sma</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">semflg</span></code></dt><dd><p>operation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission when a semaphore is requested through the semget system
call. This hook is only called when returning the semaphore identifier for
an existing semaphore, not when a new one must be created.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sem_semctl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sem_semctl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sma</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sem_semctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a sysv semaphore operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*sma</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission when a semaphore operation specified by <strong>cmd</strong> is to be
performed on the semaphore.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sem_semop">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sem_semop</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sma</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sembuf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sops</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">nsops</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">alter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sem_semop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a sysv semaphore operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*sma</span></code></dt><dd><p>sysv ipc permission structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sembuf</span> <span class="pre">*sops</span></code></dt><dd><p>operations to perform</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">nsops</span></code></dt><dd><p>number of operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">alter</span></code></dt><dd><p>flag indicating changes will be made</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions before performing operations on members of the semaphore
set. If the <strong>alter</strong> flag is nonzero, the semaphore set may be modified.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_getprocattr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_getprocattr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lsm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_getprocattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read an attribute for a task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*lsm</span></code></dt><dd><p>LSM name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>attribute name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**value</span></code></dt><dd><p>attribute value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read attribute <strong>name</strong> for task <strong>p</strong> and store it into <strong>value</strong> if allowed.</p>
<p><strong>Return</strong></p>
<p>Returns the length of <strong>value</strong> on success, a negative value otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_setprocattr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_setprocattr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lsm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_setprocattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set an attribute for a task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*lsm</span></code></dt><dd><p>LSM name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>attribute name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*value</span></code></dt><dd><p>attribute value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>attribute value size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write (set) the current task's attribute <strong>name</strong> to <strong>value</strong>, size <strong>size</strong> if
allowed.</p>
<p><strong>Return</strong></p>
<p>Returns bytes written on success, a negative value otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_netlink_send">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_netlink_send</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sock" title="sock"><span class="n"><span class="pre">sock</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff"><span class="n"><span class="pre">sk_buff</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">skb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_netlink_send" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save info and check if netlink sending is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sending socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>netlink message</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Save security information for a netlink message so that permission checking
can be performed when the message is processed.  The security information
can be saved using the eff_cap field of the netlink_skb_parms structure.
Also may be used to provide fine grained control over message transmission.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Returns 0 if the information was successfully saved and message is</dt><dd><p>allowed to be transmitted.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_post_notification">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_post_notification</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_post_notification" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w_cred</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_post_notification" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">watch_notification</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_post_notification" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a watch notification can be posted</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*w_cred</span></code></dt><dd><p>credentials of the task that set the watch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credentials of the task which triggered the watch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">watch_notification</span> <span class="pre">*n</span></code></dt><dd><p>the notification</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if a watch notification can be posted to a particular queue.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_watch_key">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_watch_key</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_watch_key" title="key"><span class="n"><span class="pre">key</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_watch_key" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a task is allowed to watch for key events</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">key</span> <span class="pre">*key</span></code></dt><dd><p>the key to watch</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if a process is allowed to watch for event notifications from
a key or keyring.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_create</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">family</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">protocol</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kern</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if creating a new socket is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communications type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>requested protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kern</span></code></dt><dd><p>set to 1 if a kernel socket is requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions prior to creating a new socket.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_post_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_post_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">family</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">protocol</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kern</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_post_create" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a newly created socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communications type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>requested protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kern</span></code></dt><dd><p>set to 1 if a kernel socket is requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This hook allows a module to update or allocate a per-socket security
structure. Note that the security field was not added directly to the socket
structure, but rather, the socket security information is stored in the
associated inode.  Typically, the inode alloc_security hook will allocate
and attach security information to SOCK_INODE(sock)-&gt;i_security.  This hook
may be used to update the SOCK_INODE(sock)-&gt;i_security field with additional
information that wasn't available when the inode was allocated.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_bind">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_bind</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sockaddr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">address</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">addrlen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_bind" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a socket bind operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*address</span></code></dt><dd><p>requested bind address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addrlen</span></code></dt><dd><p>length of address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before socket protocol layer bind operation is performed
and the socket <strong>sock</strong> is bound to the address specified in the <strong>address</strong>
parameter.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_connect">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_connect</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sockaddr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">address</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">addrlen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_connect" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a socket connect operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*address</span></code></dt><dd><p>address of remote connection point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addrlen</span></code></dt><dd><p>length of address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before socket protocol layer connect operation attempts to
connect socket <strong>sock</strong> to a remote address, <strong>address</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_listen">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_listen</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">backlog</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_listen" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a socket is allowed to listen</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">backlog</span></code></dt><dd><p>connection queue size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before socket protocol layer listen operation.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_accept">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_accept</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">newsock</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_accept" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a socket is allowed to accept connections</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>listening socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*newsock</span></code></dt><dd><p>newly creation connection socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before accepting a new connection.  Note that the new
socket, <strong>newsock</strong>, has been created and some information copied to it, but
the accept operation has not actually been performed.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_sendmsg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_sendmsg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msghdr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_sendmsg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check is sending a message is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>sending socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt><dd><p>message to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size of message</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before transmitting a message to another socket.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_recvmsg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_recvmsg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">msghdr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_recvmsg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if receiving a message is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>receiving socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt><dd><p>message to receive</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size of message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>operational flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before receiving a message from a socket.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_getsockname">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_getsockname</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_getsockname" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if reading the socket addr is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before reading the local address (name) of the socket
object.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_getpeername">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_getpeername</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_getpeername" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if reading the peer's addr is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission before the remote address (name) of a socket object.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_getsockopt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_getsockopt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">level</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">optname</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_getsockopt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if reading a socket option is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt><dd><p>option's protocol level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">optname</span></code></dt><dd><p>option name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions before retrieving the options associated with socket
<strong>sock</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_setsockopt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_setsockopt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">level</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">optname</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_setsockopt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if setting a socket option is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt><dd><p>option's protocol level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">optname</span></code></dt><dd><p>option name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permissions before setting the options associated with socket <strong>sock</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_shutdown">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_shutdown</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">how</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_shutdown" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if shutting down the socket is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">how</span></code></dt><dd><p>flag indicating how sends and receives are handled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks permission before all or part of a connection on the socket <strong>sock</strong> is
shut down.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_socket_getpeersec_stream">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_socket_getpeersec_stream</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.socket" title="socket"><span class="n"><span class="pre">socket</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sock</span></span>, <span class="n"><span class="pre">sockptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">optval</span></span>, <span class="n"><span class="pre">sockptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">optlen</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_socket_getpeersec_stream" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the remote peer label</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sockptr_t</span> <span class="pre">optval</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sockptr_t</span> <span class="pre">optlen</span></code></dt><dd><p>size of peer label copied into the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>maximum size of the destination buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This hook allows the security module to provide peer socket security state
for unix or connected tcp sockets to userspace via getsockopt SO_GETPEERSEC.
For tcp sockets this can be meaningful if the socket is associated with an
ipsec SA.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Returns 0 if all is well, otherwise, typical getsockopt return</dt><dd><p>values.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sk_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sk_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sock" title="sock"><span class="n"><span class="pre">sock</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">family</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">priority</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sk_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate and initialize a sock's LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and attach a security structure to the sk-&gt;sk_security field, which
is used to copy security attributes between local stream sockets.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, error on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_sk_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_sk_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sock" title="sock"><span class="n"><span class="pre">sock</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_sk_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free the sock's LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate security structure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_inet_csk_clone">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_inet_csk_clone</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sock" title="sock"><span class="n"><span class="pre">sock</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">newsk</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_sock</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_inet_csk_clone" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set new sock LSM state based on request_sock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*newsk</span></code></dt><dd><p>new sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">request_sock</span> <span class="pre">*req</span></code></dt><dd><p>connection request_sock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set that LSM state of <strong>sock</strong> using the LSM state from <strong>req</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_mptcp_add_subflow">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_mptcp_add_subflow</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sock" title="sock"><span class="n"><span class="pre">sock</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sock" title="sock"><span class="n"><span class="pre">sock</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_mptcp_add_subflow" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inherit the LSM label from the MPTCP socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>the owning MPTCP socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*ssk</span></code></dt><dd><p>the new subflow</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the labeling for the given MPTCP subflow, to match the one of the
owning MPTCP socket. This hook has to be called after the socket creation and
initialization via the <a class="reference internal" href="#c.security_socket_create" title="security_socket_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_socket_create()</span></code></a> and
<a class="reference internal" href="#c.security_socket_post_create" title="security_socket_post_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_socket_post_create()</span></code></a> LSM hooks.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_xfrm_policy_clone">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_xfrm_policy_clone</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_sec_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_ctx</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_sec_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_ctxp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_xfrm_policy_clone" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clone xfrm policy LSM state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_sec_ctx</span> <span class="pre">*old_ctx</span></code></dt><dd><p>xfrm security context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_sec_ctx</span> <span class="pre">**new_ctxp</span></code></dt><dd><p>target xfrm security context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a security structure in new_ctxp that contains the information from
the old_ctx structure.</p>
<p><strong>Return</strong></p>
<p>Return 0 if operation was successful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_xfrm_policy_delete">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_xfrm_policy_delete</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_sec_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_xfrm_policy_delete" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if deleting a xfrm policy is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_sec_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>xfrm security context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Authorize deletion of a SPD entry.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_xfrm_state_alloc_acquire">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_xfrm_state_alloc_acquire</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_sec_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">polsec</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">secid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_xfrm_state_alloc_acquire" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a xfrm state LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_state</span> <span class="pre">*x</span></code></dt><dd><p>xfrm state being added to the SAD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_sec_ctx</span> <span class="pre">*polsec</span></code></dt><dd><p>associated policy's security context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">secid</span></code></dt><dd><p>secid from the flow</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a security structure to the x-&gt;security field; the security field
is initialized to NULL when the xfrm_state is allocated.  Set the context to
correspond to secid.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if operation was successful.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_xfrm_state_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_xfrm_state_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_xfrm_state_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a xfrm state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_state</span> <span class="pre">*x</span></code></dt><dd><p>xfrm state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate x-&gt;security.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_xfrm_policy_lookup">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_xfrm_policy_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_sec_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">fl_secid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_xfrm_policy_lookup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if using a xfrm policy is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_sec_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>target xfrm security context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">fl_secid</span></code></dt><dd><p>flow secid used to authorize access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check permission when a flow selects a xfrm_policy for processing XFRMs on a
packet.  The hook is called when selecting either a per-socket policy or a
generic xfrm policy.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Return 0 if permission is granted, -ESRCH otherwise, or -errno on</dt><dd><p>other errors.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_xfrm_state_pol_flow_match">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_xfrm_state_pol_flow_match</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">xfrm_policy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">xp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">flowi_common</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">flic</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_xfrm_state_pol_flow_match" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check for a xfrm match</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_state</span> <span class="pre">*x</span></code></dt><dd><p>xfrm state to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfrm_policy</span> <span class="pre">*xp</span></code></dt><dd><p>xfrm policy to check for a match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">flowi_common</span> <span class="pre">*flic</span></code></dt><dd><p>flow to check for a match.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check <strong>xp</strong> and <strong>flic</strong> for a match with <strong>x</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 1 if there is a match.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_xfrm_decode_session">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_xfrm_decode_session</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff"><span class="n"><span class="pre">sk_buff</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">skb</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">secid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_xfrm_decode_session" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine the xfrm secid for a packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>xfrm packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*secid</span></code></dt><dd><p>secid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decode the packet in <strong>skb</strong> and return the security label in <strong>secid</strong>.</p>
<p><strong>Return</strong></p>
<p>Return 0 if all xfrms used have the same secid.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_key_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_key_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_key_alloc" title="key"><span class="n"><span class="pre">key</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_key_alloc" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_key_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate and initialize a kernel key LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">key</span> <span class="pre">*key</span></code></dt><dd><p>key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Permit allocation of a key and assign security data. Note that key does not
have a serial number assigned at this point.</p>
<p><strong>Return</strong></p>
<p>Return 0 if permission is granted, -ve error otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_key_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_key_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_key_free" title="key"><span class="n"><span class="pre">key</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_key_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a kernel key LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">key</span> <span class="pre">*key</span></code></dt><dd><p>key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notification of destruction; free security data.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_key_permission">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_key_permission</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">key_ref_t</span></span><span class="w"> </span><span class="n"><span class="pre">key_ref</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_key_permission" title="cred"><span class="n"><span class="pre">cred</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cred</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">key_need_perm</span></span><span class="w"> </span><span class="n"><span class="pre">need_perm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_key_permission" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a kernel key operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key_ref_t</span> <span class="pre">key_ref</span></code></dt><dd><p>key reference</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credentials of actor requesting access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">key_need_perm</span> <span class="pre">need_perm</span></code></dt><dd><p>requested permissions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See whether a specific operational right is granted to a process on a key.</p>
<p><strong>Return</strong></p>
<p>Return 0 if permission is granted, -ve error otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_key_getsecurity">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_key_getsecurity</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.security_key_getsecurity" title="key"><span class="n"><span class="pre">key</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buffer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_key_getsecurity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the key's security label</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">key</span> <span class="pre">*key</span></code></dt><dd><p>key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**buffer</span></code></dt><dd><p>security label buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a textual representation of the security context attached to a key for
the purposes of honouring KEYCTL_GETSECURITY.  This function allocates the
storage for the NUL-terminated string and the caller should free it.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Returns the length of <strong>buffer</strong> (including terminating NUL) or -ve if</dt><dd><p>an error occurs.  May also return 0 (and a NULL buffer pointer) if
there is no security label assigned to the key.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_audit_rule_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_audit_rule_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">field</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">op</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rulestr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lsmrule</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_audit_rule_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate and init an LSM audit rule struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">field</span></code></dt><dd><p>audit action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">op</span></code></dt><dd><p>rule operator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*rulestr</span></code></dt><dd><p>rule context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**lsmrule</span></code></dt><dd><p>receive buffer for audit rule struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and initialize an LSM audit rule structure.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Return 0 if <strong>lsmrule</strong> has been successfully set, -EINVAL in case of</dt><dd><p>an invalid rule.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_audit_rule_known">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_audit_rule_known</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_krule</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">krule</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_audit_rule_known" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if an audit rule contains LSM fields</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_krule</span> <span class="pre">*krule</span></code></dt><dd><p>audit rule</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Specifies whether given <strong>krule</strong> contains any fields related to the current
LSM.</p>
<p><strong>Return</strong></p>
<p>Returns 1 in case of relation found, 0 otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_audit_rule_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_audit_rule_free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lsmrule</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_audit_rule_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an LSM audit rule struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*lsmrule</span></code></dt><dd><p>audit rule struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deallocate the LSM audit rule structure previously allocated by
audit_rule_init().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_audit_rule_match">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_audit_rule_match</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">secid</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">field</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">op</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lsmrule</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_audit_rule_match" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a label matches an audit rule</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">secid</span></code></dt><dd><p>security label</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">field</span></code></dt><dd><p>LSM audit field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">op</span></code></dt><dd><p>matching operator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*lsmrule</span></code></dt><dd><p>audit rule</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if given <strong>secid</strong> matches a rule previously approved by
<a class="reference internal" href="#c.security_audit_rule_known" title="security_audit_rule_known"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_audit_rule_known()</span></code></a>.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Returns 1 if secid matches the rule, 0 if it does not, -ERRNO on</dt><dd><p>failure.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bpf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bpf</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span>, <span class="k"><span class="pre">union</span></span><span class="w"> </span><span class="n"><span class="pre">bpf_attr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bpf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if the bpf syscall operation is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">bpf_attr</span> <span class="pre">*attr</span></code></dt><dd><p>bpf attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do a initial check for all bpf syscalls after the attribute is copied into
the kernel. The actual security module can implement their own rules to
check the specific cmd they need.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bpf_map">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bpf_map</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bpf_map</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span>, <span class="n"><span class="pre">fmode_t</span></span><span class="w"> </span><span class="n"><span class="pre">fmode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bpf_map" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if access to a bpf map is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_map</span> <span class="pre">*map</span></code></dt><dd><p>bpf map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fmode_t</span> <span class="pre">fmode</span></code></dt><dd><p>mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do a check when the kernel generates and returns a file descriptor for eBPF
maps.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bpf_prog">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bpf_prog</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bpf_prog</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prog</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bpf_prog" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if access to a bpf program is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_prog</span> <span class="pre">*prog</span></code></dt><dd><p>bpf program</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do a check when the kernel generates and returns a file descriptor for eBPF
programs.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bpf_map_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bpf_map_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bpf_map</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bpf_map_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a bpf map LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_map</span> <span class="pre">*map</span></code></dt><dd><p>bpf map</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the security field inside bpf map.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, error on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bpf_prog_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bpf_prog_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bpf_prog_aux</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">aux</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bpf_prog_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a bpf program LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_prog_aux</span> <span class="pre">*aux</span></code></dt><dd><p>bpf program aux info struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the security field inside bpf program.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, error on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bpf_map_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bpf_map_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bpf_map</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bpf_map_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a bpf map's LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_map</span> <span class="pre">*map</span></code></dt><dd><p>bpf map</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clean up the security information stored inside bpf map.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_bpf_prog_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_bpf_prog_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bpf_prog_aux</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">aux</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_bpf_prog_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a bpf program's LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_prog_aux</span> <span class="pre">*aux</span></code></dt><dd><p>bpf program aux info struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clean up the security information stored inside bpf prog.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_perf_event_open">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_perf_event_open</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">perf_event_attr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_perf_event_open" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a perf event open is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">perf_event_attr</span> <span class="pre">*attr</span></code></dt><dd><p>perf event attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>type of event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the <strong>type</strong> of perf_event_open syscall is allowed.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_perf_event_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_perf_event_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">perf_event</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">event</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_perf_event_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a perf event LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">perf_event</span> <span class="pre">*event</span></code></dt><dd><p>perf event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and save perf_event security info.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, error on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_perf_event_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_perf_event_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">perf_event</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">event</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_perf_event_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free a perf event LSM blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">perf_event</span> <span class="pre">*event</span></code></dt><dd><p>perf event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release (free) perf_event security info.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_perf_event_read">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_perf_event_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">perf_event</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">event</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_perf_event_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if reading a perf event label is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">perf_event</span> <span class="pre">*event</span></code></dt><dd><p>perf event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read perf_event security info if allowed.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_perf_event_write">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_perf_event_write</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">perf_event</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">event</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_perf_event_write" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if writing a perf event label is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">perf_event</span> <span class="pre">*event</span></code></dt><dd><p>perf event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write perf_event security info if allowed.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_uring_override_creds">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_uring_override_creds</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_uring_override_creds" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if overriding creds is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>new credentials</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the current task, executing an io_uring operation, is allowed to
override it's credentials with <strong>new</strong>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_uring_sqpoll">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_uring_sqpoll</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_uring_sqpoll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if IORING_SETUP_SQPOLL is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the current task is allowed to spawn a io_uring polling thread
(IORING_SETUP_SQPOLL).</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.security_uring_cmd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">security_uring_cmd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">io_uring_cmd</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ioucmd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.security_uring_cmd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if a io_uring passthrough command is allowed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">io_uring_cmd</span> <span class="pre">*ioucmd</span></code></dt><dd><p>command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the file_operations uring_cmd is allowed to run.</p>
<p><strong>Return</strong></p>
<p>Returns 0 if permission is granted.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.securityfs_create_file">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">securityfs_create_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="n"><span class="pre">umode_t</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file_operations</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_file" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a file in the securityfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the file to create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>the permission that the file should have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
file will be created in the root of the securityfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the open() call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>a pointer to a struct file_operations that should be used for
this file.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> is
returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.securityfs_create_dir">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">securityfs_create_dir</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_dir" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a directory in the securityfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the directory to
create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a directory in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> is
returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.securityfs_create_symlink">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">securityfs_create_symlink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">target</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">inode_operations</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_symlink" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create a symlink in the securityfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a pointer to a string containing the name of the symlink to
create.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>a pointer to the parent dentry for the symlink.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*target</span></code></dt><dd><p>a pointer to a string containing the name of the symlink's target.
If this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the <strong>iops</strong> parameter needs to be
setup to handle .readlink and .get_link inode_operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode_operations</span> <span class="pre">*iops</span></code></dt><dd><p>a pointer to the struct inode_operations to use for the symlink. If
this parameter is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the default simple_symlink_inode
operations will be used.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a symlink in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> is
returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.securityfs_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">securityfs_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.securityfs_remove" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>removes a file or directory from the securityfs filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>a pointer to a the dentry of the file or directory to be removed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a file or directory in securityfs that was previously
created with a call to another securityfs function (like
<a class="reference internal" href="#c.securityfs_create_file" title="securityfs_create_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">securityfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed. No automatic cleanup of files will happen when a module is
removed; you are responsible here.</p>
</div>
</section>
<section id="audit-interfaces">
<h2>Audit Interfaces<a class="headerlink" href="#audit-interfaces" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_log_start">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_buffer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">audit_log_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>obtain an audit buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*ctx</span></code></dt><dd><p>audit_context (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>type of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>audit message type</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns audit_buffer pointer on success or NULL on error.</p>
<p>Obtain an audit buffer.  This routine does locking to obtain the
audit buffer, but then no locking is required for calls to
audit_log_*format.  If the task (ctx) is a task that is currently in a
syscall, then the syscall is marked as auditable and an audit record
will be written at syscall exit.  If there is no associated task, then
task context (ctx) should be NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_log_format">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_log_format</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_buffer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ab</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_format" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>format a message into the audit buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*ab</span></code></dt><dd><p>audit_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>optional parameters matching <strong>fmt</strong> string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the work is done in audit_log_vformat.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_log_end">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_log_end</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_buffer</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ab</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_end" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>end one audit record</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*ab</span></code></dt><dd><p>the audit_buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We can not do a netlink send inside an irq context because it blocks (last
arg, flags, is not set to MSG_DONTWAIT), so the audit buffer is placed on a
queue and a kthread is scheduled to remove them from the queue outside the
irq context.  May be called in any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_log">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_log</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fmt</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Log an audit record</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*ctx</span></code></dt><dd><p>audit context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>type of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>audit message type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format string to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable parameters matching the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a convenience function that calls audit_log_start,
audit_log_vformat, and audit_log_end.  It may be called
in any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_filter_op">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_filter_op</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tsk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_names</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_filter_op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>common filter helper for operations (syscall/uring/etc)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>associated task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*ctx</span></code></dt><dd><p>audit context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>audit filter list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_names</span> <span class="pre">*name</span></code></dt><dd><p>audit_name (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">op</span></code></dt><dd><p>current syscall/uring_op</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Run the udit filters specified in <strong>list</strong> against <strong>tsk</strong> using <strong>ctx</strong>,
<strong>name</strong>, and <strong>op</strong>, as necessary; the caller is responsible for ensuring
that the call is made while the RCU read lock is held. The <strong>name</strong>
parameter can be NULL, but all others must be specified.
Returns 1/true if the filter finds a match, 0/false if none are found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_filter_uring">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_filter_uring</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tsk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_filter_uring" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>apply filters to an io_uring operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>associated task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*ctx</span></code></dt><dd><p>audit context</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_reset_context">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_reset_context</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_reset_context" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>reset a audit_context structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*ctx</span></code></dt><dd><p>the audit_context to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All fields in the audit_context will be reset to an initial state, all
references held by fields will be dropped, and private memory will be
released.  When this function returns the audit_context will be suitable
for reuse, so long as the passed context is not NULL or a dummy context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tsk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate an audit context block for a task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filter on the task information and allocate a per-task audit context
if necessary.  Doing so turns on system call auditing for the
specified task.  This is called from copy_process, so no lock is
needed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_log_uring">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_log_uring</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_uring" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generate a AUDIT_URINGOP record</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*ctx</span></code></dt><dd><p>the audit context</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tsk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free a per-task audit context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>task whose audit context block to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from copy_process, do_exit, and the io_uring code</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_return_fixup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_return_fixup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">success</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">code</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_return_fixup" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fixup the return codes in the audit_context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*ctx</span></code></dt><dd><p>the audit_context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">success</span></code></dt><dd><p>true/false value to indicate if the operation succeeded or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">code</span></code></dt><dd><p>operation return code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We need to fixup the return code in the audit logs if the actual return
codes are later going to be fixed by the arch specific signal handlers.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_uring_entry">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_uring_entry</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">u8</span></span><span class="w"> </span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_uring_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>prepare the kernel task's audit context for io_uring</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">op</span></code></dt><dd><p>the io_uring opcode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to audit_syscall_entry() but is intended for use by io_uring
operations.  This function should only ever be called from
audit_uring_entry() as we rely on the audit context checking present in that
function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_uring_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_uring_exit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">success</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">code</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_uring_exit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wrap up the kernel task's audit context after io_uring</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">success</span></code></dt><dd><p>true/false value to indicate if the operation succeeded or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">code</span></code></dt><dd><p>operation return code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to audit_syscall_exit() but is intended for use by io_uring
operations.  This function should only ever be called from
audit_uring_exit() as we rely on the audit context checking present in that
function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_syscall_entry">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_syscall_entry</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">major</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a1</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a2</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a3</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">a4</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fill in an audit record at syscall entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">major</span></code></dt><dd><p>major syscall type (function)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a1</span></code></dt><dd><p>additional syscall register 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a2</span></code></dt><dd><p>additional syscall register 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a3</span></code></dt><dd><p>additional syscall register 3</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a4</span></code></dt><dd><p>additional syscall register 4</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in audit context at syscall entry.  This only happens if the
audit context was created when the task was created and the state or
filters demand the audit context be built.  If the state from the
per-task filter or from the per-syscall filter is AUDIT_STATE_RECORD,
then the record will be written at syscall exit time (otherwise, it
will only be written if another part of the kernel requests that it
be written).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_syscall_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_syscall_exit</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">success</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">return_code</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_exit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deallocate audit context after a system call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">success</span></code></dt><dd><p>success value of the syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">return_code</span></code></dt><dd><p>return value of the syscall</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down after system call.  If the audit context has been marked as
auditable (either because of the AUDIT_STATE_RECORD state from
filtering, or because some other part of the kernel wrote an audit
message), then write out the syscall information.  In call cases,
free the names stored from getname().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_reusename">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">filename</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__audit_reusename</span></span></span><span class="sig-paren">(</span><span class="pre">__user</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">uptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_reusename" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>fill out filename with info from existing entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">__user</span> <span class="pre">char</span> <span class="pre">*uptr</span></code></dt><dd><p>userland ptr to pathname</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the audit_names list for the current audit context. If there is an
existing entry with a matching &quot;uptr&quot; then return the filename
associated with that audit_name. If not, return NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_getname">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_getname</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">filename</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_getname" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a name to the list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*name</span></code></dt><dd><p>name to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a name to the list of audit names for this context.
Called from fs/namei.c:getname().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_inode">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_inode</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">filename</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.__audit_inode" title="dentry"><span class="n"><span class="pre">dentry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dentry</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_inode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>store the inode and device from a lookup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*name</span></code></dt><dd><p>name being audited</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry being audited</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>attributes for this particular entry</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.auditsc_get_stamp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">auditsc_get_stamp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">audit_context</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">serial</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.auditsc_get_stamp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get local copies of audit_context values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*ctx</span></code></dt><dd><p>audit_context for the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*t</span></code></dt><dd><p>timespec64 to store time recorded in the audit_context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*serial</span></code></dt><dd><p>serial value that is recorded in the audit_context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also sets the context as auditable.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_mq_open">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_mq_open</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">oflag</span></span>, <span class="n"><span class="pre">umode_t</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mq_attr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_open" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for a POSIX MQ open</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oflag</span></code></dt><dd><p>open flag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*attr</span></code></dt><dd><p>queue attributes</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_mq_sendrecv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_mq_sendrecv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mqd_t</span></span><span class="w"> </span><span class="n"><span class="pre">mqdes</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">msg_len</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">msg_prio</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">timespec64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">abs_timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_sendrecv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for a POSIX MQ timed send/receive</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt><dd><p>MQ descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">msg_len</span></code></dt><dd><p>Message length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msg_prio</span></code></dt><dd><p>Message priority</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*abs_timeout</span></code></dt><dd><p>Message timeout in absolute time</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_mq_notify">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_mq_notify</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mqd_t</span></span><span class="w"> </span><span class="n"><span class="pre">mqdes</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sigevent</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">notification</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_notify" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for a POSIX MQ notify</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt><dd><p>MQ descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigevent</span> <span class="pre">*notification</span></code></dt><dd><p>Notification event</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_mq_getsetattr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_mq_getsetattr</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mqd_t</span></span><span class="w"> </span><span class="n"><span class="pre">mqdes</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mq_attr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mqstat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_getsetattr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for a POSIX MQ get/set attribute</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt><dd><p>MQ descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*mqstat</span></code></dt><dd><p>MQ flags</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_ipc_obj">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_ipc_obj</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kern_ipc_perm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ipcp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_obj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for ipc object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*ipcp</span></code></dt><dd><p>ipc permissions</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_ipc_set_perm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_ipc_set_perm</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">qbytes</span></span>, <span class="n"><span class="pre">uid_t</span></span><span class="w"> </span><span class="n"><span class="pre">uid</span></span>, <span class="n"><span class="pre">gid_t</span></span><span class="w"> </span><span class="n"><span class="pre">gid</span></span>, <span class="n"><span class="pre">umode_t</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_set_perm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for new ipc permissions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">qbytes</span></code></dt><dd><p>msgq bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uid_t</span> <span class="pre">uid</span></code></dt><dd><p>msgq user id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gid_t</span> <span class="pre">gid</span></code></dt><dd><p>msgq group id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt><dd><p>msgq mode (permissions)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called only after audit_ipc_obj().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_socketcall">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_socketcall</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nargs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_socketcall" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for sys_socketcall</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nargs</span></code></dt><dd><p>number of args, which should not be more than AUDITSC_ARGS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*args</span></code></dt><dd><p>args array</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_fd_pair">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_fd_pair</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">fd1</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">fd2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_fd_pair" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for pipe and socketpair</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd1</span></code></dt><dd><p>the first file descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd2</span></code></dt><dd><p>the second file descriptor</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_sockaddr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_sockaddr</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_sockaddr" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record audit data for sys_bind, sys_connect, sys_sendto</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>data length in user space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*a</span></code></dt><dd><p>data address in kernel space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or NULL context or &lt; 0 on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_signal_info_syscall">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_signal_info_syscall</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">task_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_signal_info_syscall" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record signal info for syscalls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*t</span></code></dt><dd><p>task being signaled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the audit subsystem is being terminated, record the task (pid)
and uid that is doing that.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_log_bprm_fcaps">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_log_bprm_fcaps</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">linux_binprm</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bprm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_bprm_fcaps" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>store information about a loading bprm and relevant fcaps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*bprm</span></code></dt><dd><p>pointer to the bprm being processed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>the proposed new credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*old</span></code></dt><dd><p>the old credentials</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simply check if the proc already has the caps given by the file and if not
store the priv escalation info for later auditing at the end of the syscall</p>
<p>-Eric</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__audit_log_capset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__audit_log_capset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cred</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_capset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>store information about the arguments to the capset syscall</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*new</span></code></dt><dd><p>the new credentials</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*old</span></code></dt><dd><p>the old (current) credentials</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Record the arguments userspace sent to sys_capset for later printing by the
audit system if applicable</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_core_dumps">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_core_dumps</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">signr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_core_dumps" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record information about processes that end abnormally</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">signr</span></code></dt><dd><p>signal value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a process ends with a core dump, something fishy is going on and we
should record the event for investigation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_seccomp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_seccomp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">syscall</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">signr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">code</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_seccomp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>record information about a seccomp action</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">syscall</span></code></dt><dd><p>syscall number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">signr</span></code></dt><dd><p>signal value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">code</span></code></dt><dd><p>the seccomp action</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Record the information associated with a seccomp action. Event filtering for
seccomp actions that are not to be logged is done in seccomp_log().
Therefore, this function forces auditing independent of the audit_enabled
and dummy context state because seccomp actions should be logged even when
audit is not in use.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_rule_change">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_rule_change</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">seq</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">datasz</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_rule_change" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>apply all rules to the specified message type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>audit message type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">seq</span></code></dt><dd><p>netlink audit message sequence (serial) number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>payload data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">datasz</span></code></dt><dd><p>size of payload data</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_list_rules_send">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_list_rules_send</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff"><span class="n"><span class="pre">sk_buff</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">request_skb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">seq</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_list_rules_send" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>list the audit rules</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*request_skb</span></code></dt><dd><p>skb of request we are replying to (used to target the reply)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">seq</span></code></dt><dd><p>netlink audit message sequence (serial) number</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.parent_len">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parent_len</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.parent_len" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>find the length of the parent portion of a pathname</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*path</span></code></dt><dd><p>pathname of which to determine length</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.audit_compare_dname_path">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">audit_compare_dname_path</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">qstr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dname</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">parentlen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_compare_dname_path" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>compare given dentry name with last component in given path. Return of 0 indicates a match.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*dname</span></code></dt><dd><p>dentry name that we're comparing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*path</span></code></dt><dd><p>full pathname that we're comparing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">parentlen</span></code></dt><dd><p>length of the parent if known. Passing in AUDIT_NAME_FULL
here indicates that we must compute this value.</p>
</dd>
</dl>
</div>
</section>
<section id="accounting-framework">
<h2>Accounting Framework<a class="headerlink" href="#accounting-framework" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.sys_acct">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sys_acct</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_acct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>enable/disable process accounting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>file name for accounting records or NULL to shutdown accounting</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.sys_acct" title="sys_acct"><code class="xref c c-func docutils literal notranslate"><span class="pre">sys_acct()</span></code></a> is the only system call needed to implement process
accounting. It takes the name of the file where accounting records
should be written. If the filename is NULL, accounting will be
shutdown.</p>
<p><strong>Return</strong></p>
<p>0 for success or negative errno values for failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.acct_collect">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acct_collect</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">exitcode</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">group_dead</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acct_collect" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>collect accounting information into pacct_struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">exitcode</span></code></dt><dd><p>task exit code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">group_dead</span></code></dt><dd><p>not 0, if this thread is the last one in the process.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.acct_process">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acct_process</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acct_process" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handles process accounting for an exiting task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
</section>
<section id="block-devices">
<h2>Block Devices<a class="headerlink" href="#block-devices" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.bio_advance">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bio_advance</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bio_advance" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nbytes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_advance" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment/complete a bio by some number of bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to advance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt><dd><p>number of bytes to complete</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This updates bi_sector, bi_size and bi_idx; if the number of bytes to
complete doesn't align with a bvec boundary, then bv_len and bv_offset will
be updated on the last bvec as well.</p>
<p><strong>bio</strong> will then represent the remaining, uncompleted portion of the io.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.folio_iter">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">folio_iter</span></span></span><a class="headerlink" href="#c.folio_iter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>State for iterating all folios in a bio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct folio_iter {
    struct folio *folio;
    size_t offset;
    size_t length;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">folio</span></code></dt><dd><p>The current folio we're iterating.  NULL after the last folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>The byte offset within the current folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>The number of bytes in this iteration (will not cross folio
boundary).</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.bio_for_each_folio_all">
<span class="sig-name descname"><span class="n"><span class="pre">bio_for_each_folio_all</span></span></span><a class="headerlink" href="#c.bio_for_each_folio_all" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">bio_for_each_folio_all</span> <span class="pre">(fi,</span> <span class="pre">bio)</span></code></p>
<blockquote>
<div><p>Iterate over each folio in a bio.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fi</span></code></dt><dd><p><a class="reference internal" href="#c.folio_iter" title="folio_iter"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio_iter</span></code></a> which is updated for each folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bio</span></code></dt><dd><p>struct bio to iterate over.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bio_next_split">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bio_next_split" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bio_next_split</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bio_next_split" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sectors</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bio_set</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_next_split" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get next <strong>sectors</strong> from a bio, splitting if necessary</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to split</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sectors</span></code></dt><dd><p>number of sectors to split from the front of <strong>bio</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>gfp mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*bs</span></code></dt><dd><p>bio set to allocate from</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a bio representing the next <strong>sectors</strong> of <strong>bio</strong> - if the bio is smaller
than <strong>sectors</strong>, returns the original bio unchanged.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_flag_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_flag_set</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flag</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>atomically set a queue flag</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt><dd><p>flag to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_flag_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_flag_clear</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flag</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_clear" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>atomically clear a queue flag</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt><dd><p>flag to be cleared</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_flag_test_and_set">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_flag_test_and_set</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flag</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_test_and_set" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>atomically test and set a queue flag</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt><dd><p>flag to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the previous value of <strong>flag</strong> - 0 if the flag was not set and 1 if
the flag was already set.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_op_str">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">blk_op_str</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">req_op</span></span><span class="w"> </span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_op_str" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return string XXX in the REQ_OP_XXX.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">req_op</span> <span class="pre">op</span></code></dt><dd><p>REQ_OP_XXX.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Centralize block layer function to convert REQ_OP_XXX into
string format. Useful in the debugging and tracing bio or request. For
invalid REQ_OP_XXX it returns string &quot;UNKNOWN&quot;.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_sync_queue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_sync_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_sync_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>cancel any pending callbacks on a queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The block layer may perform asynchronous callback activity
on a queue, such as calling the unplug function after a timeout.
A block device may call blk_sync_queue to ensure that any
such activity is cancelled, thus allowing it to release resources
that the callbacks might use. The caller must already have made sure
that its -&gt;submit_bio will not re-add plugging prior to calling
this function.</p>
<p>This function does not cancel any asynchronous activity arising
out of elevator or throttling code. That would require elevator_exit()
and blkcg_exit_queue() to be called with queue lock initialized.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_set_pm_only">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_set_pm_only</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_pm_only" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment pm_only counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue pointer</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_put_queue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_put_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_put_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrement the request_queue refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request_queue structure to decrement the refcount for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrements the refcount of the request_queue and free it when the refcount
reaches 0.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_get_queue">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_get_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_get_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>increment the request_queue refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request_queue structure to increment the refcount for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increment the refcount of the request_queue kobject.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.submit_bio_noacct">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">submit_bio_noacct</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.submit_bio_noacct" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio_noacct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>re-submit a bio to the block device layer for I/O</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>The bio describing the location in memory and on the device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a version of <a class="reference internal" href="#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a> that shall only be used for I/O that is
resubmitted to lower level drivers by stacking block drivers.  All file
systems and other upper level users of the block layer should use
<a class="reference internal" href="#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a> instead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.submit_bio">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">submit_bio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.submit_bio" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>submit a bio to the block device layer for I/O</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> which describes the I/O</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal notranslate"><span class="pre">submit_bio()</span></code></a> is used to submit I/O requests to block devices.  It is passed a
fully set up <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span></code> that describes the I/O that needs to be done.  The
bio will be send to the device described by the bi_bdev field.</p>
<p>The success/failure status of the request, along with notification of
completion, is delivered asynchronously through the -&gt;bi_end_io() callback
in <strong>bio</strong>.  The bio must NOT be touched by the caller until -&gt;bi_end_io() has
been called.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bio_poll">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bio_poll</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bio_poll" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">io_comp_batch</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iob</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_poll" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>poll for BIO completions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to poll for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">io_comp_batch</span> <span class="pre">*iob</span></code></dt><dd><p>batches of IO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>BLK_POLL_* flags that control the behavior</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Poll for completions on queue associated with the bio. Returns number of
completed entries found.</p>
<p><strong>Note</strong></p>
<p>the caller must either be the context that submitted <strong>bio</strong>, or
be in a RCU critical section to prevent freeing of <strong>bio</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bio_start_io_acct">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bio_start_io_acct</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.bio_start_io_acct" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_start_io_acct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>start I/O accounting for bio based drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio to start account for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the start time that should be passed back to bio_end_io_acct().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_lld_busy">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_lld_busy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_lld_busy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if underlying low-level drivers of a device are busy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the queue of the device being checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check if underlying low-level drivers of a device are busy.
If the drivers want to export their busy state, they must set own
exporting function using blk_queue_lld_busy() first.</p>
<p>Basically, this function is used only by request stacking drivers
to stop dispatching requests to underlying devices when underlying
devices are busy.  This behavior helps more I/O merging on the queue
of the request stacking driver and prevents I/O throughput regression
on burst I/O load.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 - Not busy (The request stacking driver should dispatch request)
1 - Busy (The request stacking driver should stop dispatching request)</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_start_plug">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_start_plug</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">blk_plug</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">plug</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_plug" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize blk_plug and track it inside the task_struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_plug</span> <span class="pre">*plug</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_plug</span></code> that needs to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a> indicates to the block layer an intent by the caller
to submit multiple I/O requests in a batch.  The block layer may use
this hint to defer submitting I/Os from the caller until <a class="reference internal" href="#c.blk_finish_plug" title="blk_finish_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_finish_plug()</span></code></a>
is called.  However, the block layer may choose to submit requests
before a call to <a class="reference internal" href="#c.blk_finish_plug" title="blk_finish_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_finish_plug()</span></code></a> if the number of queued I/Os
exceeds <code class="docutils literal notranslate"><span class="pre">BLK_MAX_REQUEST_COUNT</span></code>, or if the size of the I/O is larger than
<code class="docutils literal notranslate"><span class="pre">BLK_PLUG_FLUSH_SIZE</span></code>.  The queued I/Os may also be submitted early if
the task schedules (see below).</p>
<p>Tracking blk_plug inside the task_struct will help with auto-flushing the
pending I/O should the task end up blocking between <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a> and
<a class="reference internal" href="#c.blk_finish_plug" title="blk_finish_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_finish_plug()</span></code></a>. This is important from a performance perspective, but
also ensures that we don't deadlock. For instance, if the task is blocking
for a memory allocation, memory reclaim could end up wanting to free a
page belonging to that request that is currently residing in our private
plug. By flushing the pending I/O when the process goes to sleep, we avoid
this kind of deadlock.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_finish_plug">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_finish_plug</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">blk_plug</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">plug</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_finish_plug" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark the end of a batch of submitted I/O</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_plug</span> <span class="pre">*plug</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_plug</span></code> passed to <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Indicate that a batch of I/O submissions is complete.  This function
must be paired with an initial call to <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a>.  The intent
is to allow the block layer to optimize I/O submission.  See the
documentation for <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_start_plug()</span></code></a> for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_enter">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_enter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">blk_mq_req_flags_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_enter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>try to increase q-&gt;q_usage_counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_mq_req_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>BLK_MQ_REQ_NOWAIT and/or BLK_MQ_REQ_PM</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_rq_map_user_iov">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_rq_map_user_iov</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rq</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rq_map_data</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map_data</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">iov_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_user_iov" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map user data to a request, for passthrough requests</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue where request should be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*rq</span></code></dt><dd><p>request to map data to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rq_map_data</span> <span class="pre">*map_data</span></code></dt><dd><p>pointer to the rq_map_data holding pages (if necessary)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*iter</span></code></dt><dd><p>iovec iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Data will be mapped directly for zero copy I/O, if possible. Otherwise
a kernel bounce buffer is used.</p>
<p>A matching <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_rq_unmap_user()</span></code></a> must be issued at the end of I/O, while
still in process context.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_rq_unmap_user">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_rq_unmap_user</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.blk_rq_unmap_user" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unmap_user" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unmap a request with user data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>start of bio list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Unmap a rq previously mapped by blk_rq_map_user(). The caller must
supply the original rq-&gt;bio from the blk_rq_map_user() return, since
the I/O completion may have changed rq-&gt;bio.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_rq_map_kern">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_rq_map_kern</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rq</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kbuf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_kern" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>map kernel data to a request, for passthrough requests</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue where request should be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*rq</span></code></dt><dd><p>request to fill</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*kbuf</span></code></dt><dd><p>the kernel buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of user data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Data will be mapped directly if possible. Otherwise a bounce
buffer is used. Can be called multiple times to append multiple
buffers.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_register_queue">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_register_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_register_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a block layer queue with sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>Disk of which the request queue should be registered with sysfs.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_unregister_queue">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_unregister_queue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_unregister_queue" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>counterpart of <a class="reference internal" href="#c.blk_register_queue" title="blk_register_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_register_queue()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>Disk of which the request queue should be unregistered from sysfs.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>the caller is responsible for guaranteeing that this function is called
after <a class="reference internal" href="#c.blk_register_queue" title="blk_register_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_register_queue()</span></code></a> has finished.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_set_stacking_limits">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_set_stacking_limits</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">queue_limits</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lim</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_stacking_limits" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set default limits for stacking devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*lim</span></code></dt><dd><p>the queue_limits structure to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns a queue_limit struct to its default state. Should be used
by stacking drivers like DM that have no internal limits.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_bounce_limit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_bounce_limit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">blk_bounce</span></span><span class="w"> </span><span class="n"><span class="pre">bounce</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bounce_limit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set bounce buffer limit for queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">blk_bounce</span> <span class="pre">bounce</span></code></dt><dd><p>bounce limit to enforce</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Force bouncing for ISA DMA ranges or highmem.</p>
<p>DEPRECATED, don't use in new code.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_max_hw_sectors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_max_hw_sectors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_hw_sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_hw_sectors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set max sectors for a request for this queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_hw_sectors</span></code></dt><dd><p>max hardware sectors in the usual 512b unit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set a hard upper limit,
max_hw_sectors, on the size of requests.  max_hw_sectors is set by
the device driver based upon the capabilities of the I/O
controller.</p>
<p>max_dev_sectors is a hard limit imposed by the storage device for
READ/WRITE requests. It is set by the disk driver.</p>
<p>max_sectors is a soft limit imposed by the block layer for
filesystem type requests.  This value can be overridden on a
per-device basis in /sys/block/&lt;device&gt;/queue/max_sectors_kb.
The soft limit can not exceed max_hw_sectors.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_chunk_sectors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_chunk_sectors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">chunk_sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_chunk_sectors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set size of the chunk for this queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">chunk_sectors</span></code></dt><dd><p>chunk sectors in the usual 512b unit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If a driver doesn't want IOs to cross a given chunk size, it can set
this limit and prevent merging across chunks. Note that the block layer
must accept a page worth of data at any offset. So if the crossing of
chunks is a hard limitation in the driver, it must still be prepared
to split single page bios.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_max_discard_sectors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_max_discard_sectors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_discard_sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_sectors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set max sectors for a single discard</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_discard_sectors</span></code></dt><dd><p>maximum number of sectors to discard</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_max_secure_erase_sectors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_max_secure_erase_sectors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_secure_erase_sectors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set max sectors for a secure erase</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_sectors</span></code></dt><dd><p>maximum number of sectors to secure_erase</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_max_write_zeroes_sectors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_max_write_zeroes_sectors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_write_zeroes_sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_zeroes_sectors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set max sectors for a single write zeroes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_zeroes_sectors</span></code></dt><dd><p>maximum number of sectors to write per command</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_max_zone_append_sectors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_max_zone_append_sectors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_zone_append_sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_zone_append_sectors" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set max sectors for a single zone append</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_zone_append_sectors</span></code></dt><dd><p>maximum number of sectors to write per command</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_max_segments">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_max_segments</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">short</span></span><span class="w"> </span><span class="n"><span class="pre">max_segments</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segments" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set max hw segments for a request for this queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt><dd><p>max number of segments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set an upper limit on the number of
hw data segments in a request.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_max_discard_segments">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_max_discard_segments</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">short</span></span><span class="w"> </span><span class="n"><span class="pre">max_segments</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_segments" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set max segments for discard requests</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt><dd><p>max number of segments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set an upper limit on the number of
segments in a discard request.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_max_segment_size">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_max_segment_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segment_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set max segment size for blk_rq_map_sg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_size</span></code></dt><dd><p>max size of segment in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set an upper limit on the size of a
coalesced segment</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_logical_block_size">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_logical_block_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_logical_block_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set logical block size for the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the logical block size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This should be set to the lowest possible block size that the
storage device can address.  The default of 512 covers most
hardware.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_physical_block_size">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_physical_block_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_physical_block_size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set physical block size for the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the physical block size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This should be set to the lowest possible sector size that the
hardware can operate on without reverting to read-modify-write
operations.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_zone_write_granularity">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_zone_write_granularity</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_zone_write_granularity" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set zone write granularity for the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the zoned device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the zone write granularity size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This should be set to the lowest possible size allowing to write in
sequential zones of a zoned block device.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_alignment_offset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_alignment_offset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_alignment_offset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set physical block alignment offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>alignment offset in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Some devices are naturally misaligned to compensate for things like
the legacy DOS partition table 63-sector offset.  Low-level drivers
should call this function for devices whose first sector is not
naturally aligned.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_limits_io_min">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_limits_io_min</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">queue_limits</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">limits</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_min" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set minimum request size for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*limits</span></code></dt><dd><p>the queue limits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>smallest I/O size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Some devices have an internal block size bigger than the reported
hardware sector size.  This function can be used to signal the
smallest I/O the device can perform without incurring a performance
penalty.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_io_min">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_io_min</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_min" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set minimum request size for the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>smallest I/O size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Storage devices may report a granularity or preferred minimum I/O
size which is the smallest request the device can perform without
incurring a performance penalty.  For disk drives this is often the
physical block size.  For RAID arrays it is often the stripe chunk
size.  A properly aligned multiple of minimum_io_size is the
preferred request size for workloads where a high number of I/O
operations is desired.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_limits_io_opt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_limits_io_opt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">queue_limits</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">limits</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">opt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_opt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set optimal request size for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*limits</span></code></dt><dd><p>the queue limits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt><dd><p>smallest I/O size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Storage devices may report an optimal I/O size, which is the
device's preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_io_opt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_io_opt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">opt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_opt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set optimal request size for the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt><dd><p>optimal request size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Storage devices may report an optimal I/O size, which is the
device's preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_stack_limits">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_stack_limits</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">queue_limits</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">queue_limits</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_stack_limits" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>adjust queue_limits for stacked devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*t</span></code></dt><dd><p>the stacking driver limits (top device)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*b</span></code></dt><dd><p>the underlying queue limits (bottom, component device)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt><dd><p>first data sector within component device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is used by stacking drivers like MD and DM to ensure
that all component devices have compatible block sizes and
alignments.  The stacking driver must provide a queue_limits
struct (top) and then iteratively call the stacking function for
all component (bottom) devices.  The stacking function will
attempt to combine the values and ensure proper alignment.</p>
<p>Returns 0 if the top and bottom queue_limits are compatible.  The
top device's block sizes and alignment offsets may be adjusted to
ensure alignment with the bottom device. If no compatible sizes
and alignments exist, -1 is returned and the resulting top
queue_limits will have the misaligned flag set to indicate that
the alignment_offset is undefined.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.disk_stack_limits">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">disk_stack_limits</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_stack_limits" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>MD/DM gendisk (top)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>the underlying block device (bottom)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">offset</span></code></dt><dd><p>offset to beginning of data within component device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Merges the limits for a top level gendisk and a bottom level
block_device.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_update_dma_pad">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_update_dma_pad</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_pad" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update pad mask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>pad mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update dma pad mask.</p>
<p>Appending pad buffer to a request modifies the last entry of a
scatter list such that it includes the pad buffer.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_segment_boundary">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_segment_boundary</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_segment_boundary" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set boundary rules for segment merging</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>the memory boundary mask</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_virt_boundary">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_virt_boundary</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_virt_boundary" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set boundary rules for bio merging</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>the memory boundary mask</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_dma_alignment">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_dma_alignment</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_alignment" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set dma length and memory alignment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>alignment mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>set required memory and length alignment for direct dma transactions.
this is used when building direct io requests for the queue.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_update_dma_alignment">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_update_dma_alignment</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_alignment" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>update dma length and memory alignment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>alignment mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>update required memory and length alignment for direct dma transactions.
If the requested alignment is larger than the current alignment, then
the current queue alignment is updated to the new value, otherwise it
is left alone.  The design of this is to allow multiple objects
(driver, device, transport etc) to set their respective
alignments without having them interfere.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_set_queue_depth">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_set_queue_depth</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">depth</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_queue_depth" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>tell the block layer about the device queue depth</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>queue depth</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_write_cache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_write_cache</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">wc</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">fua</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_write_cache" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>configure queue's write cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wc</span></code></dt><dd><p>write back cache on or off</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fua</span></code></dt><dd><p>device supports FUA writes, if true</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer about the write cache of <strong>q</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_required_elevator_features">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_required_elevator_features</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">features</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_required_elevator_features" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a queue required elevator features</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">features</span></code></dt><dd><p>Required elevator features OR'ed together</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer that for the device controlled through <strong>q</strong>, only the
only elevators that can be used are those that implement at least the set of
features specified by <strong>features</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_queue_can_use_dma_map_merging">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_queue_can_use_dma_map_merging</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_can_use_dma_map_merging" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>configure queue for merging segments.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device pointer for dma</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer about merging the segments by dma map of <strong>q</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.disk_set_zoned">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">disk_set_zoned</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">blk_zoned_model</span></span><span class="w"> </span><span class="n"><span class="pre">model</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_set_zoned" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>configure the zoned model for a disk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>the gendisk of the queue to configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">blk_zoned_model</span> <span class="pre">model</span></code></dt><dd><p>the zoned model to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the zoned model of <strong>disk</strong> to <strong>model</strong>.</p>
<p>When <strong>model</strong> is BLK_ZONED_HM (host managed), this should be called only
if zoned block device support is enabled (CONFIG_BLK_DEV_ZONED option).
If <strong>model</strong> specifies BLK_ZONED_HA (host aware), the effective model used
depends on CONFIG_BLK_DEV_ZONED settings and on the existence of partitions
on the disk.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blkdev_issue_flush">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blkdev_issue_flush</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_flush" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>queue a flush</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>blockdev to issue flush for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Issue a flush for the block device in question.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blkdev_issue_discard">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blkdev_issue_discard</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">sector</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">nr_sects</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_discard" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>queue a discard</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>blockdev to issue discard for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt><dd><p>start sector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt><dd><p>number of sectors to discard</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (for bio_alloc)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Issue a discard request for the sectors in question.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__blkdev_issue_zeroout">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__blkdev_issue_zeroout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">sector</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">nr_sects</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">bio</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">biop</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__blkdev_issue_zeroout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>generate number of zero filed write bios</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>blockdev to issue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt><dd><p>start sector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt><dd><p>number of sectors to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (for bio_alloc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">**biop</span></code></dt><dd><p>pointer to anchor bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>controls detailed behavior</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.</p>
<p>If a device is using logical block provisioning, the underlying space will
not be released if <code class="docutils literal notranslate"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOUNMAP.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOFALLBACK, the function will return
-EOPNOTSUPP if no explicit hardware offload for zeroing is provided.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blkdev_issue_zeroout">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blkdev_issue_zeroout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">sector</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">nr_sects</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_zeroout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>zero-fill a block range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>blockdev to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt><dd><p>start sector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt><dd><p>number of sectors to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>memory allocation flags (for bio_alloc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>controls detailed behavior</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.  See <a class="reference internal" href="#c.__blkdev_issue_zeroout" title="__blkdev_issue_zeroout"><code class="xref c c-func docutils literal notranslate"><span class="pre">__blkdev_issue_zeroout()</span></code></a> for the
valid values for <code class="docutils literal notranslate"><span class="pre">flags</span></code>.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_rq_count_integrity_sg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_rq_count_integrity_sg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.blk_rq_count_integrity_sg" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_count_integrity_sg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Count number of integrity scatterlist elements</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio with integrity metadata attached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of elements required in a
scatterlist corresponding to the integrity metadata in a bio.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_rq_map_integrity_sg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_rq_map_integrity_sg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.blk_rq_map_integrity_sg" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">scatterlist</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sglist</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_integrity_sg" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Map integrity metadata into a scatterlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>request queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>bio with integrity metadata attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sglist</span></code></dt><dd><p>target scatterlist</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the integrity vectors in request into a
scatterlist.  The scatterlist must be big enough to hold all
elements.  I.e. sized using <a class="reference internal" href="#c.blk_rq_count_integrity_sg" title="blk_rq_count_integrity_sg"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_rq_count_integrity_sg()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_integrity_compare">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_integrity_compare</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gd1</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gd2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_compare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compare integrity profile of two disks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*gd1</span></code></dt><dd><p>Disk to compare</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*gd2</span></code></dt><dd><p>Disk to compare</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Meta-devices like DM and MD need to verify that all
sub-devices use the same integrity format before advertising to
upper layers that they can send/receive integrity metadata.  This
function can be used to check whether two gendisk devices have
compatible integrity formats.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_integrity_register">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_integrity_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">blk_integrity</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">template</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a gendisk as being integrity-capable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>struct gendisk pointer to make integrity-aware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">blk_integrity</span> <span class="pre">*template</span></code></dt><dd><p>block integrity profile to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device needs to advertise itself as being able to
send/receive integrity metadata it must use this function to register
the capability with the block layer. The template is a blk_integrity
struct with values appropriate for the underlying hardware. See
<a class="reference internal" href="../block/data-integrity.html"><span class="doc">Data Integrity</span></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_integrity_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_integrity_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister block integrity profile</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>disk whose integrity profile to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters the integrity capability from
a block device.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_trace_ioctl">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_trace_ioctl</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">cmd</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_ioctl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>handle the ioctls associated with tracing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>the block device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">cmd</span></code></dt><dd><p>the ioctl cmd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>the argument data, if any</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_trace_shutdown">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_trace_shutdown</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_shutdown" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>stop and cleanup trace structures</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>the request queue associated with the device</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_add_trace_rq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_add_trace_rq</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rq</span></span>, <span class="n"><span class="pre">blk_status_t</span></span><span class="w"> </span><span class="n"><span class="pre">error</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_bytes</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">what</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">cgid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a trace for a request oriented action</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*rq</span></code></dt><dd><p>the source request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt><dd><p>return status to log</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt><dd><p>number of completed bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">what</span></code></dt><dd><p>the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">cgid</span></code></dt><dd><p>the cgroup info</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Records an action against a request. Will log the bio offset + size.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_add_trace_bio">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_add_trace_bio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request_queue</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.blk_add_trace_bio" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">what</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">error</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a trace for a bio oriented action</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>queue the io is for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>the source bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">what</span></code></dt><dd><p>the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt><dd><p>error, if any</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Records an action against a bio. Will log the bio offset + size.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_add_trace_bio_remap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_add_trace_bio_remap</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ignore</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.blk_add_trace_bio_remap" title="bio"><span class="n"><span class="pre">bio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bio</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio_remap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a trace for a bio-remap operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ignore</span></code></dt><dd><p>trace callback data parameter (not used)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*bio</span></code></dt><dd><p>the source bio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>source device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt><dd><p>source sector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called after a bio is remapped to a different device and/or sector.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_add_trace_rq_remap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_add_trace_rq_remap</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ignore</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">request</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rq</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">from</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq_remap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a trace for a request-remap operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ignore</span></code></dt><dd><p>trace callback data parameter (not used)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*rq</span></code></dt><dd><p>the source request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt><dd><p>source sector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Device mapper remaps request to other devices.
Add a trace for that action.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.disk_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">disk_release</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_release" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>releases all allocated resources of the gendisk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device representing this disk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases all allocated resources of the gendisk.</p>
<p>Drivers which used __device_add_disk() have a gendisk with a request_queue
assigned. Since the request_queue sits on top of the gendisk for these
drivers we also call <a class="reference internal" href="#c.blk_put_queue" title="blk_put_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">blk_put_queue()</span></code></a> for them, and we expect the
request_queue refcount to reach 0 at this point, and so the request_queue
will also be freed prior to the disk.</p>
<p><strong>Context</strong></p>
<p>can sleep</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__register_blkdev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__register_blkdev</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">major</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">probe</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">devt</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__register_blkdev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a new block device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt><dd><p>the requested major device number [1..BLKDEV_MAJOR_MAX-1]. If
<strong>major</strong> = 0, try to allocate any unused major number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name of the new block device as a zero terminated string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*probe)(dev_t</span> <span class="pre">devt)</span></code></dt><dd><p>pre-devtmpfs / pre-udev callback used to create disks when their
pre-created device node is accessed. When a probe call uses
add_disk() and it fails the driver must cleanup resources. This
interface may soon be removed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>name</strong> must be unique within the system.</p>
<p>The return value depends on the <strong>major</strong> input parameter:</p>
<blockquote>
<div><ul class="simple">
<li><p>if a major device number was requested in range [1..BLKDEV_MAJOR_MAX-1]
then the function returns zero on success, or a negative error code</p></li>
<li><p>if any unused major number was requested with <strong>major</strong> = 0 parameter
then the return value is the allocated major number in range
[1..BLKDEV_MAJOR_MAX-1] or a negative error code otherwise</p></li>
</ul>
</div></blockquote>
<p>See <a class="reference internal" href="../admin-guide/devices.html"><span class="doc">Linux allocated devices (4.x+ version)</span></a> for the list of allocated
major numbers.</p>
<p>Use register_blkdev instead for any new code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.device_add_disk">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">device_add_disk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">attribute_group</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">groups</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.device_add_disk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add disk information to kernel list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device for the disk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>per-device partitioning information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**groups</span></code></dt><dd><p>Additional per-device sysfs groups</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers the partitioning information in <strong>disk</strong>
with the kernel.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blk_mark_disk_dead">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">blk_mark_disk_dead</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_mark_disk_dead" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark a disk as dead</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>disk to mark as dead</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark as disk as dead (e.g. surprise removed) and don't accept any new I/O
to this disk.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.del_gendisk">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">del_gendisk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.del_gendisk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove the gendisk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>the struct gendisk to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the gendisk and all its associated resources. This deletes the
partitions associated with the gendisk, and unregisters the associated
request_queue.</p>
<p>This is the counter to the respective __device_add_disk() call.</p>
<p>The final removal of the struct gendisk happens when its refcount reaches 0
with <a class="reference internal" href="#c.put_disk" title="put_disk"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_disk()</span></code></a>, which should be called after <a class="reference internal" href="#c.del_gendisk" title="del_gendisk"><code class="xref c c-func docutils literal notranslate"><span class="pre">del_gendisk()</span></code></a>, if
__device_add_disk() was used.</p>
<p>Drivers exist which depend on the release of the gendisk to be synchronous,
it should not be deferred.</p>
<p><strong>Context</strong></p>
<p>can sleep</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.invalidate_disk">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">invalidate_disk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_disk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>invalidate the disk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>the struct gendisk to invalidate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A helper to invalidates the disk. It will clean the disk's associated
buffer/page caches and reset its internal states so that the disk
can be reused by the drivers.</p>
<p><strong>Context</strong></p>
<p>can sleep</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.put_disk">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">put_disk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.put_disk" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>decrements the gendisk refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>the struct gendisk to decrement the refcount for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This decrements the refcount for the struct gendisk. When this reaches 0
we'll have <a class="reference internal" href="#c.disk_release" title="disk_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">disk_release()</span></code></a> called.</p>
<p><strong>Note</strong></p>
<p>for blk-mq disk put_disk must be called before freeing the tag_set
when handling probe errors (that is before add_disk() is called).</p>
<p><strong>Context</strong></p>
<p>Any context, but the last reference must not be dropped from
atomic context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.set_disk_ro">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_disk_ro</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">gendisk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">disk</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">read_only</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.set_disk_ro" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set a gendisk read-only</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*disk</span></code></dt><dd><p>gendisk to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">read_only</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">true</span></code> to set the disk read-only, <code class="docutils literal notranslate"><span class="pre">false</span></code> set the disk read/write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to indicate whether a given disk device should have its
read-only flag set. <a class="reference internal" href="#c.set_disk_ro" title="set_disk_ro"><code class="xref c c-func docutils literal notranslate"><span class="pre">set_disk_ro()</span></code></a> is typically used by device drivers to
indicate whether the underlying physical device is write-protected.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.freeze_bdev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">freeze_bdev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.freeze_bdev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lock a filesystem and force it into a consistent state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>blockdevice to lock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a superblock is found on this device, we take the s_umount semaphore
on it to make sure nobody unmounts until the snapshot creation is done.
The reference counter (bd_fsfreeze_count) guarantees that only the last
unfreeze process can unfreeze the frozen filesystem actually when multiple
freeze requests arrive simultaneously. It counts up in <a class="reference internal" href="#c.freeze_bdev" title="freeze_bdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">freeze_bdev()</span></code></a> and
count down in <a class="reference internal" href="#c.thaw_bdev" title="thaw_bdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">thaw_bdev()</span></code></a>. When it becomes 0, <a class="reference internal" href="#c.thaw_bdev" title="thaw_bdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">thaw_bdev()</span></code></a> will unfreeze
actually.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.thaw_bdev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">thaw_bdev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.thaw_bdev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unlock filesystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>blockdevice to unlock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the filesystem and marks it writeable again after <a class="reference internal" href="#c.freeze_bdev" title="freeze_bdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">freeze_bdev()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bd_prepare_to_claim">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bd_prepare_to_claim</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">holder</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">blk_holder_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_prepare_to_claim" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>claim a block device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block device of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*holder</span></code></dt><dd><p>holder trying to claim <strong>bdev</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">blk_holder_ops</span> <span class="pre">*hops</span></code></dt><dd><p>holder ops.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Claim <strong>bdev</strong>.  This function fails if <strong>bdev</strong> is already claimed by another
holder and waits if another claiming is in progress. return, the caller
has ownership of bd_claiming and bd_holder[s].</p>
<p><strong>Return</strong></p>
<p>0 if <strong>bdev</strong> can be claimed, -EBUSY otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bd_abort_claiming">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bd_abort_claiming</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">holder</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_abort_claiming" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>abort claiming of a block device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block device of interest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*holder</span></code></dt><dd><p>holder that has claimed <strong>bdev</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Abort claiming of a block device when the exclusive open failed. This can be
also used when exclusive open is not actually desired and we just needed
to block other exclusive openers for a while.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blkdev_get_by_dev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">blkdev_get_by_dev</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">blk_mode_t</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">holder</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">blk_holder_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_get_by_dev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>open a block device by device number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>device number of block device to open</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_mode_t</span> <span class="pre">mode</span></code></dt><dd><p>open mode (BLK_OPEN_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*holder</span></code></dt><dd><p>exclusive holder identifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">blk_holder_ops</span> <span class="pre">*hops</span></code></dt><dd><p>holder operations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open the block device described by device number <strong>dev</strong>. If <strong>holder</strong> is not
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the block device is opened with exclusive access.  Exclusive opens may
nest for the same <strong>holder</strong>.</p>
<p>Use this interface ONLY if you really do not have anything better - i.e. when
you are behind a truly sucky interface and all you are given is a device
number.  Everything else should use <a class="reference internal" href="#c.blkdev_get_by_path" title="blkdev_get_by_path"><code class="xref c c-func docutils literal notranslate"><span class="pre">blkdev_get_by_path()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>Reference to the block_device on success, ERR_PTR(-errno) on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.blkdev_get_by_path">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">blkdev_get_by_path</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">path</span></span>, <span class="n"><span class="pre">blk_mode_t</span></span><span class="w"> </span><span class="n"><span class="pre">mode</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">holder</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">blk_holder_ops</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_get_by_path" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>open a block device by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*path</span></code></dt><dd><p>path to the block device to open</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_mode_t</span> <span class="pre">mode</span></code></dt><dd><p>open mode (BLK_OPEN_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*holder</span></code></dt><dd><p>exclusive holder identifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">blk_holder_ops</span> <span class="pre">*hops</span></code></dt><dd><p>holder operations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open the block device described by the device file at <strong>path</strong>.  If <strong>holder</strong> is
not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the block device is opened with exclusive access.  Exclusive opens
may nest for the same <strong>holder</strong>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>Reference to the block_device on success, ERR_PTR(-errno) on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.lookup_bdev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lookup_bdev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pathname</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_bdev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Look up a struct block_device by name.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pathname</span></code></dt><dd><p>Name of the block device in the filesystem.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to the block device's dev_t, if found.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup the block device's dev_t at <strong>pathname</strong> in the current
namespace if possible and return it in <strong>dev</strong>.</p>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>0 if succeeded, negative errno otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bdev_mark_dead">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bdev_mark_dead</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">surprise</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bdev_mark_dead" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark a block device as dead</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">surprise</span></code></dt><dd><p>indicate a surprise removal</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the file system that this devices or media is dead.  If <strong>surprise</strong> is set
to <code class="docutils literal notranslate"><span class="pre">true</span></code> the device or media is already gone, if not we are preparing for an
orderly removal.</p>
<p>This calls into the file system, which then typicall syncs out all dirty data
and writes back inodes and then invalidates any cached data in the inodes on
the file system.  In addition we also invalidate the block device mapping.</p>
</div>
</section>
<section id="char-devices">
<h2>Char devices<a class="headerlink" href="#char-devices" title="Permalink to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.register_chrdev_region">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">register_chrdev_region</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">from</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.register_chrdev_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a range of device numbers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt><dd><p>the first in the desired range of device numbers; must include
the major number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt><dd><p>the number of consecutive device numbers required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name of the device or driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return value is zero on success, a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.alloc_chrdev_region">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">alloc_chrdev_region</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">baseminor</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_chrdev_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a range of char device numbers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">*dev</span></code></dt><dd><p>output parameter for first assigned number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">baseminor</span></code></dt><dd><p>first of the requested range of minor numbers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt><dd><p>the number of minor numbers required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name of the associated device or driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a range of char device numbers.  The major number will be
chosen dynamically, and returned (along with the first minor number)
in <strong>dev</strong>.  Returns zero or a negative error code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__register_chrdev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__register_chrdev</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">major</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">baseminor</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file_operations</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__register_chrdev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>create and register a cdev occupying a range of minors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt><dd><p>major device number or 0 for dynamic allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt><dd><p>first of the requested range of minor numbers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of minor numbers required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of this range of devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>file operations associated with this devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>major</strong> == 0 this functions will dynamically allocate a major and return
its number.</p>
<p>If <strong>major</strong> &gt; 0 this function will attempt to reserve a device with the given
major number and will return zero on success.</p>
<p>Returns a -ve errno on failure.</p>
<p>The name of this device has nothing to do with the name of the device in
/dev. It only helps to keep track of the different owners of devices. If
your module name has only one type of devices it's ok to use e.g. the name
of the module here.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.unregister_chrdev_region">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">unregister_chrdev_region</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">from</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_chrdev_region" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a range of device numbers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt><dd><p>the first in the range of numbers to unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt><dd><p>the number of device numbers to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will unregister a range of <strong>count</strong> device numbers,
starting with <strong>from</strong>.  The caller should normally be the one who
allocated those numbers in the first place...</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__unregister_chrdev">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__unregister_chrdev</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">major</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">baseminor</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__unregister_chrdev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister and destroy a cdev</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt><dd><p>major device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt><dd><p>first of the range of minor numbers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of minor numbers this cdev is occupying</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of this range of devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister and destroy the cdev occupying the region described by
<strong>major</strong>, <strong>baseminor</strong> and <strong>count</strong>.  This function undoes what
<a class="reference internal" href="#c.__register_chrdev" title="__register_chrdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">__register_chrdev()</span></code></a> did.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cdev_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cdev_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cdev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">dev_t</span></span><span class="w"> </span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a char device to the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*p</span></code></dt><dd><p>the cdev structure for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt><dd><p>the first device number for which this device is responsible</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt><dd><p>the number of consecutive minor numbers corresponding to this
device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_add()</span></code></a> adds the device represented by <strong>p</strong> to the system, making it
live immediately.  A negative error code is returned on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cdev_set_parent">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cdev_set_parent</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cdev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">kobject</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kobj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_set_parent" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the parent kobject for a char device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*p</span></code></dt><dd><p>the cdev structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>the kobject to take a reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_set_parent" title="cdev_set_parent"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_set_parent()</span></code></a> sets a parent kobject which will be referenced
appropriately so the parent is not freed before the cdev. This
should be called before cdev_add.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cdev_device_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cdev_device_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.cdev_device_add" title="cdev"><span class="n"><span class="pre">cdev</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cdev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_add" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a char device and it's corresponding <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>, linkink</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*cdev</span></code></dt><dd><p>the cdev structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_add" title="cdev_device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_device_add()</span></code></a> adds the char device represented by <strong>cdev</strong> to the system,
just as cdev_add does. It then adds <strong>dev</strong> to the system using device_add
The dev_t for the char device will be taken from the <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> which
needs to be initialized first. This helper function correctly takes a
reference to the parent device so the parent will not get released until
all references to the cdev are released.</p>
<p>This helper uses dev-&gt;devt for the device number. If it is not set
it will not add the cdev and it will be equivalent to device_add.</p>
<p>This function should be used whenever the struct cdev and the
<a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> are members of the same structure whose lifetime is
managed by the <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>Callers must assume that userspace was able to open the cdev and
can call cdev fops callbacks at any time, even if this function fails.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cdev_device_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cdev_device_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.cdev_device_del" title="cdev"><span class="n"><span class="pre">cdev</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cdev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_del" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>inverse of cdev_device_add</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*cdev</span></code></dt><dd><p>the cdev structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_del" title="cdev_device_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_device_del()</span></code></a> is a helper function to call cdev_del and device_del.
It should be used whenever cdev_device_add is used.</p>
<p>If dev-&gt;devt is not set it will not remove the cdev and will be equivalent
to device_del.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that associated sysfs callbacks are not running
or runnable, however any cdevs already open will remain and their fops
will still be callable even after this function returns.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cdev_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cdev_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cdev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_del" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>remove a cdev from the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*p</span></code></dt><dd><p>the cdev structure to be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_del" title="cdev_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_del()</span></code></a> removes <strong>p</strong> from the system, possibly freeing the structure
itself.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that cdev device will no longer be able to be
opened, however any cdevs already open will remain and their fops will
still be callable even after cdev_del returns.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cdev_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cdev</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">cdev_alloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a cdev structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a cdev structure, or NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cdev_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cdev_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.cdev_init" title="cdev"><span class="n"><span class="pre">cdev</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cdev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file_operations</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a cdev structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*cdev</span></code></dt><dd><p>the structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>the file_operations for this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes <strong>cdev</strong>, remembering <strong>fops</strong>, making it ready to add to the
system with <a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">cdev_add()</span></code></a>.</p>
</div>
</section>
<section id="clock-framework">
<h2>Clock Framework<a class="headerlink" href="#clock-framework" title="Permalink to this heading">¶</a></h2>
<p>The clock framework defines programming interfaces to support software
management of the system clock tree. This framework is widely used with
System-On-Chip (SOC) platforms to support power management and various
devices which may need custom clock rates. Note that these &quot;clocks&quot;
don't relate to timekeeping or real time clocks (RTCs), each of which
have separate frameworks. These <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span></code>
instances may be used to manage for example a 96 MHz signal that is used
to shift bits into and out of peripherals or busses, or otherwise
trigger synchronous state machine transitions in system hardware.</p>
<p>Power management is supported by explicit software clock gating: unused
clocks are disabled, so the system doesn't waste power changing the
state of transistors that aren't in active use. On some systems this may
be backed by hardware clock gating, where clocks are gated without being
disabled in software. Sections of chips that are powered but not clocked
may be able to retain their last state. This low power state is often
called a <em>retention mode</em>. This mode still incurs leakage currents,
especially with finer circuit geometries, but for CMOS circuits power is
mostly used by clocked state changes.</p>
<p>Power-aware drivers only enable their clocks when the device they manage
is in active use. Also, system sleep states often differ according to
which clock domains are active: while a &quot;standby&quot; state may allow wakeup
from several active domains, a &quot;mem&quot; (suspend-to-RAM) state may require
a more wholesale shutdown of clocks derived from higher speed PLLs and
oscillators, limiting the number of possible wakeup event sources. A
driver's suspend method may need to be aware of system-specific clock
constraints on the target sleep state.</p>
<p>Some platforms support programmable clock generators. These can be used
by external chips of various kinds, such as other CPUs, multimedia
codecs, and devices with strict requirements for interface clocking.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.clk_notifier">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_notifier</span></span></span><a class="headerlink" href="#c.clk_notifier" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>associate a clk with a notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct clk_notifier {
    struct clk                      *clk;
    struct srcu_notifier_head       notifier_head;
    struct list_head                node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">clk</span></code></dt><dd><p>struct clk * to associate the notifier with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notifier_head</span></code></dt><dd><p>a blocking_notifier_head for this clk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>linked list pointers</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A list of <a class="reference internal" href="#c.clk_notifier" title="clk_notifier"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_notifier</span></code></a> is maintained by the notifier code.
An entry is created whenever code registers the first notifier on a
particular <strong>clk</strong>.  Future notifiers on that <strong>clk</strong> are added to the
<strong>notifier_head</strong>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.clk_notifier_data">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_notifier_data</span></span></span><a class="headerlink" href="#c.clk_notifier_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>rate data to pass to the notifier callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct clk_notifier_data {
    struct clk              *clk;
    unsigned long           old_rate;
    unsigned long           new_rate;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">clk</span></code></dt><dd><p>struct clk * being changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_rate</span></code></dt><dd><p>previous rate of this clk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_rate</span></code></dt><dd><p>new rate of this clk</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>For a pre-notifier, old_rate is the clk's rate before this rate
change, and new_rate is what the rate will be in the future.  For a
post-notifier, old_rate and new_rate are both set to the clk's
current rate (this was done to optimize the implementation).</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.clk_bulk_data">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_bulk_data</span></span></span><a class="headerlink" href="#c.clk_bulk_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Data used for bulk clk operations.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct clk_bulk_data {
    const char              *id;
    struct clk              *clk;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clk</span></code></dt><dd><p>struct clk * to store the associated clock</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The CLK APIs provide a series of clk_bulk_() API calls as
a convenience to consumers which require multiple clks.  This
structure is used to manage data for these calls.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_notifier_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_notifier_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_notifier_register" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">notifier_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a clock rate-change notifier callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock whose rate we are interested in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier block with callback function pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ProTip: debugging across notifier chains can be frustrating. Make sure that
your notifier callback function prints a nice big warning in case of
failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_notifier_unregister">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_notifier_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_notifier_unregister" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">notifier_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a clock rate-change notifier callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock whose rate we are no longer interested in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier block which will be unregistered</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_notifier_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_notifier_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.devm_clk_notifier_register" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">notifier_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_notifier_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a managed rate-change notifier callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock whose rate we are interested in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier block with callback function pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EERROR otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_get_accuracy">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_get_accuracy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_get_accuracy" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_accuracy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>obtain the clock accuracy in ppb (parts per billion) for a clock source.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This gets the clock source accuracy expressed in ppb.
A perfect clock returns 0.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_set_phase">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_set_phase</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_phase" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">degrees</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_phase" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>adjust the phase shift of a clock signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock signal source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">degrees</span></code></dt><dd><p>number of degrees the signal is shifted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifts the phase of a clock signal by the specified degrees. Returns 0 on
success, -EERROR otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_get_phase">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_get_phase</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_get_phase" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_phase" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the phase shift of a clock signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock signal source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the phase shift of a clock node in degrees, otherwise returns
-EERROR.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_set_duty_cycle">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_set_duty_cycle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_duty_cycle" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">den</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_duty_cycle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>adjust the duty cycle ratio of a clock signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock signal source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>numerator of the duty cycle ratio to be applied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">den</span></code></dt><dd><p>denominator of the duty cycle ratio to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adjust the duty cycle of a clock signal by the specified ratio. Returns 0 on
success, -EERROR otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_get_scaled_duty_cycle">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_get_scaled_duty_cycle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_get_scaled_duty_cycle" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">scale</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_scaled_duty_cycle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return the duty cycle ratio of a clock signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock signal source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt><dd><p>scaling factor to be applied to represent the ratio as an integer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the duty cycle ratio multiplied by the scale provided, otherwise
returns -EERROR.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_is_match">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_is_match</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_is_match" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if two clk's point to the same hardware clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*p</span></code></dt><dd><p>clk compared against q</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*q</span></code></dt><dd><p>clk compared against p</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the two struct clk pointers both point to the same hardware
clock node. Put differently, returns true if <strong>p</strong> and <strong>q</strong>
share the same <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_core</span></code> object.</p>
<p>Returns false otherwise. Note that two NULL clks are treated as matching.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_rate_exclusive_get">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_rate_exclusive_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_rate_exclusive_get" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_rate_exclusive_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get exclusivity over the rate control of a producer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows drivers to get exclusive control over the rate of a
provider. It prevents any other consumer to execute, even indirectly,
opereation which could alter the rate of the provider or cause glitches</p>
<p>If exlusivity is claimed more than once on clock, even by the same driver,
the rate effectively gets locked as exclusivity can't be preempted.</p>
<p>Must not be called from within atomic context.</p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_rate_exclusive_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_rate_exclusive_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_rate_exclusive_put" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_rate_exclusive_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>release exclusivity over the rate control of a producer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows drivers to release the exclusivity it previously got
from <a class="reference internal" href="#c.clk_rate_exclusive_get" title="clk_rate_exclusive_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_rate_exclusive_get()</span></code></a></p>
<p>The caller must balance the number of <a class="reference internal" href="#c.clk_rate_exclusive_get" title="clk_rate_exclusive_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_rate_exclusive_get()</span></code></a> and
<a class="reference internal" href="#c.clk_rate_exclusive_put" title="clk_rate_exclusive_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_rate_exclusive_put()</span></code></a> calls.</p>
<p>Must not be called from within atomic context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_prepare">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_prepare</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_prepare" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_prepare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>prepare a clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the clock source for use.</p>
<p>Must not be called from within atomic context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_is_enabled_when_prepared">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_is_enabled_when_prepared</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_is_enabled_when_prepared" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_is_enabled_when_prepared" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>indicate if preparing a clock also enables it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if <a class="reference internal" href="#c.clk_prepare" title="clk_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_prepare()</span></code></a> implicitly enables the clock, effectively
making <a class="reference internal" href="#c.clk_enable" title="clk_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_enable()</span></code></a>/<a class="reference internal" href="#c.clk_disable" title="clk_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_disable()</span></code></a> no-ops, false otherwise.</p>
<p>This is of interest mainly to the power management code where actually
disabling the clock also requires unpreparing it to have any material
effect.</p>
<p>Regardless of the value returned here, the caller must always invoke
<a class="reference internal" href="#c.clk_enable" title="clk_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_enable()</span></code></a> or clk_prepare_enable()  and counterparts for usage counts
to be right.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_unprepare">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_unprepare</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_unprepare" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_unprepare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>undo preparation of a clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This undoes a previously prepared clock.  The caller must balance
the number of prepare and unprepare calls.</p>
<p>Must not be called from within atomic context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">clk_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup and obtain a reference to a clock producer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_bulk_get">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_bulk_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_clks</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup and obtain a number of references to clock producer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to get several clk consumers in one
operation. If any of the clk cannot be acquired then any clks
that were obtained will be freed before returning to the caller.</p>
<p>Returns 0 if all clocks specified in clk_bulk_data table are obtained
successfully, or valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.
The implementation uses <strong>dev</strong> and <strong>clk_bulk_data.id</strong> to determine the
clock consumer, and thereby the clock producer.
The clock returned is stored in each <strong>clk_bulk_data.clk</strong> field.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_bulk_get_all">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_bulk_get_all</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get_all" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup and obtain all available references to clock producer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">**clks</span></code></dt><dd><p>pointer to the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to get all clk consumers in one
operation. If any of the clk cannot be acquired then any clks
that were obtained will be freed before returning to the caller.</p>
<p>Returns a positive value for the number of clocks obtained while the
clock references are stored in the clk_bulk_data table in <strong>clks</strong> field.
Returns 0 if there're none and a negative value if something failed.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_bulk_get_optional">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_bulk_get_optional</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_clks</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get_optional" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup and obtain a number of references to clock producer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Behaves the same as <a class="reference internal" href="#c.clk_bulk_get" title="clk_bulk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_bulk_get()</span></code></a> except where there is no clock producer.
In this case, instead of returning -ENOENT, the function returns 0 and
NULL for a clk for which a clock producer could not be determined.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_bulk_get">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_bulk_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_clks</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>managed get multiple clk consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to get several clk
consumers in one operation with management, the clks will
automatically be freed when the device is unbound.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_bulk_get_optional">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_bulk_get_optional</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_clks</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get_optional" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>managed get multiple optional consumer clocks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*clks</span></code></dt><dd><p>pointer to the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Behaves the same as <a class="reference internal" href="#c.devm_clk_bulk_get" title="devm_clk_bulk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_bulk_get()</span></code></a> except where there is no clock
producer.  In this case, instead of returning -ENOENT, the function returns
NULL for given clk. It is assumed all clocks in clk_bulk_data are optional.</p>
<p>Returns 0 if all clocks specified in clk_bulk_data table are obtained
successfully or for any clk there was no clk provider available, otherwise
returns valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.
The implementation uses <strong>dev</strong> and <strong>clk_bulk_data.id</strong> to determine the
clock consumer, and thereby the clock producer.
The clock returned is stored in each <strong>clk_bulk_data.clk</strong> field.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_bulk_get_all">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_bulk_get_all</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get_all" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>managed get multiple clk consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">**clks</span></code></dt><dd><p>pointer to the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a positive value for the number of clocks obtained while the
clock references are stored in the clk_bulk_data table in <strong>clks</strong> field.
Returns 0 if there're none and a negative value if something failed.</p>
<p>This helper function allows drivers to get several clk
consumers in one operation with management, the clks will
automatically be freed when the device is unbound.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup and obtain a managed reference to a clock producer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>a struct clk corresponding to the clock producer, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p><strong>Description</strong></p>
<p>Drivers must assume that the clock source is neither prepared nor
enabled.</p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_get_prepared">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_get_prepared</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get_prepared" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get()</span></code></a> + <a class="reference internal" href="#c.clk_prepare" title="clk_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_prepare()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>a struct clk corresponding to the clock producer, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p><strong>Description</strong></p>
<p>The returned clk (if valid) is prepared. Drivers must however assume
that the clock is not enabled.</p>
<p>The clock will automatically be unprepared and freed when the device
is unbound from the bus.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_get_enabled">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_get_enabled</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get_enabled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get()</span></code></a> + clk_prepare_enable()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>a struct clk corresponding to the clock producer, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p><strong>Description</strong></p>
<p>The returned clk (if valid) is prepared and enabled.</p>
<p>The clock will automatically be disabled, unprepared and freed
when the device is unbound from the bus.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_get_optional">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_get_optional</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get_optional" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup and obtain a managed reference to an optional clock producer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>a struct clk corresponding to the clock producer, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  If no such clk is found, it returns NULL
which serves as a dummy clk.  That's the only difference compared
to <a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get()</span></code></a>.</p>
<p><strong>Description</strong></p>
<p>Drivers must assume that the clock source is neither prepared nor
enabled.</p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_get_optional_prepared">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_get_optional_prepared</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get_optional_prepared" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#c.devm_clk_get_optional" title="devm_clk_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get_optional()</span></code></a> + <a class="reference internal" href="#c.clk_prepare" title="clk_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_prepare()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>a struct clk corresponding to the clock producer, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  If no such clk is found, it returns NULL
which serves as a dummy clk.  That's the only difference compared
to <a class="reference internal" href="#c.devm_clk_get_prepared" title="devm_clk_get_prepared"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get_prepared()</span></code></a>.</p>
<p><strong>Description</strong></p>
<p>The returned clk (if valid) is prepared. Drivers must however
assume that the clock is not enabled.</p>
<p>The clock will automatically be unprepared and freed when the
device is unbound from the bus.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_get_optional_enabled">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_get_optional_enabled</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get_optional_enabled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#c.devm_clk_get_optional" title="devm_clk_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get_optional()</span></code></a> + clk_prepare_enable()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>May sleep.</p>
<p><strong>Return</strong></p>
<p>a struct clk corresponding to the clock producer, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  If no such clk is found, it returns NULL
which serves as a dummy clk.  That's the only difference compared
to <a class="reference internal" href="#c.devm_clk_get_enabled" title="devm_clk_get_enabled"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get_enabled()</span></code></a>.</p>
<p><strong>Description</strong></p>
<p>The returned clk (if valid) is prepared and enabled.</p>
<p>The clock will automatically be disabled, unprepared and freed
when the device is unbound from the bus.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_get_clk_from_child">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">devm_get_clk_from_child</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">device_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">np</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">con_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_clk_from_child" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup and obtain a managed reference to a clock producer from child node.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>pointer to clock consumer node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function parses the clocks, and uses them to look up the
struct clk from the registered list of clock providers by using
<strong>np</strong> and <strong>con_id</strong></p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_enable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_enable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_enable" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>inform the system when the clock source should be running.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the clock can not be enabled/disabled, this should return success.</p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_bulk_enable">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_bulk_enable</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_clks</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_enable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>inform the system when the set of clks should be running.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_disable">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_disable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_disable" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>inform the system when the clock source is no longer required.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a clock source is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the clock source is shared between
multiple drivers, <a class="reference internal" href="#c.clk_enable" title="clk_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_disable" title="clk_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_bulk_disable">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_bulk_disable</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_clks</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_disable" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>inform the system when the set of clks is no longer required.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a set of clks is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the set of clks is shared between
multiple drivers, <a class="reference internal" href="#c.clk_bulk_enable" title="clk_bulk_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_bulk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_bulk_disable" title="clk_bulk_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_bulk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_get_rate">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_get_rate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_get_rate" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_rate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>obtain the current clock rate (in Hz) for a clock source. This is only valid once the clock source has been enabled.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_put" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>&quot;free&quot; the clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p><strong>Description</strong></p>
<p>clk_put should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_bulk_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_bulk_put</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_clks</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>&quot;free&quot; the clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_bulk_enable calls made on this
clock source are balanced by clk_bulk_disable calls prior to calling
this function.</p>
<p><strong>Description</strong></p>
<p>clk_bulk_put should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_bulk_put_all">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_bulk_put_all</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_clks</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data"><span class="n"><span class="pre">clk_bulk_data</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_put_all" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>&quot;free&quot; all the clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt><dd><p>the number of clk_bulk_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*clks</span></code></dt><dd><p>the clk_bulk_data table of consumer</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_bulk_enable calls made on this
clock source are balanced by clk_bulk_disable calls prior to calling
this function.</p>
<p><strong>Description</strong></p>
<p>clk_bulk_put_all should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.devm_clk_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">devm_clk_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.devm_clk_put" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>&quot;free&quot; a managed clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device used to acquire the clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source acquired with <a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_clk_get()</span></code></a></p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p><strong>Description</strong></p>
<p>clk_put should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_round_rate">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_round_rate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_round_rate" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">rate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_round_rate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>adjust a rate to the exact rate a clock can provide</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired clock rate in Hz</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This answers the question &quot;if I were to pass <strong>rate</strong> to <a class="reference internal" href="#c.clk_set_rate" title="clk_set_rate"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_set_rate()</span></code></a>,
what clock rate would I end up with?&quot; without changing the hardware
in any way.  In other words:</p>
<blockquote>
<div><p>rate = clk_round_rate(clk, r);</p>
</div></blockquote>
<p>and:</p>
<blockquote>
<div><p>clk_set_rate(clk, r);
rate = clk_get_rate(clk);</p>
</div></blockquote>
<p>are equivalent except the former does not modify the clock hardware
in any way.</p>
<p>Returns rounded clock rate in Hz, or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_set_rate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_set_rate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_rate" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">rate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the clock rate for a clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired clock rate in Hz</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updating the rate starts at the top-most affected clock and then
walks the tree down to the bottom-most clock that needs updating.</p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_set_rate_exclusive">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_set_rate_exclusive</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_rate_exclusive" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">rate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate_exclusive" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the clock rate and claim exclusivity over clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired clock rate in Hz</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to atomically set the rate of a producer
and claim exclusivity over the rate control of the producer.</p>
<p>It is essentially a combination of <a class="reference internal" href="#c.clk_set_rate" title="clk_set_rate"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_set_rate()</span></code></a> and
clk_rate_exclusite_get(). Caller must balance this call with a call to
<a class="reference internal" href="#c.clk_rate_exclusive_put" title="clk_rate_exclusive_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_rate_exclusive_put()</span></code></a></p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_has_parent">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_has_parent</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_has_parent" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_has_parent" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_has_parent" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>check if a clock is a possible parent for another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*parent</span></code></dt><dd><p>parent clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers that need to check that a clock can be
the parent of another without actually changing the parent.</p>
<p>Returns true if <strong>parent</strong> is a possible parent for <strong>clk</strong>, false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_set_rate_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_set_rate_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_rate_range" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set a rate range for a clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>desired minimum clock rate in Hz, inclusive</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>desired maximum clock rate in Hz, inclusive</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_set_min_rate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_set_min_rate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_min_rate" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">rate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_min_rate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set a minimum clock rate for a clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired minimum clock rate in Hz, inclusive</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_set_max_rate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_set_max_rate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_max_rate" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">rate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_max_rate" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set a maximum clock rate for a clock source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt><dd><p>desired maximum clock rate in Hz, inclusive</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_set_parent">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_set_parent</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_parent" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_set_parent" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_parent" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set the parent clock source for this clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*parent</span></code></dt><dd><p>parent clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_get_parent">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_get_parent" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">clk_get_parent</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_get_parent" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_parent" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get the parent clock source for this clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns struct clk corresponding to parent clock source, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_get_sys">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">clk_get_sys</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev_id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">con_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_sys" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get a clock based upon the device name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*dev_id</span></code></dt><dd><p>device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>connection ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <a class="reference internal" href="#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> condition containing errno.  The implementation
uses <strong>dev_id</strong> and <strong>con_id</strong> to determine the clock consumer, and
thereby the clock producer. In contrast to <a class="reference internal" href="#c.clk_get" title="clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_get()</span></code></a> this function
takes the device name instead of the device itself for identification.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get_sys should not be called from within interrupt context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_save_context">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_save_context</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_save_context" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>save clock context for poweroff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Saves the context of the clock register for powerstates in which the
contents of the registers will be lost. Occurs deep within the suspend
code so locking is not necessary.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_restore_context">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_restore_context</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_restore_context" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>restore clock context after poweroff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This occurs with all clocks enabled. Occurs deep within the resume code
so locking is not necessary.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_drop_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clk_drop_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.clk_drop_range" title="clk"><span class="n"><span class="pre">clk</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">clk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_drop_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reset any range set on that clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*clk</span></code></dt><dd><p>clock source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clk_get_optional">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">clk</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">clk_get_optional</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_optional" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>lookup and obtain a reference to an optional clock producer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for clock &quot;consumer&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>clock consumer ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Behaves the same as <a class="reference internal" href="#c.clk_get" title="clk_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">clk_get()</span></code></a> except where there is no clock producer. In
this case, instead of returning -ENOENT, the function returns NULL.</p>
</div>
</section>
<section id="synchronization-primitives">
<h2>Synchronization Primitives<a class="headerlink" href="#synchronization-primitives" title="Permalink to this heading">¶</a></h2>
<section id="read-copy-update-rcu">
<h3>Read-Copy Update (RCU)<a class="headerlink" href="#read-copy-update-rcu" title="Permalink to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.same_state_synchronize_rcu">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">same_state_synchronize_rcu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">oldstate1</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">oldstate2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.same_state_synchronize_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Are two old-state values identical?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate1</span></code></dt><dd><p>First old-state value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate2</span></code></dt><dd><p>Second old-state value.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The two old-state values must have been obtained from either
<a class="reference internal" href="#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu" title="start_poll_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu()</span></code></a>, or
<a class="reference internal" href="#c.get_completed_synchronize_rcu" title="get_completed_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_completed_synchronize_rcu()</span></code></a>.  Returns <strong>true</strong> if the two values are
identical and <strong>false</strong> otherwise.  This allows structures whose lifetimes
are tracked by old-state values to push these values to a list header,
allowing those structures to be slightly smaller.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_trace_implies_rcu_gp">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_trace_implies_rcu_gp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_trace_implies_rcu_gp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>does an RCU Tasks Trace grace period imply an RCU grace period?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>As an accident of implementation, an RCU Tasks Trace grace period also
acts as an RCU grace period.  However, this could change at any time.
Code relying on this accident must call this function to verify that
this accident is still happening.</p>
<p>You have been warned!</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.cond_resched_tasks_rcu_qs">
<span class="sig-name descname"><span class="n"><span class="pre">cond_resched_tasks_rcu_qs</span></span></span><a class="headerlink" href="#c.cond_resched_tasks_rcu_qs" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">cond_resched_tasks_rcu_qs</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>Report potential quiescent states to RCU</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro resembles cond_resched(), except that it is defined to
report potential quiescent states to RCU-tasks even if the cond_resched()
machinery were to be shut off, as some advocate for PREEMPTION kernels.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.RCU_LOCKDEP_WARN">
<span class="sig-name descname"><span class="n"><span class="pre">RCU_LOCKDEP_WARN</span></span></span><a class="headerlink" href="#c.RCU_LOCKDEP_WARN" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">RCU_LOCKDEP_WARN</span> <span class="pre">(c,</span> <span class="pre">s)</span></code></p>
<blockquote>
<div><p>emit lockdep splat if specified condition is met</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>condition to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt><dd><p>informative message</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This checks debug_lockdep_rcu_enabled() before checking (c) to
prevent early boot splats due to lockdep not yet being initialized,
and rechecks it after checking (c) to prevent false-positive splats
due to races with lockdep being disabled.  See commit 3066820034b5dd
(&quot;rcu: Reject <a class="reference internal" href="#c.RCU_LOCKDEP_WARN" title="RCU_LOCKDEP_WARN"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_LOCKDEP_WARN()</span></code></a> false positives&quot;) for more detail.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.unrcu_pointer">
<span class="sig-name descname"><span class="n"><span class="pre">unrcu_pointer</span></span></span><a class="headerlink" href="#c.unrcu_pointer" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">unrcu_pointer</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>mark a pointer as not being RCU protected</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>pointer needing to lose its __rcu property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts <strong>p</strong> from an __rcu pointer to a __kernel pointer.
This allows an __rcu pointer to be used with xchg() and friends.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.RCU_INITIALIZER">
<span class="sig-name descname"><span class="n"><span class="pre">RCU_INITIALIZER</span></span></span><a class="headerlink" href="#c.RCU_INITIALIZER" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">RCU_INITIALIZER</span> <span class="pre">(v)</span></code></p>
<blockquote>
<div><p>statically initialize an RCU-protected global variable</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>The value to statically initialize with.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_assign_pointer">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_assign_pointer</span></span></span><a class="headerlink" href="#c.rcu_assign_pointer" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_assign_pointer</span> <span class="pre">(p,</span> <span class="pre">v)</span></code></p>
<blockquote>
<div><p>assign to RCU-protected pointer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>pointer to assign to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>value to assign (publish)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assigns the specified value to the specified RCU-protected
pointer, ensuring that any concurrent RCU readers will see
any prior initialization.</p>
<p>Inserts memory barriers on architectures that require them
(which is most of them), and also prevents the compiler from
reordering the code that initializes the structure after the pointer
assignment.  More importantly, this call documents which pointers
will be dereferenced by RCU read-side code.</p>
<p>In some special cases, you may use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> instead
of <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a>.  <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> is a bit faster due
to the fact that it does not constrain either the CPU or the compiler.
That said, using <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> when you should have used
<a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> is a very bad thing that results in
impossible-to-diagnose memory corruption.  So please be careful.
See the <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> comment header for details.</p>
<p>Note that <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> evaluates each of its arguments only
once, appearances notwithstanding.  One of the &quot;extra&quot; evaluations
is in typeof() and the other visible only to sparse (__CHECKER__),
neither of which actually execute the argument.  As with most cpp
macros, this execute-arguments-only-once property is important, so
please be careful when making changes to <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> and the
other macros that it invokes.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_replace_pointer">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_replace_pointer</span></span></span><a class="headerlink" href="#c.rcu_replace_pointer" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_replace_pointer</span> <span class="pre">(rcu_ptr,</span> <span class="pre">ptr,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>replace an RCU pointer, returning its old value</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu_ptr</span></code></dt><dd><p>RCU pointer, whose old value is returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>regular pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>the lockdep conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a replacement, where <strong>rcu_ptr</strong> is an RCU-annotated
pointer and <strong>c</strong> is the lockdep argument that is passed to the
<a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_protected()</span></code></a> call used to read that pointer.  The old
value of <strong>rcu_ptr</strong> is returned, and <strong>rcu_ptr</strong> is set to <strong>ptr</strong>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_access_pointer">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_access_pointer</span></span></span><a class="headerlink" href="#c.rcu_access_pointer" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_access_pointer</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>fetch RCU pointer with no dereferencing</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the value of the specified RCU-protected pointer, but omit the
lockdep checks for being in an RCU read-side critical section.  This is
useful when the value of this pointer is accessed, but the pointer is
not dereferenced, for example, when testing an RCU-protected pointer
against NULL.  Although <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a> may also be used in cases
where update-side locks prevent the value of the pointer from changing,
you should instead use <a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_protected()</span></code></a> for this use case.
Within an RCU read-side critical section, there is little reason to
use <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a>.</p>
<p>It is usually best to test the <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a> return value
directly in order to avoid accidental dereferences being introduced
by later inattentive changes.  In other words, assigning the
<a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a> return value to a local variable results in an
accident waiting to happen.</p>
<p>It is also permissible to use <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a> when read-side
access to the pointer was removed at least one grace period ago, as is
the case in the context of the RCU callback that is freeing up the data,
or after a <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> returns.  This can be useful when tearing
down multi-linked structures after a grace period has elapsed.  However,
<a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_protected()</span></code></a> is normally preferred for this use case.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_dereference_check">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_dereference_check</span></span></span><a class="headerlink" href="#c.rcu_dereference_check" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_dereference_check</span> <span class="pre">(p,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>rcu_dereference with debug checking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>The conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do an <a class="reference internal" href="#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a>, but check that the conditions under which the
dereference will take place are correct.  Typically the conditions
indicate the various locking conditions that should be held at that
point.  The check should return true if the conditions are satisfied.
An implicit check for being in an RCU read-side critical section
(<a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>) is included.</p>
<p>For example:</p>
<blockquote>
<div><p>bar = rcu_dereference_check(foo-&gt;bar, lockdep_is_held(<code class="xref c c-type docutils literal notranslate"><span class="pre">foo-&gt;lock</span></code>));</p>
</div></blockquote>
<p>could be used to indicate to lockdep that foo-&gt;bar may only be dereferenced
if either <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> is held, or that the lock required to replace
the bar struct at foo-&gt;bar is held.</p>
<p>Note that the list of conditions may also include indications of when a lock
need not be held, for example during initialisation or destruction of the
target struct:</p>
<blockquote>
<div><dl class="simple">
<dt>bar = rcu_dereference_check(foo-&gt;bar, lockdep_is_held(<code class="xref c c-type docutils literal notranslate"><span class="pre">foo-&gt;lock</span></code>) ||</dt><dd><p>atomic_read(<code class="xref c c-type docutils literal notranslate"><span class="pre">foo-&gt;usage</span></code>) == 0);</p>
</dd>
</dl>
</div></blockquote>
<p>Inserts memory barriers on architectures that require them
(currently only the Alpha), prevents the compiler from refetching
(and from merging fetches), and, more importantly, documents exactly
which pointers are protected by RCU and checks that the pointer is
annotated as __rcu.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_dereference_bh_check">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_dereference_bh_check</span></span></span><a class="headerlink" href="#c.rcu_dereference_bh_check" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_dereference_bh_check</span> <span class="pre">(p,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>rcu_dereference_bh with debug checking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>The conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the RCU-bh counterpart to <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a>.  However,
please note that starting in v5.0 kernels, vanilla RCU grace periods
wait for local_bh_disable() regions of code in addition to regions of
code demarked by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>.  This means
that <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, call_rcu, and friends all take not only
<a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> but also <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> into account.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_dereference_sched_check">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_dereference_sched_check</span></span></span><a class="headerlink" href="#c.rcu_dereference_sched_check" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_dereference_sched_check</span> <span class="pre">(p,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>rcu_dereference_sched with debug checking</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>The conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the RCU-sched counterpart to <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a>.
However, please note that starting in v5.0 kernels, vanilla RCU grace
periods wait for preempt_disable() regions of code in addition to
regions of code demarked by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>.
This means that <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, call_rcu, and friends all take not
only <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> but also <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a> into account.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_dereference_protected">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_dereference_protected</span></span></span><a class="headerlink" href="#c.rcu_dereference_protected" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_dereference_protected</span> <span class="pre">(p,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>fetch RCU pointer when updates prevented</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>The conditions under which the dereference will take place</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the value of the specified RCU-protected pointer, but omit
the READ_ONCE().  This is useful in cases where update-side locks
prevent the value of the pointer from changing.  Please note that this
primitive does <em>not</em> prevent the compiler from repeating this reference
or combining it with other references, so it should not be used without
protection of appropriate locks.</p>
<p>This function is only for update-side use.  Using this function
when protected only by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> will result in infrequent
but very ugly failures.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_dereference">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_dereference</span></span></span><a class="headerlink" href="#c.rcu_dereference" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_dereference</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>fetch RCU-protected pointer for dereferencing</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simple wrapper around <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_dereference_bh">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_dereference_bh</span></span></span><a class="headerlink" href="#c.rcu_dereference_bh" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_dereference_bh</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>fetch an RCU-bh-protected pointer for dereferencing</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_dereference_sched">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_dereference_sched</span></span></span><a class="headerlink" href="#c.rcu_dereference_sched" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_dereference_sched</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>fetch RCU-sched-protected pointer for dereferencing</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to read, prior to dereferencing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.rcu_pointer_handoff">
<span class="sig-name descname"><span class="n"><span class="pre">rcu_pointer_handoff</span></span></span><a class="headerlink" href="#c.rcu_pointer_handoff" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">rcu_pointer_handoff</span> <span class="pre">(p)</span></code></p>
<blockquote>
<div><p>Hand off a pointer from RCU to other mechanism</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to hand off</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is simply an identity function, but it documents where a pointer
is handed off from RCU to some other synchronization mechanism, for
example, reference counting or locking.  In C11, it would map to
kill_dependency().  It could be used as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>rcu_read_lock();
p = rcu_dereference(gp);
long_lived = is_long_lived(p);
if (long_lived) {
        if (!atomic_inc_not_zero(p-&gt;refcnt))
                long_lived = false;
        else
                p = rcu_pointer_handoff(p);
}
rcu_read_unlock();
</pre></div>
</div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_lock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_lock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark the beginning of an RCU read-side critical section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is invoked on one CPU while other CPUs
are within RCU read-side critical sections, then the
<a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is guaranteed to block until after all the other
CPUs exit their critical sections.  Similarly, if <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> is invoked
on one CPU while other CPUs are within RCU read-side critical
sections, invocation of the corresponding RCU callback is deferred
until after the all the other CPUs exit their critical sections.</p>
<p>In v5.0 and later kernels, <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> and <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> also
wait for regions of code with preemption disabled, including regions of
code with interrupts or softirqs disabled.  In pre-v5.0 kernels, which
define synchronize_sched(), only code enclosed within <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>
and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> are guaranteed to be waited for.</p>
<p>Note, however, that RCU callbacks are permitted to run concurrently
with new RCU read-side critical sections.  One way that this can happen
is via the following sequence of events: (1) CPU 0 enters an RCU
read-side critical section, (2) CPU 1 invokes <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> to register
an RCU callback, (3) CPU 0 exits the RCU read-side critical section,
(4) CPU 2 enters a RCU read-side critical section, (5) the RCU
callback is invoked.  This is legal, because the RCU read-side critical
section that was running concurrently with the <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> (and which
therefore might be referencing something that the corresponding RCU
callback would free up) has completed before the corresponding
RCU callback is invoked.</p>
<p>RCU read-side critical sections may be nested.  Any deferred actions
will be deferred until the outermost RCU read-side critical section
completes.</p>
<p>You can avoid reading and understanding the next paragraph by
following this rule: don't put anything in an <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> RCU
read-side critical section that would block in a !PREEMPTION kernel.
But if you want the full story, read on!</p>
<p>In non-preemptible RCU implementations (pure TREE_RCU and TINY_RCU),
it is illegal to block while in an RCU read-side critical section.
In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPTION
kernel builds, RCU read-side critical sections may be preempted,
but explicit blocking is illegal.  Finally, in preemptible RCU
implementations in real-time (with -rt patchset) kernel builds, RCU
read-side critical sections may be preempted and they may also block, but
only when acquiring spinlocks that are subject to priority inheritance.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_unlock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>marks the end of an RCU read-side critical section.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In almost all situations, <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> is immune from deadlock.
In recent kernels that have consolidated synchronize_sched() and
synchronize_rcu_bh() into <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, this deadlock immunity
also extends to the scheduler's runqueue and priority-inheritance
spinlocks, courtesy of the quiescent-state deferral that is carried
out when <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> is invoked with interrupts disabled.</p>
<p>See <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_lock_bh">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_lock_bh</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark the beginning of an RCU-bh critical section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>, but also disables softirqs.
Note that anything else that disables softirqs can also serve as an RCU
read-side critical section.  However, please note that this equivalence
applies only to v5.0 and later.  Before v5.0, <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and
<a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> were unrelated.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> and the matching <a class="reference internal" href="#c.rcu_read_unlock_bh" title="rcu_read_unlock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_bh()</span></code></a>
must occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.rcu_read_unlock_bh" title="rcu_read_unlock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_bh()</span></code></a> from one task if the matching <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a>
was invoked from some other task.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_unlock_bh">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_unlock_bh</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_unlock_bh" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>marks the end of a softirq-only RCU critical section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_lock_sched">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_lock_sched</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_sched" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark the beginning of a RCU-sched critical section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>, but also disables preemption.
Read-side critical sections can also be introduced by anything else that
disables preemption, including local_irq_disable() and friends.  However,
please note that the equivalence to <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> applies only to
v5.0 and later.  Before v5.0, <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a>
were unrelated.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a> and the matching <a class="reference internal" href="#c.rcu_read_unlock_sched" title="rcu_read_unlock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_sched()</span></code></a>
must occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.rcu_read_unlock_sched" title="rcu_read_unlock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_sched()</span></code></a> from process context if the matching
<a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a> was invoked from an NMI handler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_unlock_sched">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_unlock_sched</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_unlock_sched" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>marks the end of a RCU-classic critical section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a> for more information.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.RCU_INIT_POINTER">
<span class="sig-name descname"><span class="n"><span class="pre">RCU_INIT_POINTER</span></span></span><a class="headerlink" href="#c.RCU_INIT_POINTER" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">RCU_INIT_POINTER</span> <span class="pre">(p,</span> <span class="pre">v)</span></code></p>
<blockquote>
<div><p>initialize an RCU protected pointer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to be initialized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>The value to initialized the pointer to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an RCU-protected pointer in special cases where readers
do not need ordering constraints on the CPU or the compiler.  These
special cases are:</p>
<ol class="arabic simple">
<li><p>This use of <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> is NULLing out the pointer <em>or</em></p></li>
<li><p>The caller has taken whatever steps are required to prevent
RCU readers from concurrently accessing this pointer <em>or</em></p></li>
<li><p>The referenced data structure has already been exposed to
readers either at compile time or via <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> <em>and</em></p>
<ol class="loweralpha simple">
<li><p>You have not made <em>any</em> reader-visible changes to
this structure since then <em>or</em></p></li>
<li><p>It is OK for readers accessing this structure from its
new location to see the old state of the structure.  (For
example, the changes were to statistical counters or to
other state where exact synchronization is not required.)</p></li>
</ol>
</li>
</ol>
<p>Failure to follow these rules governing use of <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> will
result in impossible-to-diagnose memory corruption.  As in the structures
will look OK in crash dumps, but any concurrent RCU readers might
see pre-initialized values of the referenced data structure.  So
please be very careful how you use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a>!!!</p>
<p>If you are creating an RCU-protected linked structure that is accessed
by a single external-to-structure RCU-protected pointer, then you may
use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> to initialize the internal RCU-protected
pointers, but you must use <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> to initialize the
external-to-structure pointer <em>after</em> you have completely initialized
the reader-accessible portions of the linked structure.</p>
<p>Note that unlike <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a>, <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal notranslate"><span class="pre">RCU_INIT_POINTER()</span></code></a> provides no
ordering guarantees for either the CPU or the compiler.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.RCU_POINTER_INITIALIZER">
<span class="sig-name descname"><span class="n"><span class="pre">RCU_POINTER_INITIALIZER</span></span></span><a class="headerlink" href="#c.RCU_POINTER_INITIALIZER" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">RCU_POINTER_INITIALIZER</span> <span class="pre">(p,</span> <span class="pre">v)</span></code></p>
<blockquote>
<div><p>statically initialize an RCU protected pointer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>The pointer to be initialized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v</span></code></dt><dd><p>The value to initialized the pointer to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>GCC-style initialization for an RCU-protected pointer in a structure field.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfree_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">kfree_rcu</span></span></span><a class="headerlink" href="#c.kfree_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfree_rcu</span> <span class="pre">(ptr,</span> <span class="pre">rhf)</span></code></p>
<blockquote>
<div><p>kfree an object after a grace period.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>pointer to kfree for double-argument invocations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rhf</span></code></dt><dd><p>the name of the struct rcu_head within the type of <strong>ptr</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many rcu callbacks functions just call <a class="reference internal" href="mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> on the base structure.
These functions are trivial, but their size adds up, and furthermore
when they are used in a kernel module, that module must invoke the
high-latency <a class="reference internal" href="#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> function at module-unload time.</p>
<p>The <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> function handles this issue.  Rather than encoding a
function address in the embedded rcu_head structure, <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> instead
encodes the offset of the rcu_head structure within the base structure.
Because the functions are not allowed in the low-order 4096 bytes of
kernel virtual memory, offsets up to 4095 bytes can be accommodated.
If the offset is larger than 4095 bytes, a compile-time error will
be generated in kvfree_rcu_arg_2(). If this error is triggered, you can
either fall back to use of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> or rearrange the structure to
position the rcu_head structure into the first 4096 bytes.</p>
<p>The object to be freed can be allocated either by <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or
<a class="reference internal" href="mm-api.html#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_alloc()</span></code></a>.</p>
<p>Note that the allowable offset might decrease in the future.</p>
<p>The BUILD_BUG_ON check must not involve any function calls, hence the
checks are done in macros here.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.kfree_rcu_mightsleep">
<span class="sig-name descname"><span class="n"><span class="pre">kfree_rcu_mightsleep</span></span></span><a class="headerlink" href="#c.kfree_rcu_mightsleep" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">kfree_rcu_mightsleep</span> <span class="pre">(ptr)</span></code></p>
<blockquote>
<div><p>kfree an object after a grace period.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>pointer to kfree for single-argument invocations.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When it comes to head-less variant, only one argument
is passed and that is just a pointer which has to be
freed after a grace period. Therefore the semantic is</p>
<blockquote>
<div><p>kfree_rcu_mightsleep(ptr);</p>
</div></blockquote>
<p>where <strong>ptr</strong> is the pointer to be freed by <a class="reference internal" href="mm-api.html#c.kvfree" title="kvfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kvfree()</span></code></a>.</p>
<p>Please note, head-less way of freeing is permitted to
use from a context that has to follow <a class="reference internal" href="../driver-api/basics.html#c.might_sleep" title="might_sleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">might_sleep()</span></code></a>
annotation. Otherwise, please switch and embed the
rcu_head structure within the type of <strong>ptr</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_head_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_head_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rhp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_head_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize rcu_head for <a class="reference internal" href="#c.rcu_head_after_call_rcu" title="rcu_head_after_call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_after_call_rcu()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*rhp</span></code></dt><dd><p>The rcu_head structure to initialize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you intend to invoke <a class="reference internal" href="#c.rcu_head_after_call_rcu" title="rcu_head_after_call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_after_call_rcu()</span></code></a> to test whether a
given rcu_head structure has already been passed to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, then
you must also invoke this <a class="reference internal" href="#c.rcu_head_init" title="rcu_head_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_init()</span></code></a> function on it just after
allocating that structure.  Calls to this function must not race with
calls to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, <a class="reference internal" href="#c.rcu_head_after_call_rcu" title="rcu_head_after_call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_after_call_rcu()</span></code></a>, or callback invocation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_head_after_call_rcu">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_head_after_call_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rhp</span></span>, <span class="n"><span class="pre">rcu_callback_t</span></span><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_head_after_call_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Has this rcu_head been passed to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*rhp</span></code></dt><dd><p>The rcu_head structure to test.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">f</span></code></dt><dd><p>The function passed to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> along with <strong>rhp</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <strong>true</strong> if the <strong>rhp</strong> has been passed to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> with <strong>func</strong>,
and <strong>false</strong> otherwise.  Emits a warning in any other case, including
the case where <strong>rhp</strong> has already been invoked after a grace period.
Calls to this function must not race with callback invocation.  One way
to avoid such races is to enclose the call to <a class="reference internal" href="#c.rcu_head_after_call_rcu" title="rcu_head_after_call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_head_after_call_rcu()</span></code></a>
in an RCU read-side critical section that includes a read-side fetch
of the pointer to the structure containing <strong>rhp</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_is_cpu_rrupt_from_idle">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_is_cpu_rrupt_from_idle</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_cpu_rrupt_from_idle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>see if 'interrupted' from idle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the current CPU is idle and running at a first-level (not nested)
interrupt, or directly, from idle, return true.</p>
<p>The caller must have at least disabled IRQs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_irq_exit_check_preempt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_irq_exit_check_preempt</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_irq_exit_check_preempt" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Validate that scheduling is possible</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__rcu_irq_enter_check_tick">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__rcu_irq_enter_check_tick</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__rcu_irq_enter_check_tick" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable scheduler tick on CPU if RCU needs it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The scheduler tick is not normally enabled when CPUs enter the kernel
from nohz_full userspace execution.  After all, nohz_full userspace
execution is an RCU quiescent state and the time executing in the kernel
is quite short.  Except of course when it isn't.  And it is not hard to
cause a large system to spend tens of seconds or even minutes looping
in the kernel, which can cause a number of problems, include RCU CPU
stall warnings.</p>
<p>Therefore, if a nohz_full CPU fails to report a quiescent state
in a timely manner, the RCU grace-period kthread sets that CPU's
-&gt;rcu_urgent_qs flag with the expectation that the next interrupt or
exception will invoke this function, which will turn on the scheduler
tick, which will enable RCU to detect that CPU's quiescent states,
for example, due to cond_resched() calls in CONFIG_PREEMPT=n kernels.
The tick will be disabled once a quiescent state is reported for
this CPU.</p>
<p>Of course, in carefully tuned systems, there might never be an
interrupt or exception.  In that case, the RCU grace-period kthread
will eventually cause one to happen.  However, in less carefully
controlled environments, this function allows RCU to get what it
needs without creating otherwise useless interruptions.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_is_watching">
<span class="pre">notrace</span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_is_watching</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_watching" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>RCU read-side critical sections permitted on current CPU?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return <strong>true</strong> if RCU is watching the running CPU and <strong>false</strong> otherwise.
An <strong>true</strong> return means that this CPU can safely enter RCU read-side
critical sections.</p>
<p>Although calls to <a class="reference internal" href="#c.rcu_is_watching" title="rcu_is_watching"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_is_watching()</span></code></a> from most parts of the kernel
will return <strong>true</strong>, there are important exceptions.  For example, if the
current CPU is deep within its idle loop, in kernel entry/exit code,
or offline, <a class="reference internal" href="#c.rcu_is_watching" title="rcu_is_watching"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_is_watching()</span></code></a> will return <strong>false</strong>.</p>
<p>Make notrace because it can be called by the internal functions of
ftrace, and making this notrace removes unnecessary recursion calls.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.call_rcu_hurry">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">call_rcu_hurry</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="n"><span class="pre">rcu_callback_t</span></span><span class="w"> </span><span class="n"><span class="pre">func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_hurry" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue RCU callback for invocation after grace period, and flush all lazy callbacks (including the new one) to the main -&gt;cblist while doing so.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*head</span></code></dt><dd><p>structure to be used for queueing the RCU updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>actual callback function to be invoked after the grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all pre-existing RCU read-side
critical sections have completed.</p>
<p>Use this API instead of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> if you don't want the callback to be
invoked after very long periods of time, which can happen on systems without
memory pressure and on systems which are lightly loaded or mostly idle.
This function will cause callbacks to be invoked sooner than later at the
expense of extra power. Other than that, this function is identical to, and
reuses <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>'s logic. Refer to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> for more details about memory
ordering and other functionality.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.call_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">call_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="n"><span class="pre">rcu_callback_t</span></span><span class="w"> </span><span class="n"><span class="pre">func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue an RCU callback for invocation after a grace period. By default the callbacks are 'lazy' and are kept hidden from the main -&gt;cblist to prevent starting of grace periods too soon. If you desire grace periods to start very soon, use <a class="reference internal" href="#c.call_rcu_hurry" title="call_rcu_hurry"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_hurry()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*head</span></code></dt><dd><p>structure to be used for queueing the RCU updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>actual callback function to be invoked after the grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all pre-existing RCU read-side
critical sections have completed.  However, the callback function
might well execute concurrently with RCU read-side critical sections
that started after <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> was invoked.</p>
<p>RCU read-side critical sections are delimited by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>
and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, and may be nested.  In addition, but only in
v5.0 and later, regions of code across which interrupts, preemption,
or softirqs have been disabled also serve as RCU read-side critical
sections.  This includes hardware interrupt handlers, softirq handlers,
and NMI handlers.</p>
<p>Note that all CPUs must agree that the grace period extended beyond
all pre-existing RCU read-side critical section.  On systems with more
than one CPU, this means that when &quot;func()&quot; is invoked, each CPU is
guaranteed to have executed a full memory barrier since the end of its
last RCU read-side critical section whose beginning preceded the call
to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>.  It also means that each CPU executing an RCU read-side
critical section that continues beyond the start of &quot;func()&quot; must have
executed a memory barrier after the <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> but before the beginning
of that RCU read-side critical section.  Note that these guarantees
include CPUs that are offline, idle, or executing in user mode, as
well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> and CPU B invoked the
resulting RCU callback function &quot;func()&quot;, then both CPU A and CPU B are
guaranteed to execute a full memory barrier during the time interval
between the call to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> and the invocation of &quot;func()&quot; -- even
if CPU A and CPU B are the same CPU (but again only if the system has
more than one CPU).</p>
<p>Implementation of these memory-ordering guarantees is described here:
<a class="reference internal" href="../RCU/Design/Memory-Ordering/Tree-RCU-Memory-Ordering.html"><span class="doc">A Tour Through TREE_RCU's Grace-Period Memory Ordering</span></a>.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.kvfree_rcu_bulk_data">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kvfree_rcu_bulk_data</span></span></span><a class="headerlink" href="#c.kvfree_rcu_bulk_data" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>single block to store kvfree_rcu() pointers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvfree_rcu_bulk_data {
    struct list_head list;
    struct rcu_gp_oldstate gp_snap;
    unsigned long nr_records;
    void *records[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>List node. All blocks are linked between each other</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gp_snap</span></code></dt><dd><p>Snapshot of RCU state for objects placed to this bulk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_records</span></code></dt><dd><p>Number of active pointers in the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">records</span></code></dt><dd><p>Array of the kvfree_rcu() pointers</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.kfree_rcu_cpu_work">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree_rcu_cpu_work</span></span></span><a class="headerlink" href="#c.kfree_rcu_cpu_work" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>single batch of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> requests</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kfree_rcu_cpu_work {
    struct rcu_work rcu_work;
    struct rcu_head *head_free;
    struct rcu_gp_oldstate head_free_gp_snap;
    struct list_head bulk_head_free[FREE_N_CHANNELS];
    struct kfree_rcu_cpu *krcp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu_work</span></code></dt><dd><p>Let <a class="reference internal" href="workqueue.html#c.queue_rcu_work" title="queue_rcu_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_rcu_work()</span></code></a> invoke workqueue handler after grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_free</span></code></dt><dd><p>List of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> objects waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_free_gp_snap</span></code></dt><dd><p>Grace-period snapshot to check for attempted premature frees.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bulk_head_free</span></code></dt><dd><p>Bulk-List of kvfree_rcu() objects waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">krcp</span></code></dt><dd><p>Pointer to <strong>kfree_rcu_cpu</strong> structure</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.kfree_rcu_cpu">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">kfree_rcu_cpu</span></span></span><a class="headerlink" href="#c.kfree_rcu_cpu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>batch up <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> requests for RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kfree_rcu_cpu {
    struct rcu_head *head;
    unsigned long head_gp_snap;
    atomic_t head_count;
    struct list_head bulk_head[FREE_N_CHANNELS];
    atomic_t bulk_count[FREE_N_CHANNELS];
    struct kfree_rcu_cpu_work krw_arr[KFREE_N_BATCHES];
    raw_spinlock_t lock;
    struct delayed_work monitor_work;
    bool initialized;
    struct delayed_work page_cache_work;
    atomic_t backoff_page_cache_fill;
    atomic_t work_in_progress;
    struct hrtimer hrtimer;
    struct llist_head bkvcache;
    int nr_bkv_objs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>List of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> objects not yet waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_gp_snap</span></code></dt><dd><p>Snapshot of RCU state for objects placed to &quot;<strong>head</strong>&quot;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_count</span></code></dt><dd><p>Number of objects in rcu_head singular list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bulk_head</span></code></dt><dd><p>Bulk-List of kvfree_rcu() objects not yet waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bulk_count</span></code></dt><dd><p>Number of objects in bulk-list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">krw_arr</span></code></dt><dd><p>Array of batches of <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> objects waiting for a grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Synchronize access to this structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">monitor_work</span></code></dt><dd><p>Promote <strong>head</strong> to <strong>head_free</strong> after KFREE_DRAIN_JIFFIES</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initialized</span></code></dt><dd><p>The <strong>rcu_work</strong> fields have been initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_cache_work</span></code></dt><dd><p>A work to refill the cache when it is empty</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backoff_page_cache_fill</span></code></dt><dd><p>Delay cache refills</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work_in_progress</span></code></dt><dd><p>Indicates that page_cache_work is running</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hrtimer</span></code></dt><dd><p>A hrtimer for scheduling a page_cache_work</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">bkvcache</span></code></p>
<blockquote>
<div><p>A simple cache list that contains objects for reuse purpose.
In order to save some per-cpu space the list is singular.
Even though it is lockless an access has to be protected by the
per-cpu lock.</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">nr_bkv_objs</span></code></dt><dd><p>number of allocated objects at <strong>bkvcache</strong>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is a per-CPU structure.  The reason that it is not included in
the rcu_data structure is to permit this code to be extracted from
the RCU files.  Such extraction could allow further optimization of
the interactions with the slab allocators.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.synchronize_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">synchronize_rcu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait until a grace period has elapsed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full grace
period has elapsed, in other words after all currently executing RCU
read-side critical sections have completed.  Note, however, that
upon return from <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, the caller might well be executing
concurrently with new RCU read-side critical sections that began while
<a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> was waiting.</p>
<p>RCU read-side critical sections are delimited by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>
and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, and may be nested.  In addition, but only in
v5.0 and later, regions of code across which interrupts, preemption,
or softirqs have been disabled also serve as RCU read-side critical
sections.  This includes hardware interrupt handlers, softirq handlers,
and NMI handlers.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since
the end of its last RCU read-side critical section whose beginning
preceded the call to <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>.  In addition, each CPU having
an RCU read-side critical section that extends beyond the return from
<a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is guaranteed to have executed a full memory barrier
after the beginning of <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> and before the beginning of
that RCU read-side critical section.  Note that these guarantees include
CPUs that are offline, idle, or executing in user mode, as well as CPUs
that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> -- even if CPU A and CPU B are the same CPU (but
again only if the system has more than one CPU).</p>
<p>Implementation of these memory-ordering guarantees is described here:
<a class="reference internal" href="../RCU/Design/Memory-Ordering/Tree-RCU-Memory-Ordering.html"><span class="doc">A Tour Through TREE_RCU's Grace-Period Memory Ordering</span></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_completed_synchronize_rcu_full">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_completed_synchronize_rcu_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_completed_synchronize_rcu_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a full pre-completed polled state cookie</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp</span></code></dt><dd><p>Place to put state cookie</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stores into <strong>rgosp</strong> a value that will always be treated by functions
like <a class="reference internal" href="#c.poll_state_synchronize_rcu_full" title="poll_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu_full()</span></code></a> as a cookie whose grace period
has already completed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_state_synchronize_rcu">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_state_synchronize_rcu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Snapshot current RCU state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu()</span></code></a>
or <a class="reference internal" href="#c.poll_state_synchronize_rcu" title="poll_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu()</span></code></a> to determine whether or not a full
grace period has elapsed in the meantime.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_state_synchronize_rcu_full">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_state_synchronize_rcu_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_rcu_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Snapshot RCU state, both normal and expedited</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp</span></code></dt><dd><p>location to place combined normal/expedited grace-period state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Places the normal and expedited grace-period states in <strong>rgosp</strong>.  This
state value can be passed to a later call to <a class="reference internal" href="#c.cond_synchronize_rcu_full" title="cond_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu_full()</span></code></a>
or <a class="reference internal" href="#c.poll_state_synchronize_rcu_full" title="poll_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu_full()</span></code></a> to determine whether or not a
grace period (whether normal or expedited) has elapsed in the meantime.
The rcu_gp_oldstate structure takes up twice the memory of an unsigned
long, but is guaranteed to see all grace periods.  In contrast, the
combined state occupies less memory, but can sometimes fail to take
grace periods into account.</p>
<p>This does not guarantee that the needed grace period will actually
start.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.start_poll_synchronize_rcu">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start_poll_synchronize_rcu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.start_poll_synchronize_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Snapshot and start RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu()</span></code></a>
or <a class="reference internal" href="#c.poll_state_synchronize_rcu" title="poll_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu()</span></code></a> to determine whether or not a full
grace period has elapsed in the meantime.  If the needed grace period
is not already slated to start, notifies RCU core of the need for that
grace period.</p>
<p>Interrupts must be enabled for the case where it is necessary to awaken
the grace-period kthread.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.start_poll_synchronize_rcu_full">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start_poll_synchronize_rcu_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.start_poll_synchronize_rcu_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Take a full snapshot and start RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp</span></code></dt><dd><p>value from <a class="reference internal" href="#c.get_state_synchronize_rcu_full" title="get_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu_full()</span></code></a> or <a class="reference internal" href="#c.start_poll_synchronize_rcu_full" title="start_poll_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_full()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Places the normal and expedited grace-period states in <strong>*rgos</strong>.  This
state value can be passed to a later call to <a class="reference internal" href="#c.cond_synchronize_rcu_full" title="cond_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu_full()</span></code></a>
or <a class="reference internal" href="#c.poll_state_synchronize_rcu_full" title="poll_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu_full()</span></code></a> to determine whether or not a
grace period (whether normal or expedited) has elapsed in the meantime.
If the needed grace period is not already slated to start, notifies
RCU core of the need for that grace period.</p>
<p>Interrupts must be enabled for the case where it is necessary to awaken
the grace-period kthread.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.poll_state_synchronize_rcu">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">poll_state_synchronize_rcu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">oldstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.poll_state_synchronize_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Has the specified RCU grace period completed?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt><dd><p>value from <a class="reference internal" href="#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a> or <a class="reference internal" href="#c.start_poll_synchronize_rcu" title="start_poll_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the earlier call from
which <strong>oldstate</strong> was obtained, return <strong>true</strong>, otherwise return <strong>false</strong>.
If <strong>false</strong> is returned, it is the caller's responsibility to invoke this
function later on until it does return <strong>true</strong>.  Alternatively, the caller
can explicitly wait for a grace period, for example, by passing <strong>oldstate</strong>
to either <a class="reference internal" href="#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu()</span></code></a> or <a class="reference internal" href="#c.cond_synchronize_rcu_expedited" title="cond_synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu_expedited()</span></code></a>
on the one hand or by directly invoking either <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> or
<a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a> on the other.</p>
<p>Yes, this function does not take counter wrap into account.
But counter wrap is harmless.  If the counter wraps, we have waited for
more than a billion grace periods (and way more on a 64-bit system!).
Those needing to keep old state values for very long time periods
(many hours even on 32-bit systems) should check them occasionally and
either refresh them or set a flag indicating that the grace period has
completed.  Alternatively, they can use <a class="reference internal" href="#c.get_completed_synchronize_rcu" title="get_completed_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_completed_synchronize_rcu()</span></code></a>
to get a guaranteed-completed grace-period state.</p>
<p>In addition, because oldstate compresses the grace-period state for
both normal and expedited grace periods into a single unsigned long,
it can miss a grace period when <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> runs concurrently
with <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a>.  If this is unacceptable, please
instead use the _full() variant of these polling APIs.</p>
<p>This function provides the same memory-ordering guarantees that
would be provided by a <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> that was invoked at the call
to the function that provided <strong>oldstate</strong>, and that returned at the end
of this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.poll_state_synchronize_rcu_full">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">poll_state_synchronize_rcu_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.poll_state_synchronize_rcu_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Has the specified RCU grace period completed?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp</span></code></dt><dd><p>value from <a class="reference internal" href="#c.get_state_synchronize_rcu_full" title="get_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu_full()</span></code></a> or <a class="reference internal" href="#c.start_poll_synchronize_rcu_full" title="start_poll_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_full()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the earlier call from
which <em>rgosp was obtained, return **true*</em>, otherwise return <strong>false</strong>.
If <strong>false</strong> is returned, it is the caller's responsibility to invoke this
function later on until it does return <strong>true</strong>.  Alternatively, the caller
can explicitly wait for a grace period, for example, by passing <strong>rgosp</strong>
to <a class="reference internal" href="#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu()</span></code></a> or by directly invoking <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>.</p>
<p>Yes, this function does not take counter wrap into account.
But counter wrap is harmless.  If the counter wraps, we have waited
for more than a billion grace periods (and way more on a 64-bit
system!).  Those needing to keep rcu_gp_oldstate values for very
long time periods (many hours even on 32-bit systems) should check
them occasionally and either refresh them or set a flag indicating
that the grace period has completed.  Alternatively, they can use
<a class="reference internal" href="#c.get_completed_synchronize_rcu_full" title="get_completed_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_completed_synchronize_rcu_full()</span></code></a> to get a guaranteed-completed
grace-period state.</p>
<p>This function provides the same memory-ordering guarantees that would
be provided by a <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> that was invoked at the call to
the function that provided <strong>rgosp</strong>, and that returned at the end of this
function.  And this guarantee requires that the root rcu_node structure's
-&gt;gp_seq field be checked instead of that of the rcu_state structure.
The problem is that the just-ending grace-period's callbacks can be
invoked between the time that the root rcu_node structure's -&gt;gp_seq
field is updated and the time that the rcu_state structure's -&gt;gp_seq
field is updated.  Therefore, if a single <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is to
cause a subsequent <a class="reference internal" href="#c.poll_state_synchronize_rcu_full" title="poll_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu_full()</span></code></a> to return <strong>true</strong>,
then the root rcu_node structure is the one that needs to be polled.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cond_synchronize_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cond_synchronize_rcu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">oldstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Conditionally wait for an RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt><dd><p>value from <a class="reference internal" href="#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu" title="start_poll_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu()</span></code></a>, or <a class="reference internal" href="#c.start_poll_synchronize_rcu_expedited" title="start_poll_synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_expedited()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the earlier call to
<a class="reference internal" href="#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a> or <a class="reference internal" href="#c.start_poll_synchronize_rcu" title="start_poll_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu()</span></code></a>, just return.
Otherwise, invoke <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.
But counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for a couple of additional grace periods should be just fine.</p>
<p>This function provides the same memory-ordering guarantees that
would be provided by a <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> that was invoked at the call
to the function that provided <strong>oldstate</strong> and that returned at the end
of this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cond_synchronize_rcu_full">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cond_synchronize_rcu_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_rcu_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Conditionally wait for an RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp</span></code></dt><dd><p>value from <a class="reference internal" href="#c.get_state_synchronize_rcu_full" title="get_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu_full()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu_full" title="start_poll_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_full()</span></code></a>, or <a class="reference internal" href="#c.start_poll_synchronize_rcu_expedited_full" title="start_poll_synchronize_rcu_expedited_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_expedited_full()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the call to
<a class="reference internal" href="#c.get_state_synchronize_rcu_full" title="get_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu_full()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu_full" title="start_poll_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_full()</span></code></a>,
or <a class="reference internal" href="#c.start_poll_synchronize_rcu_expedited_full" title="start_poll_synchronize_rcu_expedited_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_expedited_full()</span></code></a> from which <strong>rgosp</strong> was
obtained, just return.  Otherwise, invoke <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> to wait
for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.
But counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for a couple of additional grace periods should be just fine.</p>
<p>This function provides the same memory-ordering guarantees that
would be provided by a <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> that was invoked at the call
to the function that provided <strong>rgosp</strong> and that returned at the end of
this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_barrier">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_barrier</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this primitive does not necessarily wait for an RCU grace period
to complete.  For example, if there are no RCU callbacks queued anywhere
in the system, then <a class="reference internal" href="#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> is within its rights to return
immediately, without waiting for anything, much less an RCU grace period.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.synchronize_rcu_expedited">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">synchronize_rcu_expedited</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_expedited" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Brute-force RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an RCU grace period, but expedite it.  The basic idea is to
IPI all non-idle non-nohz online CPUs.  The IPI handler checks whether
the CPU is in an RCU critical section, and if so, it sets a flag that
causes the outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> to report the quiescent state
for RCU-preempt or asks the scheduler for help for RCU-sched.  On the
other hand, if the CPU is not in an RCU read-side critical section,
the IPI handler reports the quiescent state immediately.</p>
<p>Although this is a great improvement over previous expedited
implementations, it is still unfriendly to real-time workloads, so is
thus not recommended for any sort of common-case code.  In fact, if
you are using <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a> in a loop, please restructure
your code to batch your updates, and then use a single <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
instead.</p>
<p>This has the same semantics as (but is more brutal than) <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.start_poll_synchronize_rcu_expedited">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start_poll_synchronize_rcu_expedited</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.start_poll_synchronize_rcu_expedited" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Snapshot current RCU state and start expedited grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie to pass to a call to <a class="reference internal" href="#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu()</span></code></a>,
<a class="reference internal" href="#c.cond_synchronize_rcu_expedited" title="cond_synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu_expedited()</span></code></a>, or <a class="reference internal" href="#c.poll_state_synchronize_rcu" title="poll_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu()</span></code></a>,
allowing them to determine whether or not any sort of grace period has
elapsed in the meantime.  If the needed expedited grace period is not
already slated to start, initiates that grace period.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.start_poll_synchronize_rcu_expedited_full">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start_poll_synchronize_rcu_expedited_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.start_poll_synchronize_rcu_expedited_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Take a full snapshot and start expedited grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp</span></code></dt><dd><p>Place to put snapshot of grace-period state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Places the normal and expedited grace-period states in rgosp.  This
state value can be passed to a later call to <a class="reference internal" href="#c.cond_synchronize_rcu_full" title="cond_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_synchronize_rcu_full()</span></code></a>
or <a class="reference internal" href="#c.poll_state_synchronize_rcu_full" title="poll_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu_full()</span></code></a> to determine whether or not a
grace period (whether normal or expedited) has elapsed in the meantime.
If the needed expedited grace period is not already slated to start,
initiates that grace period.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cond_synchronize_rcu_expedited">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cond_synchronize_rcu_expedited</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">oldstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_rcu_expedited" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Conditionally wait for an expedited RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt><dd><p>value from <a class="reference internal" href="#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu" title="start_poll_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu()</span></code></a>, or <a class="reference internal" href="#c.start_poll_synchronize_rcu_expedited" title="start_poll_synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_expedited()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If any type of full RCU grace period has elapsed since the earlier
call to <a class="reference internal" href="#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu" title="start_poll_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu()</span></code></a>,
or <a class="reference internal" href="#c.start_poll_synchronize_rcu_expedited" title="start_poll_synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_expedited()</span></code></a>, just return.  Otherwise,
invoke <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.
But counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for a couple of additional grace periods should be just fine.</p>
<p>This function provides the same memory-ordering guarantees that
would be provided by a <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> that was invoked at the call
to the function that provided <strong>oldstate</strong> and that returned at the end
of this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cond_synchronize_rcu_expedited_full">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cond_synchronize_rcu_expedited_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_rcu_expedited_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Conditionally wait for an expedited RCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp</span></code></dt><dd><p>value from <a class="reference internal" href="#c.get_state_synchronize_rcu_full" title="get_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu_full()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu_full" title="start_poll_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_full()</span></code></a>, or <a class="reference internal" href="#c.start_poll_synchronize_rcu_expedited_full" title="start_poll_synchronize_rcu_expedited_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_expedited_full()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the call to
<a class="reference internal" href="#c.get_state_synchronize_rcu_full" title="get_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu_full()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu_full" title="start_poll_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_full()</span></code></a>,
or <a class="reference internal" href="#c.start_poll_synchronize_rcu_expedited_full" title="start_poll_synchronize_rcu_expedited_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_expedited_full()</span></code></a> from which <strong>rgosp</strong> was
obtained, just return.  Otherwise, invoke <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a>
to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.
But counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for a couple of additional grace periods should be just fine.</p>
<p>This function provides the same memory-ordering guarantees that
would be provided by a <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> that was invoked at the call
to the function that provided <strong>rgosp</strong> and that returned at the end of
this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_lock_held_common">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_lock_held_common</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ret</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_held_common" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>might we be in RCU-sched read-side critical section?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*ret</span></code></dt><dd><p>Best guess answer if lockdep cannot be relied on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if lockdep must be ignored, in which case <code class="docutils literal notranslate"><span class="pre">*ret</span></code> contains
the best guess described below.  Otherwise returns false, in which
case <code class="docutils literal notranslate"><span class="pre">*ret</span></code> tells the caller nothing and the caller should instead
consult lockdep.</p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, set <code class="docutils literal notranslate"><span class="pre">*ret</span></code> to nonzero iff in an
RCU-sched read-side critical section.  In absence of
CONFIG_DEBUG_LOCK_ALLOC, this assumes we are in an RCU-sched read-side
critical section unless it can prove otherwise.  Note that disabling
of preemption (including disabling irqs) counts as an RCU-sched
read-side critical section.  This is useful for debug checks in functions
that required that they be called within an RCU-sched read-side
critical section.</p>
<p>Check debug_lockdep_rcu_enabled() to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that if the CPU is in the idle loop from an RCU point of view (ie:
that we are in the section between ct_idle_enter() and ct_idle_exit())
then <a class="reference internal" href="#c.rcu_read_lock_held" title="rcu_read_lock_held"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_held()</span></code></a> sets <code class="docutils literal notranslate"><span class="pre">*ret</span></code> to false even if the CPU did an
<a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.  The reason for this is that RCU ignores CPUs that are
in such a section, considering these as in extended quiescent state,
so such a CPU is effectively never in an RCU read-side critical section
regardless of what RCU primitives it invokes.  This state of affairs is
required --- we need to keep an RCU-free window in idle where the CPU may
possibly enter into low power mode. This way we can notice an extended
quiescent state to other CPUs that started a grace period. Otherwise
we would delay any grace period as long as we run in the idle task.</p>
<p>Similarly, we avoid claiming an RCU read lock held if the current
CPU is offline.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_async_hurry">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_async_hurry</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_async_hurry" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Make future async RCU callbacks not lazy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After a call to this function, future calls to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
will be processed in a timely fashion.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_async_relax">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_async_relax</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_async_relax" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Make future async RCU callbacks lazy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After a call to this function, future calls to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
will be processed in a lazy fashion.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_expedite_gp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_expedite_gp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_expedite_gp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Expedite future RCU grace periods</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After a call to this function, future calls to <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> and
friends act as the corresponding <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a> function
had instead been called.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_unexpedite_gp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_unexpedite_gp</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_unexpedite_gp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Cancel prior <a class="reference internal" href="#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_expedite_gp()</span></code></a> invocation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo a prior call to <a class="reference internal" href="#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_expedite_gp()</span></code></a>.  If all prior calls to
<a class="reference internal" href="#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_expedite_gp()</span></code></a> are undone by a subsequent call to <a class="reference internal" href="#c.rcu_unexpedite_gp" title="rcu_unexpedite_gp"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_unexpedite_gp()</span></code></a>,
and if the rcu_expedited sysfs/boot parameter is not set, then all
subsequent calls to <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> and friends will return to
their normal non-expedited behavior.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_lock_held">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_lock_held</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_held" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>might we be in RCU read-side critical section?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an RCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an RCU read-side critical section unless it can
prove otherwise.  This is useful for debug checks in functions that
require that they be called within an RCU read-side critical section.</p>
<p>Checks debug_lockdep_rcu_enabled() to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> in process context if the matching <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>
was invoked from within an irq handler.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_lock_bh_held">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_lock_bh_held</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh_held" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>might we be in RCU-bh read-side critical section?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for bottom half being disabled, which covers both the
CONFIG_PROVE_RCU and not cases.  Note that if someone uses
<a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a>, but then later enables BH, lockdep (if enabled)
will show the situation.  This is useful for debug checks in functions
that require that they be called within an RCU read-side critical
section.</p>
<p>Check debug_lockdep_rcu_enabled() to prevent false positives during boot.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.wakeme_after_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">wakeme_after_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeme_after_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callback function to awaken a task after grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*head</span></code></dt><dd><p>Pointer to rcu_head member within rcu_synchronize structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Awaken the corresponding task now that a grace period has elapsed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.init_rcu_head_on_stack">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">init_rcu_head_on_stack</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.init_rcu_head_on_stack" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize on-stack rcu_head for debugobjects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*head</span></code></dt><dd><p>pointer to rcu_head structure to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects of a new rcu_head structure that
has been allocated as an auto variable on the stack.  This function
is not required for rcu_head structures that are statically defined or
that are dynamically allocated on the heap.  This function has no
effect for !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.destroy_rcu_head_on_stack">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">destroy_rcu_head_on_stack</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.destroy_rcu_head_on_stack" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>destroy on-stack rcu_head for debugobjects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*head</span></code></dt><dd><p>pointer to rcu_head structure to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects that an on-stack rcu_head structure
is about to go out of scope.  As with <a class="reference internal" href="#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this
function is not required for rcu_head structures that are statically
defined or that are dynamically allocated on the heap.  Also as with
<a class="reference internal" href="#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this function has no effect for
!CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_completed_synchronize_rcu">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_completed_synchronize_rcu</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_completed_synchronize_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a pre-completed polled state cookie</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a value that will always be treated by functions like
<a class="reference internal" href="#c.poll_state_synchronize_rcu" title="poll_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu()</span></code></a> as a cookie whose grace period has already
completed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_read_lock_held">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_read_lock_held</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock_held" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>might we be in SRCU read-side critical section?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>The srcu_struct structure to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an SRCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an SRCU read-side critical section unless it can
prove otherwise.</p>
<p>Checks debug_lockdep_rcu_enabled() to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that SRCU is based on its own statemachine and it doesn't
relies on normal RCU, it can be called from the CPU which
is in the idle loop from an RCU point of view or offline.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.srcu_dereference_check">
<span class="sig-name descname"><span class="n"><span class="pre">srcu_dereference_check</span></span></span><a class="headerlink" href="#c.srcu_dereference_check" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">srcu_dereference_check</span> <span class="pre">(p,</span> <span class="pre">ssp,</span> <span class="pre">c)</span></code></p>
<blockquote>
<div><p>fetch SRCU-protected pointer for later dereferencing</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>the pointer to fetch and protect for later dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp</span></code></dt><dd><p>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code></dt><dd><p>condition to check for update-side use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PROVE_RCU is enabled, invoking this outside of an RCU read-side
critical section will result in an RCU-lockdep splat, unless <strong>c</strong> evaluates
to 1.  The <strong>c</strong> argument will normally be a logical expression containing
lockdep_is_held() calls.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.srcu_dereference">
<span class="sig-name descname"><span class="n"><span class="pre">srcu_dereference</span></span></span><a class="headerlink" href="#c.srcu_dereference" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">srcu_dereference</span> <span class="pre">(p,</span> <span class="pre">ssp)</span></code></p>
<blockquote>
<div><p>fetch SRCU-protected pointer for later dereferencing</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>the pointer to fetch and protect for later dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp</span></code></dt><dd><p>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.  If PROVE_RCU
is enabled, invoking this outside of an RCU read-side critical
section will result in an RCU-lockdep splat.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.srcu_dereference_notrace">
<span class="sig-name descname"><span class="n"><span class="pre">srcu_dereference_notrace</span></span></span><a class="headerlink" href="#c.srcu_dereference_notrace" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">srcu_dereference_notrace</span> <span class="pre">(p,</span> <span class="pre">ssp)</span></code></p>
<blockquote>
<div><p>no tracing and no lockdep calls from here</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>the pointer to fetch and protect for later dereferencing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp</span></code></dt><dd><p>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_read_lock">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_read_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a new reader for an SRCU-protected structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct in which to register the new reader.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter an SRCU read-side critical section.  Note that SRCU read-side
critical sections may be nested.  However, it is illegal to
call anything that waits on an SRCU grace period for the same
srcu_struct, whether directly or indirectly.  Please note that
one way to indirectly wait on an SRCU grace period is to acquire
a mutex that is held elsewhere while calling <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> or
<a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a>.</p>
<p>Note that <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> in an irq handler if the matching <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>
was invoked in process context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_read_lock_nmisafe">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_read_lock_nmisafe</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock_nmisafe" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a new reader for an SRCU-protected structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct in which to register the new reader.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter an SRCU read-side critical section, but in an NMI-safe manner.
See <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a> for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_down_read">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_down_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_down_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register a new reader for an SRCU-protected structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct in which to register the new reader.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter a semaphore-like SRCU read-side critical section.  Note that
SRCU read-side critical sections may be nested.  However, it is
illegal to call anything that waits on an SRCU grace period for the
same srcu_struct, whether directly or indirectly.  Please note that
one way to indirectly wait on an SRCU grace period is to acquire
a mutex that is held elsewhere while calling <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> or
<a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a>.  But if you want lockdep to help you
keep this stuff straight, you should instead use <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>.</p>
<p>The semaphore-like nature of <a class="reference internal" href="#c.srcu_down_read" title="srcu_down_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_down_read()</span></code></a> means that the matching
<a class="reference internal" href="#c.srcu_up_read" title="srcu_up_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_up_read()</span></code></a> can be invoked from some other context, for example,
from some other task or from an irq handler.  However, neither
<a class="reference internal" href="#c.srcu_down_read" title="srcu_down_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_down_read()</span></code></a> nor <a class="reference internal" href="#c.srcu_up_read" title="srcu_up_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_up_read()</span></code></a> may be invoked from an NMI handler.</p>
<p>Calls to <a class="reference internal" href="#c.srcu_down_read" title="srcu_down_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_down_read()</span></code></a> may be nested, similar to the manner in
which calls to down_read() may be nested.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_read_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_read_unlock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a old reader from an SRCU-protected structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct in which to unregister the old reader.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>return value from corresponding <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit an SRCU read-side critical section.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_read_unlock_nmisafe">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_read_unlock_nmisafe</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_unlock_nmisafe" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a old reader from an SRCU-protected structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct in which to unregister the old reader.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>return value from corresponding <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit an SRCU read-side critical section, but in an NMI-safe manner.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_up_read">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_up_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">idx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_up_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister a old reader from an SRCU-protected structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct in which to unregister the old reader.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>return value from corresponding <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit an SRCU read-side critical section, but not necessarily from
the same context as the maching <a class="reference internal" href="#c.srcu_down_read" title="srcu_down_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_down_read()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.smp_mb__after_srcu_read_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">smp_mb__after_srcu_read_unlock</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.smp_mb__after_srcu_read_unlock" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>ensure full ordering after srcu_read_unlock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts the preceding srcu_read_unlock into a two-way memory barrier.</p>
<p>Call this after srcu_read_unlock, to guarantee that all memory operations
that occur after smp_mb__after_srcu_read_unlock will appear to happen after
the preceding srcu_read_unlock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.init_srcu_struct">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">init_srcu_struct</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.init_srcu_struct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>initialize a sleep-RCU structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>structure to initialize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this on a given srcu_struct before passing that srcu_struct
to any other function.  Each srcu_struct represents a separate domain
of SRCU protection.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_readers_active">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_readers_active</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_readers_active" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>returns true if there are readers. and false otherwise</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>which srcu_struct to count active readers (holding srcu_read_lock).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this is not an atomic primitive, and can therefore suffer
severe errors when invoked on an active srcu_struct.  That said, it
can be useful as an error check at cleanup time.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cleanup_srcu_struct">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cleanup_srcu_struct</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cleanup_srcu_struct" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deconstruct a sleep-RCU structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>structure to clean up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this after you are finished using a given srcu_struct that
was initialized via <a class="reference internal" href="#c.init_srcu_struct" title="init_srcu_struct"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_srcu_struct()</span></code></a>, else you leak memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.call_srcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">call_srcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rhp</span></span>, <span class="n"><span class="pre">rcu_callback_t</span></span><span class="w"> </span><span class="n"><span class="pre">func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.call_srcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue a callback for invocation after an SRCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct in queue the callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*rhp</span></code></dt><dd><p>structure to be used for queueing the SRCU callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>function to be invoked after the SRCU grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full SRCU
grace period elapses, in other words after all pre-existing SRCU
read-side critical sections have completed.  However, the callback
function might well execute concurrently with other SRCU read-side
critical sections that started after <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> was invoked.  SRCU
read-side critical sections are delimited by <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a> and
<a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a>, and may be nested.</p>
<p>The callback will be invoked from process context, but must nevertheless
be fast and must not block.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.synchronize_srcu_expedited">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">synchronize_srcu_expedited</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_srcu_expedited" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Brute-force SRCU grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct with which to synchronize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an SRCU grace period to elapse, but be more aggressive about
spinning rather than blocking when waiting.</p>
<p>Note that <a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a> has the same deadlock and
memory-ordering properties as does <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.synchronize_srcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">synchronize_srcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_srcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for prior SRCU read-side critical-section completion</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct with which to synchronize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for the count to drain to zero of both indexes. To avoid the
possible starvation of <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>, it waits for the count of
the index=((-&gt;srcu_idx &amp; 1) ^ 1) to drain to zero at first,
and then flip the srcu_idx and wait for the count of the other index.</p>
<p>Can block; must be called from process context.</p>
<p>Note that it is illegal to call <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> from the corresponding
SRCU read-side critical section; doing so will result in deadlock.
However, it is perfectly legal to call <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> on one
srcu_struct from some other srcu_struct's read-side critical section,
as long as the resulting graph of srcu_structs is acyclic.</p>
<p>There are memory-ordering constraints implied by <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>.
On systems with more than one CPU, when <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since
the end of its last corresponding SRCU read-side critical section
whose beginning preceded the call to <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>.  In addition,
each CPU having an SRCU read-side critical section that extends beyond
the return from <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> is guaranteed to have executed a
full memory barrier after the beginning of <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> and before
the beginning of that SRCU read-side critical section.  Note that these
guarantees include CPUs that are offline, idle, or executing in user mode,
as well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>.  This guarantee applies even if CPU A and CPU B
are the same CPU, but again only if the system has more than one CPU.</p>
<p>Of course, these memory-ordering guarantees apply only when
<a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>, <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>, and <a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> are
passed the same srcu_struct structure.</p>
<p>Implementation of these memory-ordering guarantees is similar to
that of <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>.</p>
<p>If SRCU is likely idle, expedite the first request.  This semantic
was provided by Classic SRCU, and is relied upon by its users, so TREE
SRCU must also provide it.  Note that detecting idleness is heuristic
and subject to both false positives and negatives.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_state_synchronize_srcu">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">get_state_synchronize_srcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_srcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Provide an end-of-grace-period cookie</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct to provide cookie for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a cookie that can be passed to
<a class="reference internal" href="#c.poll_state_synchronize_srcu" title="poll_state_synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_srcu()</span></code></a>, which will return true if a full grace
period has elapsed in the meantime.  It is the caller's responsibility
to make sure that grace period happens, for example, by invoking
<a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> after return from <a class="reference internal" href="#c.get_state_synchronize_srcu" title="get_state_synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_srcu()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.start_poll_synchronize_srcu">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start_poll_synchronize_srcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.start_poll_synchronize_srcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Provide cookie and start grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct to provide cookie for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a cookie that can be passed to
<a class="reference internal" href="#c.poll_state_synchronize_srcu" title="poll_state_synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_srcu()</span></code></a>, which will return true if a full grace
period has elapsed in the meantime.  Unlike <a class="reference internal" href="#c.get_state_synchronize_srcu" title="get_state_synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_srcu()</span></code></a>,
this function also ensures that any needed SRCU grace period will be
started.  This convenience does come at a cost in terms of CPU overhead.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.poll_state_synchronize_srcu">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">poll_state_synchronize_srcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">cookie</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.poll_state_synchronize_srcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Has cookie's grace period ended?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct to provide cookie for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">cookie</span></code></dt><dd><p>Return value from <a class="reference internal" href="#c.get_state_synchronize_srcu" title="get_state_synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_srcu()</span></code></a> or <a class="reference internal" href="#c.start_poll_synchronize_srcu" title="start_poll_synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_srcu()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes the cookie that was returned from either
<a class="reference internal" href="#c.get_state_synchronize_srcu" title="get_state_synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_srcu()</span></code></a> or <a class="reference internal" href="#c.start_poll_synchronize_srcu" title="start_poll_synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_srcu()</span></code></a>, and
returns <strong>true</strong> if an SRCU grace period elapsed since the time that the
cookie was created.</p>
<p>Because cookies are finite in size, wrapping/overflow is possible.
This is more pronounced on 32-bit systems where cookies are 32 bits,
where in theory wrapping could happen in about 14 hours assuming
25-microsecond expedited SRCU grace periods.  However, a more likely
overflow lower bound is on the order of 24 days in the case of
one-millisecond SRCU grace periods.  Of course, wrapping in a 64-bit
system requires geologic timespans, as in more than seven million years
even for expedited SRCU grace periods.</p>
<p>Wrapping/overflow is much more of an issue for CONFIG_SMP=n systems
that also have CONFIG_PREEMPTION=n, which selects Tiny SRCU.  This uses
a 16-bit cookie, which rcutorture routinely wraps in a matter of a
few minutes.  If this proves to be a problem, this counter will be
expanded to the same size as for Tree SRCU.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_barrier">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_barrier</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_barrier" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct on which to wait for in-flight callbacks.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.srcu_batches_completed">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">srcu_batches_completed</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">srcu_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ssp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_batches_completed" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>return batches completed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*ssp</span></code></dt><dd><p>srcu_struct on which to report batch completion.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Report the number of batches, correlated with, but not necessarily
precisely the same as, the number of grace periods that have elapsed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_bl_del_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_bl_del_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_bl_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_del_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>hlist_bl_unhashed() on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p><strong>Description</strong></p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
hlist_bl_for_each_entry().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_bl_add_head_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_bl_add_head_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_bl_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_bl_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_add_head_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_bl_head</span> <span class="pre">*h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_bl,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_bl_for_each_entry_rcu" title="hlist_bl_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_bl_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_bl_for_each_entry_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_bl_for_each_entry_rcu</span></span></span><a class="headerlink" href="#c.hlist_bl_for_each_entry_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_bl_for_each_entry_rcu</span> <span class="pre">(tpos,</span> <span class="pre">pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_bl_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_tail_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_tail_rcu</span></span></span><a class="headerlink" href="#c.list_tail_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_tail_rcu</span> <span class="pre">(head)</span></code></p>
<blockquote>
<div><p>returns the prev pointer of the head of the list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This should only be used with the list header, and even then
only if <a class="reference internal" href="#c.list_del" title="list_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del()</span></code></a> and similar primitives are not also used on the
list header.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_add_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_add_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a new entry to rcu-protected list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list head to add it after</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_add_tail_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_add_tail_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>add a new entry to rcu-protected list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list head to add it before</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_add_tail_rcu" title="list_add_tail_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_tail_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_del_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_del_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from list without re-initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty()</span></code></a> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p><strong>Description</strong></p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<p>Note that the caller is not permitted to immediately free
the newly deleted entry.  Instead, either <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
or <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> must be used to defer freeing until an RCU
grace period has elapsed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_del_init_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_del_init_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_init_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>list_unhashed() on the node return true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p><strong>Description</strong></p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so list_unhashed() will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_replace_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_replace_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>old</strong> entry will be replaced with the <strong>new</strong> entry atomically.</p>
<p><strong>Note</strong></p>
<p><strong>old</strong> should not be empty.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__list_splice_init_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__list_splice_init_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">next</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sync</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__list_splice_init_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>join an RCU-protected list into an existing list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the RCU-protected list to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*prev</span></code></dt><dd><p>points to the last element of the existing list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*next</span></code></dt><dd><p>points to the first element of the existing list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*sync)(void)</span></code></dt><dd><p>synchronize_rcu, synchronize_rcu_expedited, ...</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list pointed to by <strong>prev</strong> and <strong>next</strong> can be RCU-read traversed
concurrently with this function.</p>
<p>Note that this function blocks.</p>
<p>Important note: the caller must take whatever action is necessary to prevent
any other updates to the existing list.  In principle, it is possible to
modify the list as soon as sync() begins execution. If this sort of thing
becomes necessary, an alternative version based on <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> could be
created.  But only if -really- needed -- there is no shortage of RCU API
members.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice_init_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice_init_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sync</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>splice an RCU-protected list into an existing list, designed for stacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the RCU-protected list to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place in the existing list to splice the first list into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*sync)(void)</span></code></dt><dd><p>synchronize_rcu, synchronize_rcu_expedited, ...</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice_tail_init_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice_tail_init_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sync</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>splice an RCU-protected list into an existing list, designed for queues.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the RCU-protected list to splice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place in the existing list to splice the first list into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*sync)(void)</span></code></dt><dd><p>synchronize_rcu, synchronize_rcu_expedited, ...</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_entry_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_entry_rcu</span></span></span><a class="headerlink" href="#c.list_entry_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_entry_rcu</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the struct for this entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> as long as it's guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_first_or_null_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_first_or_null_rcu</span></span></span><a class="headerlink" href="#c.list_first_or_null_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_first_or_null_rcu</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the first element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> as long as it's guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_next_or_null_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_next_or_null_rcu</span></span></span><a class="headerlink" href="#c.list_next_or_null_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_next_or_null_rcu</span> <span class="pre">(head,</span> <span class="pre">ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the first element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the next element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the ptr is at the end of the list, NULL is returned.</p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> as long as it's guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_rcu</span></span></span><a class="headerlink" href="#c.list_for_each_entry_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_rcu</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member,</span> <span class="pre">cond...)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cond...</span></code></dt><dd><p>optional lockdep expression if called from non-RCU protection.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_srcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_srcu</span></span></span><a class="headerlink" href="#c.list_for_each_entry_srcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_srcu</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member,</span> <span class="pre">cond)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cond</span></code></dt><dd><p>lockdep expression for the lock required to traverse the list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>.
The lockdep expression <a class="reference internal" href="#c.srcu_read_lock_held" title="srcu_read_lock_held"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock_held()</span></code></a> can be passed as the
cond argument from read side.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_entry_lockless">
<span class="sig-name descname"><span class="n"><span class="pre">list_entry_lockless</span></span></span><a class="headerlink" href="#c.list_entry_lockless" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_entry_lockless</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the struct for this entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct this is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu
list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>, but requires some
implicit RCU read-side guarding.  One example is running within a special
exception-time environment where preemption is disabled and where lockdep
cannot be invoked.  Another example is when items are added to the list,
but never deleted.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_lockless">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_lockless</span></span></span><a class="headerlink" href="#c.list_for_each_entry_lockless" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_lockless</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_struct within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu
list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>, but requires some
implicit RCU read-side guarding.  One example is running within a special
exception-time environment where preemption is disabled and where lockdep
cannot be invoked.  Another example is when items are added to the list,
but never deleted.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_continue_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_continue_rcu</span></span></span><a class="headerlink" href="#c.list_for_each_entry_continue_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_continue_rcu</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>continue iteration over list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position which must have been in the list when the RCU read
lock was taken.
This would typically require either that you obtained the node from a
previous walk of the list in the same RCU read-side critical section, or
that you held some sort of non-RCU reference (such as a reference count)
to keep the node alive <em>and</em> in the list.</p>
<p>This iterator is similar to <a class="reference internal" href="#c.list_for_each_entry_from_rcu" title="list_for_each_entry_from_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_from_rcu()</span></code></a> except
this starts after the given position and that one starts at the given
position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_from_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_from_rcu</span></span></span><a class="headerlink" href="#c.list_for_each_entry_from_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_from_rcu</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over a list from current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_node within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the tail of a list starting from a given position,
which must have been in the list when the RCU read lock was taken.
This would typically require either that you obtained the node from a
previous walk of the list in the same RCU read-side critical section, or
that you held some sort of non-RCU reference (such as a reference count)
to keep the node alive <em>and</em> in the list.</p>
<p>This iterator is similar to <a class="reference internal" href="#c.list_for_each_entry_continue_rcu" title="list_for_each_entry_continue_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_continue_rcu()</span></code></a> except
this starts from the given position and that one starts from the position
after the given position.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_del_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_del_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>list_unhashed() on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p><strong>Description</strong></p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry" title="hlist_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_replace_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_replace_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_replace_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>old</strong> entry will be replaced with the <strong>new</strong> entry atomically.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlists_swap_heads_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlists_swap_heads_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">left</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">right</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlists_swap_heads_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>swap the lists the hlist heads point to</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*left</span></code></dt><dd><p>The hlist head on the left</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*right</span></code></dt><dd><p>The hlist head on the right</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The lists start out as [<strong>left</strong>  ][node1 ... ] and</dt><dd><p>[<strong>right</strong> ][node2 ... ]</p>
</dd>
<dt>The lists end up as    [<strong>left</strong>  ][node2 ... ]</dt><dd><p>[<strong>right</strong> ][node1 ... ]</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_head_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_head_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_head_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_tail_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_tail_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_tail_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_before_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_before_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">next</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_before_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>the new element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*next</span></code></dt><dd><p>the existing element to add the new element before.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist
before the specified node while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_behind_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_behind_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_behind_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>the new element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*prev</span></code></dt><dd><p>the existing element to add the new element after.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist
after the specified node while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_rcu</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member,</span> <span class="pre">cond...)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cond...</span></code></dt><dd><p>optional lockdep expression if called from non-RCU protection.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_srcu">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_srcu</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_srcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_srcu</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member,</span> <span class="pre">cond)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cond</span></code></dt><dd><p>lockdep expression for the lock required to traverse the list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>.
The lockdep expression <a class="reference internal" href="#c.srcu_read_lock_held" title="srcu_read_lock_held"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock_held()</span></code></a> can be passed as the
cond argument from read side.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_rcu_notrace">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_rcu_notrace</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_rcu_notrace" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu_notrace</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type (for tracing)</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<p>This is the same as <a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu()</span></code></a> except that it does
not do any RCU debugging or tracing.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_rcu_bh">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_rcu_bh</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_rcu_bh" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_rcu_bh</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_continue_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_continue_rcu</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_continue_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_continue_rcu</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over a hlist continuing after current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_continue_rcu_bh">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_continue_rcu_bh</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_continue_rcu_bh" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_continue_rcu_bh</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over a hlist continuing after current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_from_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_from_rcu</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_from_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_from_rcu</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over a hlist continuing from current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_nulls_del_init_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_nulls_del_init_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_nulls_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_del_init_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>hlist_nulls_unhashed() on the node return true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p><strong>Description</strong></p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so list_unhashed() will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_nulls_first_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_nulls_first_rcu</span></span></span><a class="headerlink" href="#c.hlist_nulls_first_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_nulls_first_rcu</span> <span class="pre">(head)</span></code></p>
<blockquote>
<div><p>returns the first element of the hash list.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_nulls_next_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_nulls_next_rcu</span></span></span><a class="headerlink" href="#c.hlist_nulls_next_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_nulls_next_rcu</span> <span class="pre">(node)</span></code></p>
<blockquote>
<div><p>returns the element of the list after <strong>node</strong>.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>element of the list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_nulls_del_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_nulls_del_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_nulls_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_del_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to delete from the hash list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>hlist_nulls_unhashed() on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p><strong>Description</strong></p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
hlist_nulls_for_each_entry().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_nulls_add_head_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_nulls_add_head_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_nulls_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_nulls_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_add_head_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_head</span> <span class="pre">*h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_nulls,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_nulls_add_tail_rcu">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_nulls_add_tail_rcu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_nulls_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_nulls_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_add_tail_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*n</span></code></dt><dd><p>the element to add to the hash list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_head</span> <span class="pre">*h</span></code></dt><dd><p>the list to add to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_nulls,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_nulls_for_each_entry_rcu">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_nulls_for_each_entry_rcu</span></span></span><a class="headerlink" href="#c.hlist_nulls_for_each_entry_rcu" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_nulls_for_each_entry_rcu</span> <span class="pre">(tpos,</span> <span class="pre">pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over rcu list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_nulls_node within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The barrier() is needed to make sure compiler doesn't cache first element [1],
as this loop can be restarted [2]
[1] Documentation/memory-barriers.txt around line 1533
[2] <a class="reference internal" href="../RCU/rculist_nulls.html"><span class="doc">Using RCU hlist_nulls to protect list and objects</span></a> around line 146</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_nulls_for_each_entry_safe">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_nulls_for_each_entry_safe</span></span></span><a class="headerlink" href="#c.hlist_nulls_for_each_entry_safe" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_nulls_for_each_entry_safe</span> <span class="pre">(tpos,</span> <span class="pre">pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_nulls_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_sync_is_idle">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_sync_is_idle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_sync</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rsp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_is_idle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Are readers permitted to use their fastpaths?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if readers are permitted to use their fastpaths.  Must be
invoked within some flavor of RCU read-side critical section.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_sync_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_sync_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_sync</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rsp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize an rcu_sync structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to be initialized</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_sync_enter_start">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_sync_enter_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_sync</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rsp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_enter_start" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Force readers onto slow path for multiple updates</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called after <a class="reference internal" href="#c.rcu_sync_init" title="rcu_sync_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_init()</span></code></a> and before first use.</p>
<p>Ensures <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_is_idle()</span></code></a> returns false and rcu_sync_{enter,exit}()
pairs turn into NO-OPs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_sync_func">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_sync_func</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rhp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_func" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callback function managing reader access to fastpath</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*rhp</span></code></dt><dd><p>Pointer to rcu_head in rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is passed to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> function by <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> and
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a>, so that it is invoked after a grace period following the
that invocation of enter/exit.</p>
<p>If it is called by <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> it signals that all the readers were
switched onto slow path.</p>
<p>If it is called by <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> it takes action based on events that
have taken place in the meantime, so that closely spaced <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a>
and <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> pairs need not wait for a grace period.</p>
<p>If another <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> is invoked before the grace period
ended, reset state to allow the next <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> to let the
readers back onto their fastpaths (after a grace period).  If both
another <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> and its matching <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> are invoked
before the grace period ended, re-invoke <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> on behalf of that
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a>.  Otherwise, set all state back to idle so that readers
can again use their fastpaths.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_sync_enter">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_sync_enter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_sync</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rsp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_enter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Force readers onto slowpath</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by updaters who need readers to make use of
a slowpath during the update.  After this function returns, all
subsequent calls to <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_is_idle()</span></code></a> will return false, which
tells readers to stay off their fastpaths.  A later call to
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a> re-enables reader fastpaths.</p>
<p>When called in isolation, <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> must wait for a grace
period, however, closely spaced calls to <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a> can
optimize away the grace-period wait via a state machine implemented
by <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_enter()</span></code></a>, <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_exit()</span></code></a>, and <a class="reference internal" href="#c.rcu_sync_func" title="rcu_sync_func"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_func()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_sync_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_sync_exit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_sync</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rsp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_exit" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allow readers back onto fast path after grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to use for synchronization</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by updaters who have completed, and can therefore
now allow readers to make use of their fastpaths after a grace period
has elapsed.  After this grace period has completed, all subsequent
calls to <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_sync_is_idle()</span></code></a> will return true, which tells readers that
they can once again use their fastpaths.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_sync_dtor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_sync_dtor</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_sync</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rsp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_dtor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean up an rcu_sync structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*rsp</span></code></dt><dd><p>Pointer to rcu_sync structure to be cleaned up</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.rcu_tasks_percpu">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_tasks_percpu</span></span></span><a class="headerlink" href="#c.rcu_tasks_percpu" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Per-CPU component of definition for a Tasks-RCU-like mechanism.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rcu_tasks_percpu {
    struct rcu_segcblist cblist;
    raw_spinlock_t __private lock;
    unsigned long rtp_jiffies;
    unsigned long rtp_n_lock_retries;
    struct timer_list lazy_timer;
    unsigned int urgent_gp;
    struct work_struct rtp_work;
    struct irq_work rtp_irq_work;
    struct rcu_head barrier_q_head;
    struct list_head rtp_blkd_tasks;
    int cpu;
    struct rcu_tasks *rtpp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cblist</span></code></dt><dd><p>Callback list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Lock protecting per-CPU callback list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtp_jiffies</span></code></dt><dd><p>Jiffies counter value for statistics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtp_n_lock_retries</span></code></dt><dd><p>Rough lock-contention statistic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lazy_timer</span></code></dt><dd><p>Timer to unlazify callbacks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">urgent_gp</span></code></dt><dd><p>Number of additional non-lazy grace periods.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtp_work</span></code></dt><dd><p>Work queue for invoking callbacks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtp_irq_work</span></code></dt><dd><p>IRQ work queue for deferred wakeups.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">barrier_q_head</span></code></dt><dd><p>RCU callback for barrier operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtp_blkd_tasks</span></code></dt><dd><p>List of tasks blocked as readers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu</span></code></dt><dd><p>CPU number corresponding to this entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtpp</span></code></dt><dd><p>Pointer to the rcu_tasks structure.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.rcu_tasks">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_tasks</span></span></span><a class="headerlink" href="#c.rcu_tasks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Definition for a Tasks-RCU-like mechanism.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rcu_tasks {
    struct rcuwait cbs_wait;
    raw_spinlock_t cbs_gbl_lock;
    struct mutex tasks_gp_mutex;
    int gp_state;
    int gp_sleep;
    int init_fract;
    unsigned long gp_jiffies;
    unsigned long gp_start;
    unsigned long tasks_gp_seq;
    unsigned long n_ipis;
    unsigned long n_ipis_fails;
    struct task_struct *kthread_ptr;
    unsigned long lazy_jiffies;
    rcu_tasks_gp_func_t gp_func;
    pregp_func_t pregp_func;
    pertask_func_t pertask_func;
    postscan_func_t postscan_func;
    holdouts_func_t holdouts_func;
    postgp_func_t postgp_func;
    call_rcu_func_t call_func;
    struct rcu_tasks_percpu __percpu *rtpcpu;
    int percpu_enqueue_shift;
    int percpu_enqueue_lim;
    int percpu_dequeue_lim;
    unsigned long percpu_dequeue_gpseq;
    struct mutex barrier_q_mutex;
    atomic_t barrier_q_count;
    struct completion barrier_q_completion;
    unsigned long barrier_q_seq;
    char *name;
    char *kname;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cbs_wait</span></code></dt><dd><p>RCU wait allowing a new callback to get kthread's attention.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cbs_gbl_lock</span></code></dt><dd><p>Lock protecting callback list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tasks_gp_mutex</span></code></dt><dd><p>Mutex protecting grace period, needed during mid-boot dead zone.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gp_state</span></code></dt><dd><p>Grace period's most recent state transition (debugging).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gp_sleep</span></code></dt><dd><p>Per-grace-period sleep to prevent CPU-bound looping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_fract</span></code></dt><dd><p>Initial backoff sleep interval.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gp_jiffies</span></code></dt><dd><p>Time of last <strong>gp_state</strong> transition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gp_start</span></code></dt><dd><p>Most recent grace-period start in jiffies.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tasks_gp_seq</span></code></dt><dd><p>Number of grace periods completed since boot.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_ipis</span></code></dt><dd><p>Number of IPIs sent to encourage grace periods to end.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_ipis_fails</span></code></dt><dd><p>Number of IPI-send failures.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kthread_ptr</span></code></dt><dd><p>This flavor's grace-period/callback-invocation kthread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lazy_jiffies</span></code></dt><dd><p>Number of jiffies to allow callbacks to be lazy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gp_func</span></code></dt><dd><p>This flavor's grace-period-wait function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pregp_func</span></code></dt><dd><p>This flavor's pre-grace-period function (optional).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pertask_func</span></code></dt><dd><p>This flavor's per-task scan function (optional).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">postscan_func</span></code></dt><dd><p>This flavor's post-task scan function (optional).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">holdouts_func</span></code></dt><dd><p>This flavor's holdout-list scan function (optional).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">postgp_func</span></code></dt><dd><p>This flavor's post-grace-period function (optional).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">call_func</span></code></dt><dd><p>This flavor's <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>-equivalent function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtpcpu</span></code></dt><dd><p>This flavor's rcu_tasks_percpu structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">percpu_enqueue_shift</span></code></dt><dd><p>Shift down CPU ID this much when enqueuing callbacks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">percpu_enqueue_lim</span></code></dt><dd><p>Number of per-CPU callback queues in use for enqueuing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">percpu_dequeue_lim</span></code></dt><dd><p>Number of per-CPU callback queues in use for dequeuing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">percpu_dequeue_gpseq</span></code></dt><dd><p>RCU grace-period number to propagate enqueue limit to dequeuers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">barrier_q_mutex</span></code></dt><dd><p>Serialize barrier operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">barrier_q_count</span></code></dt><dd><p>Number of queues being waited on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">barrier_q_completion</span></code></dt><dd><p>Barrier wait/wakeup mechanism.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">barrier_q_seq</span></code></dt><dd><p>Sequence number for barrier operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>This flavor's textual name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kname</span></code></dt><dd><p>This flavor's kthread name.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.call_rcu_tasks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">call_rcu_tasks</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rhp</span></span>, <span class="n"><span class="pre">rcu_callback_t</span></span><span class="w"> </span><span class="n"><span class="pre">func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_tasks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue an RCU for invocation task-based grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*rhp</span></code></dt><dd><p>structure to be used for queueing the RCU updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>actual callback function to be invoked after the grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_tasks()</span></code></a> assumes
that the read-side critical sections end at a voluntary context
switch (not a preemption!), <a class="reference internal" href="#c.cond_resched_tasks_rcu_qs" title="cond_resched_tasks_rcu_qs"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_resched_tasks_rcu_qs()</span></code></a>, entry into idle,
or transition to usermode execution.  As such, there are no read-side
primitives analogous to <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> because
this primitive is intended to determine that all tasks have passed
through a safe state, not so much for data-structure synchronization.</p>
<p>See the description of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.synchronize_rcu_tasks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">synchronize_rcu_tasks</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_tasks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait until an rcu-tasks grace period has elapsed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu-tasks
grace period has elapsed, in other words after all currently
executing rcu-tasks read-side critical sections have elapsed.  These
read-side critical sections are delimited by calls to schedule(),
<a class="reference internal" href="#c.cond_resched_tasks_rcu_qs" title="cond_resched_tasks_rcu_qs"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_resched_tasks_rcu_qs()</span></code></a>, idle execution, userspace execution, calls
to <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a>, and (in theory, anyway) cond_resched().</p>
<p>This is a very specialized primitive, intended only for a few uses in
tracing and other situations requiring manipulation of function
preambles and profiling hooks.  The <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks()</span></code></a> function
is not (yet) intended for heavy use from multiple CPUs.</p>
<p>See the description of <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> for more detailed information
on memory ordering guarantees.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_barrier_tasks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_barrier_tasks</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_tasks" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_tasks()</span></code></a> callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Although the current implementation is guaranteed to wait, it is not
obligated to, for example, if there are no pending callbacks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.call_rcu_tasks_rude">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">call_rcu_tasks_rude</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rhp</span></span>, <span class="n"><span class="pre">rcu_callback_t</span></span><span class="w"> </span><span class="n"><span class="pre">func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_tasks_rude" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue a callback rude task-based grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*rhp</span></code></dt><dd><p>structure to be used for queueing the RCU updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>actual callback function to be invoked after the grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="#c.call_rcu_tasks_rude" title="call_rcu_tasks_rude"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_tasks_rude()</span></code></a>
assumes that the read-side critical sections end at context switch,
<a class="reference internal" href="#c.cond_resched_tasks_rcu_qs" title="cond_resched_tasks_rcu_qs"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_resched_tasks_rcu_qs()</span></code></a>, or transition to usermode execution (as
usermode execution is schedulable). As such, there are no read-side
primitives analogous to <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> because
this primitive is intended to determine that all tasks have passed
through a safe state, not so much for data-structure synchronization.</p>
<p>See the description of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.synchronize_rcu_tasks_rude">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">synchronize_rcu_tasks_rude</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_tasks_rude" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for a rude rcu-tasks grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a rude rcu-tasks
grace period has elapsed, in other words after all currently
executing rcu-tasks read-side critical sections have elapsed.  These
read-side critical sections are delimited by calls to schedule(),
<a class="reference internal" href="#c.cond_resched_tasks_rcu_qs" title="cond_resched_tasks_rcu_qs"><code class="xref c c-func docutils literal notranslate"><span class="pre">cond_resched_tasks_rcu_qs()</span></code></a>, userspace execution (which is a schedulable
context), and (in theory, anyway) cond_resched().</p>
<p>This is a very specialized primitive, intended only for a few uses in
tracing and other situations requiring manipulation of function preambles
and profiling hooks.  The <a class="reference internal" href="#c.synchronize_rcu_tasks_rude" title="synchronize_rcu_tasks_rude"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks_rude()</span></code></a> function is not
(yet) intended for heavy use from multiple CPUs.</p>
<p>See the description of <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> for more detailed information
on memory ordering guarantees.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_barrier_tasks_rude">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_barrier_tasks_rude</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_tasks_rude" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="#c.call_rcu_tasks_rude" title="call_rcu_tasks_rude"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_tasks_rude()</span></code></a> callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Although the current implementation is guaranteed to wait, it is not
obligated to, for example, if there are no pending callbacks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.call_rcu_tasks_trace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">call_rcu_tasks_trace</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rhp</span></span>, <span class="n"><span class="pre">rcu_callback_t</span></span><span class="w"> </span><span class="n"><span class="pre">func</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_tasks_trace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue a callback trace task-based grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*rhp</span></code></dt><dd><p>structure to be used for queueing the RCU updates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt><dd><p>actual callback function to be invoked after the grace period</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a trace rcu-tasks
grace period elapses, in other words after all currently executing
trace rcu-tasks read-side critical sections have completed. These
read-side critical sections are delimited by calls to <a class="reference internal" href="#c.rcu_read_lock_trace" title="rcu_read_lock_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_trace()</span></code></a>
and <a class="reference internal" href="#c.rcu_read_unlock_trace" title="rcu_read_unlock_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_trace()</span></code></a>.</p>
<p>See the description of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.synchronize_rcu_tasks_trace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">synchronize_rcu_tasks_trace</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_tasks_trace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>wait for a trace rcu-tasks grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a trace rcu-tasks
grace period has elapsed, in other words after all currently executing
trace rcu-tasks read-side critical sections have elapsed. These read-side
critical sections are delimited by calls to <a class="reference internal" href="#c.rcu_read_lock_trace" title="rcu_read_lock_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_trace()</span></code></a>
and <a class="reference internal" href="#c.rcu_read_unlock_trace" title="rcu_read_unlock_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_trace()</span></code></a>.</p>
<p>This is a very specialized primitive, intended only for a few uses in
tracing and other situations requiring manipulation of function preambles
and profiling hooks.  The <a class="reference internal" href="#c.synchronize_rcu_tasks_trace" title="synchronize_rcu_tasks_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks_trace()</span></code></a> function is not
(yet) intended for heavy use from multiple CPUs.</p>
<p>See the description of <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> for more detailed information
on memory ordering guarantees.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_barrier_tasks_trace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_barrier_tasks_trace</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_tasks_trace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="#c.call_rcu_tasks_trace" title="call_rcu_tasks_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_tasks_trace()</span></code></a> callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Although the current implementation is guaranteed to wait, it is not
obligated to, for example, if there are no pending callbacks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_gp_might_be_stalled">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_gp_might_be_stalled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_gp_might_be_stalled" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Is it likely that the grace period is stalled?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <strong>true</strong> if the current grace period is sufficiently old that
it is reasonable to assume that it might be stalled.  This can be
useful when deciding whether to allocate memory to enable RCU-mediated
freeing on the one hand or just invoking <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> on the other.
The latter is preferable when the grace period is stalled.</p>
<p>Note that sampling of the .gp_start and .gp_seq fields must be done
carefully to avoid false positives at the beginnings and ends of
grace periods.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_cpu_stall_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_cpu_stall_reset</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_cpu_stall_reset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>restart stall-warning timeout for current grace period</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must disable hard irqs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_lock_trace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_lock_trace</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_trace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark beginning of RCU-trace read-side critical section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="#c.synchronize_rcu_tasks_trace" title="synchronize_rcu_tasks_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_tasks_trace()</span></code></a> is invoked by one task, then that
task is guaranteed to block until all other tasks exit their read-side
critical sections.  Similarly, if call_rcu_trace() is invoked on one
task while other tasks are within RCU read-side critical sections,
invocation of the corresponding RCU callback is deferred until after
the all the other tasks exit their critical sections.</p>
<p>For more details, please see the documentation for <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcu_read_unlock_trace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcu_read_unlock_trace</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_unlock_trace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>mark end of RCU-trace read-side critical section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pairs with a preceding call to <a class="reference internal" href="#c.rcu_read_lock_trace" title="rcu_read_lock_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_trace()</span></code></a>, and nesting is
allowed.  Invoking a <a class="reference internal" href="#c.rcu_read_unlock_trace" title="rcu_read_unlock_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_trace()</span></code></a> when there is no matching
<a class="reference internal" href="#c.rcu_read_lock_trace" title="rcu_read_lock_trace"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_trace()</span></code></a> is verboten, and will result in lockdep complaints.</p>
<p>For more details, please see the documentation for <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.synchronize_rcu_mult">
<span class="sig-name descname"><span class="n"><span class="pre">synchronize_rcu_mult</span></span></span><a class="headerlink" href="#c.synchronize_rcu_mult" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">synchronize_rcu_mult</span> <span class="pre">(...)</span></code></p>
<blockquote>
<div><p>Wait concurrently for multiple grace periods</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>List of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> functions for different grace periods to wait on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro waits concurrently for multiple types of RCU grace periods.
For example, synchronize_rcu_mult(call_rcu, call_rcu_tasks) would wait
on concurrent RCU and RCU-tasks grace periods.  Waiting on a given SRCU
domain requires you to write a wrapper function for that SRCU domain's
<a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> function, with this wrapper supplying the pointer to the
corresponding srcu_struct.</p>
<p>Note that <a class="reference internal" href="#c.call_rcu_hurry" title="call_rcu_hurry"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu_hurry()</span></code></a> should be used instead of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
because in kernels built with CONFIG_RCU_LAZY=y the delay between the
invocation of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> and that of the corresponding RCU callback
can be multiple seconds.</p>
<p>The first argument tells Tiny RCU's _wait_rcu_gp() not to
bother waiting for RCU.  The reason for this is because anywhere
<a class="reference internal" href="#c.synchronize_rcu_mult" title="synchronize_rcu_mult"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_mult()</span></code></a> can be called is automatically already a full
grace period.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcuref_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcuref_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">rcuref_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ref</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cnt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcuref_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize a rcuref reference count with the given reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcuref_t</span> <span class="pre">*ref</span></code></dt><dd><p>Pointer to the reference count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cnt</span></code></dt><dd><p>The initial reference count typically '1'</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcuref_read">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcuref_read</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">rcuref_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcuref_read" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read the number of held reference counts of a rcuref</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcuref_t</span> <span class="pre">*ref</span></code></dt><dd><p>Pointer to the reference count</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of held references (0 ... N)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcuref_get">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcuref_get</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">rcuref_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcuref_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Acquire one reference on a rcuref reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcuref_t</span> <span class="pre">*ref</span></code></dt><dd><p>Pointer to the reference count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="../driver-api/basics.html#c.atomic_inc_not_zero" title="atomic_inc_not_zero"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc_not_zero()</span></code></a> but saturates at RCUREF_MAXREF.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See documentation in lib/rcuref.c</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>False if the attempt to acquire a reference failed. This happens
when the last reference has been put already</p>
<p>True if a reference was successfully acquired</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcuref_put_rcusafe">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcuref_put_rcusafe</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">rcuref_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcuref_put_rcusafe" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>Release one reference for a rcuref reference count RCU safe</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcuref_t</span> <span class="pre">*ref</span></code></dt><dd><p>Pointer to the reference count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides an acquire ordering on success such that free()
must come after.</p>
<p>Can be invoked from contexts, which guarantee that no grace period can
happen which would free the object concurrently if the decrement drops
the last reference and the slowpath races against a concurrent get() and
put() pair. <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>'ed and atomic contexts qualify.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if this was the last reference with no future references
possible. This signals the caller that it can safely release the
object which is protected by the reference counter.</p>
<p>False if there are still active references or the put() raced
with a concurrent get()/put() pair. Caller is not allowed to
release the protected object.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.rcuref_put">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">rcuref_put</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">rcuref_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.rcuref_put" title="Permalink to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>Release one reference for a rcuref reference count</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcuref_t</span> <span class="pre">*ref</span></code></dt><dd><p>Pointer to the reference count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Can be invoked from any context.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides an acquire ordering on success such that free()
must come after.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if this was the last reference with no future references
possible. This signals the caller that it can safely schedule the
object, which is protected by the reference counter, for
deconstruction.</p>
<p>False if there are still active references or the put() raced
with a concurrent get()/put() pair. Caller is not allowed to
deconstruct the protected object.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.same_state_synchronize_rcu_full">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">same_state_synchronize_rcu_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp1</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">rcu_gp_oldstate</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rgosp2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.same_state_synchronize_rcu_full" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Are two old-state values identical?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp1</span></code></dt><dd><p>First old-state value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_gp_oldstate</span> <span class="pre">*rgosp2</span></code></dt><dd><p>Second old-state value.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The two old-state values must have been obtained from either
<a class="reference internal" href="#c.get_state_synchronize_rcu_full" title="get_state_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu_full()</span></code></a>, <a class="reference internal" href="#c.start_poll_synchronize_rcu_full" title="start_poll_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_poll_synchronize_rcu_full()</span></code></a>,
or <a class="reference internal" href="#c.get_completed_synchronize_rcu_full" title="get_completed_synchronize_rcu_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_completed_synchronize_rcu_full()</span></code></a>.  Returns <strong>true</strong> if the two
values are identical and <strong>false</strong> otherwise.  This allows structures
whose lifetimes are tracked by old-state values to push these values
to a list header, allowing those structures to be slightly smaller.</p>
<p>Note that equality is judged on a bitwise basis, so that an
<strong>rcu_gp_oldstate</strong> structure with an already-completed state in one field
will compare not-equal to a structure with an already-completed state
in the other field.  After all, the <strong>rcu_gp_oldstate</strong> structure is opaque
so how did such a situation come to pass in the first place?</p>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/kernel-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>