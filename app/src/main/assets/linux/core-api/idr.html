
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>ID Allocation &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Circular Buffers" href="circular-buffers.html" />
    <link rel="prev" title="Maple Tree" href="maple_tree.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.8.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kobject.html">Everything you never wanted to know about kobjects, ksets, and ktypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="kref.html">Adding reference counters (krefs) to kernel objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="xarray.html">XArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="maple_tree.html">Maple Tree</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">ID Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="circular-buffers.html">Circular Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="rbtree.html">Red-black Trees (rbtree) in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-radix-tree.html">Generic radix trees/sparse arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="packing.html">Generic bitfield packing and unpacking functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="this_cpu_ops.html">this_cpu operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="timekeeping.html">ktime accessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="errseq.html">The errseq_t datatype</a></li>
<li class="toctree-l3"><a class="reference internal" href="wrappers/atomic_t.html">Atomic types</a></li>
<li class="toctree-l3"><a class="reference internal" href="wrappers/atomic_bitops.html">Atomic bitops</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Kernel subsystem documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RAS/ras.html">Reliability, Availability and Serviceability features</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/idr.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../translations/zh_CN/core-api/idr.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="id-allocation">
<h1>ID Allocation<a class="headerlink" href="#id-allocation" title="Permalink to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Matthew Wilcox</p>
</dd>
</dl>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>A common problem to solve is allocating identifiers (IDs); generally
small numbers which identify a thing.  Examples include file descriptors,
process IDs, packet identifiers in networking protocols, SCSI tags
and device instance numbers.  The IDR and the IDA provide a reasonable
solution to the problem to avoid everybody inventing their own.  The IDR
provides the ability to map an ID to a pointer, while the IDA provides
only ID allocation, and as a result is much more memory-efficient.</p>
<p>The IDR interface is deprecated; please use the <a class="reference internal" href="xarray.html"><span class="doc">XArray</span></a>
instead.</p>
</section>
<section id="idr-usage">
<h2>IDR usage<a class="headerlink" href="#idr-usage" title="Permalink to this heading">¶</a></h2>
<p>Start by initialising an IDR, either with <a class="reference internal" href="#c.DEFINE_IDR" title="DEFINE_IDR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_IDR()</span></code></a>
for statically allocated IDRs or <a class="reference internal" href="#c.idr_init" title="idr_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_init()</span></code></a> for dynamically
allocated IDRs.</p>
<p>You can call <a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc()</span></code></a> to allocate an unused ID.  Look up
the pointer you associated with the ID by calling <a class="reference internal" href="#c.idr_find" title="idr_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_find()</span></code></a>
and free the ID by calling <a class="reference internal" href="#c.idr_remove" title="idr_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_remove()</span></code></a>.</p>
<p>If you need to change the pointer associated with an ID, you can call
<a class="reference internal" href="#c.idr_replace" title="idr_replace"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_replace()</span></code></a>.  One common reason to do this is to reserve an
ID by passing a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer to the allocation function; initialise the
object with the reserved ID and finally insert the initialised object
into the IDR.</p>
<p>Some users need to allocate IDs larger than <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>.  So far all of
these users have been content with a <code class="docutils literal notranslate"><span class="pre">UINT_MAX</span></code> limit, and they use
<a class="reference internal" href="#c.idr_alloc_u32" title="idr_alloc_u32"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc_u32()</span></code></a>.  If you need IDs that will not fit in a u32,
we will work with you to address your needs.</p>
<p>If you need to allocate IDs sequentially, you can use
<a class="reference internal" href="#c.idr_alloc_cyclic" title="idr_alloc_cyclic"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc_cyclic()</span></code></a>.  The IDR becomes less efficient when dealing
with larger IDs, so using this function comes at a slight cost.</p>
<p>To perform an action on all pointers used by the IDR, you can
either use the callback-based <a class="reference internal" href="#c.idr_for_each" title="idr_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_for_each()</span></code></a> or the
iterator-style <a class="reference internal" href="#c.idr_for_each_entry" title="idr_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_for_each_entry()</span></code></a>.  You may need to use
<a class="reference internal" href="#c.idr_for_each_entry_continue" title="idr_for_each_entry_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_for_each_entry_continue()</span></code></a> to continue an iteration.  You can
also use <a class="reference internal" href="#c.idr_get_next" title="idr_get_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_get_next()</span></code></a> if the iterator doesn't fit your needs.</p>
<p>When you have finished using an IDR, you can call idr_destroy()
to release the memory used by the IDR.  This will not free the objects
pointed to from the IDR; if you want to do that, use one of the iterators
to do it.</p>
<p>You can use <a class="reference internal" href="#c.idr_is_empty" title="idr_is_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_is_empty()</span></code></a> to find out whether there are any
IDs currently allocated.</p>
<p>If you need to take a lock while allocating a new ID from the IDR,
you may need to pass a restrictive set of GFP flags, which can lead
to the IDR being unable to allocate memory.  To work around this,
you can call idr_preload() before taking the lock, and then
<a class="reference internal" href="#c.idr_preload_end" title="idr_preload_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_preload_end()</span></code></a> after the allocation.</p>
<p>idr synchronization (stolen from radix-tree.h)</p>
<p><a class="reference internal" href="#c.idr_find" title="idr_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_find()</span></code></a> is able to be called locklessly, using RCU. The caller must
ensure calls to this function are made within <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> regions.
Other readers (lock-free or otherwise) and modifications may be running
concurrently.</p>
<p>It is still required that the caller manage the synchronization and
lifetimes of the items. So if RCU lock-free lookups are used, typically
this would mean that the items have their own locks, or are amenable to
lock-free access; and that the items are freed by RCU (or only freed after
having been deleted from the idr tree <em>and</em> a <a class="reference internal" href="kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> grace
period).</p>
</section>
<section id="ida-usage">
<h2>IDA usage<a class="headerlink" href="#ida-usage" title="Permalink to this heading">¶</a></h2>
<p>The IDA is an ID allocator which does not provide the ability to
associate an ID with a pointer.  As such, it only needs to store one
bit per ID, and so is more space efficient than an IDR.  To use an IDA,
define it using DEFINE_IDA() (or embed a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span></code> in a data structure,
then initialise it using ida_init()).  To allocate a new ID, call
<a class="reference internal" href="#c.ida_alloc" title="ida_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_alloc()</span></code></a>, <a class="reference internal" href="#c.ida_alloc_min" title="ida_alloc_min"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_alloc_min()</span></code></a>, <a class="reference internal" href="#c.ida_alloc_max" title="ida_alloc_max"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_alloc_max()</span></code></a> or <a class="reference internal" href="#c.ida_alloc_range" title="ida_alloc_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_alloc_range()</span></code></a>.
To free an ID, call <a class="reference internal" href="#c.ida_free" title="ida_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_free()</span></code></a>.</p>
<p><a class="reference internal" href="#c.ida_destroy" title="ida_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">ida_destroy()</span></code></a> can be used to dispose of an IDA without needing to
free the individual IDs in it.  You can use ida_is_empty() to find
out whether the IDA has any IDs currently allocated.</p>
<p>The IDA handles its own locking.  It is safe to call any of the IDA
functions without synchronisation in your code.</p>
<p>IDs are currently limited to the range [0-INT_MAX].  If this is an awkward
limitation, it should be quite straightforward to raise the maximum.</p>
</section>
<section id="functions-and-structures">
<h2>Functions and structures<a class="headerlink" href="#functions-and-structures" title="Permalink to this heading">¶</a></h2>
<dl class="c macro">
<dt class="sig sig-object c" id="c.IDR_INIT">
<span class="sig-name descname"><span class="n"><span class="pre">IDR_INIT</span></span></span><a class="headerlink" href="#c.IDR_INIT" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">IDR_INIT</span> <span class="pre">(name)</span></code></p>
<blockquote>
<div><p>Initialise an IDR.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of IDR.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A freshly-initialised IDR contains no IDs.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFINE_IDR">
<span class="sig-name descname"><span class="n"><span class="pre">DEFINE_IDR</span></span></span><a class="headerlink" href="#c.DEFINE_IDR" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEFINE_IDR</span> <span class="pre">(name)</span></code></p>
<blockquote>
<div><p>Define a statically-allocated IDR.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of IDR.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An IDR defined using this macro is ready for use with no additional
initialisation required.  It contains no IDs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_get_cursor">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_get_cursor</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_get_cursor" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_get_cursor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the current position of the cyclic allocator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>idr handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The value returned is the value that will be next returned from
<a class="reference internal" href="#c.idr_alloc_cyclic" title="idr_alloc_cyclic"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc_cyclic()</span></code></a> if it is free (otherwise the search will start from
this position).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_set_cursor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_set_cursor</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_set_cursor" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">val</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_set_cursor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the current position of the cyclic allocator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>idr handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>new position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The next call to <a class="reference internal" href="#c.idr_alloc_cyclic" title="idr_alloc_cyclic"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc_cyclic()</span></code></a> will return <strong>val</strong> if it is free
(otherwise the search will start from this position).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_init_base">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_init_base</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_init_base" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_init_base" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise an IDR.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>The base value for the IDR.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variation of <a class="reference internal" href="#c.idr_init" title="idr_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_init()</span></code></a> creates an IDR which will allocate IDs
starting at <code class="docutils literal notranslate"><span class="pre">base</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_init" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_init" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialise an IDR.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise a dynamically allocated IDR.  To initialise a
statically allocated IDR, use <a class="reference internal" href="#c.DEFINE_IDR" title="DEFINE_IDR"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_IDR()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_is_empty">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_is_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_is_empty" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_is_empty" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Are there any IDs allocated?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if any IDs have been allocated from this IDR.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_preload_end">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_preload_end</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_preload_end" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>end preload section started with idr_preload()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each idr_preload() should be matched with an invocation of this
function.  See idr_preload() for details.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.idr_for_each_entry">
<span class="sig-name descname"><span class="n"><span class="pre">idr_for_each_entry</span></span></span><a class="headerlink" href="#c.idr_for_each_entry" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">idr_for_each_entry</span> <span class="pre">(idr,</span> <span class="pre">entry,</span> <span class="pre">id)</span></code></p>
<blockquote>
<div><p>Iterate over an IDR's elements of a given type.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>The type * to use as cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Entry ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>entry</strong> and <strong>id</strong> do not need to be initialized before the loop, and
after normal termination <strong>entry</strong> is left with the value NULL.  This
is convenient for a &quot;not found&quot; value.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.idr_for_each_entry_ul">
<span class="sig-name descname"><span class="n"><span class="pre">idr_for_each_entry_ul</span></span></span><a class="headerlink" href="#c.idr_for_each_entry_ul" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">idr_for_each_entry_ul</span> <span class="pre">(idr,</span> <span class="pre">entry,</span> <span class="pre">tmp,</span> <span class="pre">id)</span></code></p>
<blockquote>
<div><p>Iterate over an IDR's elements of a given type.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>The type * to use as cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tmp</span></code></dt><dd><p>A temporary placeholder for ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Entry ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>entry</strong> and <strong>id</strong> do not need to be initialized before the loop, and
after normal termination <strong>entry</strong> is left with the value NULL.  This
is convenient for a &quot;not found&quot; value.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.idr_for_each_entry_continue">
<span class="sig-name descname"><span class="n"><span class="pre">idr_for_each_entry_continue</span></span></span><a class="headerlink" href="#c.idr_for_each_entry_continue" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">idr_for_each_entry_continue</span> <span class="pre">(idr,</span> <span class="pre">entry,</span> <span class="pre">id)</span></code></p>
<blockquote>
<div><p>Continue iteration over an IDR's elements of a given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>The type * to use as a cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Entry ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over entries, continuing after the current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.idr_for_each_entry_continue_ul">
<span class="sig-name descname"><span class="n"><span class="pre">idr_for_each_entry_continue_ul</span></span></span><a class="headerlink" href="#c.idr_for_each_entry_continue_ul" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">idr_for_each_entry_continue_ul</span> <span class="pre">(idr,</span> <span class="pre">entry,</span> <span class="pre">tmp,</span> <span class="pre">id)</span></code></p>
<blockquote>
<div><p>Continue iteration over an IDR's elements of a given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>The type * to use as a cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tmp</span></code></dt><dd><p>A temporary placeholder for ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Entry ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over entries, continuing after the current position.
After normal termination <strong>entry</strong> is left with the value NULL.  This
is convenient for a &quot;not found&quot; value.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ida_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ida_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ida_alloc" title="ida"><span class="n"><span class="pre">ida</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ida</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an unused ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*ida</span></code></dt><dd><p>IDA handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ID between 0 and <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>, inclusive.</p>
<p><strong>Context</strong></p>
<p>Any context. It is safe to call this function without
locking in your code.</p>
<p><strong>Return</strong></p>
<p>The allocated ID, or <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if memory could not be allocated,
or <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if there are no free IDs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ida_alloc_min">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ida_alloc_min</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ida_alloc_min" title="ida"><span class="n"><span class="pre">ida</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ida</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_alloc_min" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an unused ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*ida</span></code></dt><dd><p>IDA handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>Lowest ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ID between <strong>min</strong> and <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>, inclusive.</p>
<p><strong>Context</strong></p>
<p>Any context. It is safe to call this function without
locking in your code.</p>
<p><strong>Return</strong></p>
<p>The allocated ID, or <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if memory could not be allocated,
or <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if there are no free IDs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ida_alloc_max">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ida_alloc_max</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ida_alloc_max" title="ida"><span class="n"><span class="pre">ida</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ida</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_alloc_max" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an unused ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*ida</span></code></dt><dd><p>IDA handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>Highest ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ID between 0 and <strong>max</strong>, inclusive.</p>
<p><strong>Context</strong></p>
<p>Any context. It is safe to call this function without
locking in your code.</p>
<p><strong>Return</strong></p>
<p>The allocated ID, or <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if memory could not be allocated,
or <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if there are no free IDs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_alloc_u32">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_alloc_u32</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_alloc_u32" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nextid</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc_u32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>Pointer to be associated with the new ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*nextid</span></code></dt><dd><p>Pointer to an ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>The maximum ID to allocate (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an unused ID in the range specified by <strong>nextid</strong> and <strong>max</strong>.
Note that <strong>max</strong> is inclusive whereas the <strong>end</strong> parameter to <a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc()</span></code></a>
is exclusive.  The new ID is assigned to <strong>nextid</strong> before the pointer
is inserted into the IDR, so if <strong>nextid</strong> points into the object pointed
to by <strong>ptr</strong>, a concurrent lookup will not find an uninitialised ID.</p>
<p>The caller should provide their own locking to ensure that two
concurrent modifications to the IDR are not possible.  Read-only
accesses to the IDR may be done under the RCU read lock or may
exclude simultaneous writers.</p>
<p><strong>Return</strong></p>
<p>0 if an ID was allocated, -ENOMEM if memory allocation failed,
or -ENOSPC if no free IDs could be found.  If an error occurred,
<strong>nextid</strong> is unchanged.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_alloc" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>Pointer to be associated with the new ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">start</span></code></dt><dd><p>The minimum ID (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">end</span></code></dt><dd><p>The maximum ID (exclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an unused ID in the range specified by <strong>start</strong> and <strong>end</strong>.  If
<strong>end</strong> is &lt;= 0, it is treated as one larger than <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>.  This allows
callers to use <strong>start</strong> + N as <strong>end</strong> as long as N is within integer range.</p>
<p>The caller should provide their own locking to ensure that two
concurrent modifications to the IDR are not possible.  Read-only
accesses to the IDR may be done under the RCU read lock or may
exclude simultaneous writers.</p>
<p><strong>Return</strong></p>
<p>The newly allocated ID, -ENOMEM if memory allocation failed,
or -ENOSPC if no free IDs could be found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_alloc_cyclic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_alloc_cyclic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_alloc_cyclic" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc_cyclic" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an ID cyclically.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>Pointer to be associated with the new ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">start</span></code></dt><dd><p>The minimum ID (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">end</span></code></dt><dd><p>The maximum ID (exclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an unused ID in the range specified by <strong>start</strong> and <strong>end</strong>.  If
<strong>end</strong> is &lt;= 0, it is treated as one larger than <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>.  This allows
callers to use <strong>start</strong> + N as <strong>end</strong> as long as N is within integer range.
The search for an unused ID will start at the last ID allocated and will
wrap around to <strong>start</strong> if no free IDs are found before reaching <strong>end</strong>.</p>
<p>The caller should provide their own locking to ensure that two
concurrent modifications to the IDR are not possible.  Read-only
accesses to the IDR may be done under the RCU read lock or may
exclude simultaneous writers.</p>
<p><strong>Return</strong></p>
<p>The newly allocated ID, -ENOMEM if memory allocation failed,
or -ENOSPC if no free IDs could be found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">idr_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_remove" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_remove" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove an ID from the IDR.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">id</span></code></dt><dd><p>Pointer ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes this ID from the IDR.  If the ID was not previously in the IDR,
this function returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Since this function modifies the IDR, the caller should provide their
own locking to ensure that concurrent modification of the same IDR is
not possible.</p>
<p><strong>Return</strong></p>
<p>The pointer formerly associated with this ID.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_find">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">idr_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_find" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_find" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return pointer for given ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">id</span></code></dt><dd><p>Pointer ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the pointer associated with this ID.  A <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer may
indicate that <strong>id</strong> is not allocated or that the <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer was
associated with this ID.</p>
<p>This function can be called under <a class="reference internal" href="kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>, given that the leaf
pointers lifetimes are correctly managed.</p>
<p><strong>Return</strong></p>
<p>The pointer associated with this ID.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_for_each">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">idr_for_each</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_for_each" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fn</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_for_each" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Iterate through all stored pointers.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(int</span> <span class="pre">id,</span> <span class="pre">void</span> <span class="pre">*p,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>Function to be called for each pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data passed to callback function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be called for each entry in <strong>idr</strong>, passing
the ID, the entry and <strong>data</strong>.</p>
<p>If <strong>fn</strong> returns anything other than <code class="docutils literal notranslate"><span class="pre">0</span></code>, the iteration stops and that
value is returned from this function.</p>
<p><a class="reference internal" href="#c.idr_for_each" title="idr_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_for_each()</span></code></a> can be called concurrently with <a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc()</span></code></a> and
<a class="reference internal" href="#c.idr_remove" title="idr_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_remove()</span></code></a> if protected by RCU.  Newly added entries may not be
seen and deleted entries may be seen, but adding and removing entries
will not cause other entries to be skipped, nor spurious ones to be seen.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_get_next_ul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">idr_get_next_ul</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_get_next_ul" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nextid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_get_next_ul" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find next populated entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*nextid</span></code></dt><dd><p>Pointer to an ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next populated entry in the tree with an ID greater than
or equal to the value pointed to by <strong>nextid</strong>.  On exit, <strong>nextid</strong> is updated
to the ID of the found value.  To use in a loop, the value pointed to by
nextid must be incremented by the user.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_get_next">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">idr_get_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_get_next" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nextid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_get_next" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Find next populated entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*nextid</span></code></dt><dd><p>Pointer to an ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next populated entry in the tree with an ID greater than
or equal to the value pointed to by <strong>nextid</strong>.  On exit, <strong>nextid</strong> is updated
to the ID of the found value.  To use in a loop, the value pointed to by
nextid must be incremented by the user.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.idr_replace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">idr_replace</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.idr_replace" title="idr"><span class="n"><span class="pre">idr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">idr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_replace" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>replace pointer for given ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*idr</span></code></dt><dd><p>IDR handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>New pointer to associate with the ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">id</span></code></dt><dd><p>ID to change.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace the pointer registered with an ID and return the old value.
This function can be called under the RCU read lock concurrently with
<a class="reference internal" href="#c.idr_alloc" title="idr_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_alloc()</span></code></a> and <a class="reference internal" href="#c.idr_remove" title="idr_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">idr_remove()</span></code></a> (as long as the ID being removed is not
the one being replaced!).</p>
<p><strong>Return</strong></p>
<p>the old value on success.  <code class="docutils literal notranslate"><span class="pre">-ENOENT</span></code> indicates that <strong>id</strong> was not
found.  <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> indicates that <strong>ptr</strong> was not valid.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ida_alloc_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ida_alloc_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ida_alloc_range" title="ida"><span class="n"><span class="pre">ida</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ida</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_alloc_range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate an unused ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*ida</span></code></dt><dd><p>IDA handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>Lowest ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>Highest ID to allocate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Memory allocation flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ID between <strong>min</strong> and <strong>max</strong>, inclusive.  The allocated ID will
not exceed <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code>, even if <strong>max</strong> is larger.</p>
<p><strong>Context</strong></p>
<p>Any context. It is safe to call this function without
locking in your code.</p>
<p><strong>Return</strong></p>
<p>The allocated ID, or <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if memory could not be allocated,
or <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if there are no free IDs.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ida_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ida_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ida_free" title="ida"><span class="n"><span class="pre">ida</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ida</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_free" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release an allocated ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*ida</span></code></dt><dd><p>IDA handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>Previously allocated ID.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context. It is safe to call this function without
locking in your code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ida_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ida_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ida_destroy" title="ida"><span class="n"><span class="pre">ida</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ida</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_destroy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free all IDs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*ida</span></code></dt><dd><p>IDA handle.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function frees all IDs and releases all resources used
by an IDA.  When this call returns, the IDA is empty and can be reused
or freed.  If the IDA is already empty, there is no need to call this
function.</p>
<p><strong>Context</strong></p>
<p>Any context. It is safe to call this function without
locking in your code.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/core-api/idr.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>