<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>2. Come funziona il processo di sviluppo &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="3. I primi passi della pianificazione" href="3.Early-stage.html" />
    <link rel="prev" title="1. Introduzione" href="1.Intro.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.9.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Translations</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../zh_CN/index.html">中文翻译</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../zh_TW/index.html">繁體中文翻譯</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">La documentazione del kernel Linux</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../index.html#avvertenze">Avvertenze</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#lavorare-con-la-comunita-di-sviluppo">Lavorare con la comunità di sviluppo</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#manuali-sull-api-interna">Manuali sull’API interna</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#strumenti-e-processi-per-lo-sviluppo">Strumenti e processi per lo sviluppo</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#documentazione-per-gli-utenti">Documentazione per gli utenti</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#documentazione-relativa-ai-firmware">Documentazione relativa ai firmware</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#documentazione-specifica-per-architettura">Documentazione specifica per architettura</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#documentazione-varia">Documentazione varia</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ko_KR/index.html">한국어 번역</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ja_JP/index.html">日本語訳</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sp_SP/index.html">Traducción al español</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/it_IT/process/2.Process.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
Italian

<ul>

<li><a href="../../../process/2.Process.html">English</a></li>

<li><a href="../../zh_CN/process/2.Process.html">Chinese (Simplified)</a></li>

<li><a href="../../zh_TW/process/2.Process.html">Chinese (Traditional)</a></li>

</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In caso di dubbi sulla correttezza del contenuto di questa traduzione,
l’unico riferimento valido è la documentazione ufficiale in inglese.
Per maggiori informazioni consultate le <a class="reference internal" href="../index.html#it-disclaimer"><span class="std std-ref">avvertenze</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../process/2.Process.html#development-process"><span class="std std-ref">Documentation/process/2.Process.rst</span></a></p>
</dd>
<dt class="field-even">Translator<span class="colon">:</span></dt>
<dd class="field-even"><p>Alessia Mantegazza &lt;<a class="reference external" href="mailto:amantegazza&#37;&#52;&#48;vaga&#46;pv&#46;it">amantegazza<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</p>
</dd>
</dl>
<section id="come-funziona-il-processo-di-sviluppo">
<span id="it-development-process"></span><h1><span class="section-number">2. </span>Come funziona il processo di sviluppo<a class="headerlink" href="#come-funziona-il-processo-di-sviluppo" title="Link to this heading">¶</a></h1>
<p>Lo sviluppo del Kernel agli inizi degli anno ‘90 era abbastanza libero, con
un numero di utenti e sviluppatori relativamente basso.  Con una base
di milioni di utenti e con 2000 sviluppatori coinvolti nel giro di un anno,
il kernel da allora ha messo in atto un certo numero di procedure per rendere
lo sviluppo più agevole.  È richiesta una solida conoscenza di come tale
processo si svolge per poter esserne parte attiva.</p>
<section id="il-quadro-d-insieme">
<h2><span class="section-number">2.1. </span>Il quadro d’insieme<a class="headerlink" href="#il-quadro-d-insieme" title="Link to this heading">¶</a></h2>
<p>Gli sviluppatori kernel utilizzano un calendario di rilascio generico, dove
ogni due o tre mesi viene effettuata un rilascio importante del kernel.
I rilasci più recenti sono stati:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>5.0</p></td>
<td><p>3 marzo, 2019</p></td>
</tr>
<tr class="row-even"><td><p>5.1</p></td>
<td><p>5 maggio, 2019</p></td>
</tr>
<tr class="row-odd"><td><p>5.2</p></td>
<td><p>7 luglio, 2019</p></td>
</tr>
<tr class="row-even"><td><p>5.3</p></td>
<td><p>15 settembre, 2019</p></td>
</tr>
<tr class="row-odd"><td><p>5.4</p></td>
<td><p>24 novembre, 2019</p></td>
</tr>
<tr class="row-even"><td><p>5.5</p></td>
<td><p>6 gennaio, 2020</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Ciascun rilascio 5.x è un importante rilascio del kernel con nuove
funzionalità, modifiche interne dell’API, e molto altro.  Un tipico
rilascio contiene quasi 13,000 gruppi di modifiche con ulteriori
modifiche a parecchie migliaia di linee di codice.  La 5.x. è pertanto la
linea di confine nello sviluppo del kernel Linux; il kernel utilizza un sistema
di sviluppo continuo che integra costantemente nuove importanti modifiche.</p>
<p>Viene seguita una disciplina abbastanza lineare per l’inclusione delle
patch di ogni rilascio. All’inizio di ogni ciclo di sviluppo, la
“finestra di inclusione” viene dichiarata aperta.  In quel momento il codice
ritenuto sufficientemente stabile(e che è accettato dalla comunità di sviluppo)
viene incluso nel ramo principale del kernel.  La maggior parte delle
patch per un nuovo ciclo di sviluppo (e tutte le più importanti modifiche)
saranno inserite durante questo periodo, ad un ritmo che si attesta sulle
1000 modifiche (“patch” o “gruppo di modifiche”) al giorno.</p>
<p>(per inciso, vale la pena notare che i cambiamenti integrati durante la
“finestra di inclusione” non escono dal nulla; questi infatti, sono stati
raccolti e, verificati in anticipo.  Il funzionamento di tale procedimento
verrà descritto dettagliatamente più avanti).</p>
<p>La finestra di inclusione resta attiva approssimativamente per due settimane.
Al termine di questo periodo, Linus Torvald dichiarerà che la finestra è
chiusa e rilascerà il primo degli “rc” del kernel.
Per il kernel che è destinato ad essere 5.6, per esempio, il rilascio
che emerge al termine della finestra d’inclusione si chiamerà 5.6-rc1.
Questo rilascio indica che il momento di aggiungere nuovi componenti è
passato, e che è iniziato il periodo di stabilizzazione del prossimo kernel.</p>
<p>Nelle successive sei/dieci settimane, potranno essere sottoposte solo modifiche
che vanno a risolvere delle problematiche.  Occasionalmente potrà essere
consentita una modifica più consistente, ma tali occasioni sono rare.
Gli sviluppatori che tenteranno di aggiungere nuovi elementi al di fuori della
finestra di inclusione, tendenzialmente, riceveranno un accoglienza poco
amichevole. Come regola generale: se vi perdete la finestra di inclusione per
un dato componente, la cosa migliore da fare è aspettare il ciclo di sviluppo
successivo (un’eccezione può essere fatta per i driver per hardware non
supportati in precedenza; se toccano codice non facente parte di quello
attuale, che non causino regressioni e che potrebbero essere aggiunti in
sicurezza in un qualsiasi momento)</p>
<p>Mentre le correzioni si aprono la loro strada all’interno del ramo principale,
il ritmo delle modifiche rallenta col tempo.  Linus rilascia un nuovo
kernel -rc circa una volta alla settimana; e ne usciranno circa 6 o 9 prima
che il kernel venga considerato sufficientemente stabile e che il rilascio
finale venga fatto.  A quel punto tutto il processo ricomincerà.</p>
<p>Esempio: ecco com’è andato il ciclo di sviluppo della versione 5.4
(tutte le date si collocano nel 2018)</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>15 settembre</p></td>
<td><p>5.3 rilascio stabile</p></td>
</tr>
<tr class="row-even"><td><p>30 settembre</p></td>
<td><p>5.4-rc1, finestra di inclusione chiusa</p></td>
</tr>
<tr class="row-odd"><td><p>6 ottobre</p></td>
<td><p>5.4-rc2</p></td>
</tr>
<tr class="row-even"><td><p>13 ottobre</p></td>
<td><p>5.4-rc3</p></td>
</tr>
<tr class="row-odd"><td><p>20 ottobre</p></td>
<td><p>5.4-rc4</p></td>
</tr>
<tr class="row-even"><td><p>27 ottobre</p></td>
<td><p>5.4-rc5</p></td>
</tr>
<tr class="row-odd"><td><p>3 novembre</p></td>
<td><p>5.4-rc6</p></td>
</tr>
<tr class="row-even"><td><p>10 novembre</p></td>
<td><p>5.4-rc7</p></td>
</tr>
<tr class="row-odd"><td><p>17 novembre</p></td>
<td><p>5.4-rc8</p></td>
</tr>
<tr class="row-even"><td><p>24 novembre</p></td>
<td><p>5.4 rilascio stabile</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In che modo gli sviluppatori decidono quando chiudere il ciclo di sviluppo e
creare quindi una rilascio stabile? Un metro valido è il numero di regressioni
rilevate nel precedente rilascio.  Nessun baco è il benvenuto, ma quelli che
procurano problemi su sistemi che hanno funzionato in passato sono considerati
particolarmente seri.  Per questa ragione, le modifiche che portano ad una
regressione sono viste sfavorevolmente e verranno quasi sicuramente annullate
durante il periodo di stabilizzazione.</p>
<p>L’obiettivo degli sviluppatori è quello di aggiustare tutte le regressioni
conosciute prima che avvenga il rilascio stabile.  Nel mondo reale, questo
tipo di perfezione difficilmente viene raggiunta; esistono troppe variabili
in un progetto di questa portata.  Arriva un punto dove ritardare il rilascio
finale peggiora la situazione; la quantità di modifiche in attesa della
prossima finestra di inclusione crescerà enormemente, creando ancor più
regressioni al giro successivo.  Quindi molti kernel 5.x escono con una
manciata di regressioni delle quali, si spera, nessuna è grave.</p>
<p>Una volta che un rilascio stabile è fatto, il suo costante mantenimento è
affidato al “squadra stabilità”, attualmente composta da Greg Kroah-Hartman.
Questa squadra rilascia occasionalmente degli aggiornamenti relativi al
rilascio stabile usando la numerazione 5.x.y.  Per essere presa in
considerazione per un rilascio d’aggiornamento, una modifica deve:
(1) correggere un baco importante (2) essere già inserita nel ramo principale
per il prossimo sviluppo del kernel.  Solitamente, passato il loro rilascio
iniziale, i kernel ricevono aggiornamenti per più di un ciclo di sviluppo.
Quindi, per esempio, la storia del kernel 5.2 appare così (anno 2019):</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>7 luglio</p></td>
<td><p>5.2 rilascio stabile</p></td>
</tr>
<tr class="row-even"><td><p>14 luglio</p></td>
<td><p>5.2.1</p></td>
</tr>
<tr class="row-odd"><td><p>21 luglio</p></td>
<td><p>5.2.2</p></td>
</tr>
<tr class="row-even"><td><p>26 luglio</p></td>
<td><p>5.2.3</p></td>
</tr>
<tr class="row-odd"><td><p>28 luglio</p></td>
<td><p>5.2.4</p></td>
</tr>
<tr class="row-even"><td><p>31 luglio</p></td>
<td><p>5.2.5</p></td>
</tr>
<tr class="row-odd"><td><p>...</p></td>
<td><p>...</p></td>
</tr>
<tr class="row-even"><td><p>11 ottobre</p></td>
<td><p>5.2.21</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>La 5.2.21 fu l’aggiornamento finale per la versione 5.2.</p>
<p>Alcuni kernel sono destinati ad essere kernel a “lungo termine”; questi
riceveranno assistenza per un lungo periodo di tempo. Consultate il seguente
collegamento per avere la lista delle versioni attualmente supportate e i
relativi manutentori:</p>
<blockquote>
<div><p><a class="reference external" href="https://www.kernel.org/category/releases.html">https://www.kernel.org/category/releases.html</a></p>
</div></blockquote>
<p>Questa selezione di kernel di lungo periodo sono puramente dovuti ai loro
manutentori, alla loro necessità e al tempo per tenere aggiornate proprio
quelle versioni.  Non ci sono altri kernel a lungo termine in programma per
alcun rilascio in arrivo.</p>
</section>
<section id="il-ciclo-di-vita-di-una-patch">
<h2><span class="section-number">2.2. </span>Il ciclo di vita di una patch<a class="headerlink" href="#il-ciclo-di-vita-di-una-patch" title="Link to this heading">¶</a></h2>
<p>Le patch non passano direttamente dalla tastiera dello sviluppatori
al ramo principale del kernel. Esiste, invece, una procedura disegnata
per assicurare che ogni patch sia di buona qualità e desiderata nel
ramo principale.  Questo processo avviene velocemente per le correzioni
meno importanti, o, nel caso di patch ampie e controverse, va avanti per anni.
Per uno sviluppatore la maggior frustrazione viene dalla mancanza di
comprensione di questo processo o dai tentativi di aggirarlo.</p>
<p>Nella speranza di ridurre questa frustrazione, questo documento spiegherà
come una patch viene inserita nel kernel.  Ciò che segue è un’introduzione
che descrive il processo ideale.  Approfondimenti verranno invece trattati
più avanti.</p>
<p>Una patch attraversa, generalmente, le seguenti fasi:</p>
<blockquote>
<div><ul class="simple">
<li><p>Progetto. In questa fase sono stabilite quelli che sono i requisiti
della modifica - e come verranno soddisfatti.  Il lavoro di progettazione
viene spesso svolto senza coinvolgere la comunità, ma è meglio renderlo
il più aperto possibile; questo può far risparmiare molto tempo evitando
eventuali riprogettazioni successive.</p></li>
<li><p>Prima revisione. Le patch vengono pubblicate sulle liste di discussione
interessate, e gli sviluppatori in quella lista risponderanno coi loro
commenti.  Se si svolge correttamente, questo procedimento potrebbe far
emergere problemi rilevanti in una patch.</p></li>
<li><p>Revisione più ampia. Quando la patch è quasi pronta per essere inserita
nel ramo principale, un manutentore importante del sottosistema dovrebbe
accettarla - anche se, questa accettazione non è una garanzia che la
patch arriverà nel ramo principale. La patch sarà visibile nei sorgenti
del sottosistema in questione e nei sorgenti -next (descritti sotto).
Quando il processo va a buon fine, questo passo porta ad una revisione
più estesa della patch e alla scoperta di problemi d’integrazione
con il lavoro altrui.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Per favore, tenete da conto che la maggior parte dei manutentori ha
anche un lavoro quotidiano, quindi integrare le vostre patch potrebbe
non essere la loro priorità più alta.  Se una vostra patch riceve
dei suggerimenti su dei cambiamenti necessari, dovreste applicare
quei cambiamenti o giustificare perché non sono necessari.  Se la vostra
patch non riceve alcuna critica ma non è stata integrata dal
manutentore del driver o sottosistema, allora dovreste continuare con
i necessari aggiornamenti per mantenere la patch aggiornata al kernel
più recente cosicché questa possa integrarsi senza problemi; continuate
ad inviare gli aggiornamenti per essere revisionati e integrati.</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>Inclusione nel ramo principale. Eventualmente, una buona patch verrà
inserita all’interno nel repositorio principale, gestito da
Linus Torvalds.  In questa fase potrebbero emergere nuovi problemi e/o
commenti; è importante che lo sviluppatore sia collaborativo e che sistemi
ogni questione che possa emergere.</p></li>
<li><p>Rilascio stabile. Ora, il numero di utilizzatori che sono potenzialmente
toccati dalla patch è aumentato, quindi, ancora una volta, potrebbero
emergere nuovi problemi.</p></li>
<li><p>Manutenzione di lungo periodo. Nonostante sia possibile che uno sviluppatore
si dimentichi del codice dopo la sua integrazione, questo comportamento
lascia una brutta impressione nella comunità di sviluppo.  Integrare il
codice elimina alcuni degli oneri facenti parte della manutenzione, in
particolare, sistemerà le problematiche causate dalle modifiche all’API.
Ma lo sviluppatore originario dovrebbe continuare ad assumersi la
responsabilità per il codice se quest’ultimo continua ad essere utile
nel lungo periodo.</p></li>
</ul>
</div></blockquote>
<p>Uno dei più grandi errori fatti dagli sviluppatori kernel (o dai loro datori
di lavoro) è quello di cercare di ridurre tutta la procedura ad una singola
“integrazione nel remo principale”.  Questo approccio inevitabilmente conduce
a una condizione di frustrazione per tutti coloro che sono coinvolti.</p>
</section>
<section id="come-le-modifiche-finiscono-nel-kernel">
<h2><span class="section-number">2.3. </span>Come le modifiche finiscono nel Kernel<a class="headerlink" href="#come-le-modifiche-finiscono-nel-kernel" title="Link to this heading">¶</a></h2>
<p>Esiste una sola persona che può inserire le patch nel repositorio principale
del kernel: Linus Torvalds.  Ma, per esempio, di tutte le 9500 patch
che entrarono nella versione 2.6.38 del kernel, solo 112 (circa
l’1,3%) furono scelte direttamente da Linus in persona.  Il progetto
del kernel è cresciuto fino a raggiungere una dimensione tale per cui
un singolo sviluppatore non può controllare e selezionare
indipendentemente ogni modifica senza essere supportato.  La via
scelta dagli sviluppatori per indirizzare tale crescita è stata quella
di utilizzare un sistema di “sottotenenti” basato sulla fiducia.</p>
<p>Il codice base del kernel è spezzato in una serie si sottosistemi: rete,
supporto per specifiche architetture, gestione della memoria, video e
strumenti, etc.  Molti sottosistemi hanno un manutentore designato: ovvero uno
sviluppatore che ha piena responsabilità di tutto il codice presente in quel
sottosistema.  Tali manutentori di sottosistema sono i guardiani
(in un certo senso) della parte di kernel che gestiscono; sono coloro che
(solitamente) accetteranno una patch per l’inclusione nel ramo principale
del kernel.</p>
<p>I manutentori di sottosistema gestiscono ciascuno la propria parte dei sorgenti
del kernel, utilizzando abitualmente (ma certamente non sempre) git.
Strumenti come git (e affini come quilt o mercurial) permettono ai manutentori
di stilare una lista delle patch, includendo informazioni sull’autore ed
altri metadati.  In ogni momento, il manutentore può individuare quale patch
nel sua repositorio non si trova nel ramo principale.</p>
<p>Quando la “finestra di integrazione” si apre, i manutentori di alto livello
chiederanno a Linus di “prendere” dai loro repositori le modifiche che hanno
selezionato per l’inclusione.  Se Linus acconsente, il flusso di patch si
convoglierà nel repositorio di quest ultimo, divenendo così parte del ramo
principale del kernel.  La quantità d’attenzione che Linus presta alle
singole patch ricevute durante l’operazione di integrazione varia.
È chiaro che, qualche volta, guardi più attentamente.  Ma, come regola
generale, Linus confida nel fatto che i manutentori di sottosistema non
selezionino pessime patch.</p>
<p>I manutentori di sottosistemi, a turno, possono “prendere” patch
provenienti da altri manutentori.  Per esempio, i sorgenti per la rete rete
sono costruiti da modifiche che si sono accumulate inizialmente nei sorgenti
dedicati ai driver per dispositivi di rete, rete senza fili, ecc.  Tale
catena di repositori può essere più o meno lunga, benché raramente ecceda
i due o tre collegamenti.  Questo processo è conosciuto come
“la catena della fiducia”, perché ogni manutentore all’interno della
catena si fida di coloro che gestiscono i livelli più bassi.</p>
<p>Chiaramente, in un sistema come questo, l’inserimento delle patch all’interno
del kernel si basa sul trovare il manutentore giusto.  Di norma, inviare
patch direttamente a Linus non è la via giusta.</p>
</section>
<section id="sorgenti-next">
<h2><span class="section-number">2.4. </span>Sorgenti -next<a class="headerlink" href="#sorgenti-next" title="Link to this heading">¶</a></h2>
<p>La catena di sottosistemi guida il flusso di patch all’interno del kernel,
ma solleva anche un interessante quesito: se qualcuno volesse vedere tutte le
patch pronte per la prossima finestra di integrazione?
Gli sviluppatori si interesseranno alle patch in sospeso per verificare
che non ci siano altri conflitti di cui preoccuparsi; una modifica che, per
esempio, cambia il prototipo di una funzione fondamentale del kernel andrà in
conflitto con qualsiasi altra modifica che utilizzi la vecchia versione di
quella funzione.  Revisori e tester vogliono invece avere accesso alle
modifiche nella loro totalità prima che approdino nel ramo principale del
kernel.  Uno potrebbe prendere le patch provenienti da tutti i sottosistemi
d’interesse, ma questo sarebbe un lavoro enorme e fallace.</p>
<p>La risposta ci viene sotto forma di sorgenti -next, dove i sottosistemi sono
raccolti per essere testati e controllati.  Il più vecchio di questi sorgenti,
gestito da Andrew Morton, è chiamato “-mm” (memory management, che è l’inizio
di tutto).  L’-mm integra patch proveniente da una lunga lista di sottosistemi;
e ha, inoltre, alcune patch destinate al supporto del debugging.</p>
<p>Oltre a questo, -mm contiene una raccolta significativa di patch che sono
state selezionate da Andrew direttamente.  Queste patch potrebbero essere
state inviate in una lista di discussione, o possono essere applicate ad una
parte del kernel per la quale non esiste un sottosistema dedicato.
Di conseguenza, -mm opera come una specie di sottosistema “ultima spiaggia”;
se per una patch non esiste una via chiara per entrare nel ramo principale,
allora è probabile che finirà in -mm.  Le patch passate per -mm
eventualmente finiranno nel sottosistema più appropriato o saranno inviate
direttamente a Linus.  In un tipico ciclo di sviluppo, circa il 5-10% delle
patch andrà nel ramo principale attraverso -mm.</p>
<p>La patch -mm correnti sono disponibili nella cartella “mmotm” (-mm of
the moment) all’indirizzo:</p>
<blockquote>
<div><p><a class="reference external" href="http://www.ozlabs.org/~akpm/mmotm/">http://www.ozlabs.org/~akpm/mmotm/</a></p>
</div></blockquote>
<p>È molto probabile che l’uso dei sorgenti MMOTM diventi un’esperienza
frustrante; ci sono buone probabilità che non compili nemmeno.</p>
<p>I sorgenti principali per il prossimo ciclo d’integrazione delle patch
è linux-next, gestito da Stephen Rothwell.  I sorgenti linux-next sono, per
definizione, un’istantanea di come dovrà apparire il ramo principale dopo che
la prossima finestra di inclusione si chiuderà.  I linux-next sono annunciati
sulla lista di discussione linux-kernel e linux-next nel momento in cui
vengono assemblati; e possono essere scaricate da:</p>
<blockquote>
<div><p><a class="reference external" href="http://www.kernel.org/pub/linux/kernel/next/">http://www.kernel.org/pub/linux/kernel/next/</a></p>
</div></blockquote>
<p>Linux-next è divenuto parte integrante del processo di sviluppo del kernel;
tutte le patch incorporate durante una finestra di integrazione dovrebbero
aver trovato la propria strada in linux-next, a volte anche prima dell’apertura
della finestra di integrazione.</p>
</section>
<section id="sorgenti-in-preparazione">
<h2><span class="section-number">2.5. </span>Sorgenti in preparazione<a class="headerlink" href="#sorgenti-in-preparazione" title="Link to this heading">¶</a></h2>
<p>Nei sorgenti del kernel esiste la cartella drivers/staging/, dove risiedono
molte sotto-cartelle per i driver o i filesystem che stanno per essere aggiunti
al kernel.  Questi restano nella cartella drivers/staging fintanto che avranno
bisogno di maggior lavoro; una volta completato, possono essere spostate
all’interno del kernel nel posto più appropriato.  Questo è il modo di tener
traccia dei driver che non sono ancora in linea con gli standard di codifica
o qualità, ma che le persone potrebbero voler usare ugualmente e tracciarne
lo sviluppo.</p>
<p>Greg Kroah-Hartman attualmente gestisce i sorgenti in preparazione. I driver
che non sono completamente pronti vengono inviati a lui, e ciascun driver avrà
la propria sotto-cartella in drivers/staging/.  Assieme ai file sorgenti
dei driver, dovrebbe essere presente nella stessa cartella anche un file TODO.
Il file TODO elenca il lavoro ancora da fare su questi driver per poter essere
accettati nel kernel, e indica anche la lista di persone da inserire in copia
conoscenza per ogni modifica fatta.  Le regole attuali richiedono che i
driver debbano, come minimo, compilare adeguatamente.</p>
<p>La <em>preparazione</em> può essere una via relativamente facile per inserire nuovi
driver all’interno del ramo principale, dove, con un po’ di fortuna, saranno
notati da altri sviluppatori e migliorati velocemente.  Entrare nella fase
di preparazione non è però la fine della storia, infatti, il codice che si
trova nella cartella staging che non mostra regolari progressi potrebbe
essere rimosso.  Le distribuzioni, inoltre, tendono a dimostrarsi relativamente
riluttanti nell’attivare driver in preparazione. Quindi lo preparazione è,
nel migliore dei casi, una tappa sulla strada verso il divenire un driver
del ramo principale.</p>
</section>
<section id="strumenti">
<h2><span class="section-number">2.6. </span>Strumenti<a class="headerlink" href="#strumenti" title="Link to this heading">¶</a></h2>
<p>Come è possibile notare dal testo sopra, il processo di sviluppo del kernel
dipende pesantemente dalla capacità di guidare la raccolta di patch in
diverse direzioni.  L’intera cosa non funzionerebbe se non venisse svolta
con l’uso di strumenti appropriati e potenti.  Spiegare l’uso di tali
strumenti non è lo scopo di questo documento, ma c’è spazio per alcuni
consigli.</p>
<p>In assoluto, nella comunità del kernel, predomina l’uso di git come sistema
di gestione dei sorgenti. Git è una delle diverse tipologie di sistemi
distribuiti di controllo versione che sono stati sviluppati nella comunità
del software libero.  Esso è calibrato per lo sviluppo del kernel, e si
comporta abbastanza bene quando ha a che fare con repositori grandi e con un
vasto numero di patch.  Git ha inoltre la reputazione di essere difficile
da imparare e utilizzare, benché stia migliorando.  Agli sviluppatori
del kernel viene richiesta un po’ di familiarità con git; anche se non lo
utilizzano per il proprio lavoro, hanno bisogno di git per tenersi al passo
con il lavoro degli altri sviluppatori (e con il ramo principale).</p>
<p>Git è ora compreso in quasi tutte le distribuzioni Linux. Esiste una sito che
potete consultare:</p>
<blockquote>
<div><p><a class="reference external" href="http://git-scm.com/">http://git-scm.com/</a></p>
</div></blockquote>
<p>Qui troverete i riferimenti alla documentazione e alle guide passo-passo.</p>
<p>Tra gli sviluppatori Kernel che non usano git, la scelta alternativa più
popolare è quasi sicuramente Mercurial:</p>
<blockquote>
<div><p><a class="reference external" href="http://www.selenic.com/mercurial/">http://www.selenic.com/mercurial/</a></p>
</div></blockquote>
<p>Mercurial condivide diverse caratteristiche con git, ma fornisce
un’interfaccia che potrebbe risultare più semplice da utilizzare.</p>
<p>L’altro strumento che vale la pena conoscere è Quilt:</p>
<blockquote>
<div><p><a class="reference external" href="http://savannah.nongnu.org/projects/quilt/">http://savannah.nongnu.org/projects/quilt/</a></p>
</div></blockquote>
<p>Quilt è un sistema di gestione delle patch, piuttosto che un sistema
di gestione dei sorgenti.  Non mantiene uno storico degli eventi; ma piuttosto
è orientato verso il tracciamento di uno specifico insieme di modifiche
rispetto ad un codice in evoluzione.  Molti dei più grandi manutentori di
sottosistema utilizzano quilt per gestire le patch che dovrebbero essere
integrate.  Per la gestione di certe tipologie di sorgenti (-mm, per esempio),
quilt è il miglior strumento per svolgere il lavoro.</p>
</section>
<section id="liste-di-discussione">
<h2><span class="section-number">2.7. </span>Liste di discussione<a class="headerlink" href="#liste-di-discussione" title="Link to this heading">¶</a></h2>
<p>Una grossa parte del lavoro di sviluppo del Kernel Linux viene svolto tramite
le liste di discussione.  È difficile essere un membro della comunità
pienamente coinvolto se non si partecipa almeno ad una lista da qualche
parte.  Ma, le liste di discussione di Linux rappresentano un potenziale
problema per gli sviluppatori, che rischiano di venir sepolti da un mare di
email, restare incagliati nelle convenzioni in vigore nelle liste Linux,
o entrambi.</p>
<p>Molte delle liste di discussione del Kernel girano su vger.kernel.org;
l’elenco principale lo si trova sul sito:</p>
<blockquote>
<div><p><a class="reference external" href="http://vger.kernel.org/vger-lists.html">http://vger.kernel.org/vger-lists.html</a></p>
</div></blockquote>
<p>Esistono liste gestite altrove; un certo numero di queste sono in
redhat.com/mailman/listinfo.</p>
<p>La lista di discussione principale per lo sviluppo del kernel è, ovviamente,
linux-kernel.  Questa lista è un luogo ostile dove trovarsi; i volumi possono
raggiungere i 500 messaggi al giorno, la quantità di “rumore” è elevata,
la conversazione può essere strettamente tecnica e i partecipanti non sono
sempre preoccupati di mostrare un alto livello di educazione.  Ma non esiste
altro luogo dove la comunità di sviluppo del kernel si unisce per intero;
gli sviluppatori che evitano tale lista si perderanno informazioni importanti.</p>
<p>Ci sono alcuni consigli che possono essere utili per sopravvivere a
linux-kernel:</p>
<ul class="simple">
<li><p>Tenete la lista in una cartella separata, piuttosto che inserirla nella
casella di posta principale.  Così da essere in grado di ignorare il flusso
di mail per un certo periodo di tempo.</p></li>
<li><p>Non cercate di seguire ogni conversazione - nessuno lo fa.  È importante
filtrare solo gli argomenti d’interesse (sebbene va notato che le
conversazioni di lungo periodo possono deviare dall’argomento originario
senza cambiare il titolo della mail) e le persone che stanno partecipando.</p></li>
<li><p>Non alimentate i troll. Se qualcuno cerca di creare nervosismo, ignoratelo.</p></li>
<li><p>Quando rispondete ad una mail linux-kernel (o ad altre liste) mantenete
tutti i Cc:.  In assenza di importanti motivazioni (come una richiesta
esplicita), non dovreste mai togliere destinatari.  Assicuratevi sempre che
la persona alla quale state rispondendo sia presente nella lista Cc. Questa
usanza fa si che divenga inutile chiedere esplicitamente di essere inseriti
in copia nel rispondere al vostro messaggio.</p></li>
<li><p>Cercate nell’archivio della lista (e nella rete nella sua totalità) prima
di far domande.  Molti sviluppatori possono divenire impazienti con le
persone che chiaramente non hanno svolto i propri compiti a casa.</p></li>
<li><p>Evitate il <em>top-posting</em> (cioè la pratica di mettere la vostra risposta sopra
alla frase alla quale state rispondendo).  Ciò renderebbe la vostra risposta
difficile da leggere e genera scarsa impressione.</p></li>
<li><p>Chiedete nella lista di discussione corretta.  Linux-kernel può essere un
punto di incontro generale, ma non è il miglior posto dove trovare
sviluppatori da tutti i sottosistemi.</p></li>
</ul>
<p>Infine, la ricerca della corretta lista di discussione è uno degli errori più
comuni per gli sviluppatori principianti.  Qualcuno che pone una domanda
relativa alla rete su linux-kernel riceverà quasi certamente il suggerimento
di chiedere sulla lista netdev, che è la lista frequentata dagli sviluppatori
di rete.  Ci sono poi altre liste per i sottosistemi SCSI, video4linux, IDE,
filesystem, etc.  Il miglior posto dove cercare una lista di discussione è il
file MAINTAINERS che si trova nei sorgenti del kernel.</p>
</section>
<section id="iniziare-con-lo-sviluppo-del-kernel">
<h2><span class="section-number">2.8. </span>Iniziare con lo sviluppo del Kernel<a class="headerlink" href="#iniziare-con-lo-sviluppo-del-kernel" title="Link to this heading">¶</a></h2>
<p>Sono comuni le domande sul come iniziare con lo sviluppo del kernel - sia da
singole persone che da aziende.  Altrettanto comuni sono i passi falsi che
rendono l’inizio di tale relazione più difficile di quello che dovrebbe essere.</p>
<p>Le aziende spesso cercano di assumere sviluppatori noti per creare un gruppo
di sviluppo iniziale.  Questo, in effetti, può essere una tecnica efficace.
Ma risulta anche essere dispendiosa e non va ad accrescere il bacino di
sviluppatori kernel con esperienza.  È possibile anche “portare a casa”
sviluppatori per accelerare lo sviluppo del kernel, dando comunque
all’investimento un po’ di tempo.  Prendersi questo tempo può fornire
al datore di lavoro un gruppo di sviluppatori che comprendono sia il kernel
che l’azienda stessa, e che possono supportare la formazione di altre persone.
Nel medio periodo, questa è spesso uno delle soluzioni più proficue.</p>
<p>I singoli sviluppatori sono spesso, comprensibilmente, una perdita come punto
di partenza.  Iniziare con un grande progetto può rivelarsi intimidatorio;
spesso all’inizio si vuole solo verificare il terreno con qualcosa di piccolo.
Questa è una delle motivazioni per le quali molti sviluppatori saltano alla
creazione di patch che vanno a sistemare errori di battitura o
problematiche minori legate allo stile del codice.  Sfortunatamente, tali
patch creano un certo livello di rumore che distrae l’intera comunità di
sviluppo, quindi, sempre di più, esse vengono degradate.  I nuovi sviluppatori
che desiderano presentarsi alla comunità non riceveranno l’accoglienza
che vorrebbero con questi mezzi.</p>
<p>Andrew Morton da questo consiglio agli aspiranti sviluppatori kernel</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Il primo progetto per un neofita del kernel dovrebbe essere
sicuramente quello di &quot;assicurarsi che il kernel funzioni alla
perfezione sempre e su tutte le macchine sulle quali potete stendere
la vostra mano&quot;.  Solitamente il modo per fare ciò è quello di
collaborare con gli altri nel sistemare le cose (questo richiede
persistenza!) ma va bene - è parte dello sviluppo kernel.
</pre></div>
</div>
<p>(<a class="reference external" href="http://lwn.net/Articles/283982/">http://lwn.net/Articles/283982/</a>).</p>
<p>In assenza di problemi ovvi da risolvere, si consiglia agli sviluppatori
di consultare, in generale, la lista di regressioni e di bachi aperti.
Non c’è mai carenza di problematiche bisognose di essere sistemate;
accollandosi tali questioni gli sviluppatori accumuleranno esperienza con
la procedura, ed allo stesso tempo, aumenteranno la loro rispettabilità
all’interno della comunità di sviluppo.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/it_IT/process/2.Process.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>