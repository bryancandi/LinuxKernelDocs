<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>3. Planificación en etapa inicial &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="4. Conseguir el código correcto" href="4.Coding.html" />
    <link rel="prev" title="2. Cómo funciona el proceso de desarrollo" href="2.Process.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.14.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Translations</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../zh_CN/index.html">中文翻译</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../zh_TW/index.html">繁體中文翻譯</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../it_IT/index.html">La documentazione del kernel Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ko_KR/index.html">한국어 번역</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ja_JP/index.html">日本語訳</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Traducción al español</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../index.html#advertencia">Advertencia</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#la-documentacion-del-kernel-linux">La documentación del kernel Linux</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#traducciones-al-espanol">Traducciones al español</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/sp_SP/process/3.Early-stage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
Spanish

<ul>

<li><a href="../../../process/3.Early-stage.html">English</a></li>

<li><a href="../../zh_CN/process/3.Early-stage.html">Chinese (Simplified)</a></li>

<li><a href="../../zh_TW/process/3.Early-stage.html">Chinese (Traditional)</a></li>

<li><a href="../../it_IT/process/3.Early-stage.html">Italian</a></li>

</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Si tiene alguna duda sobre la exactitud del contenido de esta
traducción, la única referencia válida es la documentación oficial en
inglés.
Además, por defecto, los enlaces a documentos redirigen a la
documentación en inglés, incluso si existe una versión traducida.
Consulte el índice para más información.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original<span class="colon">:</span></dt>
<dd class="field-odd"><p>Documentation/process/3.Early-stage.rst</p>
</dd>
<dt class="field-even">Translator<span class="colon">:</span></dt>
<dd class="field-even"><p>Carlos Bilbao &lt;<a class="reference external" href="mailto:carlos&#46;bilbao&#46;osdev&#37;&#52;&#48;gmail&#46;com">carlos<span>&#46;</span>bilbao<span>&#46;</span>osdev<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt; and Avadhut Naik &lt;<a class="reference external" href="mailto:avadhut&#46;naik&#37;&#52;&#48;amd&#46;com">avadhut<span>&#46;</span>naik<span>&#64;</span>amd<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<section id="planificacion-en-etapa-inicial">
<span id="sp-development-early-stage"></span><h1><span class="section-number">3. </span>Planificación en etapa inicial<a class="headerlink" href="#planificacion-en-etapa-inicial" title="Link to this heading">¶</a></h1>
<p>Cuando uno se sienta a planear un proyecto de desarrollo del kernel Linux,
puede ser tentador lanzarse directamente a escribir código. Sin embargo,
como ocurre con cualquier proyecto significativo, gran parte del trabajo
que conduce al éxito es mejor realizarlo antes de escribir la primera línea
de código. Dedicar tiempo a la planificación y comunicación temprana puede
ahorrar mucho más tiempo en adelante.</p>
<section id="especificar-el-problema">
<h2><span class="section-number">3.1. </span>Especificar el problema<a class="headerlink" href="#especificar-el-problema" title="Link to this heading">¶</a></h2>
<p>Como en cualquier proyecto de ingeniería, una mejora exitosa del kernel
comienza con una descripción clara del problema a resolver. En algunos
casos, este paso es sencillo: cuando se necesita un driver para un hardware
específico, por ejemplo. En otros, sin embargo, es tentador confundir el
problema real con la solución propuesta, lo que puede generar dificultades.</p>
<p>Consideremos un ejemplo: hace algunos años, los desarrolladores que
trabajaban con audio en Linux buscaban una forma de ejecutar aplicaciones
sin interrupciones u otros artefactos causados por la latencia excesiva en
el sistema. La solución a la que llegaron fue un módulo del kernel
destinado a integrarse en el marco del Módulo de Seguridad de Linux (LSM,
por sus siglas en inglés); este módulo podía configurarse para dar acceso a
aplicaciones específicas al planificador en tiempo real. Este módulo fue
implementado y enviado a la lista de correo del kernel de Linux, donde
inmediatamente encontró problemas.</p>
<p>Para los desarrolladores de audio, este módulo de seguridad era suficiente
para resolver su problema inmediato. Sin embargo, para la comunidad más
amplia del kernel, se veía como un uso indebido del marco LSM (que no está
diseñado para otorgar privilegios a procesos que de otro modo no los
tendrían) y como un riesgo para la estabilidad del sistema. Sus soluciones
preferidas implicaban el acceso a la programación en tiempo real a través
del mecanismo de rlimit a corto plazo, y trabajo continuo para reducir la
latencia a largo plazo.</p>
<p>La comunidad de audio, sin embargo, no podía ver más allá de la solución
particular que habían implementado; no estaban dispuestos a aceptar
alternativas. El desacuerdo resultante dejó a esos desarrolladores
desilusionados con todo el proceso de desarrollo del kernel; uno de ellos
volvió a una lista de audio y publicó esto (traducido):</p>
<blockquote>
<div><p>“Hay un buen número de desarrolladores muy competentes del kernel de Linux, pero tienden a ser opacados por una multitud de arrogantes necios. Intentar comunicar los requisitos de los usuarios a estas personas es una pérdida de tiempo. Son demasiado ‘inteligentes’ como para escuchar a simples mortales”.</p>
</div></blockquote>
<p>Siendo el texto original:</p>
<blockquote>
<div><p>There are a number of very good Linux kernel developers, but they
tend to get outshouted by a large crowd of arrogant fools. Trying
to communicate user requirements to these people is a waste of
time. They are much too “intelligent” to listen to lesser mortals.</p>
</div></blockquote>
<p>(<a class="reference external" href="https://lwn.net/Articles/131776/">https://lwn.net/Articles/131776/</a>).</p>
<p>La realidad de la situación era diferente; los desarrolladores del kernel
estaban mucho más preocupados por la estabilidad del sistema, el
mantenimiento a largo plazo y encontrar la solución correcta al problema
que por un módulo específico. La moraleja de la historia es centrarse en el
problema, no en una solución específica, y discutirlo con la comunidad de
desarrollo antes de invertir en la creación de un cuerpo de código.</p>
<p>Por lo tanto, al contemplar un proyecto de desarrollo del kernel, se deben
obtener respuestas a un conjunto corto de preguntas:</p>
<ul class="simple">
<li><p>¿Cuál es exactamente el problema que necesita ser resuelto?</p></li>
<li><p>¿Quiénes son los usuarios afectados por este problema? ¿Qué casos de uso
debería abordar la solución?</p></li>
<li><p>¿En qué aspectos el kernel actual no logra abordar ese problema?</p></li>
</ul>
<p>Solo entonces tiene sentido comenzar a considerar posibles soluciones.</p>
</section>
<section id="discusion-temprana">
<h2><span class="section-number">3.2. </span>Discusión temprana<a class="headerlink" href="#discusion-temprana" title="Link to this heading">¶</a></h2>
<p>Al planificar un proyecto de desarrollo del kernel, tiene mucho sentido
realizar discusiones con la comunidad antes de lanzarse a la
implementación. La comunicación temprana puede ahorrar tiempo y problemas
de varias maneras:</p>
<ul class="simple">
<li><p>Es posible que el problema ya esté siendo abordado por el kernel de
maneras que no haya comprendido. El kernel de Linux es grande y tiene
una serie de características y capacidades que no son inmediatamente
obvias. No todas las capacidades del kernel están documentadas tan bien
como uno quisiera, y es fácil pasar cosas por alto. El autor de este
texto ha visto la publicación de un driver completo que duplicaba uno
existente del que el nuevo autor no tenía conocimiento. El código que
reinventa ruedas existentes no solo es desperdicio; tampoco será aceptado
en el kernel principal.</p></li>
<li><p>Puede haber elementos de la solución propuesta que no serán aceptables
para su inclusión en el kernel principal. Es mejor descubrir problemas
como este antes de escribir el código.</p></li>
<li><p>Es completamente posible que otros desarrolladores ya hayan pensado en el
problema; pueden tener ideas para una mejor solución y estar dispuestos a
ayudar en la creación de esa solución.</p></li>
</ul>
<p>Años de experiencia con la comunidad de desarrollo del kernel han enseñado
una lección clara: el código del kernel que se diseña y desarrolla a
puertas cerradas invariablemente tiene problemas que solo se revelan cuando
el código se libera a la comunidad. A veces, estos problemas son graves,
requiriendo meses o años de esfuerzo antes de que el código pueda cumplir
con los estándares de la comunidad del kernel. Algunos ejemplos incluyen:</p>
<ul class="simple">
<li><p>La pila de red Devicescape fue diseñada e implementada para sistemas de
un solo procesador. No pudo fusionarse en la rama principal hasta que se
hizo adecuada para sistemas multiprocesador. Adaptar el bloqueo y otros
aspectos en el código es una tarea difícil; como resultado, la fusión de
este código (ahora llamado mac80211) se retrasó más de un año.</p></li>
<li><p>El sistema de archivos Reiser4 incluía una serie de capacidades que, en
opinión de los desarrolladores principales del kernel, deberían haberse
implementado en la capa de sistemas de archivos virtuales. También
incluía funciones que no podían implementarse fácilmente sin exponer el
sistema a bloqueos causados por los usuarios. La revelación tardía de
estos problemas, y la negativa a abordar algunos de ellos, ha mantenido a
Reiser4 fuera del kernel principal.</p></li>
<li><p>El módulo de seguridad AppArmor hacía uso de estructuras de datos
internas del sistema de archivos virtual de maneras que se consideraban
inseguras y poco fiables. Esta preocupación (entre otras) mantuvo a
AppArmor fuera de la rama principal durante años.</p></li>
</ul>
<p>En cada uno de estos casos, se podría haber evitado mucho dolor y trabajo
adicional con algunas discusiones tempranas con los desarrolladores del
kernel.</p>
</section>
<section id="con-quien-hablar">
<h2><span class="section-number">3.3. </span>¿Con quién hablar?<a class="headerlink" href="#con-quien-hablar" title="Link to this heading">¶</a></h2>
<p>Cuando los desarrolladores deciden hacer públicas sus ideas, la siguiente
pregunta será: ¿dónde empezar? La respuesta es encontrar la lista de correo
adecuada y el maintainer correcto. Para las listas de correo, la mejor
opción es buscar en el archivo MAINTAINERS un lugar relevante para
publicar. Si existe una lista de subsistema adecuada, es preferible
publicarla allí en lugar de en linux-kernel; es más probable que llegues a
desarrolladores con experiencia en el subsistema relevante y el ambiente
puede ser más propicio.</p>
<p>Encontrar a los maintainers puede ser un poco más difícil. Nuevamente, el
archivo MAINTAINERS es el lugar para empezar. Sin embargo, ese archivo
tiende a no estar siempre actualizado, y no todos los subsistemas están
representados allí. La persona listada en el archivo MAINTAINERS puede, de
hecho, no ser la persona que está actuando en ese rol actualmente. Por lo
tanto, cuando haya dudas sobre a quién contactar, un truco útil es usar git
(y “git log” en particular) para ver quién está activo actualmente en el
subsistema de interés. Mira quién está escribiendo parches y quién, si
alguien, está adjuntando líneas de Signed-off-by a esos parches. Esas son
las personas que estarán mejor posicionadas para ayudar con un nuevo
proyecto de desarrollo.</p>
<p>La tarea de encontrar al maintainer correcto es lo suficientemente
desafiante como para que los desarrolladores del kernel hayan añadido un
script para facilitar el proceso:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.../scripts/get_maintainer.pl
</pre></div>
</div>
<p>Este script devolverá los maintainers actuales de un archivo o directorio
dado cuando se le pase la opción “-f”. Si se le pasa un parche en la línea
de comandos, listará a los maintainers que probablemente deberían recibir
copias del parche. Esta es la manera preferida (a diferencia de la opción
“-f”) de obtener la lista de personas a las que hay que enviar las copias
de sus parches. Hay varias opciones que regulan cuán agresivamente
get_maintainer.pl buscará maintainers; por favor, ten cuidado al usar las
opciones más agresivas, ya que podrías terminar incluyendo desarrolladores
que no tienen ningún interés real en el código que estás modificando.</p>
<p>Si todo lo demás falla, hablar con Andrew Morton puede ser una forma
efectiva de encontrar a un maintainer para un código específico.</p>
</section>
<section id="cuando-publicar">
<h2><span class="section-number">3.4. </span>¿Cuándo publicar?<a class="headerlink" href="#cuando-publicar" title="Link to this heading">¶</a></h2>
<p>Si es posible, publicar sus planes en las primeras etapas solo puede ser
útil. Describa el problema que se está resolviendo y cualquier plan que se
haya hecho sobre cómo se llevará a cabo la implementación. Cualquier
información que puedas proporcionar puede ayudar a la comunidad de
desarrollo a ofrecer comentarios útiles sobre el proyecto.</p>
<p>Una cosa desalentadora que puede suceder en esta etapa no es una reacción
hostil, sino, en cambio, poca o ninguna reacción en absoluto. La triste
realidad es que (1) los desarrolladores del kernel tienden a estar
ocupados, (2) no hay escasez de personas con grandes planes y poco código
(o incluso perspectivas de código) para respaldarlos, y (3) nadie está
obligado a revisar o comentar las ideas publicadas por otros. Además, los
diseños de alto nivel a menudo esconden problemas que solo se revelan
cuando alguien realmente intenta implementar esos diseños; por esa razón,
los desarrolladores del kernel prefieren ver el código.</p>
<p>Si una publicación de solicitud de comentarios genera pocos comentarios, no
asuma que significa que no hay interés en el proyecto. Desafortunadamente,
tampoco puedes asumir que no hay problemas con tu idea. Lo mejor que puede
hacer en esta situación es seguir adelante, manteniendo informada a
comunidad a medida que avanza.</p>
</section>
<section id="obtener-respaldo-oficial">
<h2><span class="section-number">3.5. </span>Obtener respaldo oficial<a class="headerlink" href="#obtener-respaldo-oficial" title="Link to this heading">¶</a></h2>
<p>Si su trabajo se está realizando en un entorno corporativo — como ocurre
con la mayoría del trabajo en el kernel de Linux — es obvio que debe tener
permiso de los jefes debidamente autorizados antes de poder publicar los
planes o el código de su empresa en una lista de correo pública. La
publicación de código que no ha sido autorizado para su liberación bajo una
licencia compatible con la GPL puede ser especialmente problemática; cuanto
antes la gerencia y el personal legal de una empresa lleguen a un acuerdo
sobre la publicación de un proyecto de desarrollo del kernel, mejor será
para todos los involucrados.</p>
<p>Algunos lectores pueden estar pensando en este momento que su trabajo en el
kernel está destinado a respaldar un producto que aún no ha sido reconocido
oficialmente. Revelar los planes de su empleador en una lista de correo
pública puede no ser una opción viable. En casos como este, vale la pena
considerar si realmente es necesario mantener el secreto; a menudo no hay
una necesidad real de mantener los planes de desarrollo en secreto.</p>
<p>Dicho esto, también hay casos en los que una empresa legítimamente no puede
revelar sus planes al inicio del proceso de desarrollo. Las empresas con
desarrolladores experimentados en el kernel pueden optar por proceder de
manera abierta, bajo el supuesto de que podrán evitar problemas graves de
integración más adelante. Para las empresas sin ese tipo de experiencia
interna, la mejor opción suele ser contratar a un desarrollador externo
para que revise los planes bajo un acuerdo de confidencialidad (NDA). La
Linux Foundation opera un programa de NDA diseñado para ayudar en este tipo
de situaciones; se puede encontrar más información en:</p>
<blockquote>
<div><p><a class="reference external" href="https://www.linuxfoundation.org/nda/">https://www.linuxfoundation.org/nda/</a></p>
</div></blockquote>
<p>Este tipo de revisión suele ser suficiente para evitar problemas graves más
adelante sin necesidad de revelar públicamente el proyecto.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/sp_SP/process/3.Early-stage.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>