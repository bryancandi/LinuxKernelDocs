<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Agregando una Nueva Llamada del Sistema &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Directrices para Investigadores" href="researcher-guidelines.html" />
    <link rel="prev" title="Interfaces obsoletos, Características del lenguaje, Atributos y Convenciones" href="deprecated.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.13.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Translations</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../zh_CN/index.html">中文翻译</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../zh_TW/index.html">繁體中文翻譯</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../it_IT/index.html">La documentazione del kernel Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ko_KR/index.html">한국어 번역</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ja_JP/index.html">日本語訳</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Traducción al español</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../index.html#advertencia">Advertencia</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#la-documentacion-del-kernel-linux">La documentación del kernel Linux</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#traducciones-al-espanol">Traducciones al español</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/sp_SP/process/adding-syscalls.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
Spanish

<ul>

<li><a href="../../../process/adding-syscalls.html">English</a></li>

<li><a href="../../it_IT/process/adding-syscalls.html">Italian</a></li>

</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Si tiene alguna duda sobre la exactitud del contenido de esta
traducción, la única referencia válida es la documentación oficial en
inglés.
Además, por defecto, los enlaces a documentos redirigen a la
documentación en inglés, incluso si existe una versión traducida.
Consulte el índice para más información.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../process/adding-syscalls.html#addsyscalls"><span class="std std-ref">Documentation/process/adding-syscalls.rst</span></a></p>
</dd>
<dt class="field-even">Translator<span class="colon">:</span></dt>
<dd class="field-even"><p>Mauricio Fuentes &lt;<a class="reference external" href="mailto:mauriciofb&#37;&#52;&#48;gmail&#46;com">mauriciofb<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<section id="agregando-una-nueva-llamada-del-sistema">
<span id="sp-addsyscalls"></span><h1>Agregando una Nueva Llamada del Sistema<a class="headerlink" href="#agregando-una-nueva-llamada-del-sistema" title="Link to this heading">¶</a></h1>
<p>Este documento describe qué involucra agregar una nueva llamada del sistema
al kernel Linux, más allá de la presentación y consejos normales en
<a class="reference internal" href="../../../process/submitting-patches.html#submittingpatches"><span class="std std-ref">Documentation/process/submitting-patches.rst</span></a> que
también puede encontrar traducido a este idioma.</p>
<section id="alternativas-a-llamadas-del-sistema">
<h2>Alternativas a Llamadas del Sistema<a class="headerlink" href="#alternativas-a-llamadas-del-sistema" title="Link to this heading">¶</a></h2>
<p>La primera cosa a considerar cuando se agrega una llamada al sistema es si
alguna alternativa es adecuada en su lugar. Aunque las llamadas al sistema
son los puntos de interacción entre el userspace y el kernel más obvios y
tradicionales, existen otras posibilidades -- elija la que mejor se adecúe
a su interfaz.</p>
<blockquote>
<div><ul>
<li><p>Si se puede hacer que la operación se parezca a un objeto filesystem,
podría tener más sentido crear un nuevo sistema de ficheros o
dispositivo. Esto también hará más fácil encapsular la nueva
funcionalidad en un módulo del kernel en vez de requerir que sea
construido junto al kernel principal.</p>
<blockquote>
<div><ul class="simple">
<li><p>Si la nueva funcionalidad involucra operaciones donde el kernel
notifica al userspace que algo ha pasado, entonces retornar un nuevo
descriptor de archivo para el objeto relevante permite al userspace
usar <code class="docutils literal notranslate"><span class="pre">poll</span></code>/<code class="docutils literal notranslate"><span class="pre">select</span></code>/<code class="docutils literal notranslate"><span class="pre">epoll</span></code> para recibir esta notificación.</p></li>
<li><p>Sin embargo, operaciones que no mapean a operaciones similares a
<em class="manpage">read(2)</em>/<em class="manpage">write(2)</em> tienen que ser implementadas
como solicitudes <em class="manpage">ioctl(2)</em>, las cuales pueden llevar a un
API algo opaca.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Si sólo está exponiendo información del runtime, un nuevo nodo en sysfs
(mire <code class="docutils literal notranslate"><span class="pre">Documentation/filesystems/sysfs.rst</span></code>) o el filesystem <code class="docutils literal notranslate"><span class="pre">/proc</span></code>
podría ser más adecuado. Sin embargo, acceder a estos mecanismos
requiere que el filesystem relevante esté montado, lo que podría no ser
siempre el caso (e.g. en un ambiente namespaced/sandboxed/chrooted).
Evite agregar cualquier API a debugfs, ya que no se considera una
interfaz (interface) de ‘producción’ para el userspace.</p></li>
<li><p>Si la operación es específica a un archivo o descriptor de archivo
específico, entonces la opción de comando adicional <em class="manpage">fcntl(2)</em>
podría ser más apropiada. Sin embargo, <em class="manpage">fcntl(2)</em> es una
llamada al sistema multiplexada que esconde mucha complejidad, así que
esta opción es mejor cuando la nueva funcion es analogamente cercana a
la funcionalidad existente <em class="manpage">fcntl(2)</em>, o la nueva funcionalidad
es muy simple (por ejemplo, definir/obtener un flag simple relacionado a
un descriptor de archivo).</p></li>
<li><p>Si la operación es específica a un proceso o tarea particular, entonces
un comando adicional <em class="manpage">prctl(2)</em> podría ser más apropiado. Tal
como con <em class="manpage">fcntl(2)</em>, esta llamada al sistema es un multiplexor
complicado así que está reservado para comandos análogamente cercanos
del existente <code class="docutils literal notranslate"><span class="pre">prctl()</span></code> u obtener/definir un flag simple relacionado a
un proceso.</p></li>
</ul>
</div></blockquote>
</section>
<section id="disenando-el-api-planeando-para-extensiones">
<h2>Diseñando el API: Planeando para extensiones<a class="headerlink" href="#disenando-el-api-planeando-para-extensiones" title="Link to this heading">¶</a></h2>
<p>Una nueva llamada del sistema forma parte del API del kernel, y tiene que
ser soportada indefinidamente. Como tal, es una muy buena idea discutir
explícitamente el interface en las listas de correo del kernel, y es
importante planear para futuras extensiones del interface.</p>
<p>(La tabla syscall está poblada con ejemplos históricos donde esto no se
hizo, junto con los correspondientes seguimientos de los system calls --
<code class="docutils literal notranslate"><span class="pre">eventfd</span></code>/<code class="docutils literal notranslate"><span class="pre">eventfd2</span></code>, <code class="docutils literal notranslate"><span class="pre">dup2</span></code>/<code class="docutils literal notranslate"><span class="pre">dup3</span></code>, <code class="docutils literal notranslate"><span class="pre">inotify_init</span></code>/<code class="docutils literal notranslate"><span class="pre">inotify_init1</span></code>,
<code class="docutils literal notranslate"><span class="pre">pipe</span></code>/<code class="docutils literal notranslate"><span class="pre">pipe2</span></code>, <code class="docutils literal notranslate"><span class="pre">renameat</span></code>/<code class="docutils literal notranslate"><span class="pre">renameat2</span></code> -- así que aprenda de la
historia del kernel y planee extensiones desde el inicio.)</p>
<p>Para llamadas al sistema más simples que sólo toman un par de argumentos,
la forma preferida de permitir futuras extensiones es incluir un argumento
flag a la llamada al sistema. Para asegurarse que el userspace pueda usar
de forma segura estos flags entre versiones del kernel, revise si los flags
contienen cualquier flag desconocido, y rechace la llamada al sistema (con
<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code>) si ocurre:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (flags &amp; ~(THING_FLAG1 | THINGFLAG2 | THING_FLAG3))
    return -EINVAL;
</pre></div>
</div>
<p>(Si no hay valores de flags usados aún, revise que los argumentos del flag
sean cero.)</p>
<p>Para llamadas al sistema más sofisticadas que involucran un gran número de
argumentos, es preferible encapsular la mayoría de los argumentos en una
estructura que sea pasada a través de un puntero. Tal estructura puede
hacer frente a futuras extensiones mediante la inclusión de un argumento de
tamaño en la estructura:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xyzzy_params {
    u32 size; /* userspace define p-&gt;size = sizeof(struct xyzzy_params) */
    u32 param_1;
    u64 param_2;
    u64 param_3;
};
</pre></div>
</div>
<p>Siempre que cualquier campo añadido subsecuente, digamos <code class="docutils literal notranslate"><span class="pre">param_4</span></code>, sea
diseñado de forma tal que un valor cero, devuelva el comportamiento previo,
entonces permite versiones no coincidentes en ambos sentidos:</p>
<blockquote>
<div><ul class="simple">
<li><p>Para hacer frente a programas del userspace más modernos, haciendo
llamadas a un kernel más antiguo, el código del kernel debe revisar que
cualquier memoria más allá del tamaño de la estructura sea cero (revisar
de manera efectiva que <code class="docutils literal notranslate"><span class="pre">param_4</span> <span class="pre">==</span> <span class="pre">0</span></code>).</p></li>
<li><p>Para hacer frente a programas antiguos del userspace haciendo llamadas a
un kernel más nuevo, el código del kernel puede extender con ceros, una
instancia más pequeña de la estructura (definiendo efectivamente
<code class="docutils literal notranslate"><span class="pre">param_4</span> <span class="pre">==</span> <span class="pre">0</span></code>).</p></li>
</ul>
</div></blockquote>
<p>Revise <em class="manpage">perf_event_open(2)</em> y la función <code class="docutils literal notranslate"><span class="pre">perf_copy_attr()</span></code> (en
<code class="docutils literal notranslate"><span class="pre">kernel/events/code.c</span></code>) para un ejemplo de esta aproximación.</p>
</section>
<section id="disenando-el-api-otras-consideraciones">
<h2>Diseñando el API: Otras consideraciones<a class="headerlink" href="#disenando-el-api-otras-consideraciones" title="Link to this heading">¶</a></h2>
<p>Si su nueva llamada al sistema permite al userspace hacer referencia a un
objeto del kernel, esta debería usar un descriptor de archivo como el
manipulador de ese objeto -- no invente un nuevo tipo de objeto manipulador
userspace cuando el kernel ya tiene mecanismos y semánticas bien definidas
para usar los descriptores de archivos.</p>
<p>Si su nueva llamada a sistema <em class="manpage">xyzzy(2)</em> retorna un nuevo
descriptor de archivo, entonces el argumento flag debe incluir un valor que
sea equivalente a definir <code class="docutils literal notranslate"><span class="pre">O_CLOEXEC</span></code> en el nuevo FD. Esto hace posible
al userspace acortar la brecha de tiempo entre <code class="docutils literal notranslate"><span class="pre">xyzzy()</span></code> y la llamada a
<code class="docutils literal notranslate"><span class="pre">fcntl(fd,</span> <span class="pre">F_SETFD,</span> <span class="pre">FD_CLOEXEC)</span></code>, donde un <code class="docutils literal notranslate"><span class="pre">fork()</span></code> inesperado y
<code class="docutils literal notranslate"><span class="pre">execve()</span></code> en otro hilo podrían filtrar un descriptor al programa
ejecutado. (Sin embargo, resista la tentación de reusar el valor actual de
la constante <code class="docutils literal notranslate"><span class="pre">O_CLOEXEC</span></code>, ya que es específica de la arquitectura y es
parte de un espacio numerado de flags <code class="docutils literal notranslate"><span class="pre">O_*</span></code> que está bastante lleno.)</p>
<p>Si su llamada de sistema retorna un nuevo descriptor de archivo, debería
considerar también que significa usar la familia de llamadas de sistema
<em class="manpage">poll(2)</em> en ese descriptor de archivo. Hacer un descriptor de
archivo listo para leer o escribir es la forma normal para que el kernel
indique al espacio de usuario que un evento ha ocurrido en el
correspondiente objeto del kernel.</p>
<p>Si su nueva llamada de sistema <em class="manpage">xyzzy(2)</em> involucra algún nombre
de archivo como argumento:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sys_xyzzy(const char __user *path, ..., unsigned int flags);
</pre></div>
</div>
<p>debería considerar también si una versión <em class="manpage">xyzzyat(2)</em> es mas
apropiada:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sys_xyzzyat(int dfd, const char __user *path, ..., unsigned int flags);
</pre></div>
</div>
<p>Esto permite más flexibilidad en como el userspace especifica el archivo en
cuestión; en particular esto permite al userspace pedir la funcionalidad a
un descriptor de archivo ya abierto usando el flag <code class="docutils literal notranslate"><span class="pre">AT_EMPTY_PATH</span></code>,
efectivamente dando una operación <em class="manpage">fxyzzy(3)</em> gratis:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- xyzzyat(AT_FDCWD, path, ..., 0) es equivalente a xyzzy(path, ...)
- xyzzyat(fd, &quot;&quot;, ..., AT_EMPTY_PATH) es equivalente a fxyzzy(fd, ...)
</pre></div>
</div>
<p>(Para más detalles sobre la explicación racional de las llamadas *at(),
revise el man page <em class="manpage">openat(2)</em>; para un ejemplo de AT_EMPTY_PATH,
mire el man page <em class="manpage">fstatat(2)</em> manpage.)</p>
<p>Si su nueva llamada de sistema <em class="manpage">xyzzy(2)</em> involucra un parámetro
describiendo un describiendo un movimiento dentro de un archivo, ponga de
tipo <code class="docutils literal notranslate"><span class="pre">loff_t</span></code> para que movimientos de 64-bit puedan ser soportados
incluso en arquitecturas de 32-bit.</p>
<p>Si su nueva llamada de sistema  <em class="manpage">xyzzy</em> involucra una
funcionalidad privilegiada, esta necesita ser gobernada por la capability
bit linux apropiada (revisado con una llamada a <code class="docutils literal notranslate"><span class="pre">capable()</span></code>), como se
describe en el man page <em class="manpage">capabilities(7)</em>. Elija una parte de
capability linux que govierne las funcionalidades relacionadas, pero trate
de evitar combinar muchas funciones sólo relacionadas vagamente bajo la
misma sección, ya que va en contra de los propósitos de las capabilities de
dividir el poder del usuario root. En particular, evite agregar nuevos usos
de la capacidad ya demasiado general de la capabilities <code class="docutils literal notranslate"><span class="pre">CAP_SYS_ADMIN</span></code>.</p>
<p>Si su nueva llamada de sistema <em class="manpage">xyzzy(2)</em> manipula un proceso que
no es el proceso invocado, este debería ser restringido (usando una llamada
a <code class="docutils literal notranslate"><span class="pre">ptrace_may_access()</span></code>) de forma que el único proceso con los mismos
permisos del proceso objetivo, o con las capacidades (capabilities)
necesarias, pueda manipulador el proceso objetivo.</p>
<p>Finalmente, debe ser conciente de que algunas arquitecturas no-x86 tienen
un manejo más sencillo si los parámetros que son explícitamente 64-bit
caigan en argumentos enumerados impares (i.e. parámetros 1,3,5), para
permitir el uso de pares contiguos de registros 32-bits. (Este cuidado no
aplica si el argumento es parte de una estructura que se pasa a través de
un puntero.)</p>
</section>
<section id="proponiendo-el-api">
<h2>Proponiendo el API<a class="headerlink" href="#proponiendo-el-api" title="Link to this heading">¶</a></h2>
<p>Para hacer una nueva llamada al sistema fácil de revisar, es mejor dividir
el patchset (conjunto de parches) en trozos separados. Estos deberían
incluir al menos los siguientes items como commits distintos (cada uno de
los cuales se describirá más abajo):</p>
<blockquote>
<div><ul class="simple">
<li><p>La implementación central de la llamada al sistema, junto con
prototipos, numeración genérica, cambios Kconfig e implementaciones de
rutinas de respaldo (fallback stub)</p></li>
<li><p>Conectar la nueva llamada a sistema a una arquitectura particular,
usualmente x86 (incluyendo todas las x86_64, x86_32 y x32).</p></li>
<li><p>Una demostración del use de la nueva llamada a sistema en el userspace
vía un selftest en <code class="docutils literal notranslate"><span class="pre">tools/testing/selftest/</span></code>.</p></li>
<li><p>Un borrador de man-page para la nueva llamada a sistema, ya sea como
texto plano en la carta de presentación, o como un parche (separado)
para el repositorio man-pages.</p></li>
</ul>
</div></blockquote>
<p>Nuevas propuestas de llamadas de sistema, como cualquier cambio al API del
kernel, debería siempre ser copiado a <a class="reference external" href="mailto:linux-api&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-api<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>.</p>
</section>
<section id="implementation-de-llamada-de-sistema-generica">
<h2>Implementation de Llamada de Sistema Generica<a class="headerlink" href="#implementation-de-llamada-de-sistema-generica" title="Link to this heading">¶</a></h2>
<p>La entrada principal a su nueva llamada de sistema <em class="manpage">xyzzy(2)</em> será
llamada <code class="docutils literal notranslate"><span class="pre">sys_xyzzy()</span></code>, pero incluya este punto de entrada con la macro
<code class="docutils literal notranslate"><span class="pre">SYSCALL_DEFINEn()</span></code> apropiada en vez de explicitamente. El ‘n’ indica el
numero de argumentos de la llamada de sistema, y la macro toma el nombre de
la llamada de sistema seguida por el par (tipo, nombre) para los parámetros
como argumentos. Usar esta macro permite a la metadata de la nueva llamada
de sistema estar disponible para otras herramientas.</p>
<p>El nuevo punto de entrada también necesita un prototipo de función
correspondiente en <code class="docutils literal notranslate"><span class="pre">include/linux/syscalls.h</span></code>,  marcado como asmlinkage
para calzar en la manera en que las llamadas de sistema son invocadas:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>asmlinkage long sys_xyzzy(...);
</pre></div>
</div>
<p>Algunas arquitecturas (e.g. x86) tienen sus propias tablas de syscall
específicas para la arquitectura, pero muchas otras arquitecturas comparten
una tabla de syscall genéricas. Agrega su nueva llamada de sistema a la
lista genérica agregando una entrada a la lista en
<code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/unistd.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define __NR_xyzzy 292
__SYSCALL(__NR_xyzzy, sys_xyzzy )
</pre></div>
</div>
<p>También actualice el conteo de __NR_syscalls para reflejar la llamada de
sistema adicional, y note que si multiples llamadas de sistema nuevas son
añadidas en la misma ventana unida, su nueva llamada de sistema podría
tener que ser ajustada para resolver conflictos.</p>
<p>El archivo <code class="docutils literal notranslate"><span class="pre">kernel/sys_ni.c</span></code> provee una implementación fallback stub
(rutina de respaldo) para cada llamada de sistema, retornando <code class="docutils literal notranslate"><span class="pre">-ENOSYS</span></code>.
Incluya su nueva llamada a sistema aquí también:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COND_SYSCALL(xyzzy);
</pre></div>
</div>
<p>Su nueva funcionalidad del kernel, y la llamada de sistema que la controla,
debería normalmente ser opcional, así que incluya una opción <code class="docutils literal notranslate"><span class="pre">CONFIG</span></code>
(tipicamente en <code class="docutils literal notranslate"><span class="pre">init/Kconfig</span></code>) para ella. Como es usual para opciones
<code class="docutils literal notranslate"><span class="pre">CONFIG</span></code> nuevas:</p>
<blockquote>
<div><ul class="simple">
<li><p>Incluya una descripción para la nueva funcionalidad y llamada al sistema
controlada por la opción.</p></li>
<li><p>Haga la opción dependiendo de EXPERT si esta debe estar escondida de los
usuarios normales.</p></li>
<li><p>Haga que cualquier nuevo archivo fuente que implemente la función
dependa de la opción CONFIG en el Makefile (e.g.
<code class="docutils literal notranslate"><span class="pre">obj-$(CONFIG_XYZZY_SYSCALL)</span> <span class="pre">+=</span> <span class="pre">xyzzy.o</span></code>).</p></li>
<li><p>Revise dos veces que el kernel se siga compilando con la nueva opción
CONFIG apagada.</p></li>
</ul>
</div></blockquote>
<p>Para resumir, necesita un commit que incluya:</p>
<blockquote>
<div><ul class="simple">
<li><p>una opción <code class="docutils literal notranslate"><span class="pre">CONFIG</span></code> para la nueva función, normalmente en <code class="docutils literal notranslate"><span class="pre">init/Kconfig</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SYSCALL_DEFINEn(xyzzy,</span> <span class="pre">...)</span></code> para el punto de entrada</p></li>
<li><p>El correspondiente prototipo en <code class="docutils literal notranslate"><span class="pre">include/linux/syscalls.h</span></code></p></li>
<li><p>Una entrada genérica en <code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/unistd.h</span></code></p></li>
<li><p>fallback stub en <code class="docutils literal notranslate"><span class="pre">kernel/sys_ni.c</span></code></p></li>
</ul>
</div></blockquote>
</section>
<section id="implementacion-de-llamada-de-sistema-x86">
<h2>Implementación de Llamada de Sistema x86<a class="headerlink" href="#implementacion-de-llamada-de-sistema-x86" title="Link to this heading">¶</a></h2>
<p>Para conectar su nueva llamada de sistema a plataformas x86, necesita
actualizar las tablas maestras syscall. Asumiendo que su nueva llamada de
sistema ni es especial de alguna manera (revise abajo), esto involucra una
entrada “común” (para x86_64 y x86_32) en
arch/x86/entry/syscalls/syscall_64.tbl:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>333   common   xyzz     sys_xyzzy
</pre></div>
</div>
<p>y una entrada “i386” en <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_32.tbl</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>380   i386     xyzz     sys_xyzzy
</pre></div>
</div>
<p>De nuevo, estos número son propensos de ser cambiados si hay conflictos en
la ventana de integración relevante.</p>
</section>
<section id="compatibilidad-de-llamadas-de-sistema-generica">
<h2>Compatibilidad de Llamadas de Sistema (Genérica)<a class="headerlink" href="#compatibilidad-de-llamadas-de-sistema-generica" title="Link to this heading">¶</a></h2>
<p>Para la mayoría de llamadas al sistema la misma implementación 64-bit puede
ser invocada incluso cuando el programa de userspace es en si mismo 32-bit;
incluso si los parámetros de la llamada de sistema incluyen un puntero
explícito, esto es manipulado de forma transparente.</p>
<p>Sin embargo, existe un par de situaciones donde se necesita una capa de
compatibilidad para lidiar con las diferencias de tamaño entre 32-bit y
64-bit.</p>
<p>La primera es si el kernel 64-bit también soporta programas del userspace
32-bit, y por lo tanto necesita analizar areas de memoria del (<code class="docutils literal notranslate"><span class="pre">__user</span></code>)
que podrían tener valores tanto 32-bit como 64-bit. En particular esto se
necesita siempre que un argumento de la llamada a sistema es:</p>
<blockquote>
<div><ul class="simple">
<li><p>un puntero a un puntero</p></li>
<li><p>un puntero a un struc conteniendo un puntero (por ejemplo
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iovec</span> <span class="pre">__user</span> <span class="pre">*</span></code>)</p></li>
<li><p>un puntero a un type entero de tamaño entero variable (<code class="docutils literal notranslate"><span class="pre">time_t</span></code>,
<code class="docutils literal notranslate"><span class="pre">off_t</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span></code>, ...)</p></li>
<li><p>un puntero a un struct conteniendo un type entero de tamaño variable.</p></li>
</ul>
</div></blockquote>
<p>La segunda situación que requiere una capa de compatibilidad es cuando uno
de los argumentos de la llamada a sistema tiene un argumento que es
explícitamente 64-bit incluso sobre arquitectura 32-bit, por ejemplo
<code class="docutils literal notranslate"><span class="pre">loff_t</span></code> o <code class="docutils literal notranslate"><span class="pre">__u64</span></code>. En este caso, el valor que llega a un kernel 64-bit
desde una aplicación de 32-bit se separará en dos valores de 32-bit, los
que luego necesitan ser reensamblados en la capa de compatibilidad.</p>
<p>(Note que un argumento de una llamada a sistema que sea un puntero a un
type explicitamente de 64-bit <strong>no</strong> necesita una capa de compatibilidad;
por ejemplo, los argumentos de <em class="manpage">splice(2)</em>) del tipo
<code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">__user</span> <span class="pre">*</span></code> no significan la necesidad de una llamada a sistema
<code class="docutils literal notranslate"><span class="pre">compat_</span></code>.)</p>
<p>La versión compatible de la llamada de sistema se llama
<code class="docutils literal notranslate"><span class="pre">compat_sys_xyzzy()</span></code>, y se agrega con la macro
<code class="docutils literal notranslate"><span class="pre">COMPAT_SYSCALL_DEFINEn</span></code>, de manera análoga a SYSCALL_DEFINEn. Esta
versión de la implementación se ejecuta como parte de un kernel de 64-bit,
pero espera recibir parametros con valores 32-bit y hace lo que tenga que
hacer para tratar con ellos. (Típicamente, la versión <code class="docutils literal notranslate"><span class="pre">compat_sys_</span></code>
convierte los valores a versiones de 64 bits y llama a la versión <code class="docutils literal notranslate"><span class="pre">sys_</span></code>
o ambas llaman a una función de implementación interna común.)</p>
<p>El punto de entrada compat también necesita un prototipo de función
correspondiente, en <code class="docutils literal notranslate"><span class="pre">include/linux/compat.h</span></code>, marcado como asmlinkage
para igualar la forma en que las llamadas al sistema son invocadas:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>asmlinkage long compat_sys_xyzzy(...);
</pre></div>
</div>
<p>Si la nueva llamada al sistema involucra una estructura que que se dispone
de forma distinta en sistema de 32-bit y 64-bit, digamos
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xyzzy_args</span></code>, entonces el archivo de cabecera
include/linux/compat.h también debería incluir una versión compatible de la
estructura (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">compat_xyzzy_args</span></code>) donde cada campo de tamaño
variable tiene el tipo <code class="docutils literal notranslate"><span class="pre">compat_</span></code> apropiado que corresponde al tipo en
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xyzzy_args</span></code>. La rutina <code class="docutils literal notranslate"><span class="pre">compat_sys_xyzzy()</span></code> puede entonces usar
esta estructura <code class="docutils literal notranslate"><span class="pre">compat_</span></code> para analizar los argumentos de una invocación
de 32-bit.</p>
<p>Por ejemplo, si hay campos:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct xyzzy_args {
  const char __user *ptr;
  __kernel_long_t varying_val;
  u64 fixed_val;
  /* ... */
};
</pre></div>
</div>
<p>en struct xyzzy_args, entonces struct compat_xyzzy_args debe tener:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct compat_xyzzy_args {
  compat_uptr_t ptr;
  compat_long_t varying_val;
  u64 fixed_val;
  /* ... */
};
</pre></div>
</div>
<p>la lista genérica de llamadas al sistema también necesita ajustes para
permitir la versión compat; la entrada en
<code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/unistd.h</span></code> debería usar <code class="docutils literal notranslate"><span class="pre">__SC_COMP</span></code> en vez de
<code class="docutils literal notranslate"><span class="pre">__SYSCALL</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define __NR_xyzzy 292
__SC_COMP(__NR_xyzzy, sys_xyzzy, compat_sys_xyzzy)
</pre></div>
</div>
<p>Para resumir, necesita:</p>
<blockquote>
<div><ul class="simple">
<li><p>una <code class="docutils literal notranslate"><span class="pre">COMPAT_SYSCALL_DEFINEn(xyzzy,</span> <span class="pre">...)</span></code> para el punto de entrada de compat.</p></li>
<li><p>el prototipo correspondiente en <code class="docutils literal notranslate"><span class="pre">include/linux/compat.h</span></code></p></li>
<li><p>(en caso de ser necesario) un struct de mapeo de 32-bit en <code class="docutils literal notranslate"><span class="pre">include/linux/compat.h</span></code></p></li>
<li><p>una instancia de <code class="docutils literal notranslate"><span class="pre">__SC_COMP</span></code> no <code class="docutils literal notranslate"><span class="pre">__SYSCALL</span></code> en <code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/unistd.h</span></code></p></li>
</ul>
</div></blockquote>
</section>
<section id="compatibilidad-de-llamadas-de-sistema-x86">
<h2>Compatibilidad de Llamadas de Sistema (x86)<a class="headerlink" href="#compatibilidad-de-llamadas-de-sistema-x86" title="Link to this heading">¶</a></h2>
<p>Para conectar la arquitectura x86 de una llamada al sistema con una versión
de compatibilidad, las entradas en las tablas de syscall deben ser
ajustadas.</p>
<p>Primero, la entrada en <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_32.tbl</span></code> recibe
una columna extra para indicar que un programa del userspace de 32-bit
corriendo en un kernel de 64-bit debe llegar al punto de entrada compat:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>380  i386     xyzzy      sys_xyzzy    __ia32_compat_sys_xyzzy
</pre></div>
</div>
<p>Segundo, tienes que averiguar qué debería pasar para la versión x32 ABI de
la nueva llamada al sistema. Aquí hay una elección: el diseño de los
argumentos debería coincidir con la versión de 64-bit o la versión de
32-bit.</p>
<p>Si hay involucrado un puntero-a-puntero, la decisión es fácil: x32 es
ILP32, por lo que el diseño debe coincidir con la versión 32-bit, y la
entrada en <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_64.tbl</span></code> se divide para que
progamas 32-bit lleguen al envoltorio de compatibilidad:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>333   64        xyzzy       sys_xyzzy
...
555   x32       xyzzy       __x32_compat_sys_xyzzy
</pre></div>
</div>
<p>Si no hay punteros involucrados, entonces es preferible reutilizar el system
call 64-bit para el x32 ABI  (y consecuentemente la entrada en
arch/x86/entry/syscalls/syscall_64.tbl no se cambia).</p>
<p>En cualquier caso, debes revisar que lo tipos involucrados en su diseño de
argumentos de hecho asigne exactamente de x32 (-mx32) a 32-bit(-m32) o
equivalentes 64-bit (-m64).</p>
</section>
<section id="llamadas-de-sistema-retornando-a-otros-lugares">
<h2>Llamadas de Sistema Retornando a Otros Lugares<a class="headerlink" href="#llamadas-de-sistema-retornando-a-otros-lugares" title="Link to this heading">¶</a></h2>
<p>Para la mayoría de las llamadas al sistema, una vez que se la llamada al
sistema se ha completado el programa de usuario continúa exactamente donde
quedó -- en la siguiente instrucción, con el stack igual y la mayoría de
los registros igual que antes de la llamada al sistema, y con el mismo
espacio en la memoria virtual.</p>
<p>Sin embargo, unas pocas llamadas al sistema hacen las cosas diferente.
Estas podrían retornar a una ubicación distinta (<code class="docutils literal notranslate"><span class="pre">rt_sigreturn</span></code>) o
cambiar el espacio de memoria (<code class="docutils literal notranslate"><span class="pre">fork</span></code>/<code class="docutils literal notranslate"><span class="pre">vfork</span></code>/<code class="docutils literal notranslate"><span class="pre">clone</span></code>) o incluso de
arquitectura (<code class="docutils literal notranslate"><span class="pre">execve</span></code>/<code class="docutils literal notranslate"><span class="pre">execveat</span></code>) del programa.</p>
<p>Para permitir esto, la implementación del kernel de la llamada al sistema
podría necesitar guardar y restaurar registros adicionales al stak del
kernel, brindandole control completo de donde y cómo la ejecución continúa
después de la llamada a sistema.</p>
<p>Esto es arch-specific, pero típicamente involucra definir puntos de entrada
assembly que guardan/restauran registros adicionales e invocan el punto de
entrada real de la llamada a sistema.</p>
<p>Para x86_64, esto es implementado como un punto de entrada <code class="docutils literal notranslate"><span class="pre">stub_xyzzy</span></code>
en <code class="docutils literal notranslate"><span class="pre">arch/x86/entry/entry_64.S</span></code>, y la entrada en la tabla syscall
(<code class="docutils literal notranslate"><span class="pre">arch/x86/entry/syscalls/syscall_32.tbl</span></code>) es ajustada para calzar:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>333   common  xyzzy     stub_xyzzy
</pre></div>
</div>
<p>El equivalente para programas 32-bit corriendo en un kernel 64-bit es
normalmente llamado <code class="docutils literal notranslate"><span class="pre">stub32_xyzzy</span></code> e implementado en
<code class="docutils literal notranslate"><span class="pre">arch/x86/entry/entry_64_compat.S</span></code>, con el correspondiente ajuste en la
tabla syscall en <code class="docutils literal notranslate"><span class="pre">arch/x86/syscalls/syscall_32.tbl</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>380    i386       xyzzy     sys_xyzzy     stub32_xyzzy
</pre></div>
</div>
<p>Si la llamada a sistema necesita una capa de compatibilidad (como en la
sección anterior) entonces la versión <code class="docutils literal notranslate"><span class="pre">stub32_</span></code> necesita llamar a la
versión <code class="docutils literal notranslate"><span class="pre">compat_sys_</span></code> de la llamada a sistema, en vez de la versión
nativa de 64-bit. También, si la implementación de la versión x32 ABI no es
comun con la versión x86_64, entonces su tabla syscall también necesitará
invocar un stub que llame a la versión <code class="docutils literal notranslate"><span class="pre">compat_sys_</span></code></p>
<p>Para completar, también es agradable configurar un mapeo de modo que el
user-mode linux todavía funcione -- su tabla syscall referenciará
stub_xyzzy, pero el UML construido no incluye una implementación
<code class="docutils literal notranslate"><span class="pre">arch/x86/entry/entry_64.S</span></code>. Arreglar esto es tan simple como agregar un
#define a <code class="docutils literal notranslate"><span class="pre">arch/x86/um/sys_call_table_64.c</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define stub_xyzzy sys_xyzzy
</pre></div>
</div>
</section>
<section id="otros-detalles">
<h2>Otros detalles<a class="headerlink" href="#otros-detalles" title="Link to this heading">¶</a></h2>
<p>La mayoría del kernel trata las llamadas a sistema de manera genérica, pero
está la excepción ocasional que pueda requerir actualización para su
llamada a sistema particular.</p>
<p>El subsistema de auditoría es un caso especial; este incluye funciones
(arch-specific) que clasifican algunos tipos especiales de llamadas al
sistema -- específicamente file open (<code class="docutils literal notranslate"><span class="pre">open</span></code>/<code class="docutils literal notranslate"><span class="pre">openat</span></code>), program
execution (<code class="docutils literal notranslate"><span class="pre">execve</span></code> /<code class="docutils literal notranslate"><span class="pre">execveat</span></code>) o operaciones multiplexores de socket
(<code class="docutils literal notranslate"><span class="pre">socketcall</span></code>). Si su nueva llamada de sistema es análoga a alguna de
estas, entonces el sistema auditor debe ser actualizado.</p>
<p>Más generalmente, si existe una llamada al sistema que sea análoga a su
nueva llamada al sistema, entonces vale la pena hacer un grep a todo el
kernel de la llamada a sistema existente, para revisar que no exista otro
caso especial.</p>
</section>
<section id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Link to this heading">¶</a></h2>
<p>Una nueva llamada al sistema debe obviamente ser probada; también es útil
proveer a los revisores con una demostración de cómo los programas del
userspace usarán la llamada al sistema. Una buena forma de combinar estos
objetivos es incluir un simple programa self-test en un nuevo directorio
bajo <code class="docutils literal notranslate"><span class="pre">tools/testing/selftests/</span></code>.</p>
<p>Para una nueva llamada al sistema, obviamente no habrá una función
envoltorio libc por lo que el test necesitará ser invocado usando
<code class="docutils literal notranslate"><span class="pre">syscall()</span></code>; también, si la llamada al sistema involucra una nueva
estructura userspace-visible, el encabezado correspondiente necesitará ser
instalado para compilar el test.</p>
<p>Asegure que selftest corra satisfactoriamente en todas las arquitecturas
soportadas. Por ejemplo, revise si funciona cuando es compilado como un
x86_64 (-m64), x86_32 (-m32) y x32 (-mx32) programa ABI.</p>
<p>Para pruebas más amplias y exhautivas de la nueva funcionalidad, también
debería considerar agregar tests al Linus Test Project, o al proyecto
xfstests para cambios filesystem-related</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://linux-test-project.github.io/">https://linux-test-project.github.io/</a></p></li>
<li><p>git://git.kernel.org/pub/scm/fs/xfs/xfstests-dev.git</p></li>
</ul>
</div></blockquote>
</section>
<section id="man-page">
<h2>Man Page<a class="headerlink" href="#man-page" title="Link to this heading">¶</a></h2>
<p>Todas las llamada al sistema nueva deben venir con un man page completo,
idealmente usando groff markup, pero texto plano también funciona. Si se
usa groff, es útil incluir una versión ASCII pre-renderizada del man-page
en el cover del email para el patchset, para la conveniencia de los
revisores.</p>
<p>El man page debe ser cc’do a <a class="reference external" href="mailto:linux-man&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-man<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>
Para más detalles, revise <a class="reference external" href="https://www.kernel.org/doc/man-pages/patches.html">https://www.kernel.org/doc/man-pages/patches.html</a></p>
</section>
<section id="no-invoque-las-llamadas-de-sistemas-en-el-kernel">
<h2>No invoque las llamadas de sistemas en el kernel<a class="headerlink" href="#no-invoque-las-llamadas-de-sistemas-en-el-kernel" title="Link to this heading">¶</a></h2>
<p>Las llamadas al sistema son, cómo se declaró más arriba, puntos de
interacción entre el userspace y el kernel. Por lo tanto, las funciones de
llamada al sistema como <code class="docutils literal notranslate"><span class="pre">sys_xyzzy()</span></code> o <code class="docutils literal notranslate"><span class="pre">compat_sys_xyzzy()</span></code> deberían
ser llamadas sólo desde el userspace vía la tabla de syscall, pero no de
otro lugar en el kernel. Si la funcionalidad syscall es útil para ser usada
dentro del kernel, necesita ser compartida entre syscalls nuevas o
antiguas, o necesita ser compartida entre una syscall y su variante de
compatibilidad, esta debería ser implementada mediante una función “helper”
(como <code class="docutils literal notranslate"><span class="pre">ksys_xyzzy()</span></code>). Esta función del kernel puede ahora ser llamada
dentro del syscall stub (<code class="docutils literal notranslate"><span class="pre">sys_xyzzy()</span></code>), la syscall stub de
compatibilidad (<code class="docutils literal notranslate"><span class="pre">compat_sys_xyzzy()</span></code>), y/o otro código del kernel.</p>
<p>Al menos en 64-bit x86, será un requerimiento duro desde la v4.17 en
adelante no invocar funciones de llamada al sistema (system call) en el
kernel. Este usa una convención de llamada diferente para llamadas al
sistema donde <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_regs</span></code> es decodificado on-the-fly en un
envoltorio syscall que luego entrega el procesamiento al syscall real. Esto
significa que sólo aquellos parámetros que son realmente necesarios para
una syscall específica son pasados durante la entrada del syscall, en vez
de llenar en seis registros de CPU con contenido random del userspace todo
el tiempo (los cuales podrían causar serios problemas bajando la cadena de
llamadas).</p>
<p>Más aún, reglas sobre cómo se debería acceder a la data pueden diferir
entre la data del kernel y la data de usuario. Esta es otra razón por la
cual llamar a <code class="docutils literal notranslate"><span class="pre">sys_xyzzy()</span></code> es generalmente una mala idea.</p>
<p>Excepciones a esta regla están permitidas solamente en overrides
específicos de arquitectura, envoltorios de compatibilidad específicos de
arquitectura, u otro código en arch/.</p>
</section>
<section id="referencias-y-fuentes">
<h2>Referencias y fuentes<a class="headerlink" href="#referencias-y-fuentes" title="Link to this heading">¶</a></h2>
<blockquote>
<div><ul>
<li><p>Artículo LWN de Michael Kerrisk sobre el uso de argumentos flags en llamadas al
sistema:
<a class="reference external" href="https://lwn.net/Articles/585415/">https://lwn.net/Articles/585415/</a></p></li>
<li><p>Artículo LWN de Michael Kerrisk sobre cómo manejar flags desconocidos en una
llamada al sistema: <a class="reference external" href="https://lwn.net/Articles/588444/">https://lwn.net/Articles/588444/</a></p></li>
<li><p>Artículo LWN de Jake Edge describiendo restricciones en argumentos en
64-bit system call: <a class="reference external" href="https://lwn.net/Articles/311630/">https://lwn.net/Articles/311630/</a></p></li>
<li><p>Par de artículos LWN de David Drysdale que describen la ruta de implementación
de llamadas al sistema en detalle para v3.14:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://lwn.net/Articles/604287/">https://lwn.net/Articles/604287/</a></p></li>
<li><p><a class="reference external" href="https://lwn.net/Articles/604515/">https://lwn.net/Articles/604515/</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Requerimientos arquitectura-específicos para llamadas al sistema son discutidos en el
<em class="manpage">syscall(2)</em> man-page:
<a class="reference external" href="http://man7.org/linux/man-pages/man2/syscall.2.html#NOTES">http://man7.org/linux/man-pages/man2/syscall.2.html#NOTES</a></p></li>
<li><p>Recopilación de emails de Linus Torvalds discutiendo problemas con <code class="docutils literal notranslate"><span class="pre">ioctl()</span></code>:
<a class="reference external" href="https://yarchive.net/comp/linux/ioctl.html">https://yarchive.net/comp/linux/ioctl.html</a></p></li>
<li><p>“How to not invent kernel interfaces”, Arnd Bergmann,
<a class="reference external" href="https://www.ukuug.org/events/linux2007/2007/papers/Bergmann.pdf">https://www.ukuug.org/events/linux2007/2007/papers/Bergmann.pdf</a></p></li>
<li><p>Artículo LWN de Michael Kerrisk sobre evitar nuevos usos de CAP_SYS_ADMIN:
<a class="reference external" href="https://lwn.net/Articles/486306/">https://lwn.net/Articles/486306/</a></p></li>
<li><p>Recomendaciones de Andrew Morton que toda la información relacionada a una nueva
llamada al sistema debe venir en el mismo hilo de correos:
<a class="reference external" href="https://lore.kernel.org/r/20140724144747.3041b208832bbdf9fbce5d96&#64;linux-foundation.org">https://lore.kernel.org/r/20140724144747.3041b208832bbdf9fbce5d96&#64;linux-foundation.org</a></p></li>
<li><p>Recomendaciones de Michael Kerrisk que una nueva llamada al sistema debe venir
con un man-page: <a class="reference external" href="https://lore.kernel.org/r/CAKgNAkgMA39AfoSoA5Pe1r9N+ZzfYQNvNPvcRN7tOvRb8+v06Q&#64;mail.gmail.com">https://lore.kernel.org/r/CAKgNAkgMA39AfoSoA5Pe1r9N+ZzfYQNvNPvcRN7tOvRb8+v06Q&#64;mail.gmail.com</a></p></li>
<li><p>Sugerencias de Thomas Gleixner que conexiones x86 deben ir en commits
separados: <a class="reference external" href="https://lore.kernel.org/r/alpine.DEB.2.11.1411191249560.3909&#64;nanos">https://lore.kernel.org/r/alpine.DEB.2.11.1411191249560.3909&#64;nanos</a></p></li>
<li><p>Sugerencias de Greg Kroah-Hartman que es bueno para las nueva llamadas al sistema
que vengan con man-page y selftest: <a class="reference external" href="https://lore.kernel.org/r/20140320025530.GA25469&#64;kroah.com">https://lore.kernel.org/r/20140320025530.GA25469&#64;kroah.com</a></p></li>
<li><p>Discusión de Michael Kerrisk de nuevas system call vs. extensiones <em class="manpage">prctl(2)</em>:
<a class="reference external" href="https://lore.kernel.org/r/CAHO5Pa3F2MjfTtfNxa8LbnkeeU8=YJ+9tDqxZpw7Gz59E-4AUg&#64;mail.gmail.com">https://lore.kernel.org/r/CAHO5Pa3F2MjfTtfNxa8LbnkeeU8=YJ+9tDqxZpw7Gz59E-4AUg&#64;mail.gmail.com</a></p></li>
<li><p>Sugerencias de Ingo Molnar que llamadas al sistema que involucran múltiples
argumentos deben encapsular estos argumentos en una estructura, la cual incluye
un campo de tamaño para futura extensibilidad: <a class="reference external" href="https://lore.kernel.org/r/20150730083831.GA22182&#64;gmail.com">https://lore.kernel.org/r/20150730083831.GA22182&#64;gmail.com</a></p></li>
<li><p>Enumerando rarezas por la (re-)utilización de O_* numbering space flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://git.kernel.org/torvalds/c/75069f2b5bfb">commit 75069f2b5bfb</a> (“vfs: renumber FMODE_NONOTIFY and add to uniqueness
check”)</p></li>
<li><p><a class="reference external" href="https://git.kernel.org/torvalds/c/12ed2e36c98a">commit 12ed2e36c98a</a> (“fanotify: FMODE_NONOTIFY and __O_SYNC in sparc
conflict”)</p></li>
<li><p><a class="reference external" href="https://git.kernel.org/torvalds/c/bb458c644a59">commit bb458c644a59</a> (“Safer ABI for O_TMPFILE”)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Discusión de Matthew Wilcox sobre las restricciones en argumentos 64-bit:
<a class="reference external" href="https://lore.kernel.org/r/20081212152929.GM26095&#64;parisc-linux.org">https://lore.kernel.org/r/20081212152929.GM26095&#64;parisc-linux.org</a></p></li>
<li><p>Recomendaciones de Greg Kroah-Hartman sobre flags desconocidos deben ser
vigilados: <a class="reference external" href="https://lore.kernel.org/r/20140717193330.GB4703&#64;kroah.com">https://lore.kernel.org/r/20140717193330.GB4703&#64;kroah.com</a></p></li>
<li><p>Recomendaciones de Linus Torvalds que las llamadas al sistema x32 deben favorecer
compatibilidad con versiones 64-bit sobre versiones 32-bit:
<a class="reference external" href="https://lore.kernel.org/r/CA+55aFxfmwfB7jbbrXxa=K7VBYPfAvmu3XOkGrLbB1UFjX1+Ew&#64;mail.gmail.com">https://lore.kernel.org/r/CA+55aFxfmwfB7jbbrXxa=K7VBYPfAvmu3XOkGrLbB1UFjX1+Ew&#64;mail.gmail.com</a></p></li>
</ul>
</div></blockquote>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/sp_SP/process/adding-syscalls.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>