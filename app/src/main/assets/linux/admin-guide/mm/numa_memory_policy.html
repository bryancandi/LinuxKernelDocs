
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>NUMA Memory Policy &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="NUMA Memory Performance" href="numaperf.html" />
    <link rel="prev" title="No-MMU memory mapping support" href="nommu-mmap.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.6.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Kernel subsystem documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux kernel user's and administrator's guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../README.html">Linux kernel release 6.x &lt;http://kernel.org/&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel-parameters.html">The kernel's command-line parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devices.html">Linux allocated devices (4.x+ version)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sysctl/index.html">Documentation for /proc/sys</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi.html">Linux ABI description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../features.html">Feature status on all architectures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hw-vuln/index.html">Hardware vulnerabilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reporting-regressions.html">Reporting regressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quickly-build-trimmed-linux.html">How to quickly build a trimmed Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bug-hunting.html">Bug hunting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bug-bisect.html">Bisecting a bug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tainted-kernels.html">Tainted kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ramoops.html">Ramoops oops/panic logger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dynamic-debug-howto.html">Dynamic debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../init.html">Explaining the &quot;No working init found.&quot; boot hang message</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kdump/index.html">Documentation for Kdump - The kexec-based Crash Dumping Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../perf/index.html">Performance monitor support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pstore-blk.html">pstore block oops/panic logger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sysfs-rules.html">Rules on how to access information in sysfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workload-tracing.html">Discovering Linux kernel subsystems used by a workload</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../aoe/index.html">ATA over Ethernet (AoE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../auxdisplay/index.html">Auxiliary Display Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bcache.html">A block layer cache (bcache)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../binderfs.html">The Android binderfs Filesystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../binfmt-misc.html">Kernel Support for miscellaneous Binary Formats (binfmt_misc)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blockdev/index.html">Block Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bootconfig.html">Boot Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../braille-console.html">Linux Braille Console</a></li>
<li class="toctree-l2"><a class="reference internal" href="../btmrvl.html">btmrvl driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cgroup-v1/index.html">Control Groups version 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cgroup-v2.html">Control Group v2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cifs/index.html">CIFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clearing-warn-once.html">Clearing WARN_ONCE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpu-load.html">CPU load</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cputopology.html">How CPU topology info is exported via sysfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dell_rbu.html">Dell Remote BIOS Update driver (dell_rbu)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-mapper/index.html">Device Mapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edid.html">EDID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../efi-stub.html">The EFI Boot Stub</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ext4.html">ext4 General Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../filesystem-monitoring.html">File system Monitoring with fanotify</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfs/index.html">NFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">gpio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../highuid.html">Notes on the change from 16-bit UIDs to 32-bit UIDs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hw_random.html">Hardware random number generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../initrd.html">Using the initial RAM disk (initrd)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iostats.html">I/O statistics fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../java.html">Java(tm) Binary Kernel Support for Linux v1.03</a></li>
<li class="toctree-l2"><a class="reference internal" href="../jfs.html">IBM's Journaled File System (JFS) for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel-per-CPU-kthreads.html">Reducing OS jitter due to per-cpu kthreads</a></li>
<li class="toctree-l2"><a class="reference internal" href="../laptops/index.html">Laptop Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lcd-panel-cgram.html">Parallel port LCD/Keypad Panel support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ldm.html">LDM - Logical Disk Manager (Dynamic Disks)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lockup-watchdogs.html">Softlockup detector and hardlockup detector (aka nmi_watchdog)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../LSM/index.html">Linux Security Module Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md.html">RAID arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media/index.html">Media subsystem admin and user guide</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Memory Management</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="concepts.html">Concepts overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="cma_debugfs.html">CMA Debugfs Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="damon/index.html">DAMON: Data Access MONitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="hugetlbpage.html">HugeTLB Pages</a></li>
<li class="toctree-l3"><a class="reference internal" href="idle_page_tracking.html">Idle Page Tracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="ksm.html">Kernel Samepage Merging</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-hotplug.html">Memory Hot(Un)Plug</a></li>
<li class="toctree-l3"><a class="reference internal" href="multigen_lru.html">Multi-Gen LRU</a></li>
<li class="toctree-l3"><a class="reference internal" href="nommu-mmap.html">No-MMU memory mapping support</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">NUMA Memory Policy</a></li>
<li class="toctree-l3"><a class="reference internal" href="numaperf.html">NUMA Memory Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="pagemap.html">Examining Process Page Tables</a></li>
<li class="toctree-l3"><a class="reference internal" href="shrinker_debugfs.html">Shrinker Debugfs Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="soft-dirty.html">Soft-Dirty PTEs</a></li>
<li class="toctree-l3"><a class="reference internal" href="swap_numa.html">Automatically bind swap device to numa node</a></li>
<li class="toctree-l3"><a class="reference internal" href="transhuge.html">Transparent Hugepage Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="userfaultfd.html">Userfaultfd</a></li>
<li class="toctree-l3"><a class="reference internal" href="zswap.html">zswap</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../module-signing.html">Kernel module signing facility</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mono.html">Mono(tm) Binary Kernel Support for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../namespaces/index.html">Namespaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../numastat.html">Numa policy hit/miss statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport.html">Parport</a></li>
<li class="toctree-l2"><a class="reference internal" href="../perf-security.html">Perf events and tool security</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pnp.html">Linux Plug and Play Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ras.html">Reliability, Availability and Serviceability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rtc.html">Real Time Clock (RTC) Drivers for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial-console.html">Linux Serial Console</a></li>
<li class="toctree-l2"><a class="reference internal" href="../svga.html">Video Mode Selection Support 2.13</a></li>
<li class="toctree-l2"><a class="reference internal" href="../syscall-user-dispatch.html">Syscall User Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sysrq.html">Linux Magic System Request Key Hacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thermal/index.html">Thermal Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thunderbolt.html">USB4 and Thunderbolt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ufs.html">Using UFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../unicode.html">Unicode support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vga-softcursor.html">Software cursor for VGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../video-output.html">Video Output Switcher Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xfs.html">The SGI XFS Filesystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  sbar.scrollTop = currents[currents.length - 1].offsetTop;
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/admin-guide/mm/numa_memory_policy.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="numa-memory-policy">
<h1>NUMA Memory Policy<a class="headerlink" href="#numa-memory-policy" title="Permalink to this heading">¶</a></h1>
<section id="what-is-numa-memory-policy">
<h2>What is NUMA Memory Policy?<a class="headerlink" href="#what-is-numa-memory-policy" title="Permalink to this heading">¶</a></h2>
<p>In the Linux kernel, &quot;memory policy&quot; determines from which node the kernel will
allocate memory in a NUMA system or in an emulated NUMA system.  Linux has
supported platforms with Non-Uniform Memory Access architectures since 2.4.?.
The current memory policy support was added to Linux 2.6 around May 2004.  This
document attempts to describe the concepts and APIs of the 2.6 memory policy
support.</p>
<p>Memory policies should not be confused with cpusets
(<code class="docutils literal notranslate"><span class="pre">Documentation/admin-guide/cgroup-v1/cpusets.rst</span></code>)
which is an administrative mechanism for restricting the nodes from which
memory may be allocated by a set of processes. Memory policies are a
programming interface that a NUMA-aware application can take advantage of.  When
both cpusets and policies are applied to a task, the restrictions of the cpuset
takes priority.  See <a class="reference internal" href="#mem-pol-and-cpusets"><span class="std std-ref">Memory Policies and cpusets</span></a>
below for more details.</p>
</section>
<section id="memory-policy-concepts">
<h2>Memory Policy Concepts<a class="headerlink" href="#memory-policy-concepts" title="Permalink to this heading">¶</a></h2>
<section id="scope-of-memory-policies">
<h3>Scope of Memory Policies<a class="headerlink" href="#scope-of-memory-policies" title="Permalink to this heading">¶</a></h3>
<p>The Linux kernel supports _scopes_ of memory policy, described here from
most general to most specific:</p>
<dl>
<dt>System Default Policy</dt><dd><p>this policy is &quot;hard coded&quot; into the kernel.  It is the policy
that governs all page allocations that aren't controlled by
one of the more specific policy scopes discussed below.  When
the system is &quot;up and running&quot;, the system default policy will
use &quot;local allocation&quot; described below.  However, during boot
up, the system default policy will be set to interleave
allocations across all nodes with &quot;sufficient&quot; memory, so as
not to overload the initial boot node with boot-time
allocations.</p>
</dd>
<dt>Task/Process Policy</dt><dd><p>this is an optional, per-task policy.  When defined for a
specific task, this policy controls all page allocations made
by or on behalf of the task that aren't controlled by a more
specific scope. If a task does not define a task policy, then
all page allocations that would have been controlled by the
task policy &quot;fall back&quot; to the System Default Policy.</p>
<p>The task policy applies to the entire address space of a task. Thus,
it is inheritable, and indeed is inherited, across both fork()
[clone() w/o the CLONE_VM flag] and exec*().  This allows a parent task
to establish the task policy for a child task exec()'d from an
executable image that has no awareness of memory policy.  See the
<a class="reference internal" href="#memory-policy-apis"><span class="std std-ref">Memory Policy APIs</span></a> section,
below, for an overview of the system call
that a task may use to set/change its task/process policy.</p>
<p>In a multi-threaded task, task policies apply only to the thread
[Linux kernel task] that installs the policy and any threads
subsequently created by that thread.  Any sibling threads existing
at the time a new task policy is installed retain their current
policy.</p>
<p>A task policy applies only to pages allocated after the policy is
installed.  Any pages already faulted in by the task when the task
changes its task policy remain where they were allocated based on
the policy at the time they were allocated.</p>
</dd>
</dl>
<dl id="vma-policy">
<dt>VMA Policy</dt><dd><p>A &quot;VMA&quot; or &quot;Virtual Memory Area&quot; refers to a range of a task's
virtual address space.  A task may define a specific policy for a range
of its virtual address space.   See the
<a class="reference internal" href="#memory-policy-apis"><span class="std std-ref">Memory Policy APIs</span></a> section,
below, for an overview of the mbind() system call used to set a VMA
policy.</p>
<p>A VMA policy will govern the allocation of pages that back
this region of the address space.  Any regions of the task's
address space that don't have an explicit VMA policy will fall
back to the task policy, which may itself fall back to the
System Default Policy.</p>
<p>VMA policies have a few complicating details:</p>
<ul class="simple">
<li><p>VMA policy applies ONLY to anonymous pages.  These include
pages allocated for anonymous segments, such as the task
stack and heap, and any regions of the address space
mmap()ed with the MAP_ANONYMOUS flag.  If a VMA policy is
applied to a file mapping, it will be ignored if the mapping
used the MAP_SHARED flag.  If the file mapping used the
MAP_PRIVATE flag, the VMA policy will only be applied when
an anonymous page is allocated on an attempt to write to the
mapping-- i.e., at Copy-On-Write.</p></li>
<li><p>VMA policies are shared between all tasks that share a
virtual address space--a.k.a. threads--independent of when
the policy is installed; and they are inherited across
fork().  However, because VMA policies refer to a specific
region of a task's address space, and because the address
space is discarded and recreated on exec*(), VMA policies
are NOT inheritable across exec().  Thus, only NUMA-aware
applications may use VMA policies.</p></li>
<li><p>A task may install a new VMA policy on a sub-range of a
previously mmap()ed region.  When this happens, Linux splits
the existing virtual memory area into 2 or 3 VMAs, each with
its own policy.</p></li>
<li><p>By default, VMA policy applies only to pages allocated after
the policy is installed.  Any pages already faulted into the
VMA range remain where they were allocated based on the
policy at the time they were allocated.  However, since
2.6.16, Linux supports page migration via the mbind() system
call, so that page contents can be moved to match a newly
installed policy.</p></li>
</ul>
</dd>
<dt>Shared Policy</dt><dd><p>Conceptually, shared policies apply to &quot;memory objects&quot; mapped
shared into one or more tasks' distinct address spaces.  An
application installs shared policies the same way as VMA
policies--using the mbind() system call specifying a range of
virtual addresses that map the shared object.  However, unlike
VMA policies, which can be considered to be an attribute of a
range of a task's address space, shared policies apply
directly to the shared object.  Thus, all tasks that attach to
the object share the policy, and all pages allocated for the
shared object, by any task, will obey the shared policy.</p>
<p>As of 2.6.22, only shared memory segments, created by shmget() or
mmap(MAP_ANONYMOUS|MAP_SHARED), support shared policy.  When shared
policy support was added to Linux, the associated data structures were
added to hugetlbfs shmem segments.  At the time, hugetlbfs did not
support allocation at fault time--a.k.a lazy allocation--so hugetlbfs
shmem segments were never &quot;hooked up&quot; to the shared policy support.
Although hugetlbfs segments now support lazy allocation, their support
for shared policy has not been completed.</p>
<p>As mentioned above in <a class="reference internal" href="#vma-policy"><span class="std std-ref">VMA policies</span></a> section,
allocations of page cache pages for regular files mmap()ed
with MAP_SHARED ignore any VMA policy installed on the virtual
address range backed by the shared file mapping.  Rather,
shared page cache pages, including pages backing private
mappings that have not yet been written by the task, follow
task policy, if any, else System Default Policy.</p>
<p>The shared policy infrastructure supports different policies on subset
ranges of the shared object.  However, Linux still splits the VMA of
the task that installs the policy for each range of distinct policy.
Thus, different tasks that attach to a shared memory segment can have
different VMA configurations mapping that one shared object.  This
can be seen by examining the /proc/&lt;pid&gt;/numa_maps of tasks sharing
a shared memory region, when one task has installed shared policy on
one or more ranges of the region.</p>
</dd>
</dl>
</section>
<section id="components-of-memory-policies">
<h3>Components of Memory Policies<a class="headerlink" href="#components-of-memory-policies" title="Permalink to this heading">¶</a></h3>
<p>A NUMA memory policy consists of a &quot;mode&quot;, optional mode flags, and
an optional set of nodes.  The mode determines the behavior of the
policy, the optional mode flags determine the behavior of the mode,
and the optional set of nodes can be viewed as the arguments to the
policy behavior.</p>
<p>Internally, memory policies are implemented by a reference counted
structure, struct mempolicy.  Details of this structure will be
discussed in context, below, as required to explain the behavior.</p>
<p>NUMA memory policy supports the following 4 behavioral modes:</p>
<dl>
<dt>Default Mode--MPOL_DEFAULT</dt><dd><p>This mode is only used in the memory policy APIs.  Internally,
MPOL_DEFAULT is converted to the NULL memory policy in all
policy scopes.  Any existing non-default policy will simply be
removed when MPOL_DEFAULT is specified.  As a result,
MPOL_DEFAULT means &quot;fall back to the next most specific policy
scope.&quot;</p>
<p>For example, a NULL or default task policy will fall back to the
system default policy.  A NULL or default vma policy will fall
back to the task policy.</p>
<p>When specified in one of the memory policy APIs, the Default mode
does not use the optional set of nodes.</p>
<p>It is an error for the set of nodes specified for this policy to
be non-empty.</p>
</dd>
<dt>MPOL_BIND</dt><dd><p>This mode specifies that memory must come from the set of
nodes specified by the policy.  Memory will be allocated from
the node in the set with sufficient free memory that is
closest to the node where the allocation takes place.</p>
</dd>
<dt>MPOL_PREFERRED</dt><dd><p>This mode specifies that the allocation should be attempted
from the single node specified in the policy.  If that
allocation fails, the kernel will search other nodes, in order
of increasing distance from the preferred node based on
information provided by the platform firmware.</p>
<p>Internally, the Preferred policy uses a single node--the
preferred_node member of struct mempolicy.  When the internal
mode flag MPOL_F_LOCAL is set, the preferred_node is ignored
and the policy is interpreted as local allocation.  &quot;Local&quot;
allocation policy can be viewed as a Preferred policy that
starts at the node containing the cpu where the allocation
takes place.</p>
<p>It is possible for the user to specify that local allocation
is always preferred by passing an empty nodemask with this
mode.  If an empty nodemask is passed, the policy cannot use
the MPOL_F_STATIC_NODES or MPOL_F_RELATIVE_NODES flags
described below.</p>
</dd>
<dt>MPOL_INTERLEAVED</dt><dd><p>This mode specifies that page allocations be interleaved, on a
page granularity, across the nodes specified in the policy.
This mode also behaves slightly differently, based on the
context where it is used:</p>
<p>For allocation of anonymous pages and shared memory pages,
Interleave mode indexes the set of nodes specified by the
policy using the page offset of the faulting address into the
segment [VMA] containing the address modulo the number of
nodes specified by the policy.  It then attempts to allocate a
page, starting at the selected node, as if the node had been
specified by a Preferred policy or had been selected by a
local allocation.  That is, allocation will follow the per
node zonelist.</p>
<p>For allocation of page cache pages, Interleave mode indexes
the set of nodes specified by the policy using a node counter
maintained per task.  This counter wraps around to the lowest
specified node after it reaches the highest specified node.
This will tend to spread the pages out over the nodes
specified by the policy based on the order in which they are
allocated, rather than based on any page offset into an
address range or file.  During system boot up, the temporary
interleaved system default policy works in this mode.</p>
</dd>
<dt>MPOL_PREFERRED_MANY</dt><dd><p>This mode specifies that the allocation should be preferably
satisfied from the nodemask specified in the policy. If there is
a memory pressure on all nodes in the nodemask, the allocation
can fall back to all existing numa nodes. This is effectively
MPOL_PREFERRED allowed for a mask rather than a single node.</p>
</dd>
</dl>
<p>NUMA memory policy supports the following optional mode flags:</p>
<dl>
<dt>MPOL_F_STATIC_NODES</dt><dd><p>This flag specifies that the nodemask passed by
the user should not be remapped if the task or VMA's set of allowed
nodes changes after the memory policy has been defined.</p>
<p>Without this flag, any time a mempolicy is rebound because of a
change in the set of allowed nodes, the preferred nodemask (Preferred
Many), preferred node (Preferred) or nodemask (Bind, Interleave) is
remapped to the new set of allowed nodes.  This may result in nodes
being used that were previously undesired.</p>
<p>With this flag, if the user-specified nodes overlap with the
nodes allowed by the task's cpuset, then the memory policy is
applied to their intersection.  If the two sets of nodes do not
overlap, the Default policy is used.</p>
<p>For example, consider a task that is attached to a cpuset with
mems 1-3 that sets an Interleave policy over the same set.  If
the cpuset's mems change to 3-5, the Interleave will now occur
over nodes 3, 4, and 5.  With this flag, however, since only node
3 is allowed from the user's nodemask, the &quot;interleave&quot; only
occurs over that node.  If no nodes from the user's nodemask are
now allowed, the Default behavior is used.</p>
<p>MPOL_F_STATIC_NODES cannot be combined with the
MPOL_F_RELATIVE_NODES flag.  It also cannot be used for
MPOL_PREFERRED policies that were created with an empty nodemask
(local allocation).</p>
</dd>
<dt>MPOL_F_RELATIVE_NODES</dt><dd><p>This flag specifies that the nodemask passed
by the user will be mapped relative to the set of the task or VMA's
set of allowed nodes.  The kernel stores the user-passed nodemask,
and if the allowed nodes changes, then that original nodemask will
be remapped relative to the new set of allowed nodes.</p>
<p>Without this flag (and without MPOL_F_STATIC_NODES), anytime a
mempolicy is rebound because of a change in the set of allowed
nodes, the node (Preferred) or nodemask (Bind, Interleave) is
remapped to the new set of allowed nodes.  That remap may not
preserve the relative nature of the user's passed nodemask to its
set of allowed nodes upon successive rebinds: a nodemask of
1,3,5 may be remapped to 7-9 and then to 1-3 if the set of
allowed nodes is restored to its original state.</p>
<p>With this flag, the remap is done so that the node numbers from
the user's passed nodemask are relative to the set of allowed
nodes.  In other words, if nodes 0, 2, and 4 are set in the user's
nodemask, the policy will be effected over the first (and in the
Bind or Interleave case, the third and fifth) nodes in the set of
allowed nodes.  The nodemask passed by the user represents nodes
relative to task or VMA's set of allowed nodes.</p>
<p>If the user's nodemask includes nodes that are outside the range
of the new set of allowed nodes (for example, node 5 is set in
the user's nodemask when the set of allowed nodes is only 0-3),
then the remap wraps around to the beginning of the nodemask and,
if not already set, sets the node in the mempolicy nodemask.</p>
<p>For example, consider a task that is attached to a cpuset with
mems 2-5 that sets an Interleave policy over the same set with
MPOL_F_RELATIVE_NODES.  If the cpuset's mems change to 3-7, the
interleave now occurs over nodes 3,5-7.  If the cpuset's mems
then change to 0,2-3,5, then the interleave occurs over nodes
0,2-3,5.</p>
<p>Thanks to the consistent remapping, applications preparing
nodemasks to specify memory policies using this flag should
disregard their current, actual cpuset imposed memory placement
and prepare the nodemask as if they were always located on
memory nodes 0 to N-1, where N is the number of memory nodes the
policy is intended to manage.  Let the kernel then remap to the
set of memory nodes allowed by the task's cpuset, as that may
change over time.</p>
<p>MPOL_F_RELATIVE_NODES cannot be combined with the
MPOL_F_STATIC_NODES flag.  It also cannot be used for
MPOL_PREFERRED policies that were created with an empty nodemask
(local allocation).</p>
</dd>
</dl>
</section>
</section>
<section id="memory-policy-reference-counting">
<h2>Memory Policy Reference Counting<a class="headerlink" href="#memory-policy-reference-counting" title="Permalink to this heading">¶</a></h2>
<p>To resolve use/free races, struct mempolicy contains an atomic reference
count field.  Internal interfaces, mpol_get()/mpol_put() increment and
decrement this reference count, respectively.  mpol_put() will only free
the structure back to the mempolicy kmem cache when the reference count
goes to zero.</p>
<p>When a new memory policy is allocated, its reference count is initialized
to '1', representing the reference held by the task that is installing the
new policy.  When a pointer to a memory policy structure is stored in another
structure, another reference is added, as the task's reference will be dropped
on completion of the policy installation.</p>
<p>During run-time &quot;usage&quot; of the policy, we attempt to minimize atomic operations
on the reference count, as this can lead to cache lines bouncing between cpus
and NUMA nodes.  &quot;Usage&quot; here means one of the following:</p>
<ol class="arabic simple">
<li><p>querying of the policy, either by the task itself [using the get_mempolicy()
API discussed below] or by another task using the /proc/&lt;pid&gt;/numa_maps
interface.</p></li>
<li><p>examination of the policy to determine the policy mode and associated node
or node lists, if any, for page allocation.  This is considered a &quot;hot
path&quot;.  Note that for MPOL_BIND, the &quot;usage&quot; extends across the entire
allocation process, which may sleep during page reclamation, because the
BIND policy nodemask is used, by reference, to filter ineligible nodes.</p></li>
</ol>
<p>We can avoid taking an extra reference during the usages listed above as
follows:</p>
<ol class="arabic">
<li><p>we never need to get/free the system default policy as this is never
changed nor freed, once the system is up and running.</p></li>
<li><p>for querying the policy, we do not need to take an extra reference on the
target task's task policy nor vma policies because we always acquire the
task's mm's mmap_lock for read during the query.  The set_mempolicy() and
mbind() APIs [see below] always acquire the mmap_lock for write when
installing or replacing task or vma policies.  Thus, there is no possibility
of a task or thread freeing a policy while another task or thread is
querying it.</p></li>
<li><p>Page allocation usage of task or vma policy occurs in the fault path where
we hold them mmap_lock for read.  Again, because replacing the task or vma
policy requires that the mmap_lock be held for write, the policy can't be
freed out from under us while we're using it for page allocation.</p></li>
<li><p>Shared policies require special consideration.  One task can replace a
shared memory policy while another task, with a distinct mmap_lock, is
querying or allocating a page based on the policy.  To resolve this
potential race, the shared policy infrastructure adds an extra reference
to the shared policy during lookup while holding a spin lock on the shared
policy management structure.  This requires that we drop this extra
reference when we're finished &quot;using&quot; the policy.  We must drop the
extra reference on shared policies in the same query/allocation paths
used for non-shared policies.  For this reason, shared policies are marked
as such, and the extra reference is dropped &quot;conditionally&quot;--i.e., only
for shared policies.</p>
<p>Because of this extra reference counting, and because we must lookup
shared policies in a tree structure under spinlock, shared policies are
more expensive to use in the page allocation path.  This is especially
true for shared policies on shared memory regions shared by tasks running
on different NUMA nodes.  This extra overhead can be avoided by always
falling back to task or system default policy for shared memory regions,
or by prefaulting the entire shared memory region into memory and locking
it down.  However, this might not be appropriate for all applications.</p>
</li>
</ol>
</section>
<section id="memory-policy-apis">
<span id="id1"></span><h2>Memory Policy APIs<a class="headerlink" href="#memory-policy-apis" title="Permalink to this heading">¶</a></h2>
<p>Linux supports 4 system calls for controlling memory policy.  These APIS
always affect only the calling task, the calling task's address space, or
some shared object mapped into the calling task's address space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the headers that define these APIs and the parameter data types for
user space applications reside in a package that is not part of the
Linux kernel.  The kernel system call interfaces, with the 'sys_'
prefix, are defined in &lt;linux/syscalls.h&gt;; the mode and flag
definitions are defined in &lt;linux/mempolicy.h&gt;.</p>
</div>
<p>Set [Task] Memory Policy:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long set_mempolicy(int mode, const unsigned long *nmask,
                                unsigned long maxnode);
</pre></div>
</div>
<p>Set's the calling task's &quot;task/process memory policy&quot; to mode
specified by the 'mode' argument and the set of nodes defined by
'nmask'.  'nmask' points to a bit mask of node ids containing at least
'maxnode' ids.  Optional mode flags may be passed by combining the
'mode' argument with the flag (for example: MPOL_INTERLEAVE |
MPOL_F_STATIC_NODES).</p>
<p>See the set_mempolicy(2) man page for more details</p>
<p>Get [Task] Memory Policy or Related Information:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long get_mempolicy(int *mode,
                   const unsigned long *nmask, unsigned long maxnode,
                   void *addr, int flags);
</pre></div>
</div>
<p>Queries the &quot;task/process memory policy&quot; of the calling task, or the
policy or location of a specified virtual address, depending on the
'flags' argument.</p>
<p>See the get_mempolicy(2) man page for more details</p>
<p>Install VMA/Shared Policy for a Range of Task's Address Space:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long mbind(void *start, unsigned long len, int mode,
           const unsigned long *nmask, unsigned long maxnode,
           unsigned flags);
</pre></div>
</div>
<p>mbind() installs the policy specified by (mode, nmask, maxnodes) as a
VMA policy for the range of the calling task's address space specified
by the 'start' and 'len' arguments.  Additional actions may be
requested via the 'flags' argument.</p>
<p>See the mbind(2) man page for more details.</p>
<p>Set home node for a Range of Task's Address Spacec:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>long sys_set_mempolicy_home_node(unsigned long start, unsigned long len,
                                 unsigned long home_node,
                                 unsigned long flags);
</pre></div>
</div>
<p>sys_set_mempolicy_home_node set the home node for a VMA policy present in the
task's address range. The system call updates the home node only for the existing
mempolicy range. Other address ranges are ignored. A home node is the NUMA node
closest to which page allocation will come from. Specifying the home node override
the default allocation policy to allocate memory close to the local node for an
executing CPU.</p>
</section>
<section id="memory-policy-command-line-interface">
<h2>Memory Policy Command Line Interface<a class="headerlink" href="#memory-policy-command-line-interface" title="Permalink to this heading">¶</a></h2>
<p>Although not strictly part of the Linux implementation of memory policy,
a command line tool, numactl(8), exists that allows one to:</p>
<ul class="simple">
<li><p>set the task policy for a specified program via set_mempolicy(2), fork(2) and
exec(2)</p></li>
<li><p>set the shared policy for a shared memory segment via mbind(2)</p></li>
</ul>
<p>The numactl(8) tool is packaged with the run-time version of the library
containing the memory policy system call wrappers.  Some distributions
package the headers and compile-time libraries in a separate development
package.</p>
</section>
<section id="memory-policies-and-cpusets">
<span id="mem-pol-and-cpusets"></span><h2>Memory Policies and cpusets<a class="headerlink" href="#memory-policies-and-cpusets" title="Permalink to this heading">¶</a></h2>
<p>Memory policies work within cpusets as described above.  For memory policies
that require a node or set of nodes, the nodes are restricted to the set of
nodes whose memories are allowed by the cpuset constraints.  If the nodemask
specified for the policy contains nodes that are not allowed by the cpuset and
MPOL_F_RELATIVE_NODES is not used, the intersection of the set of nodes
specified for the policy and the set of nodes with memory is used.  If the
result is the empty set, the policy is considered invalid and cannot be
installed.  If MPOL_F_RELATIVE_NODES is used, the policy's nodes are mapped
onto and folded into the task's set of allowed nodes as previously described.</p>
<p>The interaction of memory policies and cpusets can be problematic when tasks
in two cpusets share access to a memory region, such as shared memory segments
created by shmget() of mmap() with the MAP_ANONYMOUS and MAP_SHARED flags, and
any of the tasks install shared policy on the region, only nodes whose
memories are allowed in both cpusets may be used in the policies.  Obtaining
this information requires &quot;stepping outside&quot; the memory policy APIs to use the
cpuset information and requires that one know in what cpusets other task might
be attaching to the shared region.  Furthermore, if the cpusets' allowed
memory sets are disjoint, &quot;local&quot; allocation is the only valid policy.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/admin-guide/mm/numa_memory_policy.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>