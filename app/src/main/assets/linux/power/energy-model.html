<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Energy Model of devices &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Freezing of tasks" href="freezing-of-tasks.html" />
    <link rel="prev" title="Testing suspend and resume support in device drivers" href="drivers-testing.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.10.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer’s API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/power/energy-model.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->



<div class="language-selection">
English

<ul>

<li><a href="../translations/zh_CN/power/energy-model.html">Chinese (Simplified)</a></li>

</ul>
</div>
<section id="energy-model-of-devices">
<h1>Energy Model of devices<a class="headerlink" href="#energy-model-of-devices" title="Link to this heading">¶</a></h1>
<section id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>The Energy Model (EM) framework serves as an interface between drivers knowing
the power consumed by devices at various performance levels, and the kernel
subsystems willing to use that information to make energy-aware decisions.</p>
<p>The source of the information about the power consumed by devices can vary greatly
from one platform to another. These power costs can be estimated using
devicetree data in some cases. In others, the firmware will know better.
Alternatively, userspace might be best positioned. And so on. In order to avoid
each and every client subsystem to re-implement support for each and every
possible source of information on its own, the EM framework intervenes as an
abstraction layer which standardizes the format of power cost tables in the
kernel, hence enabling to avoid redundant work.</p>
<p>The power values might be expressed in micro-Watts or in an ‘abstract scale’.
Multiple subsystems might use the EM and it is up to the system integrator to
check that the requirements for the power value scale types are met. An example
can be found in the Energy-Aware Scheduler documentation
<a class="reference internal" href="../scheduler/sched-energy.html"><span class="doc">Energy Aware Scheduling</span></a>. For some subsystems like thermal or
powercap power values expressed in an ‘abstract scale’ might cause issues.
These subsystems are more interested in estimation of power used in the past,
thus the real micro-Watts might be needed. An example of these requirements can
be found in the Intelligent Power Allocation in
<a class="reference internal" href="../driver-api/thermal/power_allocator.html"><span class="doc">Power allocator governor tunables</span></a>.
Kernel subsystems might implement automatic detection to check whether EM
registered devices have inconsistent scale (based on EM internal flag).
Important thing to keep in mind is that when the power values are expressed in
an ‘abstract scale’ deriving real energy in micro-Joules would not be possible.</p>
<p>The figure below depicts an example of drivers (Arm-specific here, but the
approach is applicable to any architecture) providing power costs to the EM
framework, and interested clients reading the data from it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+---------------+  +-----------------+  +---------------+
| Thermal (IPA) |  | Scheduler (EAS) |  |     Other     |
+---------------+  +-----------------+  +---------------+
        |                   | em_cpu_energy()   |
        |                   | em_cpu_get()      |
        +---------+         |         +---------+
                  |         |         |
                  v         v         v
                 +---------------------+
                 |    Energy Model     |
                 |     Framework       |
                 +---------------------+
                    ^       ^       ^
                    |       |       | em_dev_register_perf_domain()
         +----------+       |       +---------+
         |                  |                 |
 +---------------+  +---------------+  +--------------+
 |  cpufreq-dt   |  |   arm_scmi    |  |    Other     |
 +---------------+  +---------------+  +--------------+
         ^                  ^                 ^
         |                  |                 |
 +--------------+   +---------------+  +--------------+
 | Device Tree  |   |   Firmware    |  |      ?       |
 +--------------+   +---------------+  +--------------+
</pre></div>
</div>
<p>In case of CPU devices the EM framework manages power cost tables per
‘performance domain’ in the system. A performance domain is a group of CPUs
whose performance is scaled together. Performance domains generally have a
1-to-1 mapping with CPUFreq policies. All CPUs in a performance domain are
required to have the same micro-architecture. CPUs in different performance
domains can have different micro-architectures.</p>
<p>To better reflect power variation due to static power (leakage) the EM
supports runtime modifications of the power values. The mechanism relies on
RCU to free the modifiable EM perf_state table memory. Its user, the task
scheduler, also uses RCU to access this memory. The EM framework provides
API for allocating/freeing the new memory for the modifiable EM table.
The old memory is freed automatically using RCU callback mechanism when there
are no owners anymore for the given EM runtime table instance. This is tracked
using kref mechanism. The device driver which provided the new EM at runtime,
should call EM API to free it safely when it’s no longer needed. The EM
framework will handle the clean-up when it’s possible.</p>
<p>The kernel code which want to modify the EM values is protected from concurrent
access using a mutex. Therefore, the device driver code must run in sleeping
context when it tries to modify the EM.</p>
<p>With the runtime modifiable EM we switch from a ‘single and during the entire
runtime static EM’ (system property) design to a ‘single EM which can be
changed during runtime according e.g. to the workload’ (system and workload
property) design.</p>
<p>It is possible also to modify the CPU performance values for each EM’s
performance state. Thus, the full power and performance profile (which
is an exponential curve) can be changed according e.g. to the workload
or system property.</p>
</section>
<section id="core-apis">
<h2>2. Core APIs<a class="headerlink" href="#core-apis" title="Link to this heading">¶</a></h2>
<section id="config-options">
<h3>2.1 Config options<a class="headerlink" href="#config-options" title="Link to this heading">¶</a></h3>
<p>CONFIG_ENERGY_MODEL must be enabled to use the EM framework.</p>
</section>
<section id="registration-of-performance-domains">
<h3>2.2 Registration of performance domains<a class="headerlink" href="#registration-of-performance-domains" title="Link to this heading">¶</a></h3>
<section id="registration-of-advanced-em">
<h4>Registration of ‘advanced’ EM<a class="headerlink" href="#registration-of-advanced-em" title="Link to this heading">¶</a></h4>
<p>The ‘advanced’ EM gets its name due to the fact that the driver is allowed
to provide more precised power model. It’s not limited to some implemented math
formula in the framework (like it is in ‘simple’ EM case). It can better reflect
the real power measurements performed for each performance state. Thus, this
registration method should be preferred in case considering EM static power
(leakage) is important.</p>
<p>Drivers are expected to register performance domains into the EM framework by
calling the following API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int em_dev_register_perf_domain(struct device *dev, unsigned int nr_states,
              struct em_data_callback *cb, cpumask_t *cpus, bool microwatts);
</pre></div>
</div>
<p>Drivers must provide a callback function returning &lt;frequency, power&gt; tuples
for each performance state. The callback function provided by the driver is free
to fetch data from any relevant location (DT, firmware, ...), and by any mean
deemed necessary. Only for CPU devices, drivers must specify the CPUs of the
performance domains using cpumask. For other devices than CPUs the last
argument must be set to NULL.
The last argument ‘microwatts’ is important to set with correct value. Kernel
subsystems which use EM might rely on this flag to check if all EM devices use
the same scale. If there are different scales, these subsystems might decide
to return warning/error, stop working or panic.
See Section 3. for an example of driver implementing this
callback, or Section 2.4 for further documentation on this API</p>
</section>
<section id="registration-of-em-using-dt">
<h4>Registration of EM using DT<a class="headerlink" href="#registration-of-em-using-dt" title="Link to this heading">¶</a></h4>
<p>The  EM can also be registered using OPP framework and information in DT
“operating-points-v2”. Each OPP entry in DT can be extended with a property
“opp-microwatt” containing micro-Watts power value. This OPP DT property
allows a platform to register EM power values which are reflecting total power
(static + dynamic). These power values might be coming directly from
experiments and measurements.</p>
</section>
<section id="registration-of-artificial-em">
<h4>Registration of ‘artificial’ EM<a class="headerlink" href="#registration-of-artificial-em" title="Link to this heading">¶</a></h4>
<p>There is an option to provide a custom callback for drivers missing detailed
knowledge about power value for each performance state. The callback
.get_cost() is optional and provides the ‘cost’ values used by the EAS.
This is useful for platforms that only provide information on relative
efficiency between CPU types, where one could use the information to
create an abstract power model. But even an abstract power model can
sometimes be hard to fit in, given the input power value size restrictions.
The .get_cost() allows to provide the ‘cost’ values which reflect the
efficiency of the CPUs. This would allow to provide EAS information which
has different relation than what would be forced by the EM internal
formulas calculating ‘cost’ values. To register an EM for such platform, the
driver must set the flag ‘microwatts’ to 0, provide .get_power() callback
and provide .get_cost() callback. The EM framework would handle such platform
properly during registration. A flag EM_PERF_DOMAIN_ARTIFICIAL is set for such
platform. Special care should be taken by other frameworks which are using EM
to test and treat this flag properly.</p>
</section>
<section id="registration-of-simple-em">
<h4>Registration of ‘simple’ EM<a class="headerlink" href="#registration-of-simple-em" title="Link to this heading">¶</a></h4>
<p>The ‘simple’ EM is registered using the framework helper function
cpufreq_register_em_with_opp(). It implements a power model which is tight to
math formula:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Power = C * V^2 * f
</pre></div>
</div>
<p>The EM which is registered using this method might not reflect correctly the
physics of a real device, e.g. when static power (leakage) is important.</p>
</section>
</section>
<section id="accessing-performance-domains">
<h3>2.3 Accessing performance domains<a class="headerlink" href="#accessing-performance-domains" title="Link to this heading">¶</a></h3>
<p>There are two API functions which provide the access to the energy model:
<a class="reference internal" href="#c.em_cpu_get" title="em_cpu_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_get()</span></code></a> which takes CPU id as an argument and <a class="reference internal" href="#c.em_pd_get" title="em_pd_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_pd_get()</span></code></a> with device
pointer as an argument. It depends on the subsystem which interface it is
going to use, but in case of CPU devices both functions return the same
performance domain.</p>
<p>Subsystems interested in the energy model of a CPU can retrieve it using the
<a class="reference internal" href="#c.em_cpu_get" title="em_cpu_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_get()</span></code></a> API. The energy model tables are allocated once upon creation of
the performance domains, and kept in memory untouched.</p>
<p>The energy consumed by a performance domain can be estimated using the
<a class="reference internal" href="#c.em_cpu_energy" title="em_cpu_energy"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_energy()</span></code></a> API. The estimation is performed assuming that the schedutil
CPUfreq governor is in use in case of CPU device. Currently this calculation is
not provided for other type of devices.</p>
<p>More details about the above APIs can be found in <code class="docutils literal notranslate"><span class="pre">&lt;linux/energy_model.h&gt;</span></code>
or in Section 2.5</p>
</section>
<section id="runtime-modifications">
<h3>2.4 Runtime modifications<a class="headerlink" href="#runtime-modifications" title="Link to this heading">¶</a></h3>
<p>Drivers willing to update the EM at runtime should use the following dedicated
function to allocate a new instance of the modified EM. The API is listed
below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_table __rcu *em_table_alloc(struct em_perf_domain *pd);
</pre></div>
</div>
<p>This allows to allocate a structure which contains the new EM table with
also RCU and kref needed by the EM framework. The ‘<a class="reference internal" href="#c.em_perf_table" title="em_perf_table"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_table</span></code></a>’
contains array ‘<a class="reference internal" href="#c.em_perf_state" title="em_perf_state"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_state</span></code></a> state[]’ which is a list of performance
states in ascending order. That list must be populated by the device driver
which wants to update the EM. The list of frequencies can be taken from
existing EM (created during boot). The content in the ‘<a class="reference internal" href="#c.em_perf_state" title="em_perf_state"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_state</span></code></a>’
must be populated by the driver as well.</p>
<p>This is the API which does the EM update, using RCU pointers swap:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int em_dev_update_perf_domain(struct device *dev,
                      struct em_perf_table __rcu *new_table);
</pre></div>
</div>
<p>Drivers must provide a pointer to the allocated and initialized new EM
‘<a class="reference internal" href="#c.em_perf_table" title="em_perf_table"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_table</span></code></a>’. That new EM will be safely used inside the EM framework
and will be visible to other sub-systems in the kernel (thermal, powercap).
The main design goal for this API is to be fast and avoid extra calculations
or memory allocations at runtime. When pre-computed EMs are available in the
device driver, than it should be possible to simply re-use them with low
performance overhead.</p>
<p>In order to free the EM, provided earlier by the driver (e.g. when the module
is unloaded), there is a need to call the API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void em_table_free(struct em_perf_table __rcu *table);
</pre></div>
</div>
<p>It will allow the EM framework to safely remove the memory, when there is
no other sub-system using it, e.g. EAS.</p>
<p>To use the power values in other sub-systems (like thermal, powercap) there is
a need to call API which protects the reader and provide consistency of the EM
table data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_state *em_perf_state_from_pd(struct em_perf_domain *pd);
</pre></div>
</div>
<p>It returns the ‘<a class="reference internal" href="#c.em_perf_state" title="em_perf_state"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_state</span></code></a>’ pointer which is an array of performance
states in ascending order.
This function must be called in the RCU read lock section (after the
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>). When the EM table is not needed anymore there is a need to
call rcu_real_unlock(). In this way the EM safely uses the RCU read section
and protects the users. It also allows the EM framework to manage the memory
and free it. More details how to use it can be found in Section 3.2 in the
example driver.</p>
<p>There is dedicated API for device drivers to calculate em_perf_state::cost
values:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int em_dev_compute_costs(struct device *dev, struct em_perf_state *table,
                         int nr_states);
</pre></div>
</div>
<p>These ‘cost’ values from EM are used in EAS. The new EM table should be passed
together with the number of entries and device pointer. When the computation
of the cost values is done properly the return value from the function is 0.
The function takes care for right setting of inefficiency for each performance
state as well. It updates em_perf_state::flags accordingly.
Then such prepared new EM can be passed to the <a class="reference internal" href="#c.em_dev_update_perf_domain" title="em_dev_update_perf_domain"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_dev_update_perf_domain()</span></code></a>
function, which will allow to use it.</p>
<p>More details about the above APIs can be found in <code class="docutils literal notranslate"><span class="pre">&lt;linux/energy_model.h&gt;</span></code>
or in Section 3.2 with an example code showing simple implementation of the
updating mechanism in a device driver.</p>
</section>
<section id="description-details-of-this-api">
<h3>2.5 Description details of this API<a class="headerlink" href="#description-details-of-this-api" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.em_perf_state">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_perf_state</span></span></span><a class="headerlink" href="#c.em_perf_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performance state of a performance domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_state {
    unsigned long performance;
    unsigned long frequency;
    unsigned long power;
    unsigned long cost;
    unsigned long flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">performance</span></code></dt><dd><p>CPU performance (capacity) at a given frequency</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frequency</span></code></dt><dd><p>The frequency in KHz, for consistency with CPUFreq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">power</span></code></dt><dd><p>The power consumed at this level (by 1 CPU or by a registered
device). It can be a total power: static and dynamic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cost</span></code></dt><dd><p>The cost coefficient associated with this level, used during
energy calculation. Equal to: power * max_frequency / frequency</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>see “em_perf_state flags” description below.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.em_perf_table">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_perf_table</span></span></span><a class="headerlink" href="#c.em_perf_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performance states table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_table {
    struct rcu_head rcu;
    struct kref kref;
    struct em_perf_state state[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt><dd><p>RCU used for safe access and destruction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>Reference counter to track the users</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>List of performance states, in ascending order</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.em_perf_domain">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_perf_domain</span></span></span><a class="headerlink" href="#c.em_perf_domain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performance domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_domain {
    struct em_perf_table __rcu *em_table;
    int nr_perf_states;
    unsigned long flags;
    unsigned long cpus[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">em_table</span></code></dt><dd><p>Pointer to the runtime modifiable em_perf_table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_perf_states</span></code></dt><dd><p>Number of performance states</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>See “em_perf_domain flags”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpus</span></code></dt><dd><p>Cpumask covering the CPUs of the domain. It’s here
for performance reasons to avoid potential cache
misses during energy calculations in the scheduler
and simplifies allocating/freeing that memory region.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>In case of CPU device, a “performance domain” represents a group of CPUs
whose performance is scaled together. All CPUs of a performance domain
must have the same micro-architecture. Performance domains often have
a 1-to-1 mapping with CPUFreq policies. In case of other devices the <strong>cpus</strong>
field is unused.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_pd_get_efficient_state">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_pd_get_efficient_state</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.em_perf_state" title="em_perf_state"><span class="n"><span class="pre">em_perf_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">table</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_perf_states</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max_util</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pd_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_get_efficient_state" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get an efficient performance state from the EM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_state</span> <span class="pre">*table</span></code></dt><dd><p>List of performance states, in ascending order</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_perf_states</span></code></dt><dd><p>Number of performance states</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_util</span></code></dt><dd><p>Max utilization to map with the EM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pd_flags</span></code></dt><dd><p>Performance Domain flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is called from the scheduler code quite frequently and as a consequence
doesn’t implement any check.</p>
<p><strong>Return</strong></p>
<p>An efficient performance state id, high enough to meet <strong>max_util</strong>
requirement.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_cpu_energy">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_cpu_energy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="n"><span class="pre">em_perf_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pd</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">max_util</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">sum_util</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">allowed_cpu_cap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_cpu_energy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Estimates the energy consumed by the CPUs of a performance domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt><dd><p>performance domain for which energy has to be estimated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_util</span></code></dt><dd><p>highest utilization among CPUs of the domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">sum_util</span></code></dt><dd><p>sum of the utilization of all CPUs in the domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">allowed_cpu_cap</span></code></dt><dd><p>maximum allowed CPU capacity for the <strong>pd</strong>, which
might reflect reduced frequency (due to thermal)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be used only for CPU devices. There is no validation,
i.e. if the EM is a CPU type and has cpumask allocated. It is called from
the scheduler code quite frequently and that is why there is not checks.</p>
<p><strong>Return</strong></p>
<p>the sum of the energy consumed by the CPUs of the domain assuming
a capacity state satisfying the max utilization of the domain.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_pd_nr_perf_states">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_pd_nr_perf_states</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="n"><span class="pre">em_perf_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_nr_perf_states" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the number of performance states of a perf. domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt><dd><p>performance domain for which this must be done</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of performance states in the performance domain table</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_perf_state_from_pd">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.em_perf_state" title="em_perf_state"><span class="n"><span class="pre">em_perf_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">em_perf_state_from_pd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="n"><span class="pre">em_perf_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_perf_state_from_pd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the performance states table of perf. domain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt><dd><p>performance domain for which this must be done</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>To use this function the <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> should be hold. After the usage
of the performance states table is finished, the <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> should
be called.</p>
<p><strong>Return</strong></p>
<p>the pointer to performance states table of the performance domain</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_dev_update_perf_domain">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_dev_update_perf_domain</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.em_perf_table" title="em_perf_table"><span class="n"><span class="pre">em_perf_table</span></span></a><span class="w"> </span><span class="pre">__rcu</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_table</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_dev_update_perf_domain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update runtime EM table for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device for which the EM is to be updated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_table</span> <span class="pre">__rcu</span> <span class="pre">*new_table</span></code></dt><dd><p>The new EM table that is going to be used from now</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update EM runtime modifiable table for the <strong>dev</strong> using the provided <strong>table</strong>.</p>
<p>This function uses a mutex to serialize writers, so it must not be called
from a non-sleeping context.</p>
<p>Return 0 on success or an error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_pd_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="n"><span class="pre">em_perf_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">em_pd_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the performance domain for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find the performance domain for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the performance domain to which <strong>dev</strong> belongs, or NULL if it doesn’t
exist.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_cpu_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="n"><span class="pre">em_perf_domain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">em_cpu_get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cpu</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_cpu_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the performance domain for a CPU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU to find the performance domain for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the performance domain to which <strong>cpu</strong> belongs, or NULL if it doesn’t
exist.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_dev_register_perf_domain">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_dev_register_perf_domain</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_states</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">em_data_callback</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cb</span></span>, <span class="n"><span class="pre">cpumask_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cpus</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">microwatts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_dev_register_perf_domain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register the Energy Model (EM) for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device for which the EM is to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_states</span></code></dt><dd><p>Number of performance states to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_data_callback</span> <span class="pre">*cb</span></code></dt><dd><p>Callback functions providing the data of the Energy Model</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpumask_t</span> <span class="pre">*cpus</span></code></dt><dd><p>Pointer to cpumask_t, which in case of a CPU device is
obligatory. It can be taken from i.e. ‘policy-&gt;cpus’. For other
type of devices this should be set to NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">microwatts</span></code></dt><dd><p>Flag indicating that the power values are in micro-Watts or
in some other scale. It must be set properly.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create Energy Model tables for a performance domain using the callbacks
defined in cb.</p>
<p>The <strong>microwatts</strong> is important to set with correct value. Some kernel
sub-systems might rely on this flag and check if all devices in the EM are
using the same scale.</p>
<p>If multiple clients register the same performance domain, all but the first
registration will be ignored.</p>
<p>Return 0 on success</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_dev_unregister_perf_domain">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_dev_unregister_perf_domain</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_dev_unregister_perf_domain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unregister Energy Model (EM) for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device for which the EM is registered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister the EM for the specified <strong>dev</strong> (but not a CPU device).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.em_dev_update_chip_binning">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">em_dev_update_chip_binning</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.em_dev_update_chip_binning" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update Energy Model after the new voltage information is present in the OPPs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device for which the Energy Model has to be updated.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows to update easily the EM with new values available in
the OPP framework and DT. It can be used after the chip has been properly
verified by device drivers and the voltages adjusted for the ‘chip binning’.</p>
</div>
</section>
</section>
<section id="examples">
<h2>3. Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<section id="example-driver-with-em-registration">
<h3>3.1 Example driver with EM registration<a class="headerlink" href="#example-driver-with-em-registration" title="Link to this heading">¶</a></h3>
<p>The CPUFreq framework supports dedicated callback for registering
the EM for a given CPU(s) ‘policy’ object: cpufreq_driver::register_em().
That callback has to be implemented properly for a given driver,
because the framework would call it at the right time during setup.
This section provides a simple example of a CPUFreq driver registering a
performance domain in the Energy Model framework using the (fake) ‘foo’
protocol. The driver implements an est_power() function to be provided to the
EM framework:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-&gt; drivers/cpufreq/foo_cpufreq.c

01    static int est_power(struct device *dev, unsigned long *mW,
02                    unsigned long *KHz)
03    {
04            long freq, power;
05
06            /* Use the &#39;foo&#39; protocol to ceil the frequency */
07            freq = foo_get_freq_ceil(dev, *KHz);
08            if (freq &lt; 0);
09                    return freq;
10
11            /* Estimate the power cost for the dev at the relevant freq. */
12            power = foo_estimate_power(dev, freq);
13            if (power &lt; 0);
14                    return power;
15
16            /* Return the values to the EM framework */
17            *mW = power;
18            *KHz = freq;
19
20            return 0;
21    }
22
23    static void foo_cpufreq_register_em(struct cpufreq_policy *policy)
24    {
25            struct em_data_callback em_cb = EM_DATA_CB(est_power);
26            struct device *cpu_dev;
27            int nr_opp;
28
29            cpu_dev = get_cpu_device(cpumask_first(policy-&gt;cpus));
30
31            /* Find the number of OPPs for this policy */
32            nr_opp = foo_get_nr_opp(policy);
33
34            /* And register the new performance domain */
35            em_dev_register_perf_domain(cpu_dev, nr_opp, &amp;em_cb, policy-&gt;cpus,
36                                        true);
37    }
38
39    static struct cpufreq_driver foo_cpufreq_driver = {
40            .register_em = foo_cpufreq_register_em,
41    };
</pre></div>
</div>
</section>
<section id="example-driver-with-em-modification">
<h3>3.2 Example driver with EM modification<a class="headerlink" href="#example-driver-with-em-modification" title="Link to this heading">¶</a></h3>
<p>This section provides a simple example of a thermal driver modifying the EM.
The driver implements a foo_thermal_em_update() function. The driver is woken
up periodically to check the temperature and modify the EM data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-&gt; drivers/soc/example/example_em_mod.c

01    static void foo_get_new_em(struct foo_context *ctx)
02    {
03            struct em_perf_table __rcu *em_table;
04            struct em_perf_state *table, *new_table;
05            struct device *dev = ctx-&gt;dev;
06            struct em_perf_domain *pd;
07            unsigned long freq;
08            int i, ret;
09
10            pd = em_pd_get(dev);
11            if (!pd)
12                    return;
13
14            em_table = em_table_alloc(pd);
15            if (!em_table)
16                    return;
17
18            new_table = em_table-&gt;state;
19
20            rcu_read_lock();
21            table = em_perf_state_from_pd(pd);
22            for (i = 0; i &lt; pd-&gt;nr_perf_states; i++) {
23                    freq = table[i].frequency;
24                    foo_get_power_perf_values(dev, freq, &amp;new_table[i]);
25            }
26            rcu_read_unlock();
27
28            /* Calculate &#39;cost&#39; values for EAS */
29            ret = em_dev_compute_costs(dev, table, pd-&gt;nr_perf_states);
30            if (ret) {
31                    dev_warn(dev, &quot;EM: compute costs failed %d\n&quot;, ret);
32                    em_free_table(em_table);
33                    return;
34            }
35
36            ret = em_dev_update_perf_domain(dev, em_table);
37            if (ret) {
38                    dev_warn(dev, &quot;EM: update failed %d\n&quot;, ret);
39                    em_free_table(em_table);
40                    return;
41            }
42
43            /*
44             * Since it&#39;s one-time-update drop the usage counter.
45             * The EM framework will later free the table when needed.
46             */
47            em_table_free(em_table);
48    }
49
50    /*
51     * Function called periodically to check the temperature and
52     * update the EM if needed
53     */
54    static void foo_thermal_em_update(struct foo_context *ctx)
55    {
56            struct device *dev = ctx-&gt;dev;
57            int cpu;
58
59            ctx-&gt;temperature = foo_get_temp(dev, ctx);
60            if (ctx-&gt;temperature &lt; FOO_EM_UPDATE_TEMP_THRESHOLD)
61                    return;
62
63            foo_get_new_em(ctx);
64    }
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/power/energy-model.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>