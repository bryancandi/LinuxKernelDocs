<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4. XFS Online Fsck Design &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=3918102e" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ZoneFS - Zone filesystem for Zoned block devices" href="../zonefs.html" />
    <link rel="prev" title="3. XFS Self Describing Metadata" href="xfs-self-describing-metadata.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.12.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/filesystems/xfs/xfs-online-fsck-design.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<span class="target" id="xfs-online-fsck-design"></span><section id="id1">
<h1><span class="section-number">4. </span>XFS Online Fsck Design<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
<p>This document captures the design of the online filesystem check feature for
XFS.
The purpose of this document is threefold:</p>
<ul class="simple">
<li><p>To help kernel distributors understand exactly what the XFS online fsck
feature is, and issues about which they should be aware.</p></li>
<li><p>To help people reading the code to familiarize themselves with the relevant
concepts and design points before they start digging into the code.</p></li>
<li><p>To help developers maintaining the system by capturing the reasons
supporting higher level decision making.</p></li>
</ul>
<p>As the online fsck code is merged, the links in this document to topic branches
will be replaced with links to code.</p>
<p>This document is licensed under the terms of the GNU Public License, v2.
The primary author is Darrick J. Wong.</p>
<p>This design document is split into seven parts.
Part 1 defines what fsck tools are and the motivations for writing a new one.
Parts 2 and 3 present a high level overview of how online fsck process works
and how it is tested to ensure correct functionality.
Part 4 discusses the user interface and the intended usage modes of the new
program.
Parts 5 and 6 show off the high level components and how they fit together, and
then present case studies of how each repair function actually works.
Part 7 sums up what has been discussed so far and speculates about what else
might be built atop online fsck.</p>
<nav class="contents local" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#what-is-a-filesystem-check" id="id13">1. What is a Filesystem Check?</a></p>
<ul>
<li><p><a class="reference internal" href="#tldr-show-me-the-code" id="id14">TLDR; Show Me the Code!</a></p></li>
<li><p><a class="reference internal" href="#existing-tools" id="id15">Existing Tools</a></p></li>
<li><p><a class="reference internal" href="#problem-statement" id="id16">Problem Statement</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#theory-of-operation" id="id17">2. Theory of Operation</a></p>
<ul>
<li><p><a class="reference internal" href="#scope" id="id18">Scope</a></p></li>
<li><p><a class="reference internal" href="#phases-of-work" id="id19">Phases of Work</a></p></li>
<li><p><a class="reference internal" href="#steps-for-each-scrub-item" id="id20">Steps for Each Scrub Item</a></p></li>
<li><p><a class="reference internal" href="#classification-of-metadata" id="id21">Classification of Metadata</a></p>
<ul>
<li><p><a class="reference internal" href="#primary-metadata" id="id22">Primary Metadata</a></p></li>
<li><p><a class="reference internal" href="#secondary-metadata" id="id23">Secondary Metadata</a></p></li>
<li><p><a class="reference internal" href="#summary-information" id="id24">Summary Information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#risk-management" id="id25">Risk Management</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#testing-plan" id="id26">3. Testing Plan</a></p>
<ul>
<li><p><a class="reference internal" href="#integrated-testing-with-fstests" id="id27">Integrated Testing with fstests</a></p></li>
<li><p><a class="reference internal" href="#general-fuzz-testing-of-metadata-blocks" id="id28">General Fuzz Testing of Metadata Blocks</a></p></li>
<li><p><a class="reference internal" href="#targeted-fuzz-testing-of-metadata-records" id="id29">Targeted Fuzz Testing of Metadata Records</a></p></li>
<li><p><a class="reference internal" href="#stress-testing" id="id30">Stress Testing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#user-interface" id="id31">4. User Interface</a></p>
<ul>
<li><p><a class="reference internal" href="#checking-on-demand" id="id32">Checking on Demand</a></p></li>
<li><p><a class="reference internal" href="#background-service" id="id33">Background Service</a></p></li>
<li><p><a class="reference internal" href="#health-reporting" id="id34">Health Reporting</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#kernel-algorithms-and-data-structures" id="id35">5. Kernel Algorithms and Data Structures</a></p>
<ul>
<li><p><a class="reference internal" href="#self-describing-metadata" id="id36">Self Describing Metadata</a></p></li>
<li><p><a class="reference internal" href="#reverse-mapping" id="id37">Reverse Mapping</a></p></li>
<li><p><a class="reference internal" href="#checking-and-cross-referencing" id="id38">Checking and Cross-Referencing</a></p>
<ul>
<li><p><a class="reference internal" href="#metadata-buffer-verification" id="id39">Metadata Buffer Verification</a></p></li>
<li><p><a class="reference internal" href="#internal-consistency-checks" id="id40">Internal Consistency Checks</a></p></li>
<li><p><a class="reference internal" href="#validation-of-userspace-controlled-record-attributes" id="id41">Validation of Userspace-Controlled Record Attributes</a></p></li>
<li><p><a class="reference internal" href="#cross-referencing-space-metadata" id="id42">Cross-Referencing Space Metadata</a></p></li>
<li><p><a class="reference internal" href="#checking-extended-attributes" id="id43">Checking Extended Attributes</a></p></li>
<li><p><a class="reference internal" href="#checking-and-cross-referencing-directories" id="id44">Checking and Cross-Referencing Directories</a></p>
<ul>
<li><p><a class="reference internal" href="#checking-directory-attribute-btrees" id="id45">Checking Directory/Attribute Btrees</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#cross-referencing-summary-counters" id="id46">Cross-Referencing Summary Counters</a></p></li>
<li><p><a class="reference internal" href="#post-repair-reverification" id="id47">Post-Repair Reverification</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#eventual-consistency-vs-online-fsck" id="id48">Eventual Consistency vs. Online Fsck</a></p>
<ul>
<li><p><a class="reference internal" href="#discovery-of-the-problem" id="id49">Discovery of the Problem</a></p></li>
<li><p><a class="reference internal" href="#intent-drains" id="id50">Intent Drains</a></p></li>
<li><p><a class="reference internal" href="#static-keys-aka-jump-label-patching" id="id51">Static Keys (aka Jump Label Patching)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#pageable-kernel-memory" id="id52">Pageable Kernel Memory</a></p>
<ul>
<li><p><a class="reference internal" href="#xfile-access-models" id="id53">xfile Access Models</a></p></li>
<li><p><a class="reference internal" href="#xfile-access-coordination" id="id54">xfile Access Coordination</a></p></li>
<li><p><a class="reference internal" href="#arrays-of-fixed-sized-records" id="id55">Arrays of Fixed-Sized Records</a></p>
<ul>
<li><p><a class="reference internal" href="#array-access-patterns" id="id56">Array Access Patterns</a></p></li>
<li><p><a class="reference internal" href="#iterating-array-elements" id="id57">Iterating Array Elements</a></p></li>
<li><p><a class="reference internal" href="#sorting-array-elements" id="id58">Sorting Array Elements</a></p>
<ul>
<li><p><a class="reference internal" href="#case-study-sorting-xfarrays" id="id59">Case Study: Sorting xfarrays</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#blob-storage" id="id60">Blob Storage</a></p></li>
<li><p><a class="reference internal" href="#in-memory-b-trees" id="id61">In-Memory B+Trees</a></p>
<ul>
<li><p><a class="reference internal" href="#using-xfiles-as-a-buffer-cache-target" id="id62">Using xfiles as a Buffer Cache Target</a></p></li>
<li><p><a class="reference internal" href="#space-management-with-an-xfbtree" id="id63">Space Management with an xfbtree</a></p></li>
<li><p><a class="reference internal" href="#populating-an-xfbtree" id="id64">Populating an xfbtree</a></p></li>
<li><p><a class="reference internal" href="#committing-logged-xfbtree-buffers" id="id65">Committing Logged xfbtree Buffers</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#bulk-loading-of-ondisk-b-trees" id="id66">Bulk Loading of Ondisk B+Trees</a></p>
<ul>
<li><p><a class="reference internal" href="#geometry-computation" id="id67">Geometry Computation</a></p></li>
<li><p><a class="reference internal" href="#reserving-new-b-tree-blocks" id="id68">Reserving New B+Tree Blocks</a></p></li>
<li><p><a class="reference internal" href="#writing-the-new-tree" id="id69">Writing the New Tree</a></p>
<ul>
<li><p><a class="reference internal" href="#case-study-rebuilding-the-inode-index" id="id70">Case Study: Rebuilding the Inode Index</a></p></li>
<li><p><a class="reference internal" href="#case-study-rebuilding-the-space-reference-counts" id="id71">Case Study: Rebuilding the Space Reference Counts</a></p></li>
<li><p><a class="reference internal" href="#case-study-rebuilding-file-fork-mapping-indices" id="id72">Case Study: Rebuilding File Fork Mapping Indices</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#reaping-old-metadata-blocks" id="id73">Reaping Old Metadata Blocks</a></p>
<ul>
<li><p><a class="reference internal" href="#case-study-reaping-after-a-regular-btree-repair" id="id74">Case Study: Reaping After a Regular Btree Repair</a></p></li>
<li><p><a class="reference internal" href="#case-study-rebuilding-the-free-space-indices" id="id75">Case Study: Rebuilding the Free Space Indices</a></p></li>
<li><p><a class="reference internal" href="#case-study-reaping-after-repairing-reverse-mapping-btrees" id="id76">Case Study: Reaping After Repairing Reverse Mapping Btrees</a></p></li>
<li><p><a class="reference internal" href="#case-study-rebuilding-the-agfl" id="id77">Case Study: Rebuilding the AGFL</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#inode-record-repairs" id="id78">Inode Record Repairs</a></p></li>
<li><p><a class="reference internal" href="#quota-record-repairs" id="id79">Quota Record Repairs</a></p></li>
<li><p><a class="reference internal" href="#freezing-to-fix-summary-counters" id="id80">Freezing to Fix Summary Counters</a></p></li>
<li><p><a class="reference internal" href="#full-filesystem-scans" id="id81">Full Filesystem Scans</a></p>
<ul>
<li><p><a class="reference internal" href="#coordinated-inode-scans" id="id82">Coordinated Inode Scans</a></p></li>
<li><p><a class="reference internal" href="#inode-management" id="id83">Inode Management</a></p>
<ul>
<li><p><a class="reference internal" href="#iget-and-irele-during-a-scrub" id="id84">iget and irele During a Scrub</a></p></li>
<li><p><a class="reference internal" href="#locking-inodes" id="id85">Locking Inodes</a></p></li>
<li><p><a class="reference internal" href="#case-study-finding-a-directory-parent" id="id86">Case Study: Finding a Directory Parent</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#filesystem-hooks" id="id87">Filesystem Hooks</a></p></li>
<li><p><a class="reference internal" href="#live-updates-during-a-scan" id="id88">Live Updates During a Scan</a></p>
<ul>
<li><p><a class="reference internal" href="#case-study-quota-counter-checking" id="id89">Case Study: Quota Counter Checking</a></p></li>
<li><p><a class="reference internal" href="#case-study-file-link-count-checking" id="id90">Case Study: File Link Count Checking</a></p></li>
<li><p><a class="reference internal" href="#case-study-rebuilding-reverse-mapping-records" id="id91">Case Study: Rebuilding Reverse Mapping Records</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#staging-repairs-with-temporary-files-on-disk" id="id92">Staging Repairs with Temporary Files on Disk</a></p>
<ul>
<li><p><a class="reference internal" href="#using-a-temporary-file" id="id93">Using a Temporary File</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#logged-file-content-exchanges" id="id94">Logged File Content Exchanges</a></p>
<ul>
<li><p><a class="reference internal" href="#mechanics-of-a-logged-file-content-exchange" id="id95">Mechanics of a Logged File Content Exchange</a></p></li>
<li><p><a class="reference internal" href="#preparation-for-file-content-exchanges" id="id96">Preparation for File Content Exchanges</a></p></li>
<li><p><a class="reference internal" href="#special-features-for-exchanging-metadata-file-contents" id="id97">Special Features for Exchanging Metadata File Contents</a></p></li>
<li><p><a class="reference internal" href="#exchanging-temporary-file-contents" id="id98">Exchanging Temporary File Contents</a></p>
<ul>
<li><p><a class="reference internal" href="#case-study-repairing-the-realtime-summary-file" id="id99">Case Study: Repairing the Realtime Summary File</a></p></li>
<li><p><a class="reference internal" href="#case-study-salvaging-extended-attributes" id="id100">Case Study: Salvaging Extended Attributes</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#fixing-directories" id="id101">Fixing Directories</a></p>
<ul>
<li><p><a class="reference internal" href="#case-study-salvaging-directories" id="id102">Case Study: Salvaging Directories</a></p></li>
<li><p><a class="reference internal" href="#parent-pointers" id="id103">Parent Pointers</a></p>
<ul>
<li><p><a class="reference internal" href="#case-study-repairing-directories-with-parent-pointers" id="id104">Case Study: Repairing Directories with Parent Pointers</a></p></li>
<li><p><a class="reference internal" href="#case-study-repairing-parent-pointers" id="id105">Case Study: Repairing Parent Pointers</a></p></li>
<li><p><a class="reference internal" href="#digression-offline-checking-of-parent-pointers" id="id106">Digression: Offline Checking of Parent Pointers</a></p></li>
<li><p><a class="reference internal" href="#case-study-directory-tree-structure" id="id107">Case Study: Directory Tree Structure</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-orphanage" id="id108">The Orphanage</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#userspace-algorithms-and-data-structures" id="id109">6. Userspace Algorithms and Data Structures</a></p>
<ul>
<li><p><a class="reference internal" href="#checking-metadata" id="id110">Checking Metadata</a></p></li>
<li><p><a class="reference internal" href="#parallel-inode-scans" id="id111">Parallel Inode Scans</a></p></li>
<li><p><a class="reference internal" href="#scheduling-repairs" id="id112">Scheduling Repairs</a></p></li>
<li><p><a class="reference internal" href="#checking-names-for-confusable-unicode-sequences" id="id113">Checking Names for Confusable Unicode Sequences</a></p></li>
<li><p><a class="reference internal" href="#media-verification-of-file-data-extents" id="id114">Media Verification of File Data Extents</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#conclusion-and-future-work" id="id115">7. Conclusion and Future Work</a></p>
<ul>
<li><p><a class="reference internal" href="#xfs-ioc-exchange-range" id="id116">XFS_IOC_EXCHANGE_RANGE</a></p>
<ul>
<li><p><a class="reference internal" href="#file-content-exchanges-with-regular-user-files" id="id117">File Content Exchanges with Regular User Files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#vectorized-scrub" id="id118">Vectorized Scrub</a></p></li>
<li><p><a class="reference internal" href="#quality-of-service-targets-for-scrub" id="id119">Quality of Service Targets for Scrub</a></p></li>
<li><p><a class="reference internal" href="#defragmenting-free-space" id="id120">Defragmenting Free Space</a></p></li>
<li><p><a class="reference internal" href="#shrinking-filesystems" id="id121">Shrinking Filesystems</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="what-is-a-filesystem-check">
<h2><a class="toc-backref" href="#id13" role="doc-backlink"><span class="section-number">4.1. </span>1. What is a Filesystem Check?</a><a class="headerlink" href="#what-is-a-filesystem-check" title="Link to this heading">¶</a></h2>
<p>A Unix filesystem has four main responsibilities:</p>
<ul class="simple">
<li><p>Provide a hierarchy of names through which application programs can associate
arbitrary blobs of data for any length of time,</p></li>
<li><p>Virtualize physical storage media across those names, and</p></li>
<li><p>Retrieve the named data blobs at any time.</p></li>
<li><p>Examine resource usage.</p></li>
</ul>
<p>Metadata directly supporting these functions (e.g. files, directories, space
mappings) are sometimes called primary metadata.
Secondary metadata (e.g. reverse mapping and directory parent pointers) support
operations internal to the filesystem, such as internal consistency checking
and reorganization.
Summary metadata, as the name implies, condense information contained in
primary metadata for performance reasons.</p>
<p>The filesystem check (fsck) tool examines all the metadata in a filesystem
to look for errors.
In addition to looking for obvious metadata corruptions, fsck also
cross-references different types of metadata records with each other to look
for inconsistencies.
People do not like losing data, so most fsck tools also contains some ability
to correct any problems found.
As a word of caution -- the primary goal of most Linux fsck tools is to restore
the filesystem metadata to a consistent state, not to maximize the data
recovered.
That precedent will not be challenged here.</p>
<p>Filesystems of the 20th century generally lacked any redundancy in the ondisk
format, which means that fsck can only respond to errors by erasing files until
errors are no longer detected.
More recent filesystem designs contain enough redundancy in their metadata that
it is now possible to regenerate data structures when non-catastrophic errors
occur; this capability aids both strategies.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Note</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>System administrators avoid data loss by increasing the number of
separate storage systems through the creation of backups; and they avoid
downtime by increasing the redundancy of each storage system through the
creation of RAID arrays.
fsck tools address only the first problem.</p></td>
</tr>
</tbody>
</table>
<section id="tldr-show-me-the-code">
<h3><a class="toc-backref" href="#id14" role="doc-backlink"><span class="section-number">4.1.1. </span>TLDR; Show Me the Code!</a><a class="headerlink" href="#tldr-show-me-the-code" title="Link to this heading">¶</a></h3>
<p>Code is posted to the kernel.org git trees as follows:
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-symlink">kernel changes</a>,
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=scrub-media-scan-service">userspace changes</a>, and
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfstests-dev.git/log/?h=repair-dirs">QA test changes</a>.
Each kernel patchset adding an online repair function will use the same branch
name across the kernel, xfsprogs, and fstests git repos.</p>
</section>
<section id="existing-tools">
<h3><a class="toc-backref" href="#id15" role="doc-backlink"><span class="section-number">4.1.2. </span>Existing Tools</a><a class="headerlink" href="#existing-tools" title="Link to this heading">¶</a></h3>
<p>The online fsck tool described here will be the third tool in the history of
XFS (on Linux) to check and repair filesystems.
Two programs precede it:</p>
<p>The first program, <code class="docutils literal notranslate"><span class="pre">xfs_check</span></code>, was created as part of the XFS debugger
(<code class="docutils literal notranslate"><span class="pre">xfs_db</span></code>) and can only be used with unmounted filesystems.
It walks all metadata in the filesystem looking for inconsistencies in the
metadata, though it lacks any ability to repair what it finds.
Due to its high memory requirements and inability to repair things, this
program is now deprecated and will not be discussed further.</p>
<p>The second program, <code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code>, was created to be faster and more robust
than the first program.
Like its predecessor, it can only be used with unmounted filesystems.
It uses extent-based in-memory data structures to reduce memory consumption,
and tries to schedule readahead IO appropriately to reduce I/O waiting time
while it scans the metadata of the entire filesystem.
The most important feature of this tool is its ability to respond to
inconsistencies in file metadata and directory tree by erasing things as needed
to eliminate problems.
Space usage metadata are rebuilt from the observed file metadata.</p>
</section>
<section id="problem-statement">
<h3><a class="toc-backref" href="#id16" role="doc-backlink"><span class="section-number">4.1.3. </span>Problem Statement</a><a class="headerlink" href="#problem-statement" title="Link to this heading">¶</a></h3>
<p>The current XFS tools leave several problems unsolved:</p>
<ol class="arabic simple">
<li><p><strong>User programs</strong> suddenly <strong>lose access</strong> to the filesystem when unexpected
shutdowns occur as a result of silent corruptions in the metadata.
These occur <strong>unpredictably</strong> and often without warning.</p></li>
<li><p><strong>Users</strong> experience a <strong>total loss of service</strong> during the recovery period
after an <strong>unexpected shutdown</strong> occurs.</p></li>
<li><p><strong>Users</strong> experience a <strong>total loss of service</strong> if the filesystem is taken
offline to <strong>look for problems</strong> proactively.</p></li>
<li><p><strong>Data owners</strong> cannot <strong>check the integrity</strong> of their stored data without
reading all of it.
This may expose them to substantial billing costs when a linear media scan
performed by the storage system administrator might suffice.</p></li>
<li><p><strong>System administrators</strong> cannot <strong>schedule</strong> a maintenance window to deal
with corruptions if they <strong>lack the means</strong> to assess filesystem health
while the filesystem is online.</p></li>
<li><p><strong>Fleet monitoring tools</strong> cannot <strong>automate periodic checks</strong> of filesystem
health when doing so requires <strong>manual intervention</strong> and downtime.</p></li>
<li><p><strong>Users</strong> can be tricked into <strong>doing things they do not desire</strong> when
malicious actors <strong>exploit quirks of Unicode</strong> to place misleading names
in directories.</p></li>
</ol>
<p>Given this definition of the problems to be solved and the actors who would
benefit, the proposed solution is a third fsck tool that acts on a running
filesystem.</p>
<p>This new third program has three components: an in-kernel facility to check
metadata, an in-kernel facility to repair metadata, and a userspace driver
program to drive fsck activity on a live filesystem.
<code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> is the name of the driver program.
The rest of this document presents the goals and use cases of the new fsck
tool, describes its major design points in connection to those goals, and
discusses the similarities and differences with existing tools.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Note</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>Throughout this document, the existing offline fsck tool can also be
referred to by its current name “<code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code>”.
The userspace driver program for the new online fsck tool can be
referred to as “<code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code>”.
The kernel portion of online fsck that validates metadata is called
“online scrub”, and portion of the kernel that fixes metadata is called
“online repair”.</p></td>
</tr>
</tbody>
</table>
<p>The naming hierarchy is broken up into objects known as directories and files
and the physical space is split into pieces known as allocation groups.
Sharding enables better performance on highly parallel systems and helps to
contain the damage when corruptions occur.
The division of the filesystem into principal objects (allocation groups and
inodes) means that there are ample opportunities to perform targeted checks and
repairs on a subset of the filesystem.</p>
<p>While this is going on, other parts continue processing IO requests.
Even if a piece of filesystem metadata can only be regenerated by scanning the
entire system, the scan can still be done in the background while other file
operations continue.</p>
<p>In summary, online fsck takes advantage of resource sharding and redundant
metadata to enable targeted checking and repair operations while the system
is running.
This capability will be coupled to automatic system management so that
autonomous self-healing of XFS maximizes service availability.</p>
</section>
</section>
<section id="theory-of-operation">
<h2><a class="toc-backref" href="#id17" role="doc-backlink"><span class="section-number">4.2. </span>2. Theory of Operation</a><a class="headerlink" href="#theory-of-operation" title="Link to this heading">¶</a></h2>
<p>Because it is necessary for online fsck to lock and scan live metadata objects,
online fsck consists of three separate code components.
The first is the userspace driver program <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code>, which is responsible
for identifying individual metadata items, scheduling work items for them,
reacting to the outcomes appropriately, and reporting results to the system
administrator.
The second and third are in the kernel, which implements functions to check
and repair each type of online fsck work item.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Note</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>For brevity, this document shortens the phrase “online fsck work
item” to “scrub item”.</p></td>
</tr>
</tbody>
</table>
<p>Scrub item types are delineated in a manner consistent with the Unix design
philosophy, which is to say that each item should handle one aspect of a
metadata structure, and handle it well.</p>
<section id="scope">
<h3><a class="toc-backref" href="#id18" role="doc-backlink"><span class="section-number">4.2.1. </span>Scope</a><a class="headerlink" href="#scope" title="Link to this heading">¶</a></h3>
<p>In principle, online fsck should be able to check and to repair everything that
the offline fsck program can handle.
However, online fsck cannot be running 100% of the time, which means that
latent errors may creep in after a scrub completes.
If these errors cause the next mount to fail, offline fsck is the only
solution.
This limitation means that maintenance of the offline fsck tool will continue.
A second limitation of online fsck is that it must follow the same resource
sharing and lock acquisition rules as the regular filesystem.
This means that scrub cannot take <em>any</em> shortcuts to save time, because doing
so could lead to concurrency problems.
In other words, online fsck is not a complete replacement for offline fsck, and
a complete run of online fsck may take longer than online fsck.
However, both of these limitations are acceptable tradeoffs to satisfy the
different motivations of online fsck, which are to <strong>minimize system downtime</strong>
and to <strong>increase predictability of operation</strong>.</p>
</section>
<section id="phases-of-work">
<span id="scrubphases"></span><h3><a class="toc-backref" href="#id19" role="doc-backlink"><span class="section-number">4.2.2. </span>Phases of Work</a><a class="headerlink" href="#phases-of-work" title="Link to this heading">¶</a></h3>
<p>The userspace driver program <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> splits the work of checking and
repairing an entire filesystem into seven phases.
Each phase concentrates on checking specific types of scrub items and depends
on the success of all previous phases.
The seven phases are as follows:</p>
<ol class="arabic simple">
<li><p>Collect geometry information about the mounted filesystem and computer,
discover the online fsck capabilities of the kernel, and open the
underlying storage devices.</p></li>
<li><p>Check allocation group metadata, all realtime volume metadata, and all quota
files.
Each metadata structure is scheduled as a separate scrub item.
If corruption is found in the inode header or inode btree and <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code>
is permitted to perform repairs, then those scrub items are repaired to
prepare for phase 3.
Repairs are implemented by using the information in the scrub item to
resubmit the kernel scrub call with the repair flag enabled; this is
discussed in the next section.
Optimizations and all other repairs are deferred to phase 4.</p></li>
<li><p>Check all metadata of every file in the filesystem.
Each metadata structure is also scheduled as a separate scrub item.
If repairs are needed and <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> is permitted to perform repairs,
and there were no problems detected during phase 2, then those scrub items
are repaired immediately.
Optimizations, deferred repairs, and unsuccessful repairs are deferred to
phase 4.</p></li>
<li><p>All remaining repairs and scheduled optimizations are performed during this
phase, if the caller permits them.
Before starting repairs, the summary counters are checked and any necessary
repairs are performed so that subsequent repairs will not fail the resource
reservation step due to wildly incorrect summary counters.
Unsuccessful repairs are requeued as long as forward progress on repairs is
made somewhere in the filesystem.
Free space in the filesystem is trimmed at the end of phase 4 if the
filesystem is clean.</p></li>
<li><p>By the start of this phase, all primary and secondary filesystem metadata
must be correct.
Summary counters such as the free space counts and quota resource counts
are checked and corrected.
Directory entry names and extended attribute names are checked for
suspicious entries such as control characters or confusing Unicode sequences
appearing in names.</p></li>
<li><p>If the caller asks for a media scan, read all allocated and written data
file extents in the filesystem.
The ability to use hardware-assisted data file integrity checking is new
to online fsck; neither of the previous tools have this capability.
If media errors occur, they will be mapped to the owning files and reported.</p></li>
<li><p>Re-check the summary counters and presents the caller with a summary of
space usage and file counts.</p></li>
</ol>
<p>This allocation of responsibilities will be <a class="reference internal" href="#scrubcheck"><span class="std std-ref">revisited</span></a>
later in this document.</p>
</section>
<section id="steps-for-each-scrub-item">
<h3><a class="toc-backref" href="#id20" role="doc-backlink"><span class="section-number">4.2.3. </span>Steps for Each Scrub Item</a><a class="headerlink" href="#steps-for-each-scrub-item" title="Link to this heading">¶</a></h3>
<p>The kernel scrub code uses a three-step strategy for checking and repairing
the one aspect of a metadata object represented by a scrub item:</p>
<ol class="arabic simple">
<li><p>The scrub item of interest is checked for corruptions; opportunities for
optimization; and for values that are directly controlled by the system
administrator but look suspicious.
If the item is not corrupt or does not need optimization, resource are
released and the positive scan results are returned to userspace.
If the item is corrupt or could be optimized but the caller does not permit
this, resources are released and the negative scan results are returned to
userspace.
Otherwise, the kernel moves on to the second step.</p></li>
<li><p>The repair function is called to rebuild the data structure.
Repair functions generally choose rebuild a structure from other metadata
rather than try to salvage the existing structure.
If the repair fails, the scan results from the first step are returned to
userspace.
Otherwise, the kernel moves on to the third step.</p></li>
<li><p>In the third step, the kernel runs the same checks over the new metadata
item to assess the efficacy of the repairs.
The results of the reassessment are returned to userspace.</p></li>
</ol>
</section>
<section id="classification-of-metadata">
<h3><a class="toc-backref" href="#id21" role="doc-backlink"><span class="section-number">4.2.4. </span>Classification of Metadata</a><a class="headerlink" href="#classification-of-metadata" title="Link to this heading">¶</a></h3>
<p>Each type of metadata object (and therefore each type of scrub item) is
classified as follows:</p>
<section id="primary-metadata">
<h4><a class="toc-backref" href="#id22" role="doc-backlink"><span class="section-number">4.2.4.1. </span>Primary Metadata</a><a class="headerlink" href="#primary-metadata" title="Link to this heading">¶</a></h4>
<p>Metadata structures in this category should be most familiar to filesystem
users either because they are directly created by the user or they index
objects created by the user
Most filesystem objects fall into this class:</p>
<ul class="simple">
<li><p>Free space and reference count information</p></li>
<li><p>Inode records and indexes</p></li>
<li><p>Storage mapping information for file data</p></li>
<li><p>Directories</p></li>
<li><p>Extended attributes</p></li>
<li><p>Symbolic links</p></li>
<li><p>Quota limits</p></li>
</ul>
<p>Scrub obeys the same rules as regular filesystem accesses for resource and lock
acquisition.</p>
<p>Primary metadata objects are the simplest for scrub to process.
The principal filesystem object (either an allocation group or an inode) that
owns the item being scrubbed is locked to guard against concurrent updates.
The check function examines every record associated with the type for obvious
errors and cross-references healthy records against other metadata to look for
inconsistencies.
Repairs for this class of scrub item are simple, since the repair function
starts by holding all the resources acquired in the previous step.
The repair function scans available metadata as needed to record all the
observations needed to complete the structure.
Next, it stages the observations in a new ondisk structure and commits it
atomically to complete the repair.
Finally, the storage from the old data structure are carefully reaped.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> locks a primary object for the duration of the repair,
this is effectively an offline repair operation performed on a subset of the
filesystem.
This minimizes the complexity of the repair code because it is not necessary to
handle concurrent updates from other threads, nor is it necessary to access
any other part of the filesystem.
As a result, indexed structures can be rebuilt very quickly, and programs
trying to access the damaged structure will be blocked until repairs complete.
The only infrastructure needed by the repair code are the staging area for
observations and a means to write new structures to disk.
Despite these limitations, the advantage that online repair holds is clear:
targeted work on individual shards of the filesystem avoids total loss of
service.</p>
<p>This mechanism is described in section 2.1 (“Off-Line Algorithm”) of
V. Srinivasan and M. J. Carey, <a class="reference external" href="https://minds.wisconsin.edu/bitstream/handle/1793/59524/TR1047.pdf">“Performance of On-Line Index Construction
Algorithms”</a>,
<em>Extending Database Technology</em>, pp. 293-309, 1992.</p>
<p>Most primary metadata repair functions stage their intermediate results in an
in-memory array prior to formatting the new ondisk structure, which is very
similar to the list-based algorithm discussed in section 2.3 (“List-Based
Algorithms”) of Srinivasan.
However, any data structure builder that maintains a resource lock for the
duration of the repair is <em>always</em> an offline algorithm.</p>
</section>
<section id="secondary-metadata">
<span id="id2"></span><h4><a class="toc-backref" href="#id23" role="doc-backlink"><span class="section-number">4.2.4.2. </span>Secondary Metadata</a><a class="headerlink" href="#secondary-metadata" title="Link to this heading">¶</a></h4>
<p>Metadata structures in this category reflect records found in primary metadata,
but are only needed for online fsck or for reorganization of the filesystem.</p>
<p>Secondary metadata include:</p>
<ul class="simple">
<li><p>Reverse mapping information</p></li>
<li><p>Directory parent pointers</p></li>
</ul>
<p>This class of metadata is difficult for scrub to process because scrub attaches
to the secondary object but needs to check primary metadata, which runs counter
to the usual order of resource acquisition.
Frequently, this means that full filesystems scans are necessary to rebuild the
metadata.
Check functions can be limited in scope to reduce runtime.
Repairs, however, require a full scan of primary metadata, which can take a
long time to complete.
Under these conditions, <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> cannot lock resources for the entire
duration of the repair.</p>
<p>Instead, repair functions set up an in-memory staging structure to store
observations.
Depending on the requirements of the specific repair function, the staging
index will either have the same format as the ondisk structure or a design
specific to that repair function.
The next step is to release all locks and start the filesystem scan.
When the repair scanner needs to record an observation, the staging data are
locked long enough to apply the update.
While the filesystem scan is in progress, the repair function hooks the
filesystem so that it can apply pending filesystem updates to the staging
information.
Once the scan is done, the owning object is re-locked, the live data is used to
write a new ondisk structure, and the repairs are committed atomically.
The hooks are disabled and the staging staging area is freed.
Finally, the storage from the old data structure are carefully reaped.</p>
<p>Introducing concurrency helps online repair avoid various locking problems, but
comes at a high cost to code complexity.
Live filesystem code has to be hooked so that the repair function can observe
updates in progress.
The staging area has to become a fully functional parallel structure so that
updates can be merged from the hooks.
Finally, the hook, the filesystem scan, and the inode locking model must be
sufficiently well integrated that a hook event can decide if a given update
should be applied to the staging structure.</p>
<p>In theory, the scrub implementation could apply these same techniques for
primary metadata, but doing so would make it massively more complex and less
performant.
Programs attempting to access the damaged structures are not blocked from
operation, which may cause application failure or an unplanned filesystem
shutdown.</p>
<p>Inspiration for the secondary metadata repair strategy was drawn from section
2.4 of Srinivasan above, and sections 2 (“NSF: Inded Build Without Side-File”)
and 3.1.1 (“Duplicate Key Insert Problem”) in C. Mohan, <a class="reference external" href="https://dl.acm.org/doi/10.1145/130283.130337">“Algorithms for
Creating Indexes for Very Large Tables Without Quiescing Updates”</a>, 1992.</p>
<p>The sidecar index mentioned above bears some resemblance to the side file
method mentioned in Srinivasan and Mohan.
Their method consists of an index builder that extracts relevant record data to
build the new structure as quickly as possible; and an auxiliary structure that
captures all updates that would be committed to the index by other threads were
the new index already online.
After the index building scan finishes, the updates recorded in the side file
are applied to the new index.
To avoid conflicts between the index builder and other writer threads, the
builder maintains a publicly visible cursor that tracks the progress of the
scan through the record space.
To avoid duplication of work between the side file and the index builder, side
file updates are elided when the record ID for the update is greater than the
cursor position within the record ID space.</p>
<p>To minimize changes to the rest of the codebase, XFS online repair keeps the
replacement index hidden until it’s completely ready to go.
In other words, there is no attempt to expose the keyspace of the new index
while repair is running.
The complexity of such an approach would be very high and perhaps more
appropriate to building <em>new</em> indices.</p>
<p><strong>Future Work Question</strong>: Can the full scan and live update code used to
facilitate a repair also be used to implement a comprehensive check?</p>
<p><em>Answer</em>: In theory, yes.  Check would be much stronger if each scrub function
employed these live scans to build a shadow copy of the metadata and then
compared the shadow records to the ondisk records.
However, doing that is a fair amount more work than what the checking functions
do now.
The live scans and hooks were developed much later.
That in turn increases the runtime of those scrub functions.</p>
</section>
<section id="summary-information">
<h4><a class="toc-backref" href="#id24" role="doc-backlink"><span class="section-number">4.2.4.3. </span>Summary Information</a><a class="headerlink" href="#summary-information" title="Link to this heading">¶</a></h4>
<p>Metadata structures in this last category summarize the contents of primary
metadata records.
These are often used to speed up resource usage queries, and are many times
smaller than the primary metadata which they represent.</p>
<p>Examples of summary information include:</p>
<ul class="simple">
<li><p>Summary counts of free space and inodes</p></li>
<li><p>File link counts from directories</p></li>
<li><p>Quota resource usage counts</p></li>
</ul>
<p>Check and repair require full filesystem scans, but resource and lock
acquisition follow the same paths as regular filesystem accesses.</p>
<p>The superblock summary counters have special requirements due to the underlying
implementation of the incore counters, and will be treated separately.
Check and repair of the other types of summary counters (quota resource counts
and file link counts) employ the same filesystem scanning and hooking
techniques as outlined above, but because the underlying data are sets of
integer counters, the staging data need not be a fully functional mirror of the
ondisk structure.</p>
<p>Inspiration for quota and file link count repair strategies were drawn from
sections 2.12 (“Online Index Operations”) through 2.14 (“Incremental View
Maintenance”) of G.  Graefe, <a class="reference external" href="http://www.odbms.org/wp-content/uploads/2014/06/Increment-locks.pdf">“Concurrent Queries and Updates in Summary Views
and Their Indexes”</a>, 2011.</p>
<p>Since quotas are non-negative integer counts of resource usage, online
quotacheck can use the incremental view deltas described in section 2.14 to
track pending changes to the block and inode usage counts in each transaction,
and commit those changes to a dquot side file when the transaction commits.
Delta tracking is necessary for dquots because the index builder scans inodes,
whereas the data structure being rebuilt is an index of dquots.
Link count checking combines the view deltas and commit step into one because
it sets attributes of the objects being scanned instead of writing them to a
separate data structure.
Each online fsck function will be discussed as case studies later in this
document.</p>
</section>
</section>
<section id="risk-management">
<h3><a class="toc-backref" href="#id25" role="doc-backlink"><span class="section-number">4.2.5. </span>Risk Management</a><a class="headerlink" href="#risk-management" title="Link to this heading">¶</a></h3>
<p>During the development of online fsck, several risk factors were identified
that may make the feature unsuitable for certain distributors and users.
Steps can be taken to mitigate or eliminate those risks, though at a cost to
functionality.</p>
<ul class="simple">
<li><p><strong>Decreased performance</strong>: Adding metadata indices to the filesystem
increases the time cost of persisting changes to disk, and the reverse space
mapping and directory parent pointers are no exception.
System administrators who require the maximum performance can disable the
reverse mapping features at format time, though this choice dramatically
reduces the ability of online fsck to find inconsistencies and repair them.</p></li>
<li><p><strong>Incorrect repairs</strong>: As with all software, there might be defects in the
software that result in incorrect repairs being written to the filesystem.
Systematic fuzz testing (detailed in the next section) is employed by the
authors to find bugs early, but it might not catch everything.
The kernel build system provides Kconfig options (<code class="docutils literal notranslate"><span class="pre">CONFIG_XFS_ONLINE_SCRUB</span></code>
and <code class="docutils literal notranslate"><span class="pre">CONFIG_XFS_ONLINE_REPAIR</span></code>) to enable distributors to choose not to
accept this risk.
The xfsprogs build system has a configure option (<code class="docutils literal notranslate"><span class="pre">--enable-scrub=no</span></code>) that
disables building of the <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> binary, though this is not a risk
mitigation if the kernel functionality remains enabled.</p></li>
<li><p><strong>Inability to repair</strong>: Sometimes, a filesystem is too badly damaged to be
repairable.
If the keyspaces of several metadata indices overlap in some manner but a
coherent narrative cannot be formed from records collected, then the repair
fails.
To reduce the chance that a repair will fail with a dirty transaction and
render the filesystem unusable, the online repair functions have been
designed to stage and validate all new records before committing the new
structure.</p></li>
<li><p><strong>Misbehavior</strong>: Online fsck requires many privileges -- raw IO to block
devices, opening files by handle, ignoring Unix discretionary access control,
and the ability to perform administrative changes.
Running this automatically in the background scares people, so the systemd
background service is configured to run with only the privileges required.
Obviously, this cannot address certain problems like the kernel crashing or
deadlocking, but it should be sufficient to prevent the scrub process from
escaping and reconfiguring the system.
The cron job does not have this protection.</p></li>
<li><p><strong>Fuzz Kiddiez</strong>: There are many people now who seem to think that running
automated fuzz testing of ondisk artifacts to find mischievous behavior and
spraying exploit code onto the public mailing list for instant zero-day
disclosure is somehow of some social benefit.
In the view of this author, the benefit is realized only when the fuzz
operators help to <strong>fix</strong> the flaws, but this opinion apparently is not
widely shared among security “researchers”.
The XFS maintainers’ continuing ability to manage these events presents an
ongoing risk to the stability of the development process.
Automated testing should front-load some of the risk while the feature is
considered EXPERIMENTAL.</p></li>
</ul>
<p>Many of these risks are inherent to software programming.
Despite this, it is hoped that this new functionality will prove useful in
reducing unexpected downtime.</p>
</section>
</section>
<section id="testing-plan">
<h2><a class="toc-backref" href="#id26" role="doc-backlink"><span class="section-number">4.3. </span>3. Testing Plan</a><a class="headerlink" href="#testing-plan" title="Link to this heading">¶</a></h2>
<p>As stated before, fsck tools have three main goals:</p>
<ol class="arabic simple">
<li><p>Detect inconsistencies in the metadata;</p></li>
<li><p>Eliminate those inconsistencies; and</p></li>
<li><p>Minimize further loss of data.</p></li>
</ol>
<p>Demonstrations of correct operation are necessary to build users’ confidence
that the software behaves within expectations.
Unfortunately, it was not really feasible to perform regular exhaustive testing
of every aspect of a fsck tool until the introduction of low-cost virtual
machines with high-IOPS storage.
With ample hardware availability in mind, the testing strategy for the online
fsck project involves differential analysis against the existing fsck tools and
systematic testing of every attribute of every type of metadata object.
Testing can be split into four major categories, as discussed below.</p>
<section id="integrated-testing-with-fstests">
<h3><a class="toc-backref" href="#id27" role="doc-backlink"><span class="section-number">4.3.1. </span>Integrated Testing with fstests</a><a class="headerlink" href="#integrated-testing-with-fstests" title="Link to this heading">¶</a></h3>
<p>The primary goal of any free software QA effort is to make testing as
inexpensive and widespread as possible to maximize the scaling advantages of
community.
In other words, testing should maximize the breadth of filesystem configuration
scenarios and hardware setups.
This improves code quality by enabling the authors of online fsck to find and
fix bugs early, and helps developers of new features to find integration
issues earlier in their development effort.</p>
<p>The Linux filesystem community shares a common QA testing suite,
<a class="reference external" href="https://git.kernel.org/pub/scm/fs/xfs/xfstests-dev.git/">fstests</a>, for
functional and regression testing.
Even before development work began on online fsck, fstests (when run on XFS)
would run both the <code class="docutils literal notranslate"><span class="pre">xfs_check</span></code> and <code class="docutils literal notranslate"><span class="pre">xfs_repair</span> <span class="pre">-n</span></code> commands on the test and
scratch filesystems between each test.
This provides a level of assurance that the kernel and the fsck tools stay in
alignment about what constitutes consistent metadata.
During development of the online checking code, fstests was modified to run
<code class="docutils literal notranslate"><span class="pre">xfs_scrub</span> <span class="pre">-n</span></code> between each test to ensure that the new checking code
produces the same results as the two existing fsck tools.</p>
<p>To start development of online repair, fstests was modified to run
<code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code> to rebuild the filesystem’s metadata indices between tests.
This ensures that offline repair does not crash, leave a corrupt filesystem
after it exists, or trigger complaints from the online check.
This also established a baseline for what can and cannot be repaired offline.
To complete the first phase of development of online repair, fstests was
modified to be able to run <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> in a “force rebuild” mode.
This enables a comparison of the effectiveness of online repair as compared to
the existing offline repair tools.</p>
</section>
<section id="general-fuzz-testing-of-metadata-blocks">
<h3><a class="toc-backref" href="#id28" role="doc-backlink"><span class="section-number">4.3.2. </span>General Fuzz Testing of Metadata Blocks</a><a class="headerlink" href="#general-fuzz-testing-of-metadata-blocks" title="Link to this heading">¶</a></h3>
<p>XFS benefits greatly from having a very robust debugging tool, <code class="docutils literal notranslate"><span class="pre">xfs_db</span></code>.</p>
<p>Before development of online fsck even began, a set of fstests were created
to test the rather common fault that entire metadata blocks get corrupted.
This required the creation of fstests library code that can create a filesystem
containing every possible type of metadata object.
Next, individual test cases were created to create a test filesystem, identify
a single block of a specific type of metadata object, trash it with the
existing <code class="docutils literal notranslate"><span class="pre">blocktrash</span></code> command in <code class="docutils literal notranslate"><span class="pre">xfs_db</span></code>, and test the reaction of a
particular metadata validation strategy.</p>
<p>This earlier test suite enabled XFS developers to test the ability of the
in-kernel validation functions and the ability of the offline fsck tool to
detect and eliminate the inconsistent metadata.
This part of the test suite was extended to cover online fsck in exactly the
same manner.</p>
<p>In other words, for a given fstests filesystem configuration:</p>
<ul class="simple">
<li><p>For each metadata object existing on the filesystem:</p>
<ul>
<li><p>Write garbage to it</p></li>
<li><p>Test the reactions of:</p>
<ol class="arabic simple">
<li><p>The kernel verifiers to stop obviously bad metadata</p></li>
<li><p>Offline repair (<code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code>) to detect and fix</p></li>
<li><p>Online repair (<code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code>) to detect and fix</p></li>
</ol>
</li>
</ul>
</li>
</ul>
</section>
<section id="targeted-fuzz-testing-of-metadata-records">
<h3><a class="toc-backref" href="#id29" role="doc-backlink"><span class="section-number">4.3.3. </span>Targeted Fuzz Testing of Metadata Records</a><a class="headerlink" href="#targeted-fuzz-testing-of-metadata-records" title="Link to this heading">¶</a></h3>
<p>The testing plan for online fsck includes extending the existing fs testing
infrastructure to provide a much more powerful facility: targeted fuzz testing
of every metadata field of every metadata object in the filesystem.
<code class="docutils literal notranslate"><span class="pre">xfs_db</span></code> can modify every field of every metadata structure in every
block in the filesystem to simulate the effects of memory corruption and
software bugs.
Given that fstests already contains the ability to create a filesystem
containing every metadata format known to the filesystem, <code class="docutils literal notranslate"><span class="pre">xfs_db</span></code> can be
used to perform exhaustive fuzz testing!</p>
<p>For a given fstests filesystem configuration:</p>
<ul>
<li><p>For each metadata object existing on the filesystem...</p>
<ul>
<li><p>For each record inside that metadata object...</p>
<ul>
<li><p>For each field inside that record...</p>
<ul>
<li><p>For each conceivable type of transformation that can be applied to a bit field...</p>
<ol class="arabic simple">
<li><p>Clear all bits</p></li>
<li><p>Set all bits</p></li>
<li><p>Toggle the most significant bit</p></li>
<li><p>Toggle the middle bit</p></li>
<li><p>Toggle the least significant bit</p></li>
<li><p>Add a small quantity</p></li>
<li><p>Subtract a small quantity</p></li>
<li><p>Randomize the contents</p></li>
</ol>
<ul class="simple">
<li><p>...test the reactions of:</p>
<ol class="arabic simple">
<li><p>The kernel verifiers to stop obviously bad metadata</p></li>
<li><p>Offline checking (<code class="docutils literal notranslate"><span class="pre">xfs_repair</span> <span class="pre">-n</span></code>)</p></li>
<li><p>Offline repair (<code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code>)</p></li>
<li><p>Online checking (<code class="docutils literal notranslate"><span class="pre">xfs_scrub</span> <span class="pre">-n</span></code>)</p></li>
<li><p>Online repair (<code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code>)</p></li>
<li><p>Both repair tools (<code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> and then <code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code> if online repair doesn’t succeed)</p></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This is quite the combinatoric explosion!</p>
<p>Fortunately, having this much test coverage makes it easy for XFS developers to
check the responses of XFS’ fsck tools.
Since the introduction of the fuzz testing framework, these tests have been
used to discover incorrect repair code and missing functionality for entire
classes of metadata objects in <code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code>.
The enhanced testing was used to finalize the deprecation of <code class="docutils literal notranslate"><span class="pre">xfs_check</span></code> by
confirming that <code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code> could detect at least as many corruptions as
the older tool.</p>
<p>These tests have been very valuable for <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> in the same ways -- they
allow the online fsck developers to compare online fsck against offline fsck,
and they enable XFS developers to find deficiencies in the code base.</p>
<p>Proposed patchsets include
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfstests-dev.git/log/?h=fuzzer-improvements">general fuzzer improvements</a>,
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfstests-dev.git/log/?h=fuzz-baseline">fuzzing baselines</a>,
and <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfstests-dev.git/log/?h=more-fuzz-testing">improvements in fuzz testing comprehensiveness</a>.</p>
</section>
<section id="stress-testing">
<h3><a class="toc-backref" href="#id30" role="doc-backlink"><span class="section-number">4.3.4. </span>Stress Testing</a><a class="headerlink" href="#stress-testing" title="Link to this heading">¶</a></h3>
<p>A unique requirement to online fsck is the ability to operate on a filesystem
concurrently with regular workloads.
Although it is of course impossible to run <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> with <em>zero</em> observable
impact on the running system, the online repair code should never introduce
inconsistencies into the filesystem metadata, and regular workloads should
never notice resource starvation.
To verify that these conditions are being met, fstests has been enhanced in
the following ways:</p>
<ul class="simple">
<li><p>For each scrub item type, create a test to exercise checking that item type
while running <code class="docutils literal notranslate"><span class="pre">fsstress</span></code>.</p></li>
<li><p>For each scrub item type, create a test to exercise repairing that item type
while running <code class="docutils literal notranslate"><span class="pre">fsstress</span></code>.</p></li>
<li><p>Race <code class="docutils literal notranslate"><span class="pre">fsstress</span></code> and <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span> <span class="pre">-n</span></code> to ensure that checking the whole
filesystem doesn’t cause problems.</p></li>
<li><p>Race <code class="docutils literal notranslate"><span class="pre">fsstress</span></code> and <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> in force-rebuild mode to ensure that
force-repairing the whole filesystem doesn’t cause problems.</p></li>
<li><p>Race <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> in check and force-repair mode against <code class="docutils literal notranslate"><span class="pre">fsstress</span></code> while
freezing and thawing the filesystem.</p></li>
<li><p>Race <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> in check and force-repair mode against <code class="docutils literal notranslate"><span class="pre">fsstress</span></code> while
remounting the filesystem read-only and read-write.</p></li>
<li><p>The same, but running <code class="docutils literal notranslate"><span class="pre">fsx</span></code> instead of <code class="docutils literal notranslate"><span class="pre">fsstress</span></code>.  (Not done yet?)</p></li>
</ul>
<p>Success is defined by the ability to run all of these tests without observing
any unexpected filesystem shutdowns due to corrupted metadata, kernel hang
check warnings, or any other sort of mischief.</p>
<p>Proposed patchsets include <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfstests-dev.git/log/?h=race-scrub-and-mount-state-changes">general stress testing</a>
and the <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfstests-dev.git/log/?h=refactor-scrub-stress">evolution of existing per-function stress testing</a>.</p>
</section>
</section>
<section id="user-interface">
<h2><a class="toc-backref" href="#id31" role="doc-backlink"><span class="section-number">4.4. </span>4. User Interface</a><a class="headerlink" href="#user-interface" title="Link to this heading">¶</a></h2>
<p>The primary user of online fsck is the system administrator, just like offline
repair.
Online fsck presents two modes of operation to administrators:
A foreground CLI process for online fsck on demand, and a background service
that performs autonomous checking and repair.</p>
<section id="checking-on-demand">
<h3><a class="toc-backref" href="#id32" role="doc-backlink"><span class="section-number">4.4.1. </span>Checking on Demand</a><a class="headerlink" href="#checking-on-demand" title="Link to this heading">¶</a></h3>
<p>For administrators who want the absolute freshest information about the
metadata in a filesystem, <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> can be run as a foreground process on
a command line.
The program checks every piece of metadata in the filesystem while the
administrator waits for the results to be reported, just like the existing
<code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code> tool.
Both tools share a <code class="docutils literal notranslate"><span class="pre">-n</span></code> option to perform a read-only scan, and a <code class="docutils literal notranslate"><span class="pre">-v</span></code>
option to increase the verbosity of the information reported.</p>
<p>A new feature of <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> is the <code class="docutils literal notranslate"><span class="pre">-x</span></code> option, which employs the error
correction capabilities of the hardware to check data file contents.
The media scan is not enabled by default because it may dramatically increase
program runtime and consume a lot of bandwidth on older storage hardware.</p>
<p>The output of a foreground invocation is captured in the system log.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">xfs_scrub_all</span></code> program walks the list of mounted filesystems and
initiates <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> for each of them in parallel.
It serializes scans for any filesystems that resolve to the same top level
kernel block device to prevent resource overconsumption.</p>
</section>
<section id="background-service">
<h3><a class="toc-backref" href="#id33" role="doc-backlink"><span class="section-number">4.4.2. </span>Background Service</a><a class="headerlink" href="#background-service" title="Link to this heading">¶</a></h3>
<p>To reduce the workload of system administrators, the <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> package
provides a suite of <a class="reference external" href="https://systemd.io/">systemd</a> timers and services that
run online fsck automatically on weekends by default.
The background service configures scrub to run with as little privilege as
possible, the lowest CPU and IO priority, and in a CPU-constrained single
threaded mode.
This can be tuned by the systemd administrator at any time to suit the latency
and throughput requirements of customer workloads.</p>
<p>The output of the background service is also captured in the system log.
If desired, reports of failures (either due to inconsistencies or mere runtime
errors) can be emailed automatically by setting the <code class="docutils literal notranslate"><span class="pre">EMAIL_ADDR</span></code> environment
variable in the following service files:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xfs_scrub_fail&#64;.service</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xfs_scrub_media_fail&#64;.service</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xfs_scrub_all_fail.service</span></code></p></li>
</ul>
<p>The decision to enable the background scan is left to the system administrator.
This can be done by enabling either of the following services:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xfs_scrub_all.timer</span></code> on systemd systems</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xfs_scrub_all.cron</span></code> on non-systemd systems</p></li>
</ul>
<p>This automatic weekly scan is configured out of the box to perform an
additional media scan of all file data once per month.
This is less foolproof than, say, storing file data block checksums, but much
more performant if application software provides its own integrity checking,
redundancy can be provided elsewhere above the filesystem, or the storage
device’s integrity guarantees are deemed sufficient.</p>
<p>The systemd unit file definitions have been subjected to a security audit
(as of systemd 249) to ensure that the xfs_scrub processes have as little
access to the rest of the system as possible.
This was performed via <code class="docutils literal notranslate"><span class="pre">systemd-analyze</span> <span class="pre">security</span></code>, after which privileges
were restricted to the minimum required, sandboxing was set up to the maximal
extent possible with sandboxing and system call filtering; and access to the
filesystem tree was restricted to the minimum needed to start the program and
access the filesystem being scanned.
The service definition files restrict CPU usage to 80% of one CPU core, and
apply as nice of a priority to IO and CPU scheduling as possible.
This measure was taken to minimize delays in the rest of the filesystem.
No such hardening has been performed for the cron job.</p>
<p>Proposed patchset:
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=scrub-media-scan-service">Enabling the xfs_scrub background service</a>.</p>
</section>
<section id="health-reporting">
<h3><a class="toc-backref" href="#id34" role="doc-backlink"><span class="section-number">4.4.3. </span>Health Reporting</a><a class="headerlink" href="#health-reporting" title="Link to this heading">¶</a></h3>
<p>XFS caches a summary of each filesystem’s health status in memory.
The information is updated whenever <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> is run, or whenever
inconsistencies are detected in the filesystem metadata during regular
operations.
System administrators should use the <code class="docutils literal notranslate"><span class="pre">health</span></code> command of <code class="docutils literal notranslate"><span class="pre">xfs_spaceman</span></code> to
download this information into a human-readable format.
If problems have been observed, the administrator can schedule a reduced
service window to run the online repair tool to correct the problem.
Failing that, the administrator can decide to schedule a maintenance window to
run the traditional offline repair tool to correct the problem.</p>
<p><strong>Future Work Question</strong>: Should the health reporting integrate with the new
inotify fs error notification system?
Would it be helpful for sysadmins to have a daemon to listen for corruption
notifications and initiate a repair?</p>
<p><em>Answer</em>: These questions remain unanswered, but should be a part of the
conversation with early adopters and potential downstream users of XFS.</p>
<p>Proposed patchsets include
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=corruption-health-reports">wiring up health reports to correction returns</a>
and
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=indirect-health-reporting">preservation of sickness info during memory reclaim</a>.</p>
</section>
</section>
<section id="kernel-algorithms-and-data-structures">
<h2><a class="toc-backref" href="#id35" role="doc-backlink"><span class="section-number">4.5. </span>5. Kernel Algorithms and Data Structures</a><a class="headerlink" href="#kernel-algorithms-and-data-structures" title="Link to this heading">¶</a></h2>
<p>This section discusses the key algorithms and data structures of the kernel
code that provide the ability to check and repair metadata while the system
is running.
The first chapters in this section reveal the pieces that provide the
foundation for checking metadata.
The remainder of this section presents the mechanisms through which XFS
regenerates itself.</p>
<section id="self-describing-metadata">
<h3><a class="toc-backref" href="#id36" role="doc-backlink"><span class="section-number">4.5.1. </span>Self Describing Metadata</a><a class="headerlink" href="#self-describing-metadata" title="Link to this heading">¶</a></h3>
<p>Starting with XFS version 5 in 2012, XFS updated the format of nearly every
ondisk block header to record a magic number, a checksum, a universally
“unique” identifier (UUID), an owner code, the ondisk address of the block,
and a log sequence number.
When loading a block buffer from disk, the magic number, UUID, owner, and
ondisk address confirm that the retrieved block matches the specific owner of
the current filesystem, and that the information contained in the block is
supposed to be found at the ondisk address.
The first three components enable checking tools to disregard alleged metadata
that doesn’t belong to the filesystem, and the fourth component enables the
filesystem to detect lost writes.</p>
<p>Whenever a file system operation modifies a block, the change is submitted
to the log as part of a transaction.
The log then processes these transactions marking them done once they are
safely persisted to storage.
The logging code maintains the checksum and the log sequence number of the last
transactional update.
Checksums are useful for detecting torn writes and other discrepancies that can
be introduced between the computer and its storage devices.
Sequence number tracking enables log recovery to avoid applying out of date
log updates to the filesystem.</p>
<p>These two features improve overall runtime resiliency by providing a means for
the filesystem to detect obvious corruption when reading metadata blocks from
disk, but these buffer verifiers cannot provide any consistency checking
between metadata structures.</p>
<p>For more information, please see the documentation for
<a class="reference internal" href="xfs-self-describing-metadata.html"><span class="doc">XFS Self Describing Metadata</span></a></p>
</section>
<section id="reverse-mapping">
<h3><a class="toc-backref" href="#id37" role="doc-backlink"><span class="section-number">4.5.2. </span>Reverse Mapping</a><a class="headerlink" href="#reverse-mapping" title="Link to this heading">¶</a></h3>
<p>The original design of XFS (circa 1993) is an improvement upon 1980s Unix
filesystem design.
In those days, storage density was expensive, CPU time was scarce, and
excessive seek time could kill performance.
For performance reasons, filesystem authors were reluctant to add redundancy to
the filesystem, even at the cost of data integrity.
Filesystems designers in the early 21st century choose different strategies to
increase internal redundancy -- either storing nearly identical copies of
metadata, or more space-efficient encoding techniques.</p>
<p>For XFS, a different redundancy strategy was chosen to modernize the design:
a secondary space usage index that maps allocated disk extents back to their
owners.
By adding a new index, the filesystem retains most of its ability to scale
well to heavily threaded workloads involving large datasets, since the primary
file metadata (the directory tree, the file block map, and the allocation
groups) remain unchanged.
Like any system that improves redundancy, the reverse-mapping feature increases
overhead costs for space mapping activities.
However, it has two critical advantages: first, the reverse index is key to
enabling online fsck and other requested functionality such as free space
defragmentation, better media failure reporting, and filesystem shrinking.
Second, the different ondisk storage format of the reverse mapping btree
defeats device-level deduplication because the filesystem requires real
redundancy.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Sidebar</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>A criticism of adding the secondary index is that it does nothing to
improve the robustness of user data storage itself.
This is a valid point, but adding a new index for file data block
checksums increases write amplification by turning data overwrites into
copy-writes, which age the filesystem prematurely.
In keeping with thirty years of precedent, users who want file data
integrity can supply as powerful a solution as they require.
As for metadata, the complexity of adding a new secondary index of space
usage is much less than adding volume management and storage device
mirroring to XFS itself.
Perfection of RAID and volume management are best left to existing
layers in the kernel.</p></td>
</tr>
</tbody>
</table>
<p>The information captured in a reverse space mapping record is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">xfs_rmap_irec</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">xfs_agblock_t</span><span class="w">    </span><span class="n">rm_startblock</span><span class="p">;</span><span class="w">   </span><span class="cm">/* extent start block */</span>
<span class="w">    </span><span class="n">xfs_extlen_t</span><span class="w">     </span><span class="n">rm_blockcount</span><span class="p">;</span><span class="w">   </span><span class="cm">/* extent length */</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w">         </span><span class="n">rm_owner</span><span class="p">;</span><span class="w">        </span><span class="cm">/* extent owner */</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w">         </span><span class="n">rm_offset</span><span class="p">;</span><span class="w">       </span><span class="cm">/* offset within the owner */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">     </span><span class="n">rm_flags</span><span class="p">;</span><span class="w">        </span><span class="cm">/* state flags */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The first two fields capture the location and size of the physical space,
in units of filesystem blocks.
The owner field tells scrub which metadata structure or file inode have been
assigned this space.
For space allocated to files, the offset field tells scrub where the space was
mapped within the file fork.
Finally, the flags field provides extra information about the space usage --
is this an attribute fork extent?  A file mapping btree extent?  Or an
unwritten data extent?</p>
<p>Online filesystem checking judges the consistency of each primary metadata
record by comparing its information against all other space indices.
The reverse mapping index plays a key role in the consistency checking process
because it contains a centralized alternate copy of all space allocation
information.
Program runtime and ease of resource acquisition are the only real limits to
what online checking can consult.
For example, a file data extent mapping can be checked against:</p>
<ul class="simple">
<li><p>The absence of an entry in the free space information.</p></li>
<li><p>The absence of an entry in the inode index.</p></li>
<li><p>The absence of an entry in the reference count data if the file is not
marked as having shared extents.</p></li>
<li><p>The correspondence of an entry in the reverse mapping information.</p></li>
</ul>
<p>There are several observations to make about reverse mapping indices:</p>
<ol class="arabic simple">
<li><p>Reverse mappings can provide a positive affirmation of correctness if any of
the above primary metadata are in doubt.
The checking code for most primary metadata follows a path similar to the
one outlined above.</p></li>
<li><p>Proving the consistency of secondary metadata with the primary metadata is
difficult because that requires a full scan of all primary space metadata,
which is very time intensive.
For example, checking a reverse mapping record for a file extent mapping
btree block requires locking the file and searching the entire btree to
confirm the block.
Instead, scrub relies on rigorous cross-referencing during the primary space
mapping structure checks.</p></li>
<li><p>Consistency scans must use non-blocking lock acquisition primitives if the
required locking order is not the same order used by regular filesystem
operations.
For example, if the filesystem normally takes a file ILOCK before taking
the AGF buffer lock but scrub wants to take a file ILOCK while holding
an AGF buffer lock, scrub cannot block on that second acquisition.
This means that forward progress during this part of a scan of the reverse
mapping data cannot be guaranteed if system load is heavy.</p></li>
</ol>
<p>In summary, reverse mappings play a key role in reconstruction of primary
metadata.
The details of how these records are staged, written to disk, and committed
into the filesystem are covered in subsequent sections.</p>
</section>
<section id="checking-and-cross-referencing">
<h3><a class="toc-backref" href="#id38" role="doc-backlink"><span class="section-number">4.5.3. </span>Checking and Cross-Referencing</a><a class="headerlink" href="#checking-and-cross-referencing" title="Link to this heading">¶</a></h3>
<p>The first step of checking a metadata structure is to examine every record
contained within the structure and its relationship with the rest of the
system.
XFS contains multiple layers of checking to try to prevent inconsistent
metadata from wreaking havoc on the system.
Each of these layers contributes information that helps the kernel to make
three decisions about the health of a metadata structure:</p>
<ul class="simple">
<li><p>Is a part of this structure obviously corrupt (<code class="docutils literal notranslate"><span class="pre">XFS_SCRUB_OFLAG_CORRUPT</span></code>) ?</p></li>
<li><p>Is this structure inconsistent with the rest of the system
(<code class="docutils literal notranslate"><span class="pre">XFS_SCRUB_OFLAG_XCORRUPT</span></code>) ?</p></li>
<li><p>Is there so much damage around the filesystem that cross-referencing is not
possible (<code class="docutils literal notranslate"><span class="pre">XFS_SCRUB_OFLAG_XFAIL</span></code>) ?</p></li>
<li><p>Can the structure be optimized to improve performance or reduce the size of
metadata (<code class="docutils literal notranslate"><span class="pre">XFS_SCRUB_OFLAG_PREEN</span></code>) ?</p></li>
<li><p>Does the structure contain data that is not inconsistent but deserves review
by the system administrator (<code class="docutils literal notranslate"><span class="pre">XFS_SCRUB_OFLAG_WARNING</span></code>) ?</p></li>
</ul>
<p>The following sections describe how the metadata scrubbing process works.</p>
<section id="metadata-buffer-verification">
<h4><a class="toc-backref" href="#id39" role="doc-backlink"><span class="section-number">4.5.3.1. </span>Metadata Buffer Verification</a><a class="headerlink" href="#metadata-buffer-verification" title="Link to this heading">¶</a></h4>
<p>The lowest layer of metadata protection in XFS are the metadata verifiers built
into the buffer cache.
These functions perform inexpensive internal consistency checking of the block
itself, and answer these questions:</p>
<ul class="simple">
<li><p>Does the block belong to this filesystem?</p></li>
<li><p>Does the block belong to the structure that asked for the read?
This assumes that metadata blocks only have one owner, which is always true
in XFS.</p></li>
<li><p>Is the type of data stored in the block within a reasonable range of what
scrub is expecting?</p></li>
<li><p>Does the physical location of the block match the location it was read from?</p></li>
<li><p>Does the block checksum match the data?</p></li>
</ul>
<p>The scope of the protections here are very limited -- verifiers can only
establish that the filesystem code is reasonably free of gross corruption bugs
and that the storage system is reasonably competent at retrieval.
Corruption problems observed at runtime cause the generation of health reports,
failed system calls, and in the extreme case, filesystem shutdowns if the
corrupt metadata force the cancellation of a dirty transaction.</p>
<p>Every online fsck scrubbing function is expected to read every ondisk metadata
block of a structure in the course of checking the structure.
Corruption problems observed during a check are immediately reported to
userspace as corruption; during a cross-reference, they are reported as a
failure to cross-reference once the full examination is complete.
Reads satisfied by a buffer already in cache (and hence already verified)
bypass these checks.</p>
</section>
<section id="internal-consistency-checks">
<h4><a class="toc-backref" href="#id40" role="doc-backlink"><span class="section-number">4.5.3.2. </span>Internal Consistency Checks</a><a class="headerlink" href="#internal-consistency-checks" title="Link to this heading">¶</a></h4>
<p>After the buffer cache, the next level of metadata protection is the internal
record verification code built into the filesystem.
These checks are split between the buffer verifiers, the in-filesystem users of
the buffer cache, and the scrub code itself, depending on the amount of higher
level context required.
The scope of checking is still internal to the block.
These higher level checking functions answer these questions:</p>
<ul class="simple">
<li><p>Does the type of data stored in the block match what scrub is expecting?</p></li>
<li><p>Does the block belong to the owning structure that asked for the read?</p></li>
<li><p>If the block contains records, do the records fit within the block?</p></li>
<li><p>If the block tracks internal free space information, is it consistent with
the record areas?</p></li>
<li><p>Are the records contained inside the block free of obvious corruptions?</p></li>
</ul>
<p>Record checks in this category are more rigorous and more time-intensive.
For example, block pointers and inumbers are checked to ensure that they point
within the dynamically allocated parts of an allocation group and within
the filesystem.
Names are checked for invalid characters, and flags are checked for invalid
combinations.
Other record attributes are checked for sensible values.
Btree records spanning an interval of the btree keyspace are checked for
correct order and lack of mergeability (except for file fork mappings).
For performance reasons, regular code may skip some of these checks unless
debugging is enabled or a write is about to occur.
Scrub functions, of course, must check all possible problems.</p>
</section>
<section id="validation-of-userspace-controlled-record-attributes">
<h4><a class="toc-backref" href="#id41" role="doc-backlink"><span class="section-number">4.5.3.3. </span>Validation of Userspace-Controlled Record Attributes</a><a class="headerlink" href="#validation-of-userspace-controlled-record-attributes" title="Link to this heading">¶</a></h4>
<p>Various pieces of filesystem metadata are directly controlled by userspace.
Because of this nature, validation work cannot be more precise than checking
that a value is within the possible range.
These fields include:</p>
<ul class="simple">
<li><p>Superblock fields controlled by mount options</p></li>
<li><p>Filesystem labels</p></li>
<li><p>File timestamps</p></li>
<li><p>File permissions</p></li>
<li><p>File size</p></li>
<li><p>File flags</p></li>
<li><p>Names present in directory entries, extended attribute keys, and filesystem
labels</p></li>
<li><p>Extended attribute key namespaces</p></li>
<li><p>Extended attribute values</p></li>
<li><p>File data block contents</p></li>
<li><p>Quota limits</p></li>
<li><p>Quota timer expiration (if resource usage exceeds the soft limit)</p></li>
</ul>
</section>
<section id="cross-referencing-space-metadata">
<h4><a class="toc-backref" href="#id42" role="doc-backlink"><span class="section-number">4.5.3.4. </span>Cross-Referencing Space Metadata</a><a class="headerlink" href="#cross-referencing-space-metadata" title="Link to this heading">¶</a></h4>
<p>After internal block checks, the next higher level of checking is
cross-referencing records between metadata structures.
For regular runtime code, the cost of these checks is considered to be
prohibitively expensive, but as scrub is dedicated to rooting out
inconsistencies, it must pursue all avenues of inquiry.
The exact set of cross-referencing is highly dependent on the context of the
data structure being checked.</p>
<p>The XFS btree code has keyspace scanning functions that online fsck uses to
cross reference one structure with another.
Specifically, scrub can scan the key space of an index to determine if that
keyspace is fully, sparsely, or not at all mapped to records.
For the reverse mapping btree, it is possible to mask parts of the key for the
purposes of performing a keyspace scan so that scrub can decide if the rmap
btree contains records mapping a certain extent of physical space without the
sparsenses of the rest of the rmap keyspace getting in the way.</p>
<p>Btree blocks undergo the following checks before cross-referencing:</p>
<ul class="simple">
<li><p>Does the type of data stored in the block match what scrub is expecting?</p></li>
<li><p>Does the block belong to the owning structure that asked for the read?</p></li>
<li><p>Do the records fit within the block?</p></li>
<li><p>Are the records contained inside the block free of obvious corruptions?</p></li>
<li><p>Are the name hashes in the correct order?</p></li>
<li><p>Do node pointers within the btree point to valid block addresses for the type
of btree?</p></li>
<li><p>Do child pointers point towards the leaves?</p></li>
<li><p>Do sibling pointers point across the same level?</p></li>
<li><p>For each node block record, does the record key accurate reflect the contents
of the child block?</p></li>
</ul>
<p>Space allocation records are cross-referenced as follows:</p>
<ol class="arabic simple">
<li><p>Any space mentioned by any metadata structure are cross-referenced as
follows:</p>
<ul class="simple">
<li><p>Does the reverse mapping index list only the appropriate owner as the
owner of each block?</p></li>
<li><p>Are none of the blocks claimed as free space?</p></li>
<li><p>If these aren’t file data blocks, are none of the blocks claimed as space
shared by different owners?</p></li>
</ul>
</li>
<li><p>Btree blocks are cross-referenced as follows:</p>
<ul class="simple">
<li><p>Everything in class 1 above.</p></li>
<li><p>If there’s a parent node block, do the keys listed for this block match the
keyspace of this block?</p></li>
<li><p>Do the sibling pointers point to valid blocks?  Of the same level?</p></li>
<li><p>Do the child pointers point to valid blocks?  Of the next level down?</p></li>
</ul>
</li>
<li><p>Free space btree records are cross-referenced as follows:</p>
<ul class="simple">
<li><p>Everything in class 1 and 2 above.</p></li>
<li><p>Does the reverse mapping index list no owners of this space?</p></li>
<li><p>Is this space not claimed by the inode index for inodes?</p></li>
<li><p>Is it not mentioned by the reference count index?</p></li>
<li><p>Is there a matching record in the other free space btree?</p></li>
</ul>
</li>
<li><p>Inode btree records are cross-referenced as follows:</p>
<ul class="simple">
<li><p>Everything in class 1 and 2 above.</p></li>
<li><p>Is there a matching record in free inode btree?</p></li>
<li><p>Do cleared bits in the holemask correspond with inode clusters?</p></li>
<li><p>Do set bits in the freemask correspond with inode records with zero link
count?</p></li>
</ul>
</li>
<li><p>Inode records are cross-referenced as follows:</p>
<ul class="simple">
<li><p>Everything in class 1.</p></li>
<li><p>Do all the fields that summarize information about the file forks actually
match those forks?</p></li>
<li><p>Does each inode with zero link count correspond to a record in the free
inode btree?</p></li>
</ul>
</li>
<li><p>File fork space mapping records are cross-referenced as follows:</p>
<ul class="simple">
<li><p>Everything in class 1 and 2 above.</p></li>
<li><p>Is this space not mentioned by the inode btrees?</p></li>
<li><p>If this is a CoW fork mapping, does it correspond to a CoW entry in the
reference count btree?</p></li>
</ul>
</li>
<li><p>Reference count records are cross-referenced as follows:</p>
<ul class="simple">
<li><p>Everything in class 1 and 2 above.</p></li>
<li><p>Within the space subkeyspace of the rmap btree (that is to say, all
records mapped to a particular space extent and ignoring the owner info),
are there the same number of reverse mapping records for each block as the
reference count record claims?</p></li>
</ul>
</li>
</ol>
<p>Proposed patchsets are the series to find gaps in
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-detect-refcount-gaps">refcount btree</a>,
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-detect-inobt-gaps">inode btree</a>, and
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-detect-rmapbt-gaps">rmap btree</a> records;
to find
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-detect-mergeable-records">mergeable records</a>;
and to
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-strengthen-rmap-checking">improve cross referencing with rmap</a>
before starting a repair.</p>
</section>
<section id="checking-extended-attributes">
<h4><a class="toc-backref" href="#id43" role="doc-backlink"><span class="section-number">4.5.3.5. </span>Checking Extended Attributes</a><a class="headerlink" href="#checking-extended-attributes" title="Link to this heading">¶</a></h4>
<p>Extended attributes implement a key-value store that enable fragments of data
to be attached to any file.
Both the kernel and userspace can access the keys and values, subject to
namespace and privilege restrictions.
Most typically these fragments are metadata about the file -- origins, security
contexts, user-supplied labels, indexing information, etc.</p>
<p>Names can be as long as 255 bytes and can exist in several different
namespaces.
Values can be as large as 64KB.
A file’s extended attributes are stored in blocks mapped by the attr fork.
The mappings point to leaf blocks, remote value blocks, or dabtree blocks.
Block 0 in the attribute fork is always the top of the structure, but otherwise
each of the three types of blocks can be found at any offset in the attr fork.
Leaf blocks contain attribute key records that point to the name and the value.
Names are always stored elsewhere in the same leaf block.
Values that are less than 3/4 the size of a filesystem block are also stored
elsewhere in the same leaf block.
Remote value blocks contain values that are too large to fit inside a leaf.
If the leaf information exceeds a single filesystem block, a dabtree (also
rooted at block 0) is created to map hashes of the attribute names to leaf
blocks in the attr fork.</p>
<p>Checking an extended attribute structure is not so straightforward due to the
lack of separation between attr blocks and index blocks.
Scrub must read each block mapped by the attr fork and ignore the non-leaf
blocks:</p>
<ol class="arabic simple">
<li><p>Walk the dabtree in the attr fork (if present) to ensure that there are no
irregularities in the blocks or dabtree mappings that do not point to
attr leaf blocks.</p></li>
<li><p>Walk the blocks of the attr fork looking for leaf blocks.
For each entry inside a leaf:</p>
<ol class="loweralpha simple">
<li><p>Validate that the name does not contain invalid characters.</p></li>
<li><p>Read the attr value.
This performs a named lookup of the attr name to ensure the correctness
of the dabtree.
If the value is stored in a remote block, this also validates the
integrity of the remote value block.</p></li>
</ol>
</li>
</ol>
</section>
<section id="checking-and-cross-referencing-directories">
<h4><a class="toc-backref" href="#id44" role="doc-backlink"><span class="section-number">4.5.3.6. </span>Checking and Cross-Referencing Directories</a><a class="headerlink" href="#checking-and-cross-referencing-directories" title="Link to this heading">¶</a></h4>
<p>The filesystem directory tree is a directed acylic graph structure, with files
constituting the nodes, and directory entries (dirents) constituting the edges.
Directories are a special type of file containing a set of mappings from a
255-byte sequence (name) to an inumber.
These are called directory entries, or dirents for short.
Each directory file must have exactly one directory pointing to the file.
A root directory points to itself.
Directory entries point to files of any type.
Each non-directory file may have multiple directories point to it.</p>
<p>In XFS, directories are implemented as a file containing up to three 32GB
partitions.
The first partition contains directory entry data blocks.
Each data block contains variable-sized records associating a user-provided
name with an inumber and, optionally, a file type.
If the directory entry data grows beyond one block, the second partition (which
exists as post-EOF extents) is populated with a block containing free space
information and an index that maps hashes of the dirent names to directory data
blocks in the first partition.
This makes directory name lookups very fast.
If this second partition grows beyond one block, the third partition is
populated with a linear array of free space information for faster
expansions.
If the free space has been separated and the second partition grows again
beyond one block, then a dabtree is used to map hashes of dirent names to
directory data blocks.</p>
<p>Checking a directory is pretty straightforward:</p>
<ol class="arabic simple">
<li><p>Walk the dabtree in the second partition (if present) to ensure that there
are no irregularities in the blocks or dabtree mappings that do not point to
dirent blocks.</p></li>
<li><p>Walk the blocks of the first partition looking for directory entries.
Each dirent is checked as follows:</p>
<ol class="loweralpha simple">
<li><p>Does the name contain no invalid characters?</p></li>
<li><p>Does the inumber correspond to an actual, allocated inode?</p></li>
<li><p>Does the child inode have a nonzero link count?</p></li>
<li><p>If a file type is included in the dirent, does it match the type of the
inode?</p></li>
<li><p>If the child is a subdirectory, does the child’s dotdot pointer point
back to the parent?</p></li>
<li><p>If the directory has a second partition, perform a named lookup of the
dirent name to ensure the correctness of the dabtree.</p></li>
</ol>
</li>
<li><p>Walk the free space list in the third partition (if present) to ensure that
the free spaces it describes are really unused.</p></li>
</ol>
<p>Checking operations involving <a class="reference internal" href="#dirparent"><span class="std std-ref">parents</span></a> and
<a class="reference internal" href="#nlinks"><span class="std std-ref">file link counts</span></a> are discussed in more detail in later
sections.</p>
<section id="checking-directory-attribute-btrees">
<h5><a class="toc-backref" href="#id45" role="doc-backlink"><span class="section-number">4.5.3.6.1. </span>Checking Directory/Attribute Btrees</a><a class="headerlink" href="#checking-directory-attribute-btrees" title="Link to this heading">¶</a></h5>
<p>As stated in previous sections, the directory/attribute btree (dabtree) index
maps user-provided names to improve lookup times by avoiding linear scans.
Internally, it maps a 32-bit hash of the name to a block offset within the
appropriate file fork.</p>
<p>The internal structure of a dabtree closely resembles the btrees that record
fixed-size metadata records -- each dabtree block contains a magic number, a
checksum, sibling pointers, a UUID, a tree level, and a log sequence number.
The format of leaf and node records are the same -- each entry points to the
next level down in the hierarchy, with dabtree node records pointing to dabtree
leaf blocks, and dabtree leaf records pointing to non-dabtree blocks elsewhere
in the fork.</p>
<p>Checking and cross-referencing the dabtree is very similar to what is done for
space btrees:</p>
<ul class="simple">
<li><p>Does the type of data stored in the block match what scrub is expecting?</p></li>
<li><p>Does the block belong to the owning structure that asked for the read?</p></li>
<li><p>Do the records fit within the block?</p></li>
<li><p>Are the records contained inside the block free of obvious corruptions?</p></li>
<li><p>Are the name hashes in the correct order?</p></li>
<li><p>Do node pointers within the dabtree point to valid fork offsets for dabtree
blocks?</p></li>
<li><p>Do leaf pointers within the dabtree point to valid fork offsets for directory
or attr leaf blocks?</p></li>
<li><p>Do child pointers point towards the leaves?</p></li>
<li><p>Do sibling pointers point across the same level?</p></li>
<li><p>For each dabtree node record, does the record key accurate reflect the
contents of the child dabtree block?</p></li>
<li><p>For each dabtree leaf record, does the record key accurate reflect the
contents of the directory or attr block?</p></li>
</ul>
</section>
</section>
<section id="cross-referencing-summary-counters">
<h4><a class="toc-backref" href="#id46" role="doc-backlink"><span class="section-number">4.5.3.7. </span>Cross-Referencing Summary Counters</a><a class="headerlink" href="#cross-referencing-summary-counters" title="Link to this heading">¶</a></h4>
<p>XFS maintains three classes of summary counters: available resources, quota
resource usage, and file link counts.</p>
<p>In theory, the amount of available resources (data blocks, inodes, realtime
extents) can be found by walking the entire filesystem.
This would make for very slow reporting, so a transactional filesystem can
maintain summaries of this information in the superblock.
Cross-referencing these values against the filesystem metadata should be a
simple matter of walking the free space and inode metadata in each AG and the
realtime bitmap, but there are complications that will be discussed in
<a class="reference internal" href="#fscounters"><span class="std std-ref">more detail</span></a> later.</p>
<p><a class="reference internal" href="#quotacheck"><span class="std std-ref">Quota usage</span></a> and <a class="reference internal" href="#nlinks"><span class="std std-ref">file link count</span></a>
checking are sufficiently complicated to warrant separate sections.</p>
</section>
<section id="post-repair-reverification">
<h4><a class="toc-backref" href="#id47" role="doc-backlink"><span class="section-number">4.5.3.8. </span>Post-Repair Reverification</a><a class="headerlink" href="#post-repair-reverification" title="Link to this heading">¶</a></h4>
<p>After performing a repair, the checking code is run a second time to validate
the new structure, and the results of the health assessment are recorded
internally and returned to the calling process.
This step is critical for enabling system administrator to monitor the status
of the filesystem and the progress of any repairs.
For developers, it is a useful means to judge the efficacy of error detection
and correction in the online and offline checking tools.</p>
</section>
</section>
<section id="eventual-consistency-vs-online-fsck">
<h3><a class="toc-backref" href="#id48" role="doc-backlink"><span class="section-number">4.5.4. </span>Eventual Consistency vs. Online Fsck</a><a class="headerlink" href="#eventual-consistency-vs-online-fsck" title="Link to this heading">¶</a></h3>
<p>Complex operations can make modifications to multiple per-AG data structures
with a chain of transactions.
These chains, once committed to the log, are restarted during log recovery if
the system crashes while processing the chain.
Because the AG header buffers are unlocked between transactions within a chain,
online checking must coordinate with chained operations that are in progress to
avoid incorrectly detecting inconsistencies due to pending chains.
Furthermore, online repair must not run when operations are pending because
the metadata are temporarily inconsistent with each other, and rebuilding is
not possible.</p>
<p>Only online fsck has this requirement of total consistency of AG metadata, and
should be relatively rare as compared to filesystem change operations.
Online fsck coordinates with transaction chains as follows:</p>
<ul class="simple">
<li><p>For each AG, maintain a count of intent items targeting that AG.
The count should be bumped whenever a new item is added to the chain.
The count should be dropped when the filesystem has locked the AG header
buffers and finished the work.</p></li>
<li><p>When online fsck wants to examine an AG, it should lock the AG header
buffers to quiesce all transaction chains that want to modify that AG.
If the count is zero, proceed with the checking operation.
If it is nonzero, cycle the buffer locks to allow the chain to make forward
progress.</p></li>
</ul>
<p>This may lead to online fsck taking a long time to complete, but regular
filesystem updates take precedence over background checking activity.
Details about the discovery of this situation are presented in the
<a class="reference internal" href="#chain-coordination"><span class="std std-ref">next section</span></a>, and details about the solution
are presented <a class="reference internal" href="#intent-drains"><span class="std std-ref">after that</span></a>.</p>
<section id="discovery-of-the-problem">
<span id="chain-coordination"></span><h4><a class="toc-backref" href="#id49" role="doc-backlink"><span class="section-number">4.5.4.1. </span>Discovery of the Problem</a><a class="headerlink" href="#discovery-of-the-problem" title="Link to this heading">¶</a></h4>
<p>Midway through the development of online scrubbing, the fsstress tests
uncovered a misinteraction between online fsck and compound transaction chains
created by other writer threads that resulted in false reports of metadata
inconsistency.
The root cause of these reports is the eventual consistency model introduced by
the expansion of deferred work items and compound transaction chains when
reverse mapping and reflink were introduced.</p>
<p>Originally, transaction chains were added to XFS to avoid deadlocks when
unmapping space from files.
Deadlock avoidance rules require that AGs only be locked in increasing order,
which makes it impossible (say) to use a single transaction to free a space
extent in AG 7 and then try to free a now superfluous block mapping btree block
in AG 3.
To avoid these kinds of deadlocks, XFS creates Extent Freeing Intent (EFI) log
items to commit to freeing some space in one transaction while deferring the
actual metadata updates to a fresh transaction.
The transaction sequence looks like this:</p>
<ol class="arabic simple">
<li><p>The first transaction contains a physical update to the file’s block mapping
structures to remove the mapping from the btree blocks.
It then attaches to the in-memory transaction an action item to schedule
deferred freeing of space.
Concretely, each transaction maintains a list of <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">xfs_defer_pending</span></code> objects, each of which maintains a list of <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">xfs_extent_free_item</span></code> objects.
Returning to the example above, the action item tracks the freeing of both
the unmapped space from AG 7 and the block mapping btree (BMBT) block from
AG 3.
Deferred frees recorded in this manner are committed in the log by creating
an EFI log item from the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_extent_free_item</span></code> object and
attaching the log item to the transaction.
When the log is persisted to disk, the EFI item is written into the ondisk
transaction record.
EFIs can list up to 16 extents to free, all sorted in AG order.</p></li>
<li><p>The second transaction contains a physical update to the free space btrees
of AG 3 to release the former BMBT block and a second physical update to the
free space btrees of AG 7 to release the unmapped file space.
Observe that the physical updates are resequenced in the correct order
when possible.
Attached to the transaction is a an extent free done (EFD) log item.
The EFD contains a pointer to the EFI logged in transaction #1 so that log
recovery can tell if the EFI needs to be replayed.</p></li>
</ol>
<p>If the system goes down after transaction #1 is written back to the filesystem
but before #2 is committed, a scan of the filesystem metadata would show
inconsistent filesystem metadata because there would not appear to be any owner
of the unmapped space.
Happily, log recovery corrects this inconsistency for us -- when recovery finds
an intent log item but does not find a corresponding intent done item, it will
reconstruct the incore state of the intent item and finish it.
In the example above, the log must replay both frees described in the recovered
EFI to complete the recovery phase.</p>
<p>There are subtleties to XFS’ transaction chaining strategy to consider:</p>
<ul class="simple">
<li><p>Log items must be added to a transaction in the correct order to prevent
conflicts with principal objects that are not held by the transaction.
In other words, all per-AG metadata updates for an unmapped block must be
completed before the last update to free the extent, and extents should not
be reallocated until that last update commits to the log.</p></li>
<li><p>AG header buffers are released between each transaction in a chain.
This means that other threads can observe an AG in an intermediate state,
but as long as the first subtlety is handled, this should not affect the
correctness of filesystem operations.</p></li>
<li><p>Unmounting the filesystem flushes all pending work to disk, which means that
offline fsck never sees the temporary inconsistencies caused by deferred
work item processing.</p></li>
</ul>
<p>In this manner, XFS employs a form of eventual consistency to avoid deadlocks
and increase parallelism.</p>
<p>During the design phase of the reverse mapping and reflink features, it was
decided that it was impractical to cram all the reverse mapping updates for a
single filesystem change into a single transaction because a single file
mapping operation can explode into many small updates:</p>
<ul class="simple">
<li><p>The block mapping update itself</p></li>
<li><p>A reverse mapping update for the block mapping update</p></li>
<li><p>Fixing the freelist</p></li>
<li><p>A reverse mapping update for the freelist fix</p></li>
<li><p>A shape change to the block mapping btree</p></li>
<li><p>A reverse mapping update for the btree update</p></li>
<li><p>Fixing the freelist (again)</p></li>
<li><p>A reverse mapping update for the freelist fix</p></li>
<li><p>An update to the reference counting information</p></li>
<li><p>A reverse mapping update for the refcount update</p></li>
<li><p>Fixing the freelist (a third time)</p></li>
<li><p>A reverse mapping update for the freelist fix</p></li>
<li><p>Freeing any space that was unmapped and not owned by any other file</p></li>
<li><p>Fixing the freelist (a fourth time)</p></li>
<li><p>A reverse mapping update for the freelist fix</p></li>
<li><p>Freeing the space used by the block mapping btree</p></li>
<li><p>Fixing the freelist (a fifth time)</p></li>
<li><p>A reverse mapping update for the freelist fix</p></li>
</ul>
<p>Free list fixups are not usually needed more than once per AG per transaction
chain, but it is theoretically possible if space is very tight.
For copy-on-write updates this is even worse, because this must be done once to
remove the space from a staging area and again to map it into the file!</p>
<p>To deal with this explosion in a calm manner, XFS expands its use of deferred
work items to cover most reverse mapping updates and all refcount updates.
This reduces the worst case size of transaction reservations by breaking the
work into a long chain of small updates, which increases the degree of eventual
consistency in the system.
Again, this generally isn’t a problem because XFS orders its deferred work
items carefully to avoid resource reuse conflicts between unsuspecting threads.</p>
<p>However, online fsck changes the rules -- remember that although physical
updates to per-AG structures are coordinated by locking the buffers for AG
headers, buffer locks are dropped between transactions.
Once scrub acquires resources and takes locks for a data structure, it must do
all the validation work without releasing the lock.
If the main lock for a space btree is an AG header buffer lock, scrub may have
interrupted another thread that is midway through finishing a chain.
For example, if a thread performing a copy-on-write has completed a reverse
mapping update but not the corresponding refcount update, the two AG btrees
will appear inconsistent to scrub and an observation of corruption will be
recorded.  This observation will not be correct.
If a repair is attempted in this state, the results will be catastrophic!</p>
<p>Several other solutions to this problem were evaluated upon discovery of this
flaw and rejected:</p>
<ol class="arabic simple">
<li><p>Add a higher level lock to allocation groups and require writer threads to
acquire the higher level lock in AG order before making any changes.
This would be very difficult to implement in practice because it is
difficult to determine which locks need to be obtained, and in what order,
without simulating the entire operation.
Performing a dry run of a file operation to discover necessary locks would
make the filesystem very slow.</p></li>
<li><p>Make the deferred work coordinator code aware of consecutive intent items
targeting the same AG and have it hold the AG header buffers locked across
the transaction roll between updates.
This would introduce a lot of complexity into the coordinator since it is
only loosely coupled with the actual deferred work items.
It would also fail to solve the problem because deferred work items can
generate new deferred subtasks, but all subtasks must be complete before
work can start on a new sibling task.</p></li>
<li><p>Teach online fsck to walk all transactions waiting for whichever lock(s)
protect the data structure being scrubbed to look for pending operations.
The checking and repair operations must factor these pending operations into
the evaluations being performed.
This solution is a nonstarter because it is <em>extremely</em> invasive to the main
filesystem.</p></li>
</ol>
</section>
<section id="intent-drains">
<span id="id3"></span><h4><a class="toc-backref" href="#id50" role="doc-backlink"><span class="section-number">4.5.4.2. </span>Intent Drains</a><a class="headerlink" href="#intent-drains" title="Link to this heading">¶</a></h4>
<p>Online fsck uses an atomic intent item counter and lock cycling to coordinate
with transaction chains.
There are two key properties to the drain mechanism.
First, the counter is incremented when a deferred work item is <em>queued</em> to a
transaction, and it is decremented after the associated intent done log item is
<em>committed</em> to another transaction.
The second property is that deferred work can be added to a transaction without
holding an AG header lock, but per-AG work items cannot be marked done without
locking that AG header buffer to log the physical updates and the intent done
log item.
The first property enables scrub to yield to running transaction chains, which
is an explicit deprioritization of online fsck to benefit file operations.
The second property of the drain is key to the correct coordination of scrub,
since scrub will always be able to decide if a conflict is possible.</p>
<p>For regular filesystem code, the drain works as follows:</p>
<ol class="arabic simple">
<li><p>Call the appropriate subsystem function to add a deferred work item to a
transaction.</p></li>
<li><p>The function calls <code class="docutils literal notranslate"><span class="pre">xfs_defer_drain_bump</span></code> to increase the counter.</p></li>
<li><p>When the deferred item manager wants to finish the deferred work item, it
calls <code class="docutils literal notranslate"><span class="pre">-&gt;finish_item</span></code> to complete it.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">-&gt;finish_item</span></code> implementation logs some changes and calls
<code class="docutils literal notranslate"><span class="pre">xfs_defer_drain_drop</span></code> to decrease the sloppy counter and wake up any threads
waiting on the drain.</p></li>
<li><p>The subtransaction commits, which unlocks the resource associated with the
intent item.</p></li>
</ol>
<p>For scrub, the drain works as follows:</p>
<ol class="arabic simple">
<li><p>Lock the resource(s) associated with the metadata being scrubbed.
For example, a scan of the refcount btree would lock the AGI and AGF header
buffers.</p></li>
<li><p>If the counter is zero (<code class="docutils literal notranslate"><span class="pre">xfs_defer_drain_busy</span></code> returns false), there are no
chains in progress and the operation may proceed.</p></li>
<li><p>Otherwise, release the resources grabbed in step 1.</p></li>
<li><p>Wait for the intent counter to reach zero (<code class="docutils literal notranslate"><span class="pre">xfs_defer_drain_intents</span></code>), then go
back to step 1 unless a signal has been caught.</p></li>
</ol>
<p>To avoid polling in step 4, the drain provides a waitqueue for scrub threads to
be woken up whenever the intent count drops to zero.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-drain-intents">scrub intent drain series</a>.</p>
</section>
<section id="static-keys-aka-jump-label-patching">
<span id="jump-labels"></span><h4><a class="toc-backref" href="#id51" role="doc-backlink"><span class="section-number">4.5.4.3. </span>Static Keys (aka Jump Label Patching)</a><a class="headerlink" href="#static-keys-aka-jump-label-patching" title="Link to this heading">¶</a></h4>
<p>Online fsck for XFS separates the regular filesystem from the checking and
repair code as much as possible.
However, there are a few parts of online fsck (such as the intent drains, and
later, live update hooks) where it is useful for the online fsck code to know
what’s going on in the rest of the filesystem.
Since it is not expected that online fsck will be constantly running in the
background, it is very important to minimize the runtime overhead imposed by
these hooks when online fsck is compiled into the kernel but not actively
running on behalf of userspace.
Taking locks in the hot path of a writer thread to access a data structure only
to find that no further action is necessary is expensive -- on the author’s
computer, this have an overhead of 40-50ns per access.
Fortunately, the kernel supports dynamic code patching, which enables XFS to
replace a static branch to hook code with <code class="docutils literal notranslate"><span class="pre">nop</span></code> sleds when online fsck isn’t
running.
This sled has an overhead of however long it takes the instruction decoder to
skip past the sled, which seems to be on the order of less than 1ns and
does not access memory outside of instruction fetching.</p>
<p>When online fsck enables the static key, the sled is replaced with an
unconditional branch to call the hook code.
The switchover is quite expensive (~22000ns) but is paid entirely by the
program that invoked online fsck, and can be amortized if multiple threads
enter online fsck at the same time, or if multiple filesystems are being
checked at the same time.
Changing the branch direction requires taking the CPU hotplug lock, and since
CPU initialization requires memory allocation, online fsck must be careful not
to change a static key while holding any locks or resources that could be
accessed in the memory reclaim paths.
To minimize contention on the CPU hotplug lock, care should be taken not to
enable or disable static keys unnecessarily.</p>
<p>Because static keys are intended to minimize hook overhead for regular
filesystem operations when xfs_scrub is not running, the intended usage
patterns are as follows:</p>
<ul class="simple">
<li><p>The hooked part of XFS should declare a static-scoped static key that
defaults to false.
The <code class="docutils literal notranslate"><span class="pre">DEFINE_STATIC_KEY_FALSE</span></code> macro takes care of this.
The static key itself should be declared as a <code class="docutils literal notranslate"><span class="pre">static</span></code> variable.</p></li>
<li><p>When deciding to invoke code that’s only used by scrub, the regular
filesystem should call the <code class="docutils literal notranslate"><span class="pre">static_branch_unlikely</span></code> predicate to avoid the
scrub-only hook code if the static key is not enabled.</p></li>
<li><p>The regular filesystem should export helper functions that call
<code class="docutils literal notranslate"><span class="pre">static_branch_inc</span></code> to enable and <code class="docutils literal notranslate"><span class="pre">static_branch_dec</span></code> to disable the
static key.
Wrapper functions make it easy to compile out the relevant code if the kernel
distributor turns off online fsck at build time.</p></li>
<li><p>Scrub functions wanting to turn on scrub-only XFS functionality should call
the <code class="docutils literal notranslate"><span class="pre">xchk_fsgates_enable</span></code> from the setup function to enable a specific
hook.
This must be done before obtaining any resources that are used by memory
reclaim.
Callers had better be sure they really need the functionality gated by the
static key; the <code class="docutils literal notranslate"><span class="pre">TRY_HARDER</span></code> flag is useful here.</p></li>
</ul>
<p>Online scrub has resource acquisition helpers (e.g. <code class="docutils literal notranslate"><span class="pre">xchk_perag_lock</span></code>) to
handle locking AGI and AGF buffers for all scrubber functions.
If it detects a conflict between scrub and the running transactions, it will
try to wait for intents to complete.
If the caller of the helper has not enabled the static key, the helper will
return -EDEADLOCK, which should result in the scrub being restarted with the
<code class="docutils literal notranslate"><span class="pre">TRY_HARDER</span></code> flag set.
The scrub setup function should detect that flag, enable the static key, and
try the scrub again.
Scrub teardown disables all static keys obtained by <code class="docutils literal notranslate"><span class="pre">xchk_fsgates_enable</span></code>.</p>
<p>For more information, please see the kernel documentation of
<a class="reference internal" href="../../staging/static-keys.html"><span class="doc">Static Keys</span></a>.</p>
</section>
</section>
<section id="pageable-kernel-memory">
<span id="xfile"></span><h3><a class="toc-backref" href="#id52" role="doc-backlink"><span class="section-number">4.5.5. </span>Pageable Kernel Memory</a><a class="headerlink" href="#pageable-kernel-memory" title="Link to this heading">¶</a></h3>
<p>Some online checking functions work by scanning the filesystem to build a
shadow copy of an ondisk metadata structure in memory and comparing the two
copies.
For online repair to rebuild a metadata structure, it must compute the record
set that will be stored in the new structure before it can persist that new
structure to disk.
Ideally, repairs complete with a single atomic commit that introduces
a new data structure.
To meet these goals, the kernel needs to collect a large amount of information
in a place that doesn’t require the correct operation of the filesystem.</p>
<p>Kernel memory isn’t suitable because:</p>
<ul class="simple">
<li><p>Allocating a contiguous region of memory to create a C array is very
difficult, especially on 32-bit systems.</p></li>
<li><p>Linked lists of records introduce double pointer overhead which is very high
and eliminate the possibility of indexed lookups.</p></li>
<li><p>Kernel memory is pinned, which can drive the system into OOM conditions.</p></li>
<li><p>The system might not have sufficient memory to stage all the information.</p></li>
</ul>
<p>At any given time, online fsck does not need to keep the entire record set in
memory, which means that individual records can be paged out if necessary.
Continued development of online fsck demonstrated that the ability to perform
indexed data storage would also be very useful.
Fortunately, the Linux kernel already has a facility for byte-addressable and
pageable storage: tmpfs.
In-kernel graphics drivers (most notably i915) take advantage of tmpfs files
to store intermediate data that doesn’t need to be in memory at all times, so
that usage precedent is already established.
Hence, the <code class="docutils literal notranslate"><span class="pre">xfile</span></code> was born!</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Historical Sidebar</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>The first edition of online repair inserted records into a new btree as
it found them, which failed because filesystem could shut down with a
built data structure, which would be live after recovery finished.</p>
<p>The second edition solved the half-rebuilt structure problem by storing
everything in memory, but frequently ran the system out of memory.</p>
<p>The third edition solved the OOM problem by using linked lists, but the
memory overhead of the list pointers was extreme.</p>
</td>
</tr>
</tbody>
</table>
<section id="xfile-access-models">
<h4><a class="toc-backref" href="#id53" role="doc-backlink"><span class="section-number">4.5.5.1. </span>xfile Access Models</a><a class="headerlink" href="#xfile-access-models" title="Link to this heading">¶</a></h4>
<p>A survey of the intended uses of xfiles suggested these use cases:</p>
<ol class="arabic simple">
<li><p>Arrays of fixed-sized records (space management btrees, directory and
extended attribute entries)</p></li>
<li><p>Sparse arrays of fixed-sized records (quotas and link counts)</p></li>
<li><p>Large binary objects (BLOBs) of variable sizes (directory and extended
attribute names and values)</p></li>
<li><p>Staging btrees in memory (reverse mapping btrees)</p></li>
<li><p>Arbitrary contents (realtime space management)</p></li>
</ol>
<p>To support the first four use cases, high level data structures wrap the xfile
to share functionality between online fsck functions.
The rest of this section discusses the interfaces that the xfile presents to
four of those five higher level data structures.
The fifth use case is discussed in the <a class="reference internal" href="#rtsummary"><span class="std std-ref">realtime summary</span></a> case
study.</p>
<p>XFS is very record-based, which suggests that the ability to load and store
complete records is important.
To support these cases, a pair of <code class="docutils literal notranslate"><span class="pre">xfile_load</span></code> and <code class="docutils literal notranslate"><span class="pre">xfile_store</span></code>
functions are provided to read and persist objects into an xfile that treat any
error as an out of memory error.  For online repair, squashing error conditions
in this manner is an acceptable behavior because the only reaction is to abort
the operation back to userspace.</p>
<p>However, no discussion of file access idioms is complete without answering the
question, “But what about mmap?”
It is convenient to access storage directly with pointers, just like userspace
code does with regular memory.
Online fsck must not drive the system into OOM conditions, which means that
xfiles must be responsive to memory reclamation.
tmpfs can only push a pagecache folio to the swap cache if the folio is neither
pinned nor locked, which means the xfile must not pin too many folios.</p>
<p>Short term direct access to xfile contents is done by locking the pagecache
folio and mapping it into kernel address space.  Object load and store uses this
mechanism.  Folio locks are not supposed to be held for long periods of time, so
long term direct access to xfile contents is done by bumping the folio refcount,
mapping it into kernel address space, and dropping the folio lock.
These long term users <em>must</em> be responsive to memory reclaim by hooking into
the shrinker infrastructure to know when to release folios.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">xfile_get_folio</span></code> and <code class="docutils literal notranslate"><span class="pre">xfile_put_folio</span></code> functions are provided to
retrieve the (locked) folio that backs part of an xfile and to release it.
The only code to use these folio lease functions are the xfarray
<a class="reference internal" href="#xfarray-sort"><span class="std std-ref">sorting</span></a> algorithms and the <a class="reference internal" href="#xfbtree"><span class="std std-ref">in-memory
btrees</span></a>.</p>
</section>
<section id="xfile-access-coordination">
<h4><a class="toc-backref" href="#id54" role="doc-backlink"><span class="section-number">4.5.5.2. </span>xfile Access Coordination</a><a class="headerlink" href="#xfile-access-coordination" title="Link to this heading">¶</a></h4>
<p>For security reasons, xfiles must be owned privately by the kernel.
They are marked <code class="docutils literal notranslate"><span class="pre">S_PRIVATE</span></code> to prevent interference from the security system,
must never be mapped into process file descriptor tables, and their pages must
never be mapped into userspace processes.</p>
<p>To avoid locking recursion issues with the VFS, all accesses to the shmfs file
are performed by manipulating the page cache directly.
xfile writers call the <code class="docutils literal notranslate"><span class="pre">-&gt;write_begin</span></code> and <code class="docutils literal notranslate"><span class="pre">-&gt;write_end</span></code> functions of the
xfile’s address space to grab writable pages, copy the caller’s buffer into the
page, and release the pages.
xfile readers call <code class="docutils literal notranslate"><span class="pre">shmem_read_mapping_page_gfp</span></code> to grab pages directly
before copying the contents into the caller’s buffer.
In other words, xfiles ignore the VFS read and write code paths to avoid
having to create a dummy <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kiocb</span></code> and to avoid taking inode and
freeze locks.
tmpfs cannot be frozen, and xfiles must not be exposed to userspace.</p>
<p>If an xfile is shared between threads to stage repairs, the caller must provide
its own locks to coordinate access.
For example, if a scrub function stores scan results in an xfile and needs
other threads to provide updates to the scanned data, the scrub function must
provide a lock for all threads to share.</p>
</section>
<section id="arrays-of-fixed-sized-records">
<span id="xfarray"></span><h4><a class="toc-backref" href="#id55" role="doc-backlink"><span class="section-number">4.5.5.3. </span>Arrays of Fixed-Sized Records</a><a class="headerlink" href="#arrays-of-fixed-sized-records" title="Link to this heading">¶</a></h4>
<p>In XFS, each type of indexed space metadata (free space, inodes, reference
counts, file fork space, and reverse mappings) consists of a set of fixed-size
records indexed with a classic B+ tree.
Directories have a set of fixed-size dirent records that point to the names,
and extended attributes have a set of fixed-size attribute keys that point to
names and values.
Quota counters and file link counters index records with numbers.
During a repair, scrub needs to stage new records during the gathering step and
retrieve them during the btree building step.</p>
<p>Although this requirement can be satisfied by calling the read and write
methods of the xfile directly, it is simpler for callers for there to be a
higher level abstraction to take care of computing array offsets, to provide
iterator functions, and to deal with sparse records and sorting.
The <code class="docutils literal notranslate"><span class="pre">xfarray</span></code> abstraction presents a linear array for fixed-size records atop
the byte-accessible xfile.</p>
<section id="array-access-patterns">
<span id="xfarray-access-patterns"></span><h5><a class="toc-backref" href="#id56" role="doc-backlink"><span class="section-number">4.5.5.3.1. </span>Array Access Patterns</a><a class="headerlink" href="#array-access-patterns" title="Link to this heading">¶</a></h5>
<p>Array access patterns in online fsck tend to fall into three categories.
Iteration of records is assumed to be necessary for all cases and will be
covered in the next section.</p>
<p>The first type of caller handles records that are indexed by position.
Gaps may exist between records, and a record may be updated multiple times
during the collection step.
In other words, these callers want a sparse linearly addressed table file.
The typical use case are quota records or file link count records.
Access to array elements is performed programmatically via <code class="docutils literal notranslate"><span class="pre">xfarray_load</span></code> and
<code class="docutils literal notranslate"><span class="pre">xfarray_store</span></code> functions, which wrap the similarly-named xfile functions to
provide loading and storing of array elements at arbitrary array indices.
Gaps are defined to be null records, and null records are defined to be a
sequence of all zero bytes.
Null records are detected by calling <code class="docutils literal notranslate"><span class="pre">xfarray_element_is_null</span></code>.
They are created either by calling <code class="docutils literal notranslate"><span class="pre">xfarray_unset</span></code> to null out an existing
record or by never storing anything to an array index.</p>
<p>The second type of caller handles records that are not indexed by position
and do not require multiple updates to a record.
The typical use case here is rebuilding space btrees and key/value btrees.
These callers can add records to the array without caring about array indices
via the <code class="docutils literal notranslate"><span class="pre">xfarray_append</span></code> function, which stores a record at the end of the
array.
For callers that require records to be presentable in a specific order (e.g.
rebuilding btree data), the <code class="docutils literal notranslate"><span class="pre">xfarray_sort</span></code> function can arrange the sorted
records; this function will be covered later.</p>
<p>The third type of caller is a bag, which is useful for counting records.
The typical use case here is constructing space extent reference counts from
reverse mapping information.
Records can be put in the bag in any order, they can be removed from the bag
at any time, and uniqueness of records is left to callers.
The <code class="docutils literal notranslate"><span class="pre">xfarray_store_anywhere</span></code> function is used to insert a record in any
null record slot in the bag; and the <code class="docutils literal notranslate"><span class="pre">xfarray_unset</span></code> function removes a
record from the bag.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=big-array">big in-memory array</a>.</p>
</section>
<section id="iterating-array-elements">
<h5><a class="toc-backref" href="#id57" role="doc-backlink"><span class="section-number">4.5.5.3.2. </span>Iterating Array Elements</a><a class="headerlink" href="#iterating-array-elements" title="Link to this heading">¶</a></h5>
<p>Most users of the xfarray require the ability to iterate the records stored in
the array.
Callers can probe every possible array index with the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">xfarray_idx_t</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="n">foreach_xfarray_idx</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">xfarray_load</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rec</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* do something with rec */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All users of this idiom must be prepared to handle null records or must already
know that there aren’t any.</p>
<p>For xfarray users that want to iterate a sparse array, the <code class="docutils literal notranslate"><span class="pre">xfarray_iter</span></code>
function ignores indices in the xfarray that have never been written to by
calling <code class="docutils literal notranslate"><span class="pre">xfile_seek_data</span></code> (which internally uses <code class="docutils literal notranslate"><span class="pre">SEEK_DATA</span></code>) to skip areas
of the array that are not populated with memory pages.
Once it finds a page, it will skip the zeroed areas of the page.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">xfarray_idx_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XFARRAY_CURSOR_INIT</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xfarray_iter</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rec</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* do something with rec */</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="sorting-array-elements">
<span id="xfarray-sort"></span><h5><a class="toc-backref" href="#id58" role="doc-backlink"><span class="section-number">4.5.5.3.3. </span>Sorting Array Elements</a><a class="headerlink" href="#sorting-array-elements" title="Link to this heading">¶</a></h5>
<p>During the fourth demonstration of online repair, a community reviewer remarked
that for performance reasons, online repair ought to load batches of records
into btree record blocks instead of inserting records into a new btree one at a
time.
The btree insertion code in XFS is responsible for maintaining correct ordering
of the records, so naturally the xfarray must also support sorting the record
set prior to bulk loading.</p>
<section id="case-study-sorting-xfarrays">
<h6><a class="toc-backref" href="#id59" role="doc-backlink"><span class="section-number">4.5.5.3.3.1. </span>Case Study: Sorting xfarrays</a><a class="headerlink" href="#case-study-sorting-xfarrays" title="Link to this heading">¶</a></h6>
<p>The sorting algorithm used in the xfarray is actually a combination of adaptive
quicksort and a heapsort subalgorithm in the spirit of
<a class="reference external" href="https://algs4.cs.princeton.edu/23quicksort/">Sedgewick</a> and
<a class="reference external" href="https://github.com/orlp/pdqsort">pdqsort</a>, with customizations for the Linux
kernel.
To sort records in a reasonably short amount of time, <code class="docutils literal notranslate"><span class="pre">xfarray</span></code> takes
advantage of the binary subpartitioning offered by quicksort, but it also uses
heapsort to hedge against performance collapse if the chosen quicksort pivots
are poor.
Both algorithms are (in general) O(n * lg(n)), but there is a wide performance
gulf between the two implementations.</p>
<p>The Linux kernel already contains a reasonably fast implementation of heapsort.
It only operates on regular C arrays, which limits the scope of its usefulness.
There are two key places where the xfarray uses it:</p>
<ul class="simple">
<li><p>Sorting any record subset backed by a single xfile page.</p></li>
<li><p>Loading a small number of xfarray records from potentially disparate parts
of the xfarray into a memory buffer, and sorting the buffer.</p></li>
</ul>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">xfarray</span></code> uses heapsort to constrain the nested recursion of
quicksort, thereby mitigating quicksort’s worst runtime behavior.</p>
<p>Choosing a quicksort pivot is a tricky business.
A good pivot splits the set to sort in half, leading to the divide and conquer
behavior that is crucial to  O(n * lg(n)) performance.
A poor pivot barely splits the subset at all, leading to O(n<sup>2</sup>)
runtime.
The xfarray sort routine tries to avoid picking a bad pivot by sampling nine
records into a memory buffer and using the kernel heapsort to identify the
median of the nine.</p>
<p>Most modern quicksort implementations employ Tukey’s “ninther” to select a
pivot from a classic C array.
Typical ninther implementations pick three unique triads of records, sort each
of the triads, and then sort the middle value of each triad to determine the
ninther value.
As stated previously, however, xfile accesses are not entirely cheap.
It turned out to be much more performant to read the nine elements into a
memory buffer, run the kernel’s in-memory heapsort on the buffer, and choose
the 4th element of that buffer as the pivot.
Tukey’s ninthers are described in J. W. Tukey, <cite>The ninther, a technique for
low-effort robust (resistant) location in large samples</cite>, in <em>Contributions to
Survey Sampling and Applied Statistics</em>, edited by H. David, (Academic Press,
1978), pp. 251–257.</p>
<p>The partitioning of quicksort is fairly textbook -- rearrange the record
subset around the pivot, then set up the current and next stack frames to
sort with the larger and the smaller halves of the pivot, respectively.
This keeps the stack space requirements to log2(record count).</p>
<p>As a final performance optimization, the hi and lo scanning phase of quicksort
keeps examined xfile pages mapped in the kernel for as long as possible to
reduce map/unmap cycles.
Surprisingly, this reduces overall sort runtime by nearly half again after
accounting for the application of heapsort directly onto xfile pages.</p>
</section>
</section>
</section>
<section id="blob-storage">
<span id="xfblob"></span><h4><a class="toc-backref" href="#id60" role="doc-backlink"><span class="section-number">4.5.5.4. </span>Blob Storage</a><a class="headerlink" href="#blob-storage" title="Link to this heading">¶</a></h4>
<p>Extended attributes and directories add an additional requirement for staging
records: arbitrary byte sequences of finite length.
Each directory entry record needs to store entry name,
and each extended attribute needs to store both the attribute name and value.
The names, keys, and values can consume a large amount of memory, so the
<code class="docutils literal notranslate"><span class="pre">xfblob</span></code> abstraction was created to simplify management of these blobs
atop an xfile.</p>
<p>Blob arrays provide <code class="docutils literal notranslate"><span class="pre">xfblob_load</span></code> and <code class="docutils literal notranslate"><span class="pre">xfblob_store</span></code> functions to retrieve
and persist objects.
The store function returns a magic cookie for every object that it persists.
Later, callers provide this cookie to the <code class="docutils literal notranslate"><span class="pre">xblob_load</span></code> to recall the object.
The <code class="docutils literal notranslate"><span class="pre">xfblob_free</span></code> function frees a specific blob, and the <code class="docutils literal notranslate"><span class="pre">xfblob_truncate</span></code>
function frees them all because compaction is not needed.</p>
<p>The details of repairing directories and extended attributes will be discussed
in a subsequent section about atomic file content exchanges.
However, it should be noted that these repair functions only use blob storage
to cache a small number of entries before adding them to a temporary ondisk
file, which is why compaction is not required.</p>
<p>The proposed patchset is at the start of the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-xattrs">extended attribute repair</a> series.</p>
</section>
<section id="in-memory-b-trees">
<span id="xfbtree"></span><h4><a class="toc-backref" href="#id61" role="doc-backlink"><span class="section-number">4.5.5.5. </span>In-Memory B+Trees</a><a class="headerlink" href="#in-memory-b-trees" title="Link to this heading">¶</a></h4>
<p>The chapter about <a class="reference internal" href="#secondary-metadata"><span class="std std-ref">secondary metadata</span></a> mentioned that
checking and repairing of secondary metadata commonly requires coordination
between a live metadata scan of the filesystem and writer threads that are
updating that metadata.
Keeping the scan data up to date requires requires the ability to propagate
metadata updates from the filesystem into the data being collected by the scan.
This <em>can</em> be done by appending concurrent updates into a separate log file and
applying them before writing the new metadata to disk, but this leads to
unbounded memory consumption if the rest of the system is very busy.
Another option is to skip the side-log and commit live updates from the
filesystem directly into the scan data, which trades more overhead for a lower
maximum memory requirement.
In both cases, the data structure holding the scan results must support indexed
access to perform well.</p>
<p>Given that indexed lookups of scan data is required for both strategies, online
fsck employs the second strategy of committing live updates directly into
scan data.
Because xfarrays are not indexed and do not enforce record ordering, they
are not suitable for this task.
Conveniently, however, XFS has a library to create and maintain ordered reverse
mapping records: the existing rmap btree code!
If only there was a means to create one in memory.</p>
<p>Recall that the <a class="reference internal" href="#xfile"><span class="std std-ref">xfile</span></a> abstraction represents memory pages as a
regular file, which means that the kernel can create byte or block addressable
virtual address spaces at will.
The XFS buffer cache specializes in abstracting IO to block-oriented  address
spaces, which means that adaptation of the buffer cache to interface with
xfiles enables reuse of the entire btree library.
Btrees built atop an xfile are collectively known as <code class="docutils literal notranslate"><span class="pre">xfbtrees</span></code>.
The next few sections describe how they actually work.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=in-memory-btrees">in-memory btree</a>
series.</p>
<section id="using-xfiles-as-a-buffer-cache-target">
<h5><a class="toc-backref" href="#id62" role="doc-backlink"><span class="section-number">4.5.5.5.1. </span>Using xfiles as a Buffer Cache Target</a><a class="headerlink" href="#using-xfiles-as-a-buffer-cache-target" title="Link to this heading">¶</a></h5>
<p>Two modifications are necessary to support xfiles as a buffer cache target.
The first is to make it possible for the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_buftarg</span></code> structure to
host the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_buf</span></code> rhashtable, because normally those are held by a
per-AG structure.
The second change is to modify the buffer <code class="docutils literal notranslate"><span class="pre">ioapply</span></code> function to “read” cached
pages from the xfile and “write” cached pages back to the xfile.
Multiple access to individual buffers is controlled by the <code class="docutils literal notranslate"><span class="pre">xfs_buf</span></code> lock,
since the xfile does not provide any locking on its own.
With this adaptation in place, users of the xfile-backed buffer cache use
exactly the same APIs as users of the disk-backed buffer cache.
The separation between xfile and buffer cache implies higher memory usage since
they do not share pages, but this property could some day enable transactional
updates to an in-memory btree.
Today, however, it simply eliminates the need for new code.</p>
</section>
<section id="space-management-with-an-xfbtree">
<h5><a class="toc-backref" href="#id63" role="doc-backlink"><span class="section-number">4.5.5.5.2. </span>Space Management with an xfbtree</a><a class="headerlink" href="#space-management-with-an-xfbtree" title="Link to this heading">¶</a></h5>
<p>Space management for an xfile is very simple -- each btree block is one memory
page in size.
These blocks use the same header format as an on-disk btree, but the in-memory
block verifiers ignore the checksums, assuming that xfile memory is no more
corruption-prone than regular DRAM.
Reusing existing code here is more important than absolute memory efficiency.</p>
<p>The very first block of an xfile backing an xfbtree contains a header block.
The header describes the owner, height, and the block number of the root
xfbtree block.</p>
<p>To allocate a btree block, use <code class="docutils literal notranslate"><span class="pre">xfile_seek_data</span></code> to find a gap in the file.
If there are no gaps, create one by extending the length of the xfile.
Preallocate space for the block with <code class="docutils literal notranslate"><span class="pre">xfile_prealloc</span></code>, and hand back the
location.
To free an xfbtree block, use <code class="docutils literal notranslate"><span class="pre">xfile_discard</span></code> (which internally uses
<code class="docutils literal notranslate"><span class="pre">FALLOC_FL_PUNCH_HOLE</span></code>) to remove the memory page from the xfile.</p>
</section>
<section id="populating-an-xfbtree">
<h5><a class="toc-backref" href="#id64" role="doc-backlink"><span class="section-number">4.5.5.5.3. </span>Populating an xfbtree</a><a class="headerlink" href="#populating-an-xfbtree" title="Link to this heading">¶</a></h5>
<p>An online fsck function that wants to create an xfbtree should proceed as
follows:</p>
<ol class="arabic simple">
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xfile_create</span></code> to create an xfile.</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xfs_alloc_memory_buftarg</span></code> to create a buffer cache target structure
pointing to the xfile.</p></li>
<li><p>Pass the buffer cache target, buffer ops, and other information to
<code class="docutils literal notranslate"><span class="pre">xfbtree_init</span></code> to initialize the passed in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfbtree</span></code> and write an
initial root block to the xfile.
Each btree type should define a wrapper that passes necessary arguments to
the creation function.
For example, rmap btrees define <code class="docutils literal notranslate"><span class="pre">xfs_rmapbt_mem_create</span></code> to take care of
all the necessary details for callers.</p></li>
<li><p>Pass the xfbtree object to the btree cursor creation function for the
btree type.
Following the example above, <code class="docutils literal notranslate"><span class="pre">xfs_rmapbt_mem_cursor</span></code> takes care of this
for callers.</p></li>
<li><p>Pass the btree cursor to the regular btree functions to make queries against
and to update the in-memory btree.
For example, a btree cursor for an rmap xfbtree can be passed to the
<code class="docutils literal notranslate"><span class="pre">xfs_rmap_*</span></code> functions just like any other btree cursor.
See the <a class="reference internal" href="#xfbtree-commit"><span class="std std-ref">next section</span></a> for information on dealing with
xfbtree updates that are logged to a transaction.</p></li>
<li><p>When finished, delete the btree cursor, destroy the xfbtree object, free the
buffer target, and the destroy the xfile to release all resources.</p></li>
</ol>
</section>
<section id="committing-logged-xfbtree-buffers">
<span id="xfbtree-commit"></span><h5><a class="toc-backref" href="#id65" role="doc-backlink"><span class="section-number">4.5.5.5.4. </span>Committing Logged xfbtree Buffers</a><a class="headerlink" href="#committing-logged-xfbtree-buffers" title="Link to this heading">¶</a></h5>
<p>Although it is a clever hack to reuse the rmap btree code to handle the staging
structure, the ephemeral nature of the in-memory btree block storage presents
some challenges of its own.
The XFS transaction manager must not commit buffer log items for buffers backed
by an xfile because the log format does not understand updates for devices
other than the data device.
An ephemeral xfbtree probably will not exist by the time the AIL checkpoints
log transactions back into the filesystem, and certainly won’t exist during
log recovery.
For these reasons, any code updating an xfbtree in transaction context must
remove the buffer log items from the transaction and write the updates into the
backing xfile before committing or cancelling the transaction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">xfbtree_trans_commit</span></code> and <code class="docutils literal notranslate"><span class="pre">xfbtree_trans_cancel</span></code> functions implement
this functionality as follows:</p>
<ol class="arabic simple">
<li><p>Find each buffer log item whose buffer targets the xfile.</p></li>
<li><p>Record the dirty/ordered status of the log item.</p></li>
<li><p>Detach the log item from the buffer.</p></li>
<li><p>Queue the buffer to a special delwri list.</p></li>
<li><p>Clear the transaction dirty flag if the only dirty log items were the ones
that were detached in step 3.</p></li>
<li><p>Submit the delwri list to commit the changes to the xfile, if the updates
are being committed.</p></li>
</ol>
<p>After removing xfile logged buffers from the transaction in this manner, the
transaction can be committed or cancelled.</p>
</section>
</section>
</section>
<section id="bulk-loading-of-ondisk-b-trees">
<h3><a class="toc-backref" href="#id66" role="doc-backlink"><span class="section-number">4.5.6. </span>Bulk Loading of Ondisk B+Trees</a><a class="headerlink" href="#bulk-loading-of-ondisk-b-trees" title="Link to this heading">¶</a></h3>
<p>As mentioned previously, early iterations of online repair built new btree
structures by creating a new btree and adding observations individually.
Loading a btree one record at a time had a slight advantage of not requiring
the incore records to be sorted prior to commit, but was very slow and leaked
blocks if the system went down during a repair.
Loading records one at a time also meant that repair could not control the
loading factor of the blocks in the new btree.</p>
<p>Fortunately, the venerable <code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code> tool had a more efficient means for
rebuilding a btree index from a collection of records -- bulk btree loading.
This was implemented rather inefficiently code-wise, since <code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code>
had separate copy-pasted implementations for each btree type.</p>
<p>To prepare for online fsck, each of the four bulk loaders were studied, notes
were taken, and the four were refactored into a single generic btree bulk
loading mechanism.
Those notes in turn have been refreshed and are presented below.</p>
<section id="geometry-computation">
<h4><a class="toc-backref" href="#id67" role="doc-backlink"><span class="section-number">4.5.6.1. </span>Geometry Computation</a><a class="headerlink" href="#geometry-computation" title="Link to this heading">¶</a></h4>
<p>The zeroth step of bulk loading is to assemble the entire record set that will
be stored in the new btree, and sort the records.
Next, call <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload_compute_geometry</span></code> to compute the shape of the
btree from the record set, the type of btree, and any load factor preferences.
This information is required for resource reservation.</p>
<p>First, the geometry computation computes the minimum and maximum records that
will fit in a leaf block from the size of a btree block and the size of the
block header.
Roughly speaking, the maximum number of records is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>maxrecs = (block_size - header_size) / record_size
</pre></div>
</div>
<p>The XFS design specifies that btree blocks should be merged when possible,
which means the minimum number of records is half of maxrecs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>minrecs = maxrecs / 2
</pre></div>
</div>
<p>The next variable to determine is the desired loading factor.
This must be at least minrecs and no more than maxrecs.
Choosing minrecs is undesirable because it wastes half the block.
Choosing maxrecs is also undesirable because adding a single record to each
newly rebuilt leaf block will cause a tree split, which causes a noticeable
drop in performance immediately afterwards.
The default loading factor was chosen to be 75% of maxrecs, which provides a
reasonably compact structure without any immediate split penalties:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>default_load_factor = (maxrecs + minrecs) / 2
</pre></div>
</div>
<p>If space is tight, the loading factor will be set to maxrecs to try to avoid
running out of space:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>leaf_load_factor = enough space ? default_load_factor : maxrecs
</pre></div>
</div>
<p>Load factor is computed for btree node blocks using the combined size of the
btree key and pointer as the record size:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>maxrecs = (block_size - header_size) / (key_size + ptr_size)
minrecs = maxrecs / 2
node_load_factor = enough space ? default_load_factor : maxrecs
</pre></div>
</div>
<p>Once that’s done, the number of leaf blocks required to store the record set
can be computed as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>leaf_blocks = ceil(record_count / leaf_load_factor)
</pre></div>
</div>
<p>The number of node blocks needed to point to the next level down in the tree
is computed as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>n_blocks = (n == 0 ? leaf_blocks : node_blocks[n])
node_blocks[n + 1] = ceil(n_blocks / node_load_factor)
</pre></div>
</div>
<p>The entire computation is performed recursively until the current level only
needs one block.
The resulting geometry is as follows:</p>
<ul class="simple">
<li><p>For AG-rooted btrees, this level is the root level, so the height of the new
tree is <code class="docutils literal notranslate"><span class="pre">level</span> <span class="pre">+</span> <span class="pre">1</span></code> and the space needed is the summation of the number of
blocks on each level.</p></li>
<li><p>For inode-rooted btrees where the records in the top level do not fit in the
inode fork area, the height is <code class="docutils literal notranslate"><span class="pre">level</span> <span class="pre">+</span> <span class="pre">2</span></code>, the space needed is the
summation of the number of blocks on each level, and the inode fork points to
the root block.</p></li>
<li><p>For inode-rooted btrees where the records in the top level can be stored in
the inode fork area, then the root block can be stored in the inode, the
height is <code class="docutils literal notranslate"><span class="pre">level</span> <span class="pre">+</span> <span class="pre">1</span></code>, and the space needed is one less than the summation
of the number of blocks on each level.
This only becomes relevant when non-bmap btrees gain the ability to root in
an inode, which is a future patchset and only included here for completeness.</p></li>
</ul>
</section>
<section id="reserving-new-b-tree-blocks">
<span id="newbt"></span><h4><a class="toc-backref" href="#id68" role="doc-backlink"><span class="section-number">4.5.6.2. </span>Reserving New B+Tree Blocks</a><a class="headerlink" href="#reserving-new-b-tree-blocks" title="Link to this heading">¶</a></h4>
<p>Once repair knows the number of blocks needed for the new btree, it allocates
those blocks using the free space information.
Each reserved extent is tracked separately by the btree builder state data.
To improve crash resilience, the reservation code also logs an Extent Freeing
Intent (EFI) item in the same transaction as each space allocation and attaches
its in-memory <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_extent_free_item</span></code> object to the space reservation.
If the system goes down, log recovery will use the unfinished EFIs to free the
unused space, the free space, leaving the filesystem unchanged.</p>
<p>Each time the btree builder claims a block for the btree from a reserved
extent, it updates the in-memory reservation to reflect the claimed space.
Block reservation tries to allocate as much contiguous space as possible to
reduce the number of EFIs in play.</p>
<p>While repair is writing these new btree blocks, the EFIs created for the space
reservations pin the tail of the ondisk log.
It’s possible that other parts of the system will remain busy and push the head
of the log towards the pinned tail.
To avoid livelocking the filesystem, the EFIs must not pin the tail of the log
for too long.
To alleviate this problem, the dynamic relogging capability of the deferred ops
mechanism is reused here to commit a transaction at the log head containing an
EFD for the old EFI and new EFI at the head.
This enables the log to release the old EFI to keep the log moving forwards.</p>
<p>EFIs have a role to play during the commit and reaping phases; please see the
next section and the section about <a class="reference internal" href="#reaping"><span class="std std-ref">reaping</span></a> for more details.</p>
<p>Proposed patchsets are the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-bitmap-rework">bitmap rework</a>
and the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-prep-for-bulk-loading">preparation for bulk loading btrees</a>.</p>
</section>
<section id="writing-the-new-tree">
<h4><a class="toc-backref" href="#id69" role="doc-backlink"><span class="section-number">4.5.6.3. </span>Writing the New Tree</a><a class="headerlink" href="#writing-the-new-tree" title="Link to this heading">¶</a></h4>
<p>This part is pretty simple -- the btree builder (<code class="docutils literal notranslate"><span class="pre">xfs_btree_bulkload</span></code>) claims
a block from the reserved list, writes the new btree block header, fills the
rest of the block with records, and adds the new leaf block to a list of
written blocks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>┌────┐
│leaf│
│RRR │
└────┘
</pre></div>
</div>
<p>Sibling pointers are set every time a new block is added to the level:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>┌────┐ ┌────┐ ┌────┐ ┌────┐
│leaf│→│leaf│→│leaf│→│leaf│
│RRR │←│RRR │←│RRR │←│RRR │
└────┘ └────┘ └────┘ └────┘
</pre></div>
</div>
<p>When it finishes writing the record leaf blocks, it moves on to the node
blocks
To fill a node block, it walks each block in the next level down in the tree
to compute the relevant keys and write them into the parent node:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    ┌────┐       ┌────┐
    │node│──────→│node│
    │PP  │←──────│PP  │
    └────┘       └────┘
    ↙   ↘         ↙   ↘
┌────┐ ┌────┐ ┌────┐ ┌────┐
│leaf│→│leaf│→│leaf│→│leaf│
│RRR │←│RRR │←│RRR │←│RRR │
└────┘ └────┘ └────┘ └────┘
</pre></div>
</div>
<p>When it reaches the root level, it is ready to commit the new btree!:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        ┌─────────┐
        │  root   │
        │   PP    │
        └─────────┘
        ↙         ↘
    ┌────┐       ┌────┐
    │node│──────→│node│
    │PP  │←──────│PP  │
    └────┘       └────┘
    ↙   ↘         ↙   ↘
┌────┐ ┌────┐ ┌────┐ ┌────┐
│leaf│→│leaf│→│leaf│→│leaf│
│RRR │←│RRR │←│RRR │←│RRR │
└────┘ └────┘ └────┘ └────┘
</pre></div>
</div>
<p>The first step to commit the new btree is to persist the btree blocks to disk
synchronously.
This is a little complicated because a new btree block could have been freed
in the recent past, so the builder must use <code class="docutils literal notranslate"><span class="pre">xfs_buf_delwri_queue_here</span></code> to
remove the (stale) buffer from the AIL list before it can write the new blocks
to disk.
Blocks are queued for IO using a delwri list and written in one large batch
with <code class="docutils literal notranslate"><span class="pre">xfs_buf_delwri_submit</span></code>.</p>
<p>Once the new blocks have been persisted to disk, control returns to the
individual repair function that called the bulk loader.
The repair function must log the location of the new root in a transaction,
clean up the space reservations that were made for the new btree, and reap the
old metadata blocks:</p>
<ol class="arabic simple">
<li><p>Commit the location of the new btree root.</p></li>
<li><p>For each incore reservation:</p>
<ol class="loweralpha simple">
<li><p>Log Extent Freeing Done (EFD) items for all the space that was consumed
by the btree builder.  The new EFDs must point to the EFIs attached to
the reservation to prevent log recovery from freeing the new blocks.</p></li>
<li><p>For unclaimed portions of incore reservations, create a regular deferred
extent free work item to be free the unused space later in the
transaction chain.</p></li>
<li><p>The EFDs and EFIs logged in steps 2a and 2b must not overrun the
reservation of the committing transaction.
If the btree loading code suspects this might be about to happen, it must
call <code class="docutils literal notranslate"><span class="pre">xrep_defer_finish</span></code> to clear out the deferred work and obtain a
fresh transaction.</p></li>
</ol>
</li>
<li><p>Clear out the deferred work a second time to finish the commit and clean
the repair transaction.</p></li>
</ol>
<p>The transaction rolling in steps 2c and 3 represent a weakness in the repair
algorithm, because a log flush and a crash before the end of the reap step can
result in space leaking.
Online repair functions minimize the chances of this occurring by using very
large transactions, which each can accommodate many thousands of block freeing
instructions.
Repair moves on to reaping the old blocks, which will be presented in a
subsequent <a class="reference internal" href="#reaping"><span class="std std-ref">section</span></a> after a few case studies of bulk loading.</p>
<section id="case-study-rebuilding-the-inode-index">
<h5><a class="toc-backref" href="#id70" role="doc-backlink"><span class="section-number">4.5.6.3.1. </span>Case Study: Rebuilding the Inode Index</a><a class="headerlink" href="#case-study-rebuilding-the-inode-index" title="Link to this heading">¶</a></h5>
<p>The high level process to rebuild the inode index btree is:</p>
<ol class="arabic simple">
<li><p>Walk the reverse mapping records to generate <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_inobt_rec</span></code>
records from the inode chunk information and a bitmap of the old inode btree
blocks.</p></li>
<li><p>Append the records to an xfarray in inode order.</p></li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload_compute_geometry</span></code> function to compute the number
of blocks needed for the inode btree.
If the free space inode btree is enabled, call it again to estimate the
geometry of the finobt.</p></li>
<li><p>Allocate the number of blocks computed in the previous step.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload</span></code> to write the xfarray records to btree blocks and
generate the internal node blocks.
If the free space inode btree is enabled, call it again to load the finobt.</p></li>
<li><p>Commit the location of the new btree root block(s) to the AGI.</p></li>
<li><p>Reap the old btree blocks using the bitmap created in step 1.</p></li>
</ol>
<p>Details are as follows.</p>
<p>The inode btree maps inumbers to the ondisk location of the associated
inode records, which means that the inode btrees can be rebuilt from the
reverse mapping information.
Reverse mapping records with an owner of <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_INOBT</span></code> marks the
location of the old inode btree blocks.
Each reverse mapping record with an owner of <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_INODES</span></code> marks the
location of at least one inode cluster buffer.
A cluster is the smallest number of ondisk inodes that can be allocated or
freed in a single transaction; it is never smaller than 1 fs block or 4 inodes.</p>
<p>For the space represented by each inode cluster, ensure that there are no
records in the free space btrees nor any records in the reference count btree.
If there are, the space metadata inconsistencies are reason enough to abort the
operation.
Otherwise, read each cluster buffer to check that its contents appear to be
ondisk inodes and to decide if the file is allocated
(<code class="docutils literal notranslate"><span class="pre">xfs_dinode.i_mode</span> <span class="pre">!=</span> <span class="pre">0</span></code>) or free (<code class="docutils literal notranslate"><span class="pre">xfs_dinode.i_mode</span> <span class="pre">==</span> <span class="pre">0</span></code>).
Accumulate the results of successive inode cluster buffer reads until there is
enough information to fill a single inode chunk record, which is 64 consecutive
numbers in the inumber keyspace.
If the chunk is sparse, the chunk record may include holes.</p>
<p>Once the repair function accumulates one chunk’s worth of data, it calls
<code class="docutils literal notranslate"><span class="pre">xfarray_append</span></code> to add the inode btree record to the xfarray.
This xfarray is walked twice during the btree creation step -- once to populate
the inode btree with all inode chunk records, and a second time to populate the
free inode btree with records for chunks that have free non-sparse inodes.
The number of records for the inode btree is the number of xfarray records,
but the record count for the free inode btree has to be computed as inode chunk
records are stored in the xfarray.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-ag-btrees">AG btree repair</a>
series.</p>
</section>
<section id="case-study-rebuilding-the-space-reference-counts">
<h5><a class="toc-backref" href="#id71" role="doc-backlink"><span class="section-number">4.5.6.3.2. </span>Case Study: Rebuilding the Space Reference Counts</a><a class="headerlink" href="#case-study-rebuilding-the-space-reference-counts" title="Link to this heading">¶</a></h5>
<p>Reverse mapping records are used to rebuild the reference count information.
Reference counts are required for correct operation of copy on write for shared
file data.
Imagine the reverse mapping entries as rectangles representing extents of
physical blocks, and that the rectangles can be laid down to allow them to
overlap each other.
From the diagram below, it is apparent that a reference count record must start
or end wherever the height of the stack changes.
In other words, the record emission stimulus is level-triggered:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                █    ███
      ██      █████ ████   ███        ██████
██   ████     ███████████ ████     █████████
████████████████████████████████ ███████████
^ ^  ^^ ^^    ^ ^^ ^^^  ^^^^  ^ ^^ ^  ^     ^
2 1  23 21    3 43 234  2123  1 01 2  3     0
</pre></div>
</div>
<p>The ondisk reference count btree does not store the refcount == 0 cases because
the free space btree already records which blocks are free.
Extents being used to stage copy-on-write operations should be the only records
with refcount == 1.
Single-owner file blocks aren’t recorded in either the free space or the
reference count btrees.</p>
<p>The high level process to rebuild the reference count btree is:</p>
<ol class="arabic">
<li><p>Walk the reverse mapping records to generate <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_refcount_irec</span></code>
records for any space having more than one reverse mapping and add them to
the xfarray.
Any records owned by <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_COW</span></code> are also added to the xfarray
because these are extents allocated to stage a copy on write operation and
are tracked in the refcount btree.</p>
<p>Use any records owned by <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_REFC</span></code> to create a bitmap of old
refcount btree blocks.</p>
</li>
<li><p>Sort the records in physical extent order, putting the CoW staging extents
at the end of the xfarray.
This matches the sorting order of records in the refcount btree.</p></li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload_compute_geometry</span></code> function to compute the number
of blocks needed for the new tree.</p></li>
<li><p>Allocate the number of blocks computed in the previous step.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload</span></code> to write the xfarray records to btree blocks and
generate the internal node blocks.</p></li>
<li><p>Commit the location of new btree root block to the AGF.</p></li>
<li><p>Reap the old btree blocks using the bitmap created in step 1.</p></li>
</ol>
<p>Details are as follows; the same algorithm is used by <code class="docutils literal notranslate"><span class="pre">xfs_repair</span></code> to
generate refcount information from reverse mapping records.</p>
<ul class="simple">
<li><p>Until the reverse mapping btree runs out of records:</p>
<ul>
<li><p>Retrieve the next record from the btree and put it in a bag.</p></li>
<li><p>Collect all records with the same starting block from the btree and put
them in the bag.</p></li>
<li><p>While the bag isn’t empty:</p>
<ul>
<li><p>Among the mappings in the bag, compute the lowest block number where the
reference count changes.
This position will be either the starting block number of the next
unprocessed reverse mapping or the next block after the shortest mapping
in the bag.</p></li>
<li><p>Remove all mappings from the bag that end at this position.</p></li>
<li><p>Collect all reverse mappings that start at this position from the btree
and put them in the bag.</p></li>
<li><p>If the size of the bag changed and is greater than one, create a new
refcount record associating the block number range that we just walked to
the size of the bag.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The bag-like structure in this case is a type 2 xfarray as discussed in the
<a class="reference internal" href="#xfarray-access-patterns"><span class="std std-ref">xfarray access patterns</span></a> section.
Reverse mappings are added to the bag using <code class="docutils literal notranslate"><span class="pre">xfarray_store_anywhere</span></code> and
removed via <code class="docutils literal notranslate"><span class="pre">xfarray_unset</span></code>.
Bag members are examined through <code class="docutils literal notranslate"><span class="pre">xfarray_iter</span></code> loops.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-ag-btrees">AG btree repair</a>
series.</p>
</section>
<section id="case-study-rebuilding-file-fork-mapping-indices">
<h5><a class="toc-backref" href="#id72" role="doc-backlink"><span class="section-number">4.5.6.3.3. </span>Case Study: Rebuilding File Fork Mapping Indices</a><a class="headerlink" href="#case-study-rebuilding-file-fork-mapping-indices" title="Link to this heading">¶</a></h5>
<p>The high level process to rebuild a data/attr fork mapping btree is:</p>
<ol class="arabic simple">
<li><p>Walk the reverse mapping records to generate <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_bmbt_rec</span></code>
records from the reverse mapping records for that inode and fork.
Append these records to an xfarray.
Compute the bitmap of the old bmap btree blocks from the <code class="docutils literal notranslate"><span class="pre">BMBT_BLOCK</span></code>
records.</p></li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload_compute_geometry</span></code> function to compute the number
of blocks needed for the new tree.</p></li>
<li><p>Sort the records in file offset order.</p></li>
<li><p>If the extent records would fit in the inode fork immediate area, commit the
records to that immediate area and skip to step 8.</p></li>
<li><p>Allocate the number of blocks computed in the previous step.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload</span></code> to write the xfarray records to btree blocks and
generate the internal node blocks.</p></li>
<li><p>Commit the new btree root block to the inode fork immediate area.</p></li>
<li><p>Reap the old btree blocks using the bitmap created in step 1.</p></li>
</ol>
<p>There are some complications here:
First, it’s possible to move the fork offset to adjust the sizes of the
immediate areas if the data and attr forks are not both in BMBT format.
Second, if there are sufficiently few fork mappings, it may be possible to use
EXTENTS format instead of BMBT, which may require a conversion.
Third, the incore extent map must be reloaded carefully to avoid disturbing
any delayed allocation extents.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-file-mappings">file mapping repair</a>
series.</p>
</section>
</section>
</section>
<section id="reaping-old-metadata-blocks">
<span id="reaping"></span><h3><a class="toc-backref" href="#id73" role="doc-backlink"><span class="section-number">4.5.7. </span>Reaping Old Metadata Blocks</a><a class="headerlink" href="#reaping-old-metadata-blocks" title="Link to this heading">¶</a></h3>
<p>Whenever online fsck builds a new data structure to replace one that is
suspect, there is a question of how to find and dispose of the blocks that
belonged to the old structure.
The laziest method of course is not to deal with them at all, but this slowly
leads to service degradations as space leaks out of the filesystem.
Hopefully, someone will schedule a rebuild of the free space information to
plug all those leaks.
Offline repair rebuilds all space metadata after recording the usage of
the files and directories that it decides not to clear, hence it can build new
structures in the discovered free space and avoid the question of reaping.</p>
<p>As part of a repair, online fsck relies heavily on the reverse mapping records
to find space that is owned by the corresponding rmap owner yet truly free.
Cross referencing rmap records with other rmap records is necessary because
there may be other data structures that also think they own some of those
blocks (e.g. crosslinked trees).
Permitting the block allocator to hand them out again will not push the system
towards consistency.</p>
<p>For space metadata, the process of finding extents to dispose of generally
follows this format:</p>
<ol class="arabic simple">
<li><p>Create a bitmap of space used by data structures that must be preserved.
The space reservations used to create the new metadata can be used here if
the same rmap owner code is used to denote all of the objects being rebuilt.</p></li>
<li><p>Survey the reverse mapping data to create a bitmap of space owned by the
same <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_*</span></code> number for the metadata that is being preserved.</p></li>
<li><p>Use the bitmap disunion operator to subtract (1) from (2).
The remaining set bits represent candidate extents that could be freed.
The process moves on to step 4 below.</p></li>
</ol>
<p>Repairs for file-based metadata such as extended attributes, directories,
symbolic links, quota files and realtime bitmaps are performed by building a
new structure attached to a temporary file and exchanging all mappings in the
file forks.
Afterward, the mappings in the old file fork are the candidate blocks for
disposal.</p>
<p>The process for disposing of old extents is as follows:</p>
<ol class="arabic simple" start="4">
<li><p>For each candidate extent, count the number of reverse mapping records for
the first block in that extent that do not have the same rmap owner for the
data structure being repaired.</p>
<ul class="simple">
<li><p>If zero, the block has a single owner and can be freed.</p></li>
<li><p>If not, the block is part of a crosslinked structure and must not be
freed.</p></li>
</ul>
</li>
<li><p>Starting with the next block in the extent, figure out how many more blocks
have the same zero/nonzero other owner status as that first block.</p></li>
<li><p>If the region is crosslinked, delete the reverse mapping entry for the
structure being repaired and move on to the next region.</p></li>
<li><p>If the region is to be freed, mark any corresponding buffers in the buffer
cache as stale to prevent log writeback.</p></li>
<li><p>Free the region and move on.</p></li>
</ol>
<p>However, there is one complication to this procedure.
Transactions are of finite size, so the reaping process must be careful to roll
the transactions to avoid overruns.
Overruns come from two sources:</p>
<ol class="loweralpha simple">
<li><p>EFIs logged on behalf of space that is no longer occupied</p></li>
<li><p>Log items for buffer invalidations</p></li>
</ol>
<p>This is also a window in which a crash during the reaping process can leak
blocks.
As stated earlier, online repair functions use very large transactions to
minimize the chances of this occurring.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-prep-for-bulk-loading">preparation for bulk loading btrees</a>
series.</p>
<section id="case-study-reaping-after-a-regular-btree-repair">
<h4><a class="toc-backref" href="#id74" role="doc-backlink"><span class="section-number">4.5.7.1. </span>Case Study: Reaping After a Regular Btree Repair</a><a class="headerlink" href="#case-study-reaping-after-a-regular-btree-repair" title="Link to this heading">¶</a></h4>
<p>Old reference count and inode btrees are the easiest to reap because they have
rmap records with special owner codes: <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_REFC</span></code> for the refcount
btree, and <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_INOBT</span></code> for the inode and free inode btrees.
Creating a list of extents to reap the old btree blocks is quite simple,
conceptually:</p>
<ol class="arabic simple">
<li><p>Lock the relevant AGI/AGF header buffers to prevent allocation and frees.</p></li>
<li><p>For each reverse mapping record with an rmap owner corresponding to the
metadata structure being rebuilt, set the corresponding range in a bitmap.</p></li>
<li><p>Walk the current data structures that have the same rmap owner.
For each block visited, clear that range in the above bitmap.</p></li>
<li><p>Each set bit in the bitmap represents a block that could be a block from the
old data structures and hence is a candidate for reaping.
In other words, <code class="docutils literal notranslate"><span class="pre">(rmap_records_owned_by</span> <span class="pre">&amp;</span> <span class="pre">~blocks_reachable_by_walk)</span></code>
are the blocks that might be freeable.</p></li>
</ol>
<p>If it is possible to maintain the AGF lock throughout the repair (which is the
common case), then step 2 can be performed at the same time as the reverse
mapping record walk that creates the records for the new btree.</p>
</section>
<section id="case-study-rebuilding-the-free-space-indices">
<h4><a class="toc-backref" href="#id75" role="doc-backlink"><span class="section-number">4.5.7.2. </span>Case Study: Rebuilding the Free Space Indices</a><a class="headerlink" href="#case-study-rebuilding-the-free-space-indices" title="Link to this heading">¶</a></h4>
<p>The high level process to rebuild the free space indices is:</p>
<ol class="arabic simple">
<li><p>Walk the reverse mapping records to generate <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_alloc_rec_incore</span></code>
records from the gaps in the reverse mapping btree.</p></li>
<li><p>Append the records to an xfarray.</p></li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload_compute_geometry</span></code> function to compute the number
of blocks needed for each new tree.</p></li>
<li><p>Allocate the number of blocks computed in the previous step from the free
space information collected.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">xfs_btree_bload</span></code> to write the xfarray records to btree blocks and
generate the internal node blocks for the free space by length index.
Call it again for the free space by block number index.</p></li>
<li><p>Commit the locations of the new btree root blocks to the AGF.</p></li>
<li><p>Reap the old btree blocks by looking for space that is not recorded by the
reverse mapping btree, the new free space btrees, or the AGFL.</p></li>
</ol>
<p>Repairing the free space btrees has three key complications over a regular
btree repair:</p>
<p>First, free space is not explicitly tracked in the reverse mapping records.
Hence, the new free space records must be inferred from gaps in the physical
space component of the keyspace of the reverse mapping btree.</p>
<p>Second, free space repairs cannot use the common btree reservation code because
new blocks are reserved out of the free space btrees.
This is impossible when repairing the free space btrees themselves.
However, repair holds the AGF buffer lock for the duration of the free space
index reconstruction, so it can use the collected free space information to
supply the blocks for the new free space btrees.
It is not necessary to back each reserved extent with an EFI because the new
free space btrees are constructed in what the ondisk filesystem thinks is
unowned space.
However, if reserving blocks for the new btrees from the collected free space
information changes the number of free space records, repair must re-estimate
the new free space btree geometry with the new record count until the
reservation is sufficient.
As part of committing the new btrees, repair must ensure that reverse mappings
are created for the reserved blocks and that unused reserved blocks are
inserted into the free space btrees.
Deferrred rmap and freeing operations are used to ensure that this transition
is atomic, similar to the other btree repair functions.</p>
<p>Third, finding the blocks to reap after the repair is not overly
straightforward.
Blocks for the free space btrees and the reverse mapping btrees are supplied by
the AGFL.
Blocks put onto the AGFL have reverse mapping records with the owner
<code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_AG</span></code>.
This ownership is retained when blocks move from the AGFL into the free space
btrees or the reverse mapping btrees.
When repair walks reverse mapping records to synthesize free space records, it
creates a bitmap (<code class="docutils literal notranslate"><span class="pre">ag_owner_bitmap</span></code>) of all the space claimed by
<code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_AG</span></code> records.
The repair context maintains a second bitmap corresponding to the rmap btree
blocks and the AGFL blocks (<code class="docutils literal notranslate"><span class="pre">rmap_agfl_bitmap</span></code>).
When the walk is complete, the bitmap disunion operation <code class="docutils literal notranslate"><span class="pre">(ag_owner_bitmap</span> <span class="pre">&amp;</span>
<span class="pre">~rmap_agfl_bitmap)</span></code> computes the extents that are used by the old free space
btrees.
These blocks can then be reaped using the methods outlined above.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-ag-btrees">AG btree repair</a>
series.</p>
</section>
<section id="case-study-reaping-after-repairing-reverse-mapping-btrees">
<span id="rmap-reap"></span><h4><a class="toc-backref" href="#id76" role="doc-backlink"><span class="section-number">4.5.7.3. </span>Case Study: Reaping After Repairing Reverse Mapping Btrees</a><a class="headerlink" href="#case-study-reaping-after-repairing-reverse-mapping-btrees" title="Link to this heading">¶</a></h4>
<p>Old reverse mapping btrees are less difficult to reap after a repair.
As mentioned in the previous section, blocks on the AGFL, the two free space
btree blocks, and the reverse mapping btree blocks all have reverse mapping
records with <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_AG</span></code> as the owner.
The full process of gathering reverse mapping records and building a new btree
are described in the case study of
<a class="reference internal" href="#rmap-repair"><span class="std std-ref">live rebuilds of rmap data</span></a>, but a crucial point from that
discussion is that the new rmap btree will not contain any records for the old
rmap btree, nor will the old btree blocks be tracked in the free space btrees.
The list of candidate reaping blocks is computed by setting the bits
corresponding to the gaps in the new rmap btree records, and then clearing the
bits corresponding to extents in the free space btrees and the current AGFL
blocks.
The result <code class="docutils literal notranslate"><span class="pre">(new_rmapbt_gaps</span> <span class="pre">&amp;</span> <span class="pre">~(agfl</span> <span class="pre">|</span> <span class="pre">bnobt_records))</span></code> are reaped using the
methods outlined above.</p>
<p>The rest of the process of rebuildng the reverse mapping btree is discussed
in a separate <a class="reference internal" href="#rmap-repair"><span class="std std-ref">case study</span></a>.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-ag-btrees">AG btree repair</a>
series.</p>
</section>
<section id="case-study-rebuilding-the-agfl">
<h4><a class="toc-backref" href="#id77" role="doc-backlink"><span class="section-number">4.5.7.4. </span>Case Study: Rebuilding the AGFL</a><a class="headerlink" href="#case-study-rebuilding-the-agfl" title="Link to this heading">¶</a></h4>
<p>The allocation group free block list (AGFL) is repaired as follows:</p>
<ol class="arabic simple">
<li><p>Create a bitmap for all the space that the reverse mapping data claims is
owned by <code class="docutils literal notranslate"><span class="pre">XFS_RMAP_OWN_AG</span></code>.</p></li>
<li><p>Subtract the space used by the two free space btrees and the rmap btree.</p></li>
<li><p>Subtract any space that the reverse mapping data claims is owned by any
other owner, to avoid re-adding crosslinked blocks to the AGFL.</p></li>
<li><p>Once the AGFL is full, reap any blocks leftover.</p></li>
<li><p>The next operation to fix the freelist will right-size the list.</p></li>
</ol>
<p>See <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/xfs/scrub/agheader_repair.c">fs/xfs/scrub/agheader_repair.c</a> for more details.</p>
</section>
</section>
<section id="inode-record-repairs">
<h3><a class="toc-backref" href="#id78" role="doc-backlink"><span class="section-number">4.5.8. </span>Inode Record Repairs</a><a class="headerlink" href="#inode-record-repairs" title="Link to this heading">¶</a></h3>
<p>Inode records must be handled carefully, because they have both ondisk records
(“dinodes”) and an in-memory (“cached”) representation.
There is a very high potential for cache coherency issues if online fsck is not
careful to access the ondisk metadata <em>only</em> when the ondisk metadata is so
badly damaged that the filesystem cannot load the in-memory representation.
When online fsck wants to open a damaged file for scrubbing, it must use
specialized resource acquisition functions that return either the in-memory
representation <em>or</em> a lock on whichever object is necessary to prevent any
update to the ondisk location.</p>
<p>The only repairs that should be made to the ondisk inode buffers are whatever
is necessary to get the in-core structure loaded.
This means fixing whatever is caught by the inode cluster buffer and inode fork
verifiers, and retrying the <code class="docutils literal notranslate"><span class="pre">iget</span></code> operation.
If the second <code class="docutils literal notranslate"><span class="pre">iget</span></code> fails, the repair has failed.</p>
<p>Once the in-memory representation is loaded, repair can lock the inode and can
subject it to comprehensive checks, repairs, and optimizations.
Most inode attributes are easy to check and constrain, or are user-controlled
arbitrary bit patterns; these are both easy to fix.
Dealing with the data and attr fork extent counts and the file block counts is
more complicated, because computing the correct value requires traversing the
forks, or if that fails, leaving the fields invalid and waiting for the fork
fsck functions to run.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-inodes">inode</a>
repair series.</p>
</section>
<section id="quota-record-repairs">
<h3><a class="toc-backref" href="#id79" role="doc-backlink"><span class="section-number">4.5.9. </span>Quota Record Repairs</a><a class="headerlink" href="#quota-record-repairs" title="Link to this heading">¶</a></h3>
<p>Similar to inodes, quota records (“dquots”) also have both ondisk records and
an in-memory representation, and hence are subject to the same cache coherency
issues.
Somewhat confusingly, both are known as dquots in the XFS codebase.</p>
<p>The only repairs that should be made to the ondisk quota record buffers are
whatever is necessary to get the in-core structure loaded.
Once the in-memory representation is loaded, the only attributes needing
checking are obviously bad limits and timer values.</p>
<p>Quota usage counters are checked, repaired, and discussed separately in the
section about <a class="reference internal" href="#quotacheck"><span class="std std-ref">live quotacheck</span></a>.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-quota">quota</a>
repair series.</p>
</section>
<section id="freezing-to-fix-summary-counters">
<span id="fscounters"></span><h3><a class="toc-backref" href="#id80" role="doc-backlink"><span class="section-number">4.5.10. </span>Freezing to Fix Summary Counters</a><a class="headerlink" href="#freezing-to-fix-summary-counters" title="Link to this heading">¶</a></h3>
<p>Filesystem summary counters track availability of filesystem resources such
as free blocks, free inodes, and allocated inodes.
This information could be compiled by walking the free space and inode indexes,
but this is a slow process, so XFS maintains a copy in the ondisk superblock
that should reflect the ondisk metadata, at least when the filesystem has been
unmounted cleanly.
For performance reasons, XFS also maintains incore copies of those counters,
which are key to enabling resource reservations for active transactions.
Writer threads reserve the worst-case quantities of resources from the
incore counter and give back whatever they don’t use at commit time.
It is therefore only necessary to serialize on the superblock when the
superblock is being committed to disk.</p>
<p>The lazy superblock counter feature introduced in XFS v5 took this even further
by training log recovery to recompute the summary counters from the AG headers,
which eliminated the need for most transactions even to touch the superblock.
The only time XFS commits the summary counters is at filesystem unmount.
To reduce contention even further, the incore counter is implemented as a
percpu counter, which means that each CPU is allocated a batch of blocks from a
global incore counter and can satisfy small allocations from the local batch.</p>
<p>The high-performance nature of the summary counters makes it difficult for
online fsck to check them, since there is no way to quiesce a percpu counter
while the system is running.
Although online fsck can read the filesystem metadata to compute the correct
values of the summary counters, there’s no way to hold the value of a percpu
counter stable, so it’s quite possible that the counter will be out of date by
the time the walk is complete.
Earlier versions of online scrub would return to userspace with an incomplete
scan flag, but this is not a satisfying outcome for a system administrator.
For repairs, the in-memory counters must be stabilized while walking the
filesystem metadata to get an accurate reading and install it in the percpu
counter.</p>
<p>To satisfy this requirement, online fsck must prevent other programs in the
system from initiating new writes to the filesystem, it must disable background
garbage collection threads, and it must wait for existing writer programs to
exit the kernel.
Once that has been established, scrub can walk the AG free space indexes, the
inode btrees, and the realtime bitmap to compute the correct value of all
four summary counters.
This is very similar to a filesystem freeze, though not all of the pieces are
necessary:</p>
<ul class="simple">
<li><p>The final freeze state is set one higher than <code class="docutils literal notranslate"><span class="pre">SB_FREEZE_COMPLETE</span></code> to
prevent other threads from thawing the filesystem, or other scrub threads
from initiating another fscounters freeze.</p></li>
<li><p>It does not quiesce the log.</p></li>
</ul>
<p>With this code in place, it is now possible to pause the filesystem for just
long enough to check and correct the summary counters.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Historical Sidebar</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>The initial implementation used the actual VFS filesystem freeze
mechanism to quiesce filesystem activity.
With the filesystem frozen, it is possible to resolve the counter values
with exact precision, but there are many problems with calling the VFS
methods directly:</p>
<ul class="simple">
<li><p>Other programs can unfreeze the filesystem without our knowledge.
This leads to incorrect scan results and incorrect repairs.</p></li>
<li><p>Adding an extra lock to prevent others from thawing the filesystem
required the addition of a <code class="docutils literal notranslate"><span class="pre">-&gt;freeze_super</span></code> function to wrap
<code class="docutils literal notranslate"><span class="pre">freeze_fs()</span></code>.
This in turn caused other subtle problems because it turns out that
the VFS <code class="docutils literal notranslate"><span class="pre">freeze_super</span></code> and <code class="docutils literal notranslate"><span class="pre">thaw_super</span></code> functions can drop the
last reference to the VFS superblock, and any subsequent access
becomes a UAF bug!
This can happen if the filesystem is unmounted while the underlying
block device has frozen the filesystem.
This problem could be solved by grabbing extra references to the
superblock, but it felt suboptimal given the other inadequacies of
this approach.</p></li>
<li><p>The log need not be quiesced to check the summary counters, but a VFS
freeze initiates one anyway.
This adds unnecessary runtime to live fscounter fsck operations.</p></li>
<li><p>Quiescing the log means that XFS flushes the (possibly incorrect)
counters to disk as part of cleaning the log.</p></li>
<li><p>A bug in the VFS meant that freeze could complete even when
sync_filesystem fails to flush the filesystem and returns an error.
This bug was fixed in Linux 5.17.</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-fscounters">summary counter cleanup</a>
series.</p>
</section>
<section id="full-filesystem-scans">
<h3><a class="toc-backref" href="#id81" role="doc-backlink"><span class="section-number">4.5.11. </span>Full Filesystem Scans</a><a class="headerlink" href="#full-filesystem-scans" title="Link to this heading">¶</a></h3>
<p>Certain types of metadata can only be checked by walking every file in the
entire filesystem to record observations and comparing the observations against
what’s recorded on disk.
Like every other type of online repair, repairs are made by writing those
observations to disk in a replacement structure and committing it atomically.
However, it is not practical to shut down the entire filesystem to examine
hundreds of billions of files because the downtime would be excessive.
Therefore, online fsck must build the infrastructure to manage a live scan of
all the files in the filesystem.
There are two questions that need to be solved to perform a live walk:</p>
<ul class="simple">
<li><p>How does scrub manage the scan while it is collecting data?</p></li>
<li><p>How does the scan keep abreast of changes being made to the system by other
threads?</p></li>
</ul>
<section id="coordinated-inode-scans">
<span id="iscan"></span><h4><a class="toc-backref" href="#id82" role="doc-backlink"><span class="section-number">4.5.11.1. </span>Coordinated Inode Scans</a><a class="headerlink" href="#coordinated-inode-scans" title="Link to this heading">¶</a></h4>
<p>In the original Unix filesystems of the 1970s, each directory entry contained
an index number (<em>inumber</em>) which was used as an index into on ondisk array
(<em>itable</em>) of fixed-size records (<em>inodes</em>) describing a file’s attributes and
its data block mapping.
This system is described by J. Lions, <a class="reference external" href="http://www.lemis.com/grog/Documentation/Lions/">“inode (5659)”</a> in <em>Lions’ Commentary on
UNIX, 6th Edition</em>, (Dept. of Computer Science, the University of New South
Wales, November 1977), pp. 18-2; and later by D. Ritchie and K. Thompson,
<a class="reference external" href="https://archive.org/details/bstj57-6-1905/page/n8/mode/1up">“Implementation of the File System”</a>, from <em>The UNIX
Time-Sharing System</em>, (The Bell System Technical Journal, July 1978), pp.
1913-4.</p>
<p>XFS retains most of this design, except now inumbers are search keys over all
the space in the data section filesystem.
They form a continuous keyspace that can be expressed as a 64-bit integer,
though the inodes themselves are sparsely distributed within the keyspace.
Scans proceed in a linear fashion across the inumber keyspace, starting from
<code class="docutils literal notranslate"><span class="pre">0x0</span></code> and ending at <code class="docutils literal notranslate"><span class="pre">0xFFFFFFFFFFFFFFFF</span></code>.
Naturally, a scan through a keyspace requires a scan cursor object to track the
scan progress.
Because this keyspace is sparse, this cursor contains two parts.
The first part of this scan cursor object tracks the inode that will be
examined next; call this the examination cursor.
Somewhat less obviously, the scan cursor object must also track which parts of
the keyspace have already been visited, which is critical for deciding if a
concurrent filesystem update needs to be incorporated into the scan data.
Call this the visited inode cursor.</p>
<p>Advancing the scan cursor is a multi-step process encapsulated in
<code class="docutils literal notranslate"><span class="pre">xchk_iscan_iter</span></code>:</p>
<ol class="arabic simple">
<li><p>Lock the AGI buffer of the AG containing the inode pointed to by the visited
inode cursor.
This guarantee that inodes in this AG cannot be allocated or freed while
advancing the cursor.</p></li>
<li><p>Use the per-AG inode btree to look up the next inumber after the one that
was just visited, since it may not be keyspace adjacent.</p></li>
<li><p>If there are no more inodes left in this AG:</p>
<ol class="loweralpha simple">
<li><p>Move the examination cursor to the point of the inumber keyspace that
corresponds to the start of the next AG.</p></li>
<li><p>Adjust the visited inode cursor to indicate that it has “visited” the
last possible inode in the current AG’s inode keyspace.
XFS inumbers are segmented, so the cursor needs to be marked as having
visited the entire keyspace up to just before the start of the next AG’s
inode keyspace.</p></li>
<li><p>Unlock the AGI and return to step 1 if there are unexamined AGs in the
filesystem.</p></li>
<li><p>If there are no more AGs to examine, set both cursors to the end of the
inumber keyspace.
The scan is now complete.</p></li>
</ol>
</li>
<li><p>Otherwise, there is at least one more inode to scan in this AG:</p>
<ol class="loweralpha simple">
<li><p>Move the examination cursor ahead to the next inode marked as allocated
by the inode btree.</p></li>
<li><p>Adjust the visited inode cursor to point to the inode just prior to where
the examination cursor is now.
Because the scanner holds the AGI buffer lock, no inodes could have been
created in the part of the inode keyspace that the visited inode cursor
just advanced.</p></li>
</ol>
</li>
<li><p>Get the incore inode for the inumber of the examination cursor.
By maintaining the AGI buffer lock until this point, the scanner knows that
it was safe to advance the examination cursor across the entire keyspace,
and that it has stabilized this next inode so that it cannot disappear from
the filesystem until the scan releases the incore inode.</p></li>
<li><p>Drop the AGI lock and return the incore inode to the caller.</p></li>
</ol>
<p>Online fsck functions scan all files in the filesystem as follows:</p>
<ol class="arabic simple">
<li><p>Start a scan by calling <code class="docutils literal notranslate"><span class="pre">xchk_iscan_start</span></code>.</p></li>
<li><p>Advance the scan cursor (<code class="docutils literal notranslate"><span class="pre">xchk_iscan_iter</span></code>) to get the next inode.
If one is provided:</p>
<ol class="loweralpha simple">
<li><p>Lock the inode to prevent updates during the scan.</p></li>
<li><p>Scan the inode.</p></li>
<li><p>While still holding the inode lock, adjust the visited inode cursor
(<code class="docutils literal notranslate"><span class="pre">xchk_iscan_mark_visited</span></code>) to point to this inode.</p></li>
<li><p>Unlock and release the inode.</p></li>
</ol>
</li>
</ol>
<ol class="arabic simple" start="8">
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xchk_iscan_teardown</span></code> to complete the scan.</p></li>
</ol>
<p>There are subtleties with the inode cache that complicate grabbing the incore
inode for the caller.
Obviously, it is an absolute requirement that the inode metadata be consistent
enough to load it into the inode cache.
Second, if the incore inode is stuck in some intermediate state, the scan
coordinator must release the AGI and push the main filesystem to get the inode
back into a loadable state.</p>
<p>The proposed patches are the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-iscan">inode scanner</a>
series.
The first user of the new functionality is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-quotacheck">online quotacheck</a>
series.</p>
</section>
<section id="inode-management">
<h4><a class="toc-backref" href="#id83" role="doc-backlink"><span class="section-number">4.5.11.2. </span>Inode Management</a><a class="headerlink" href="#inode-management" title="Link to this heading">¶</a></h4>
<p>In regular filesystem code, references to allocated XFS incore inodes are
always obtained (<code class="docutils literal notranslate"><span class="pre">xfs_iget</span></code>) outside of transaction context because the
creation of the incore context for an existing file does not require metadata
updates.
However, it is important to note that references to incore inodes obtained as
part of file creation must be performed in transaction context because the
filesystem must ensure the atomicity of the ondisk inode btree index updates
and the initialization of the actual ondisk inode.</p>
<p>References to incore inodes are always released (<code class="docutils literal notranslate"><span class="pre">xfs_irele</span></code>) outside of
transaction context because there are a handful of activities that might
require ondisk updates:</p>
<ul class="simple">
<li><p>The VFS may decide to kick off writeback as part of a <code class="docutils literal notranslate"><span class="pre">DONTCACHE</span></code> inode
release.</p></li>
<li><p>Speculative preallocations need to be unreserved.</p></li>
<li><p>An unlinked file may have lost its last reference, in which case the entire
file must be inactivated, which involves releasing all of its resources in
the ondisk metadata and freeing the inode.</p></li>
</ul>
<p>These activities are collectively called inode inactivation.
Inactivation has two parts -- the VFS part, which initiates writeback on all
dirty file pages, and the XFS part, which cleans up XFS-specific information
and frees the inode if it was unlinked.
If the inode is unlinked (or unconnected after a file handle operation), the
kernel drops the inode into the inactivation machinery immediately.</p>
<p>During normal operation, resource acquisition for an update follows this order
to avoid deadlocks:</p>
<ol class="arabic simple">
<li><p>Inode reference (<code class="docutils literal notranslate"><span class="pre">iget</span></code>).</p></li>
<li><p>Filesystem freeze protection, if repairing (<code class="docutils literal notranslate"><span class="pre">mnt_want_write_file</span></code>).</p></li>
<li><p>Inode <code class="docutils literal notranslate"><span class="pre">IOLOCK</span></code> (VFS <code class="docutils literal notranslate"><span class="pre">i_rwsem</span></code>) lock to control file IO.</p></li>
<li><p>Inode <code class="docutils literal notranslate"><span class="pre">MMAPLOCK</span></code> (page cache <code class="docutils literal notranslate"><span class="pre">invalidate_lock</span></code>) lock for operations that
can update page cache mappings.</p></li>
<li><p>Log feature enablement.</p></li>
<li><p>Transaction log space grant.</p></li>
<li><p>Space on the data and realtime devices for the transaction.</p></li>
<li><p>Incore dquot references, if a file is being repaired.
Note that they are not locked, merely acquired.</p></li>
<li><p>Inode <code class="docutils literal notranslate"><span class="pre">ILOCK</span></code> for file metadata updates.</p></li>
<li><p>AG header buffer locks / Realtime metadata inode ILOCK.</p></li>
<li><p>Realtime metadata buffer locks, if applicable.</p></li>
<li><p>Extent mapping btree blocks, if applicable.</p></li>
</ol>
<p>Resources are often released in the reverse order, though this is not required.
However, online fsck differs from regular XFS operations because it may examine
an object that normally is acquired in a later stage of the locking order, and
then decide to cross-reference the object with an object that is acquired
earlier in the order.
The next few sections detail the specific ways in which online fsck takes care
to avoid deadlocks.</p>
<section id="iget-and-irele-during-a-scrub">
<h5><a class="toc-backref" href="#id84" role="doc-backlink"><span class="section-number">4.5.11.2.1. </span>iget and irele During a Scrub</a><a class="headerlink" href="#iget-and-irele-during-a-scrub" title="Link to this heading">¶</a></h5>
<p>An inode scan performed on behalf of a scrub operation runs in transaction
context, and possibly with resources already locked and bound to it.
This isn’t much of a problem for <code class="docutils literal notranslate"><span class="pre">iget</span></code> since it can operate in the context
of an existing transaction, as long as all of the bound resources are acquired
before the inode reference in the regular filesystem.</p>
<p>When the VFS <code class="docutils literal notranslate"><span class="pre">iput</span></code> function is given a linked inode with no other
references, it normally puts the inode on an LRU list in the hope that it can
save time if another process re-opens the file before the system runs out
of memory and frees it.
Filesystem callers can short-circuit the LRU process by setting a <code class="docutils literal notranslate"><span class="pre">DONTCACHE</span></code>
flag on the inode to cause the kernel to try to drop the inode into the
inactivation machinery immediately.</p>
<p>In the past, inactivation was always done from the process that dropped the
inode, which was a problem for scrub because scrub may already hold a
transaction, and XFS does not support nesting transactions.
On the other hand, if there is no scrub transaction, it is desirable to drop
otherwise unused inodes immediately to avoid polluting caches.
To capture these nuances, the online fsck code has a separate <code class="docutils literal notranslate"><span class="pre">xchk_irele</span></code>
function to set or clear the <code class="docutils literal notranslate"><span class="pre">DONTCACHE</span></code> flag to get the required release
behavior.</p>
<p>Proposed patchsets include fixing
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-iget-fixes">scrub iget usage</a> and
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-dir-iget-fixes">dir iget usage</a>.</p>
</section>
<section id="locking-inodes">
<span id="ilocking"></span><h5><a class="toc-backref" href="#id85" role="doc-backlink"><span class="section-number">4.5.11.2.2. </span>Locking Inodes</a><a class="headerlink" href="#locking-inodes" title="Link to this heading">¶</a></h5>
<p>In regular filesystem code, the VFS and XFS will acquire multiple IOLOCK locks
in a well-known order: parent → child when updating the directory tree, and
in numerical order of the addresses of their <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span></code> object otherwise.
For regular files, the MMAPLOCK can be acquired after the IOLOCK to stop page
faults.
If two MMAPLOCKs must be acquired, they are acquired in numerical order of
the addresses of their <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span></code> objects.
Due to the structure of existing filesystem code, IOLOCKs and MMAPLOCKs must be
acquired before transactions are allocated.
If two ILOCKs must be acquired, they are acquired in inumber order.</p>
<p>Inode lock acquisition must be done carefully during a coordinated inode scan.
Online fsck cannot abide these conventions, because for a directory tree
scanner, the scrub process holds the IOLOCK of the file being scanned and it
needs to take the IOLOCK of the file at the other end of the directory link.
If the directory tree is corrupt because it contains a cycle, <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code>
cannot use the regular inode locking functions and avoid becoming trapped in an
ABBA deadlock.</p>
<p>Solving both of these problems is straightforward -- any time online fsck
needs to take a second lock of the same class, it uses trylock to avoid an ABBA
deadlock.
If the trylock fails, scrub drops all inode locks and use trylock loops to
(re)acquire all necessary resources.
Trylock loops enable scrub to check for pending fatal signals, which is how
scrub avoids deadlocking the filesystem or becoming an unresponsive process.
However, trylock loops means that online fsck must be prepared to measure the
resource being scrubbed before and after the lock cycle to detect changes and
react accordingly.</p>
</section>
<section id="case-study-finding-a-directory-parent">
<span id="dirparent"></span><h5><a class="toc-backref" href="#id86" role="doc-backlink"><span class="section-number">4.5.11.2.3. </span>Case Study: Finding a Directory Parent</a><a class="headerlink" href="#case-study-finding-a-directory-parent" title="Link to this heading">¶</a></h5>
<p>Consider the directory parent pointer repair code as an example.
Online fsck must verify that the dotdot dirent of a directory points up to a
parent directory, and that the parent directory contains exactly one dirent
pointing down to the child directory.
Fully validating this relationship (and repairing it if possible) requires a
walk of every directory on the filesystem while holding the child locked, and
while updates to the directory tree are being made.
The coordinated inode scan provides a way to walk the filesystem without the
possibility of missing an inode.
The child directory is kept locked to prevent updates to the dotdot dirent, but
if the scanner fails to lock a parent, it can drop and relock both the child
and the prospective parent.
If the dotdot entry changes while the directory is unlocked, then a move or
rename operation must have changed the child’s parentage, and the scan can
exit early.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-dirs">directory repair</a>
series.</p>
</section>
</section>
<section id="filesystem-hooks">
<span id="fshooks"></span><h4><a class="toc-backref" href="#id87" role="doc-backlink"><span class="section-number">4.5.11.3. </span>Filesystem Hooks</a><a class="headerlink" href="#filesystem-hooks" title="Link to this heading">¶</a></h4>
<p>The second piece of support that online fsck functions need during a full
filesystem scan is the ability to stay informed about updates being made by
other threads in the filesystem, since comparisons against the past are useless
in a dynamic environment.
Two pieces of Linux kernel infrastructure enable online fsck to monitor regular
filesystem operations: filesystem hooks and <a class="reference internal" href="#jump-labels"><span class="std std-ref">static keys</span></a>.</p>
<p>Filesystem hooks convey information about an ongoing filesystem operation to
a downstream consumer.
In this case, the downstream consumer is always an online fsck function.
Because multiple fsck functions can run in parallel, online fsck uses the Linux
notifier call chain facility to dispatch updates to any number of interested
fsck processes.
Call chains are a dynamic list, which means that they can be configured at
run time.
Because these hooks are private to the XFS module, the information passed along
contains exactly what the checking function needs to update its observations.</p>
<p>The current implementation of XFS hooks uses SRCU notifier chains to reduce the
impact to highly threaded workloads.
Regular blocking notifier chains use a rwsem and seem to have a much lower
overhead for single-threaded applications.
However, it may turn out that the combination of blocking chains and static
keys are a more performant combination; more study is needed here.</p>
<p>The following pieces are necessary to hook a certain point in the filesystem:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_hooks</span></code> object must be embedded in a convenient place such as
a well-known incore filesystem object.</p></li>
<li><p>Each hook must define an action code and a structure containing more context
about the action.</p></li>
<li><p>Hook providers should provide appropriate wrapper functions and structs
around the <code class="docutils literal notranslate"><span class="pre">xfs_hooks</span></code> and <code class="docutils literal notranslate"><span class="pre">xfs_hook</span></code> objects to take advantage of type
checking to ensure correct usage.</p></li>
<li><p>A callsite in the regular filesystem code must be chosen to call
<code class="docutils literal notranslate"><span class="pre">xfs_hooks_call</span></code> with the action code and data structure.
This place should be adjacent to (and not earlier than) the place where
the filesystem update is committed to the transaction.
In general, when the filesystem calls a hook chain, it should be able to
handle sleeping and should not be vulnerable to memory reclaim or locking
recursion.
However, the exact requirements are very dependent on the context of the hook
caller and the callee.</p></li>
<li><p>The online fsck function should define a structure to hold scan data, a lock
to coordinate access to the scan data, and a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_hook</span></code> object.
The scanner function and the regular filesystem code must acquire resources
in the same order; see the next section for details.</p></li>
<li><p>The online fsck code must contain a C function to catch the hook action code
and data structure.
If the object being updated has already been visited by the scan, then the
hook information must be applied to the scan data.</p></li>
<li><p>Prior to unlocking inodes to start the scan, online fsck must call
<code class="docutils literal notranslate"><span class="pre">xfs_hooks_setup</span></code> to initialize the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_hook</span></code>, and
<code class="docutils literal notranslate"><span class="pre">xfs_hooks_add</span></code> to enable the hook.</p></li>
<li><p>Online fsck must call <code class="docutils literal notranslate"><span class="pre">xfs_hooks_del</span></code> to disable the hook once the scan is
complete.</p></li>
</ul>
<p>The number of hooks should be kept to a minimum to reduce complexity.
Static keys are used to reduce the overhead of filesystem hooks to nearly
zero when online fsck is not running.</p>
</section>
<section id="live-updates-during-a-scan">
<span id="liveupdate"></span><h4><a class="toc-backref" href="#id88" role="doc-backlink"><span class="section-number">4.5.11.4. </span>Live Updates During a Scan</a><a class="headerlink" href="#live-updates-during-a-scan" title="Link to this heading">¶</a></h4>
<p>The code paths of the online fsck scanning code and the <a class="reference internal" href="#fshooks"><span class="std std-ref">hooked</span></a>
filesystem code look like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>other program
      ↓
inode lock ←────────────────────┐
      ↓                         │
AG header lock                  │
      ↓                         │
filesystem function             │
      ↓                         │
notifier call chain             │    same
      ↓                         ├─── inode
scrub hook function             │    lock
      ↓                         │
scan data mutex ←──┐    same    │
      ↓            ├─── scan    │
update scan data   │    lock    │
      ↑            │            │
scan data mutex ←──┘            │
      ↑                         │
inode lock ←────────────────────┘
      ↑
scrub function
      ↑
inode scanner
      ↑
xfs_scrub
</pre></div>
</div>
<p>These rules must be followed to ensure correct interactions between the
checking code and the code making an update to the filesystem:</p>
<ul class="simple">
<li><p>Prior to invoking the notifier call chain, the filesystem function being
hooked must acquire the same lock that the scrub scanning function acquires
to scan the inode.</p></li>
<li><p>The scanning function and the scrub hook function must coordinate access to
the scan data by acquiring a lock on the scan data.</p></li>
<li><p>Scrub hook function must not add the live update information to the scan
observations unless the inode being updated has already been scanned.
The scan coordinator has a helper predicate (<code class="docutils literal notranslate"><span class="pre">xchk_iscan_want_live_update</span></code>)
for this.</p></li>
<li><p>Scrub hook functions must not change the caller’s state, including the
transaction that it is running.
They must not acquire any resources that might conflict with the filesystem
function being hooked.</p></li>
<li><p>The hook function can abort the inode scan to avoid breaking the other rules.</p></li>
</ul>
<p>The inode scan APIs are pretty simple:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xchk_iscan_start</span></code> starts a scan</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xchk_iscan_iter</span></code> grabs a reference to the next inode in the scan or
returns zero if there is nothing left to scan</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xchk_iscan_want_live_update</span></code> to decide if an inode has already been
visited in the scan.
This is critical for hook functions to decide if they need to update the
in-memory scan information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xchk_iscan_mark_visited</span></code> to mark an inode as having been visited in the
scan</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xchk_iscan_teardown</span></code> to finish the scan</p></li>
</ul>
<p>This functionality is also a part of the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-iscan">inode scanner</a>
series.</p>
<section id="case-study-quota-counter-checking">
<span id="quotacheck"></span><h5><a class="toc-backref" href="#id89" role="doc-backlink"><span class="section-number">4.5.11.4.1. </span>Case Study: Quota Counter Checking</a><a class="headerlink" href="#case-study-quota-counter-checking" title="Link to this heading">¶</a></h5>
<p>It is useful to compare the mount time quotacheck code to the online repair
quotacheck code.
Mount time quotacheck does not have to contend with concurrent operations, so
it does the following:</p>
<ol class="arabic simple">
<li><p>Make sure the ondisk dquots are in good enough shape that all the incore
dquots will actually load, and zero the resource usage counters in the
ondisk buffer.</p></li>
<li><p>Walk every inode in the filesystem.
Add each file’s resource usage to the incore dquot.</p></li>
<li><p>Walk each incore dquot.
If the incore dquot is not being flushed, add the ondisk buffer backing the
incore dquot to a delayed write (delwri) list.</p></li>
<li><p>Write the buffer list to disk.</p></li>
</ol>
<p>Like most online fsck functions, online quotacheck can’t write to regular
filesystem objects until the newly collected metadata reflect all filesystem
state.
Therefore, online quotacheck records file resource usage to a shadow dquot
index implemented with a sparse <code class="docutils literal notranslate"><span class="pre">xfarray</span></code>, and only writes to the real dquots
once the scan is complete.
Handling transactional updates is tricky because quota resource usage updates
are handled in phases to minimize contention on dquots:</p>
<ol class="arabic simple">
<li><p>The inodes involved are joined and locked to a transaction.</p></li>
<li><p>For each dquot attached to the file:</p>
<ol class="loweralpha simple">
<li><p>The dquot is locked.</p></li>
<li><p>A quota reservation is added to the dquot’s resource usage.
The reservation is recorded in the transaction.</p></li>
<li><p>The dquot is unlocked.</p></li>
</ol>
</li>
<li><p>Changes in actual quota usage are tracked in the transaction.</p></li>
<li><p>At transaction commit time, each dquot is examined again:</p>
<ol class="loweralpha simple">
<li><p>The dquot is locked again.</p></li>
<li><p>Quota usage changes are logged and unused reservation is given back to
the dquot.</p></li>
<li><p>The dquot is unlocked.</p></li>
</ol>
</li>
</ol>
<p>For online quotacheck, hooks are placed in steps 2 and 4.
The step 2 hook creates a shadow version of the transaction dquot context
(<code class="docutils literal notranslate"><span class="pre">dqtrx</span></code>) that operates in a similar manner to the regular code.
The step 4 hook commits the shadow <code class="docutils literal notranslate"><span class="pre">dqtrx</span></code> changes to the shadow dquots.
Notice that both hooks are called with the inode locked, which is how the
live update coordinates with the inode scanner.</p>
<p>The quotacheck scan looks like this:</p>
<ol class="arabic simple">
<li><p>Set up a coordinated inode scan.</p></li>
<li><p>For each inode returned by the inode scan iterator:</p>
<ol class="loweralpha simple">
<li><p>Grab and lock the inode.</p></li>
<li><p>Determine that inode’s resource usage (data blocks, inode counts,
realtime blocks) and add that to the shadow dquots for the user, group,
and project ids associated with the inode.</p></li>
<li><p>Unlock and release the inode.</p></li>
</ol>
</li>
<li><p>For each dquot in the system:</p>
<ol class="loweralpha simple">
<li><p>Grab and lock the dquot.</p></li>
<li><p>Check the dquot against the shadow dquots created by the scan and updated
by the live hooks.</p></li>
</ol>
</li>
</ol>
<p>Live updates are key to being able to walk every quota record without
needing to hold any locks for a long duration.
If repairs are desired, the real and shadow dquots are locked and their
resource counts are set to the values in the shadow dquot.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-quotacheck">online quotacheck</a>
series.</p>
</section>
<section id="case-study-file-link-count-checking">
<span id="nlinks"></span><h5><a class="toc-backref" href="#id90" role="doc-backlink"><span class="section-number">4.5.11.4.2. </span>Case Study: File Link Count Checking</a><a class="headerlink" href="#case-study-file-link-count-checking" title="Link to this heading">¶</a></h5>
<p>File link count checking also uses live update hooks.
The coordinated inode scanner is used to visit all directories on the
filesystem, and per-file link count records are stored in a sparse <code class="docutils literal notranslate"><span class="pre">xfarray</span></code>
indexed by inumber.
During the scanning phase, each entry in a directory generates observation
data as follows:</p>
<ol class="arabic simple">
<li><p>If the entry is a dotdot (<code class="docutils literal notranslate"><span class="pre">'..'</span></code>) entry of the root directory, the
directory’s parent link count is bumped because the root directory’s dotdot
entry is self referential.</p></li>
<li><p>If the entry is a dotdot entry of a subdirectory, the parent’s backref
count is bumped.</p></li>
<li><p>If the entry is neither a dot nor a dotdot entry, the target file’s parent
count is bumped.</p></li>
<li><p>If the target is a subdirectory, the parent’s child link count is bumped.</p></li>
</ol>
<p>A crucial point to understand about how the link count inode scanner interacts
with the live update hooks is that the scan cursor tracks which <em>parent</em>
directories have been scanned.
In other words, the live updates ignore any update about <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">B</span></code> when A has
not been scanned, even if B has been scanned.
Furthermore, a subdirectory A with a dotdot entry pointing back to B is
accounted as a backref counter in the shadow data for A, since child dotdot
entries affect the parent’s link count.
Live update hooks are carefully placed in all parts of the filesystem that
create, change, or remove directory entries, since those operations involve
bumplink and droplink.</p>
<p>For any file, the correct link count is the number of parents plus the number
of child subdirectories.
Non-directories never have children of any kind.
The backref information is used to detect inconsistencies in the number of
links pointing to child subdirectories and the number of dotdot entries
pointing back.</p>
<p>After the scan completes, the link count of each file can be checked by locking
both the inode and the shadow data, and comparing the link counts.
A second coordinated inode scan cursor is used for comparisons.
Live updates are key to being able to walk every inode without needing to hold
any locks between inodes.
If repairs are desired, the inode’s link count is set to the value in the
shadow information.
If no parents are found, the file must be <a class="reference internal" href="#orphanage"><span class="std std-ref">reparented</span></a> to the
orphanage to prevent the file from being lost forever.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-nlinks">file link count repair</a>
series.</p>
</section>
<section id="case-study-rebuilding-reverse-mapping-records">
<span id="rmap-repair"></span><h5><a class="toc-backref" href="#id91" role="doc-backlink"><span class="section-number">4.5.11.4.3. </span>Case Study: Rebuilding Reverse Mapping Records</a><a class="headerlink" href="#case-study-rebuilding-reverse-mapping-records" title="Link to this heading">¶</a></h5>
<p>Most repair functions follow the same pattern: lock filesystem resources,
walk the surviving ondisk metadata looking for replacement metadata records,
and use an <a class="reference internal" href="#xfarray"><span class="std std-ref">in-memory array</span></a> to store the gathered observations.
The primary advantage of this approach is the simplicity and modularity of the
repair code -- code and data are entirely contained within the scrub module,
do not require hooks in the main filesystem, and are usually the most efficient
in memory use.
A secondary advantage of this repair approach is atomicity -- once the kernel
decides a structure is corrupt, no other threads can access the metadata until
the kernel finishes repairing and revalidating the metadata.</p>
<p>For repairs going on within a shard of the filesystem, these advantages
outweigh the delays inherent in locking the shard while repairing parts of the
shard.
Unfortunately, repairs to the reverse mapping btree cannot use the “standard”
btree repair strategy because it must scan every space mapping of every fork of
every file in the filesystem, and the filesystem cannot stop.
Therefore, rmap repair foregoes atomicity between scrub and repair.
It combines a <a class="reference internal" href="#iscan"><span class="std std-ref">coordinated inode scanner</span></a>, <a class="reference internal" href="#liveupdate"><span class="std std-ref">live update hooks</span></a>, and an <a class="reference internal" href="#xfbtree"><span class="std std-ref">in-memory rmap btree</span></a> to complete the
scan for reverse mapping records.</p>
<ol class="arabic simple">
<li><p>Set up an xfbtree to stage rmap records.</p></li>
<li><p>While holding the locks on the AGI and AGF buffers acquired during the
scrub, generate reverse mappings for all AG metadata: inodes, btrees, CoW
staging extents, and the internal log.</p></li>
<li><p>Set up an inode scanner.</p></li>
<li><p>Hook into rmap updates for the AG being repaired so that the live scan data
can receive updates to the rmap btree from the rest of the filesystem during
the file scan.</p></li>
<li><p>For each space mapping found in either fork of each file scanned,
decide if the mapping matches the AG of interest.
If so:</p>
<ol class="loweralpha simple">
<li><p>Create a btree cursor for the in-memory btree.</p></li>
<li><p>Use the rmap code to add the record to the in-memory btree.</p></li>
<li><p>Use the <a class="reference internal" href="#xfbtree-commit"><span class="std std-ref">special commit function</span></a> to write the
xfbtree changes to the xfile.</p></li>
</ol>
</li>
<li><p>For each live update received via the hook, decide if the owner has already
been scanned.
If so, apply the live update into the scan data:</p>
<ol class="loweralpha simple">
<li><p>Create a btree cursor for the in-memory btree.</p></li>
<li><p>Replay the operation into the in-memory btree.</p></li>
<li><p>Use the <a class="reference internal" href="#xfbtree-commit"><span class="std std-ref">special commit function</span></a> to write the
xfbtree changes to the xfile.
This is performed with an empty transaction to avoid changing the
caller’s state.</p></li>
</ol>
</li>
<li><p>When the inode scan finishes, create a new scrub transaction and relock the
two AG headers.</p></li>
<li><p>Compute the new btree geometry using the number of rmap records in the
shadow btree, like all other btree rebuilding functions.</p></li>
<li><p>Allocate the number of blocks computed in the previous step.</p></li>
<li><p>Perform the usual btree bulk loading and commit to install the new rmap
btree.</p></li>
<li><p>Reap the old rmap btree blocks as discussed in the case study about how
to <a class="reference internal" href="#rmap-reap"><span class="std std-ref">reap after rmap btree repair</span></a>.</p></li>
<li><p>Free the xfbtree now that it not needed.</p></li>
</ol>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-rmap-btree">rmap repair</a>
series.</p>
</section>
</section>
</section>
<section id="staging-repairs-with-temporary-files-on-disk">
<h3><a class="toc-backref" href="#id92" role="doc-backlink"><span class="section-number">4.5.12. </span>Staging Repairs with Temporary Files on Disk</a><a class="headerlink" href="#staging-repairs-with-temporary-files-on-disk" title="Link to this heading">¶</a></h3>
<p>XFS stores a substantial amount of metadata in file forks: directories,
extended attributes, symbolic link targets, free space bitmaps and summary
information for the realtime volume, and quota records.
File forks map 64-bit logical file fork space extents to physical storage space
extents, similar to how a memory management unit maps 64-bit virtual addresses
to physical memory addresses.
Therefore, file-based tree structures (such as directories and extended
attributes) use blocks mapped in the file fork offset address space that point
to other blocks mapped within that same address space, and file-based linear
structures (such as bitmaps and quota records) compute array element offsets in
the file fork offset address space.</p>
<p>Because file forks can consume as much space as the entire filesystem, repairs
cannot be staged in memory, even when a paging scheme is available.
Therefore, online repair of file-based metadata createas a temporary file in
the XFS filesystem, writes a new structure at the correct offsets into the
temporary file, and atomically exchanges all file fork mappings (and hence the
fork contents) to commit the repair.
Once the repair is complete, the old fork can be reaped as necessary; if the
system goes down during the reap, the iunlink code will delete the blocks
during log recovery.</p>
<p><strong>Note</strong>: All space usage and inode indices in the filesystem <em>must</em> be
consistent to use a temporary file safely!
This dependency is the reason why online repair can only use pageable kernel
memory to stage ondisk space usage information.</p>
<p>Exchanging metadata file mappings with a temporary file requires the owner
field of the block headers to match the file being repaired and not the
temporary file.
The directory, extended attribute, and symbolic link functions were all
modified to allow callers to specify owner numbers explicitly.</p>
<p>There is a downside to the reaping process -- if the system crashes during the
reap phase and the fork extents are crosslinked, the iunlink processing will
fail because freeing space will find the extra reverse mappings and abort.</p>
<p>Temporary files created for repair are similar to <code class="docutils literal notranslate"><span class="pre">O_TMPFILE</span></code> files created
by userspace.
They are not linked into a directory and the entire file will be reaped when
the last reference to the file is lost.
The key differences are that these files must have no access permission outside
the kernel at all, they must be specially marked to prevent them from being
opened by handle, and they must never be linked into the directory tree.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Historical Sidebar</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>In the initial iteration of file metadata repair, the damaged metadata
blocks would be scanned for salvageable data; the extents in the file
fork would be reaped; and then a new structure would be built in its
place.
This strategy did not survive the introduction of the atomic repair
requirement expressed earlier in this document.</p>
<p>The second iteration explored building a second structure at a high
offset in the fork from the salvage data, reaping the old extents, and
using a <code class="docutils literal notranslate"><span class="pre">COLLAPSE_RANGE</span></code> operation to slide the new extents into
place.</p>
<p>This had many drawbacks:</p>
<ul class="simple">
<li><p>Array structures are linearly addressed, and the regular filesystem
codebase does not have the concept of a linear offset that could be
applied to the record offset computation to build an alternate copy.</p></li>
<li><p>Extended attributes are allowed to use the entire attr fork offset
address space.</p></li>
<li><p>Even if repair could build an alternate copy of a data structure in a
different part of the fork address space, the atomic repair commit
requirement means that online repair would have to be able to perform
a log assisted <code class="docutils literal notranslate"><span class="pre">COLLAPSE_RANGE</span></code> operation to ensure that the old
structure was completely replaced.</p></li>
<li><p>A crash after construction of the secondary tree but before the range
collapse would leave unreachable blocks in the file fork.
This would likely confuse things further.</p></li>
<li><p>Reaping blocks after a repair is not a simple operation, and
initiating a reap operation from a restarted range collapse operation
during log recovery is daunting.</p></li>
<li><p>Directory entry blocks and quota records record the file fork offset
in the header area of each block.
An atomic range collapse operation would have to rewrite this part of
each block header.
Rewriting a single field in block headers is not a huge problem, but
it’s something to be aware of.</p></li>
<li><p>Each block in a directory or extended attributes btree index contains
sibling and child block pointers.
Were the atomic commit to use a range collapse operation, each block
would have to be rewritten very carefully to preserve the graph
structure.
Doing this as part of a range collapse means rewriting a large number
of blocks repeatedly, which is not conducive to quick repairs.</p></li>
</ul>
<p>This lead to the introduction of temporary file staging.</p>
</td>
</tr>
</tbody>
</table>
<section id="using-a-temporary-file">
<h4><a class="toc-backref" href="#id93" role="doc-backlink"><span class="section-number">4.5.12.1. </span>Using a Temporary File</a><a class="headerlink" href="#using-a-temporary-file" title="Link to this heading">¶</a></h4>
<p>Online repair code should use the <code class="docutils literal notranslate"><span class="pre">xrep_tempfile_create</span></code> function to create a
temporary file inside the filesystem.
This allocates an inode, marks the in-core inode private, and attaches it to
the scrub context.
These files are hidden from userspace, may not be added to the directory tree,
and must be kept private.</p>
<p>Temporary files only use two inode locks: the IOLOCK and the ILOCK.
The MMAPLOCK is not needed here, because there must not be page faults from
userspace for data fork blocks.
The usage patterns of these two locks are the same as for any other XFS file --
access to file data are controlled via the IOLOCK, and access to file metadata
are controlled via the ILOCK.
Locking helpers are provided so that the temporary file and its lock state can
be cleaned up by the scrub context.
To comply with the nested locking strategy laid out in the <a class="reference internal" href="#ilocking"><span class="std std-ref">inode
locking</span></a> section, it is recommended that scrub functions use the
xrep_tempfile_ilock*_nowait lock helpers.</p>
<p>Data can be written to a temporary file by two means:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrep_tempfile_copyin</span></code> can be used to set the contents of a regular
temporary file from an xfile.</p></li>
<li><p>The regular directory, symbolic link, and extended attribute functions can
be used to write to the temporary file.</p></li>
</ol>
<p>Once a good copy of a data file has been constructed in a temporary file, it
must be conveyed to the file being repaired, which is the topic of the next
section.</p>
<p>The proposed patches are in the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-tempfiles">repair temporary files</a>
series.</p>
</section>
</section>
<section id="logged-file-content-exchanges">
<h3><a class="toc-backref" href="#id94" role="doc-backlink"><span class="section-number">4.5.13. </span>Logged File Content Exchanges</a><a class="headerlink" href="#logged-file-content-exchanges" title="Link to this heading">¶</a></h3>
<p>Once repair builds a temporary file with a new data structure written into
it, it must commit the new changes into the existing file.
It is not possible to swap the inumbers of two files, so instead the new
metadata must replace the old.
This suggests the need for the ability to swap extents, but the existing extent
swapping code used by the file defragmenting tool <code class="docutils literal notranslate"><span class="pre">xfs_fsr</span></code> is not sufficient
for online repair because:</p>
<ol class="loweralpha simple">
<li><p>When the reverse-mapping btree is enabled, the swap code must keep the
reverse mapping information up to date with every exchange of mappings.
Therefore, it can only exchange one mapping per transaction, and each
transaction is independent.</p></li>
<li><p>Reverse-mapping is critical for the operation of online fsck, so the old
defragmentation code (which swapped entire extent forks in a single
operation) is not useful here.</p></li>
<li><p>Defragmentation is assumed to occur between two files with identical
contents.
For this use case, an incomplete exchange will not result in a user-visible
change in file contents, even if the operation is interrupted.</p></li>
<li><p>Online repair needs to swap the contents of two files that are by definition
<em>not</em> identical.
For directory and xattr repairs, the user-visible contents might be the
same, but the contents of individual blocks may be very different.</p></li>
<li><p>Old blocks in the file may be cross-linked with another structure and must
not reappear if the system goes down mid-repair.</p></li>
</ol>
<p>These problems are overcome by creating a new deferred operation and a new type
of log intent item to track the progress of an operation to exchange two file
ranges.
The new exchange operation type chains together the same transactions used by
the reverse-mapping extent swap code, but records intermedia progress in the
log so that operations can be restarted after a crash.
This new functionality is called the file contents exchange (xfs_exchrange)
code.
The underlying implementation exchanges file fork mappings (xfs_exchmaps).
The new log item records the progress of the exchange to ensure that once an
exchange begins, it will always run to completion, even there are
interruptions.
The new <code class="docutils literal notranslate"><span class="pre">XFS_SB_FEAT_INCOMPAT_EXCHRANGE</span></code> incompatible feature flag
in the superblock protects these new log item records from being replayed on
old kernels.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=atomic-file-updates">file contents exchange</a>
series.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Sidebar: Using Log-Incompatible Feature Flags</strong></p></td>
</tr>
<tr class="row-even"><td><p>Starting with XFS v5, the superblock contains a
<code class="docutils literal notranslate"><span class="pre">sb_features_log_incompat</span></code> field to indicate that the log contains
records that might not readable by all kernels that could mount this
filesystem.
In short, log incompat features protect the log contents against kernels
that will not understand the contents.
Unlike the other superblock feature bits, log incompat bits are
ephemeral because an empty (clean) log does not need protection.
The log cleans itself after its contents have been committed into the
filesystem, either as part of an unmount or because the system is
otherwise idle.
Because upper level code can be working on a transaction at the same
time that the log cleans itself, it is necessary for upper level code to
communicate to the log when it is going to use a log incompatible
feature.</p>
<p>The log coordinates access to incompatible features through the use of
one <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rw_semaphore</span></code> for each feature.
The log cleaning code tries to take this rwsem in exclusive mode to
clear the bit; if the lock attempt fails, the feature bit remains set.
The code supporting a log incompat feature should create wrapper
functions to obtain the log feature and call
<code class="docutils literal notranslate"><span class="pre">xfs_add_incompat_log_feature</span></code> to set the feature bits in the primary
superblock.
The superblock update is performed transactionally, so the wrapper to
obtain log assistance must be called just prior to the creation of the
transaction that uses the functionality.
For a file operation, this step must happen after taking the IOLOCK
and the MMAPLOCK, but before allocating the transaction.
When the transaction is complete, the <code class="docutils literal notranslate"><span class="pre">xlog_drop_incompat_feat</span></code>
function is called to release the feature.
The feature bit will not be cleared from the superblock until the log
becomes clean.</p>
<p>Log-assisted extended attribute updates and file content exchanges bothe
use log incompat features and provide convenience wrappers around the
functionality.</p>
</td>
</tr>
</tbody>
</table>
<section id="mechanics-of-a-logged-file-content-exchange">
<h4><a class="toc-backref" href="#id95" role="doc-backlink"><span class="section-number">4.5.13.1. </span>Mechanics of a Logged File Content Exchange</a><a class="headerlink" href="#mechanics-of-a-logged-file-content-exchange" title="Link to this heading">¶</a></h4>
<p>Exchanging contents between file forks is a complex task.
The goal is to exchange all file fork mappings between two file fork offset
ranges.
There are likely to be many extent mappings in each fork, and the edges of
the mappings aren’t necessarily aligned.
Furthermore, there may be other updates that need to happen after the exchange,
such as exchanging file sizes, inode flags, or conversion of fork data to local
format.
This is roughly the format of the new deferred exchange-mapping work item:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">xfs_exchmaps_intent</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Inodes participating in the operation. */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">xfs_inode</span><span class="w">    </span><span class="o">*</span><span class="n">xmi_ip1</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">xfs_inode</span><span class="w">    </span><span class="o">*</span><span class="n">xmi_ip2</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* File offset range information. */</span>
<span class="w">    </span><span class="n">xfs_fileoff_t</span><span class="w">       </span><span class="n">xmi_startoff1</span><span class="p">;</span>
<span class="w">    </span><span class="n">xfs_fileoff_t</span><span class="w">       </span><span class="n">xmi_startoff2</span><span class="p">;</span>
<span class="w">    </span><span class="n">xfs_filblks_t</span><span class="w">       </span><span class="n">xmi_blockcount</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Set these file sizes after the operation, unless negative. */</span>
<span class="w">    </span><span class="n">xfs_fsize_t</span><span class="w">         </span><span class="n">xmi_isize1</span><span class="p">;</span>
<span class="w">    </span><span class="n">xfs_fsize_t</span><span class="w">         </span><span class="n">xmi_isize2</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* XFS_EXCHMAPS_* log operation flags */</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w">            </span><span class="n">xmi_flags</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The new log intent item contains enough information to track two logical fork
offset ranges: <code class="docutils literal notranslate"><span class="pre">(inode1,</span> <span class="pre">startoff1,</span> <span class="pre">blockcount)</span></code> and <code class="docutils literal notranslate"><span class="pre">(inode2,</span> <span class="pre">startoff2,</span>
<span class="pre">blockcount)</span></code>.
Each step of an exchange operation exchanges the largest file range mapping
possible from one file to the other.
After each step in the exchange operation, the two startoff fields are
incremented and the blockcount field is decremented to reflect the progress
made.
The flags field captures behavioral parameters such as exchanging attr fork
mappings instead of the data fork and other work to be done after the exchange.
The two isize fields are used to exchange the file sizes at the end of the
operation if the file data fork is the target of the operation.</p>
<p>When the exchange is initiated, the sequence of operations is as follows:</p>
<ol class="arabic">
<li><p>Create a deferred work item for the file mapping exchange.
At the start, it should contain the entirety of the file block ranges to be
exchanged.</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xfs_defer_finish</span></code> to process the exchange.
This is encapsulated in <code class="docutils literal notranslate"><span class="pre">xrep_tempexch_contents</span></code> for scrub operations.
This will log an extent swap intent item to the transaction for the deferred
mapping exchange work item.</p></li>
<li><p>Until <code class="docutils literal notranslate"><span class="pre">xmi_blockcount</span></code> of the deferred mapping exchange work item is zero,</p>
<ol class="loweralpha">
<li><p>Read the block maps of both file ranges starting at <code class="docutils literal notranslate"><span class="pre">xmi_startoff1</span></code> and
<code class="docutils literal notranslate"><span class="pre">xmi_startoff2</span></code>, respectively, and compute the longest extent that can
be exchanged in a single step.
This is the minimum of the two <code class="docutils literal notranslate"><span class="pre">br_blockcount</span></code> s in the mappings.
Keep advancing through the file forks until at least one of the mappings
contains written blocks.
Mutual holes, unwritten extents, and extent mappings to the same physical
space are not exchanged.</p>
<p>For the next few steps, this document will refer to the mapping that came
from file 1 as “map1”, and the mapping that came from file 2 as “map2”.</p>
</li>
<li><p>Create a deferred block mapping update to unmap map1 from file 1.</p></li>
<li><p>Create a deferred block mapping update to unmap map2 from file 2.</p></li>
<li><p>Create a deferred block mapping update to map map1 into file 2.</p></li>
<li><p>Create a deferred block mapping update to map map2 into file 1.</p></li>
<li><p>Log the block, quota, and extent count updates for both files.</p></li>
<li><p>Extend the ondisk size of either file if necessary.</p></li>
<li><p>Log a mapping exchange done log item for th mapping exchange intent log
item that was read at the start of step 3.</p></li>
<li><p>Compute the amount of file range that has just been covered.
This quantity is <code class="docutils literal notranslate"><span class="pre">(map1.br_startoff</span> <span class="pre">+</span> <span class="pre">map1.br_blockcount</span> <span class="pre">-</span>
<span class="pre">xmi_startoff1)</span></code>, because step 3a could have skipped holes.</p></li>
<li><p>Increase the starting offsets of <code class="docutils literal notranslate"><span class="pre">xmi_startoff1</span></code> and <code class="docutils literal notranslate"><span class="pre">xmi_startoff2</span></code>
by the number of blocks computed in the previous step, and decrease
<code class="docutils literal notranslate"><span class="pre">xmi_blockcount</span></code> by the same quantity.
This advances the cursor.</p></li>
<li><p>Log a new mapping exchange intent log item reflecting the advanced state
of the work item.</p></li>
<li><p>Return the proper error code (EAGAIN) to the deferred operation manager
to inform it that there is more work to be done.
The operation manager completes the deferred work in steps 3b-3e before
moving back to the start of step 3.</p></li>
</ol>
</li>
<li><p>Perform any post-processing.
This will be discussed in more detail in subsequent sections.</p></li>
</ol>
<p>If the filesystem goes down in the middle of an operation, log recovery will
find the most recent unfinished maping exchange log intent item and restart
from there.
This is how atomic file mapping exchanges guarantees that an outside observer
will either see the old broken structure or the new one, and never a mismash of
both.</p>
</section>
<section id="preparation-for-file-content-exchanges">
<h4><a class="toc-backref" href="#id96" role="doc-backlink"><span class="section-number">4.5.13.2. </span>Preparation for File Content Exchanges</a><a class="headerlink" href="#preparation-for-file-content-exchanges" title="Link to this heading">¶</a></h4>
<p>There are a few things that need to be taken care of before initiating an
atomic file mapping exchange operation.
First, regular files require the page cache to be flushed to disk before the
operation begins, and directio writes to be quiesced.
Like any filesystem operation, file mapping exchanges must determine the
maximum amount of disk space and quota that can be consumed on behalf of both
files in the operation, and reserve that quantity of resources to avoid an
unrecoverable out of space failure once it starts dirtying metadata.
The preparation step scans the ranges of both files to estimate:</p>
<ul class="simple">
<li><p>Data device blocks needed to handle the repeated updates to the fork
mappings.</p></li>
<li><p>Change in data and realtime block counts for both files.</p></li>
<li><p>Increase in quota usage for both files, if the two files do not share the
same set of quota ids.</p></li>
<li><p>The number of extent mappings that will be added to each file.</p></li>
<li><p>Whether or not there are partially written realtime extents.
User programs must never be able to access a realtime file extent that maps
to different extents on the realtime volume, which could happen if the
operation fails to run to completion.</p></li>
</ul>
<p>The need for precise estimation increases the run time of the exchange
operation, but it is very important to maintain correct accounting.
The filesystem must not run completely out of free space, nor can the mapping
exchange ever add more extent mappings to a fork than it can support.
Regular users are required to abide the quota limits, though metadata repairs
may exceed quota to resolve inconsistent metadata elsewhere.</p>
</section>
<section id="special-features-for-exchanging-metadata-file-contents">
<h4><a class="toc-backref" href="#id97" role="doc-backlink"><span class="section-number">4.5.13.3. </span>Special Features for Exchanging Metadata File Contents</a><a class="headerlink" href="#special-features-for-exchanging-metadata-file-contents" title="Link to this heading">¶</a></h4>
<p>Extended attributes, symbolic links, and directories can set the fork format to
“local” and treat the fork as a literal area for data storage.
Metadata repairs must take extra steps to support these cases:</p>
<ul class="simple">
<li><p>If both forks are in local format and the fork areas are large enough, the
exchange is performed by copying the incore fork contents, logging both
forks, and committing.
The atomic file mapping exchange mechanism is not necessary, since this can
be done with a single transaction.</p></li>
<li><p>If both forks map blocks, then the regular atomic file mapping exchange is
used.</p></li>
<li><p>Otherwise, only one fork is in local format.
The contents of the local format fork are converted to a block to perform the
exchange.
The conversion to block format must be done in the same transaction that
logs the initial mapping exchange intent log item.
The regular atomic mapping exchange is used to exchange the metadata file
mappings.
Special flags are set on the exchange operation so that the transaction can
be rolled one more time to convert the second file’s fork back to local
format so that the second file will be ready to go as soon as the ILOCK is
dropped.</p></li>
</ul>
<p>Extended attributes and directories stamp the owning inode into every block,
but the buffer verifiers do not actually check the inode number!
Although there is no verification, it is still important to maintain
referential integrity, so prior to performing the mapping exchange, online
repair builds every block in the new data structure with the owner field of the
file being repaired.</p>
<p>After a successful exchange operation, the repair operation must reap the old
fork blocks by processing each fork mapping through the standard <a class="reference internal" href="#reaping"><span class="std std-ref">file
extent reaping</span></a> mechanism that is done post-repair.
If the filesystem should go down during the reap part of the repair, the
iunlink processing at the end of recovery will free both the temporary file and
whatever blocks were not reaped.
However, this iunlink processing omits the cross-link detection of online
repair, and is not completely foolproof.</p>
</section>
<section id="exchanging-temporary-file-contents">
<h4><a class="toc-backref" href="#id98" role="doc-backlink"><span class="section-number">4.5.13.4. </span>Exchanging Temporary File Contents</a><a class="headerlink" href="#exchanging-temporary-file-contents" title="Link to this heading">¶</a></h4>
<p>To repair a metadata file, online repair proceeds as follows:</p>
<ol class="arabic simple">
<li><p>Create a temporary repair file.</p></li>
<li><p>Use the staging data to write out new contents into the temporary repair
file.
The same fork must be written to as is being repaired.</p></li>
<li><p>Commit the scrub transaction, since the exchange resource estimation step
must be completed before transaction reservations are made.</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xrep_tempexch_trans_alloc</span></code> to allocate a new scrub transaction with
the appropriate resource reservations, locks, and fill out a <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">xfs_exchmaps_req</span></code> with the details of the exchange operation.</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xrep_tempexch_contents</span></code> to exchange the contents.</p></li>
<li><p>Commit the transaction to complete the repair.</p></li>
</ol>
<section id="case-study-repairing-the-realtime-summary-file">
<span id="rtsummary"></span><h5><a class="toc-backref" href="#id99" role="doc-backlink"><span class="section-number">4.5.13.4.1. </span>Case Study: Repairing the Realtime Summary File</a><a class="headerlink" href="#case-study-repairing-the-realtime-summary-file" title="Link to this heading">¶</a></h5>
<p>In the “realtime” section of an XFS filesystem, free space is tracked via a
bitmap, similar to Unix FFS.
Each bit in the bitmap represents one realtime extent, which is a multiple of
the filesystem block size between 4KiB and 1GiB in size.
The realtime summary file indexes the number of free extents of a given size to
the offset of the block within the realtime free space bitmap where those free
extents begin.
In other words, the summary file helps the allocator find free extents by
length, similar to what the free space by count (cntbt) btree does for the data
section.</p>
<p>The summary file itself is a flat file (with no block headers or checksums!)
partitioned into <code class="docutils literal notranslate"><span class="pre">log2(total</span> <span class="pre">rt</span> <span class="pre">extents)</span></code> sections containing enough 32-bit
counters to match the number of blocks in the rt bitmap.
Each counter records the number of free extents that start in that bitmap block
and can satisfy a power-of-two allocation request.</p>
<p>To check the summary file against the bitmap:</p>
<ol class="arabic simple">
<li><p>Take the ILOCK of both the realtime bitmap and summary files.</p></li>
<li><p>For each free space extent recorded in the bitmap:</p>
<ol class="loweralpha simple">
<li><p>Compute the position in the summary file that contains a counter that
represents this free extent.</p></li>
<li><p>Read the counter from the xfile.</p></li>
<li><p>Increment it, and write it back to the xfile.</p></li>
</ol>
</li>
<li><p>Compare the contents of the xfile against the ondisk file.</p></li>
</ol>
<p>To repair the summary file, write the xfile contents into the temporary file
and use atomic mapping exchange to commit the new contents.
The temporary file is then reaped.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-rtsummary">realtime summary repair</a>
series.</p>
</section>
<section id="case-study-salvaging-extended-attributes">
<h5><a class="toc-backref" href="#id100" role="doc-backlink"><span class="section-number">4.5.13.4.2. </span>Case Study: Salvaging Extended Attributes</a><a class="headerlink" href="#case-study-salvaging-extended-attributes" title="Link to this heading">¶</a></h5>
<p>In XFS, extended attributes are implemented as a namespaced name-value store.
Values are limited in size to 64KiB, but there is no limit in the number of
names.
The attribute fork is unpartitioned, which means that the root of the attribute
structure is always in logical block zero, but attribute leaf blocks, dabtree
index blocks, and remote value blocks are intermixed.
Attribute leaf blocks contain variable-sized records that associate
user-provided names with the user-provided values.
Values larger than a block are allocated separate extents and written there.
If the leaf information expands beyond a single block, a directory/attribute
btree (<code class="docutils literal notranslate"><span class="pre">dabtree</span></code>) is created to map hashes of attribute names to entries
for fast lookup.</p>
<p>Salvaging extended attributes is done as follows:</p>
<ol class="arabic simple">
<li><p>Walk the attr fork mappings of the file being repaired to find the attribute
leaf blocks.
When one is found,</p>
<ol class="loweralpha simple">
<li><p>Walk the attr leaf block to find candidate keys.
When one is found,</p>
<ol class="arabic simple">
<li><p>Check the name for problems, and ignore the name if there are.</p></li>
<li><p>Retrieve the value.
If that succeeds, add the name and value to the staging xfarray and
xfblob.</p></li>
</ol>
</li>
</ol>
</li>
<li><p>If the memory usage of the xfarray and xfblob exceed a certain amount of
memory or there are no more attr fork blocks to examine, unlock the file and
add the staged extended attributes to the temporary file.</p></li>
<li><p>Use atomic file mapping exchange to exchange the new and old extended
attribute structures.
The old attribute blocks are now attached to the temporary file.</p></li>
<li><p>Reap the temporary file.</p></li>
</ol>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-xattrs">extended attribute repair</a>
series.</p>
</section>
</section>
</section>
<section id="fixing-directories">
<h3><a class="toc-backref" href="#id101" role="doc-backlink"><span class="section-number">4.5.14. </span>Fixing Directories</a><a class="headerlink" href="#fixing-directories" title="Link to this heading">¶</a></h3>
<p>Fixing directories is difficult with currently available filesystem features,
since directory entries are not redundant.
The offline repair tool scans all inodes to find files with nonzero link count,
and then it scans all directories to establish parentage of those linked files.
Damaged files and directories are zapped, and files with no parent are
moved to the <code class="docutils literal notranslate"><span class="pre">/lost+found</span></code> directory.
It does not try to salvage anything.</p>
<p>The best that online repair can do at this time is to read directory data
blocks and salvage any dirents that look plausible, correct link counts, and
move orphans back into the directory tree.
The salvage process is discussed in the case study at the end of this section.
The <a class="reference internal" href="#nlinks"><span class="std std-ref">file link count fsck</span></a> code takes care of fixing link counts
and moving orphans to the <code class="docutils literal notranslate"><span class="pre">/lost+found</span></code> directory.</p>
<section id="case-study-salvaging-directories">
<h4><a class="toc-backref" href="#id102" role="doc-backlink"><span class="section-number">4.5.14.1. </span>Case Study: Salvaging Directories</a><a class="headerlink" href="#case-study-salvaging-directories" title="Link to this heading">¶</a></h4>
<p>Unlike extended attributes, directory blocks are all the same size, so
salvaging directories is straightforward:</p>
<ol class="arabic simple">
<li><p>Find the parent of the directory.
If the dotdot entry is not unreadable, try to confirm that the alleged
parent has a child entry pointing back to the directory being repaired.
Otherwise, walk the filesystem to find it.</p></li>
<li><p>Walk the first partition of data fork of the directory to find the directory
entry data blocks.
When one is found,</p>
<ol class="loweralpha simple">
<li><p>Walk the directory data block to find candidate entries.
When an entry is found:</p>
<ol class="lowerroman simple">
<li><p>Check the name for problems, and ignore the name if there are.</p></li>
<li><p>Retrieve the inumber and grab the inode.
If that succeeds, add the name, inode number, and file type to the
staging xfarray and xblob.</p></li>
</ol>
</li>
</ol>
</li>
<li><p>If the memory usage of the xfarray and xfblob exceed a certain amount of
memory or there are no more directory data blocks to examine, unlock the
directory and add the staged dirents into the temporary directory.
Truncate the staging files.</p></li>
<li><p>Use atomic file mapping exchange to exchange the new and old directory
structures.
The old directory blocks are now attached to the temporary file.</p></li>
<li><p>Reap the temporary file.</p></li>
</ol>
<p><strong>Future Work Question</strong>: Should repair revalidate the dentry cache when
rebuilding a directory?</p>
<p><em>Answer</em>: Yes, it should.</p>
<p>In theory it is necessary to scan all dentry cache entries for a directory to
ensure that one of the following apply:</p>
<ol class="arabic simple">
<li><p>The cached dentry reflects an ondisk dirent in the new directory.</p></li>
<li><p>The cached dentry no longer has a corresponding ondisk dirent in the new
directory and the dentry can be purged from the cache.</p></li>
<li><p>The cached dentry no longer has an ondisk dirent but the dentry cannot be
purged.
This is the problem case.</p></li>
</ol>
<p>Unfortunately, the current dentry cache design doesn’t provide a means to walk
every child dentry of a specific directory, which makes this a hard problem.
There is no known solution.</p>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-dirs">directory repair</a>
series.</p>
</section>
<section id="parent-pointers">
<h4><a class="toc-backref" href="#id103" role="doc-backlink"><span class="section-number">4.5.14.2. </span>Parent Pointers</a><a class="headerlink" href="#parent-pointers" title="Link to this heading">¶</a></h4>
<p>A parent pointer is a piece of file metadata that enables a user to locate the
file’s parent directory without having to traverse the directory tree from the
root.
Without them, reconstruction of directory trees is hindered in much the same
way that the historic lack of reverse space mapping information once hindered
reconstruction of filesystem space metadata.
The parent pointer feature, however, makes total directory reconstruction
possible.</p>
<p>XFS parent pointers contain the information needed to identify the
corresponding directory entry in the parent directory.
In other words, child files use extended attributes to store pointers to
parents in the form <code class="docutils literal notranslate"><span class="pre">(dirent_name)</span> <span class="pre">→</span> <span class="pre">(parent_inum,</span> <span class="pre">parent_gen)</span></code>.
The directory checking process can be strengthened to ensure that the target of
each dirent also contains a parent pointer pointing back to the dirent.
Likewise, each parent pointer can be checked by ensuring that the target of
each parent pointer is a directory and that it contains a dirent matching
the parent pointer.
Both online and offline repair can use this strategy.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>Historical Sidebar</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>Directory parent pointers were first proposed as an XFS feature more
than a decade ago by SGI.
Each link from a parent directory to a child file is mirrored with an
extended attribute in the child that could be used to identify the
parent directory.
Unfortunately, this early implementation had major shortcomings and was
never merged into Linux XFS:</p>
<ol class="arabic simple">
<li><p>The XFS codebase of the late 2000s did not have the infrastructure to
enforce strong referential integrity in the directory tree.
It did not guarantee that a change in a forward link would always be
followed up with the corresponding change to the reverse links.</p></li>
<li><p>Referential integrity was not integrated into offline repair.
Checking and repairs were performed on mounted filesystems without
taking any kernel or inode locks to coordinate access.
It is not clear how this actually worked properly.</p></li>
<li><p>The extended attribute did not record the name of the directory entry
in the parent, so the SGI parent pointer implementation cannot be
used to reconnect the directory tree.</p></li>
<li><p>Extended attribute forks only support 65,536 extents, which means
that parent pointer attribute creation is likely to fail at some
point before the maximum file link count is achieved.</p></li>
</ol>
<p>The original parent pointer design was too unstable for something like
a file system repair to depend on.
Allison Henderson, Chandan Babu, and Catherine Hoang are working on a
second implementation that solves all shortcomings of the first.
During 2022, Allison introduced log intent items to track physical
manipulations of the extended attribute structures.
This solves the referential integrity problem by making it possible to
commit a dirent update and a parent pointer update in the same
transaction.
Chandan increased the maximum extent counts of both data and attribute
forks, thereby ensuring that the extended attribute structure can grow
to handle the maximum hardlink count of any file.</p>
<p>For this second effort, the ondisk parent pointer format as originally
proposed was <code class="docutils literal notranslate"><span class="pre">(parent_inum,</span> <span class="pre">parent_gen,</span> <span class="pre">dirent_pos)</span> <span class="pre">→</span> <span class="pre">(dirent_name)</span></code>.
The format was changed during development to eliminate the requirement
of repair tools needing to to ensure that the <code class="docutils literal notranslate"><span class="pre">dirent_pos</span></code> field
always matched when reconstructing a directory.</p>
<p>There were a few other ways to have solved that problem:</p>
<ol class="arabic">
<li><p>The field could be designated advisory, since the other three values
are sufficient to find the entry in the parent.
However, this makes indexed key lookup impossible while repairs are
ongoing.</p></li>
<li><p>We could allow creating directory entries at specified offsets, which
solves the referential integrity problem but runs the risk that
dirent creation will fail due to conflicts with the free space in the
directory.</p>
<p>These conflicts could be resolved by appending the directory entry
and amending the xattr code to support updating an xattr key and
reindexing the dabtree, though this would have to be performed with
the parent directory still locked.</p>
</li>
<li><p>Same as above, but remove the old parent pointer entry and add a new
one atomically.</p></li>
<li><p>Change the ondisk xattr format to
<code class="docutils literal notranslate"><span class="pre">(parent_inum,</span> <span class="pre">name)</span> <span class="pre">→</span> <span class="pre">(parent_gen)</span></code>, which would provide the attr
name uniqueness that we require, without forcing repair code to
update the dirent position.
Unfortunately, this requires changes to the xattr code to support
attr names as long as 263 bytes.</p></li>
<li><p>Change the ondisk xattr format to <code class="docutils literal notranslate"><span class="pre">(parent_inum,</span> <span class="pre">hash(name))</span> <span class="pre">→</span>
<span class="pre">(name,</span> <span class="pre">parent_gen)</span></code>.
If the hash is sufficiently resistant to collisions (e.g. sha256)
then this should provide the attr name uniqueness that we require.
Names shorter than 247 bytes could be stored directly.</p></li>
<li><p>Change the ondisk xattr format to <code class="docutils literal notranslate"><span class="pre">(dirent_name)</span> <span class="pre">→</span> <span class="pre">(parent_ino,</span>
<span class="pre">parent_gen)</span></code>.  This format doesn’t require any of the complicated
nested name hashing of the previous suggestions.  However, it was
discovered that multiple hardlinks to the same inode with the same
filename caused performance problems with hashed xattr lookups, so
the parent inumber is now xor’d into the hash index.</p></li>
</ol>
<p>In the end, it was decided that solution #6 was the most compact and the
most performant.  A new hash function was designed for parent pointers.</p>
</td>
</tr>
</tbody>
</table>
<section id="case-study-repairing-directories-with-parent-pointers">
<h5><a class="toc-backref" href="#id104" role="doc-backlink"><span class="section-number">4.5.14.2.1. </span>Case Study: Repairing Directories with Parent Pointers</a><a class="headerlink" href="#case-study-repairing-directories-with-parent-pointers" title="Link to this heading">¶</a></h5>
<p>Directory rebuilding uses a <a class="reference internal" href="#iscan"><span class="std std-ref">coordinated inode scan</span></a> and
a <a class="reference internal" href="#liveupdate"><span class="std std-ref">directory entry live update hook</span></a> as follows:</p>
<ol class="arabic simple">
<li><p>Set up a temporary directory for generating the new directory structure,
an xfblob for storing entry names, and an xfarray for stashing the fixed
size fields involved in a directory update: <code class="docutils literal notranslate"><span class="pre">(child</span> <span class="pre">inumber,</span> <span class="pre">add</span> <span class="pre">vs.</span>
<span class="pre">remove,</span> <span class="pre">name</span> <span class="pre">cookie,</span> <span class="pre">ftype)</span></code>.</p></li>
<li><p>Set up an inode scanner and hook into the directory entry code to receive
updates on directory operations.</p></li>
<li><p>For each parent pointer found in each file scanned, decide if the parent
pointer references the directory of interest.
If so:</p>
<ol class="loweralpha simple">
<li><p>Stash the parent pointer name and an addname entry for this dirent in the
xfblob and xfarray, respectively.</p></li>
<li><p>When finished scanning that file or the kernel memory consumption exceeds
a threshold, flush the stashed updates to the temporary directory.</p></li>
</ol>
</li>
<li><p>For each live directory update received via the hook, decide if the child
has already been scanned.
If so:</p>
<ol class="loweralpha simple">
<li><p>Stash the parent pointer name an addname or removename entry for this
dirent update in the xfblob and xfarray for later.
We cannot write directly to the temporary directory because hook
functions are not allowed to modify filesystem metadata.
Instead, we stash updates in the xfarray and rely on the scanner thread
to apply the stashed updates to the temporary directory.</p></li>
</ol>
</li>
<li><p>When the scan is complete, replay any stashed entries in the xfarray.</p></li>
<li><p>When the scan is complete, atomically exchange the contents of the temporary
directory and the directory being repaired.
The temporary directory now contains the damaged directory structure.</p></li>
<li><p>Reap the temporary directory.</p></li>
</ol>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=pptrs-fsck">parent pointers directory repair</a>
series.</p>
</section>
<section id="case-study-repairing-parent-pointers">
<h5><a class="toc-backref" href="#id105" role="doc-backlink"><span class="section-number">4.5.14.2.2. </span>Case Study: Repairing Parent Pointers</a><a class="headerlink" href="#case-study-repairing-parent-pointers" title="Link to this heading">¶</a></h5>
<p>Online reconstruction of a file’s parent pointer information works similarly to
directory reconstruction:</p>
<ol class="arabic simple">
<li><p>Set up a temporary file for generating a new extended attribute structure,
an xfblob for storing parent pointer names, and an xfarray for stashing the
fixed size fields involved in a parent pointer update: <code class="docutils literal notranslate"><span class="pre">(parent</span> <span class="pre">inumber,</span>
<span class="pre">parent</span> <span class="pre">generation,</span> <span class="pre">add</span> <span class="pre">vs.</span> <span class="pre">remove,</span> <span class="pre">name</span> <span class="pre">cookie)</span></code>.</p></li>
<li><p>Set up an inode scanner and hook into the directory entry code to receive
updates on directory operations.</p></li>
<li><p>For each directory entry found in each directory scanned, decide if the
dirent references the file of interest.
If so:</p>
<ol class="loweralpha simple">
<li><p>Stash the dirent name and an addpptr entry for this parent pointer in the
xfblob and xfarray, respectively.</p></li>
<li><p>When finished scanning the directory or the kernel memory consumption
exceeds a threshold, flush the stashed updates to the temporary file.</p></li>
</ol>
</li>
<li><p>For each live directory update received via the hook, decide if the parent
has already been scanned.
If so:</p>
<ol class="loweralpha simple">
<li><p>Stash the dirent name and an addpptr or removepptr entry for this dirent
update in the xfblob and xfarray for later.
We cannot write parent pointers directly to the temporary file because
hook functions are not allowed to modify filesystem metadata.
Instead, we stash updates in the xfarray and rely on the scanner thread
to apply the stashed parent pointer updates to the temporary file.</p></li>
</ol>
</li>
<li><p>When the scan is complete, replay any stashed entries in the xfarray.</p></li>
<li><p>Copy all non-parent pointer extended attributes to the temporary file.</p></li>
<li><p>When the scan is complete, atomically exchange the mappings of the attribute
forks of the temporary file and the file being repaired.
The temporary file now contains the damaged extended attribute structure.</p></li>
<li><p>Reap the temporary file.</p></li>
</ol>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=pptrs-fsck">parent pointers repair</a>
series.</p>
</section>
<section id="digression-offline-checking-of-parent-pointers">
<h5><a class="toc-backref" href="#id106" role="doc-backlink"><span class="section-number">4.5.14.2.3. </span>Digression: Offline Checking of Parent Pointers</a><a class="headerlink" href="#digression-offline-checking-of-parent-pointers" title="Link to this heading">¶</a></h5>
<p>Examining parent pointers in offline repair works differently because corrupt
files are erased long before directory tree connectivity checks are performed.
Parent pointer checks are therefore a second pass to be added to the existing
connectivity checks:</p>
<ol class="arabic simple">
<li><p>After the set of surviving files has been established (phase 6),
walk the surviving directories of each AG in the filesystem.
This is already performed as part of the connectivity checks.</p></li>
<li><p>For each directory entry found,</p>
<ol class="loweralpha simple">
<li><p>If the name has already been stored in the xfblob, then use that cookie
and skip the next step.</p></li>
<li><p>Otherwise, record the name in an xfblob, and remember the xfblob cookie.
Unique mappings are critical for</p>
<ol class="arabic simple">
<li><p>Deduplicating names to reduce memory usage, and</p></li>
<li><p>Creating a stable sort key for the parent pointer indexes so that the
parent pointer validation described below will work.</p></li>
</ol>
</li>
<li><p>Store <code class="docutils literal notranslate"><span class="pre">(child_ag_inum,</span> <span class="pre">parent_inum,</span> <span class="pre">parent_gen,</span> <span class="pre">name_hash,</span> <span class="pre">name_len,</span>
<span class="pre">name_cookie)</span></code> tuples in a per-AG in-memory slab.  The <code class="docutils literal notranslate"><span class="pre">name_hash</span></code>
referenced in this section is the regular directory entry name hash, not
the specialized one used for parent pointer xattrs.</p></li>
</ol>
</li>
<li><p>For each AG in the filesystem,</p>
<ol class="loweralpha simple">
<li><p>Sort the per-AG tuple set in order of <code class="docutils literal notranslate"><span class="pre">child_ag_inum</span></code>, <code class="docutils literal notranslate"><span class="pre">parent_inum</span></code>,
<code class="docutils literal notranslate"><span class="pre">name_hash</span></code>, and <code class="docutils literal notranslate"><span class="pre">name_cookie</span></code>.
Having a single <code class="docutils literal notranslate"><span class="pre">name_cookie</span></code> for each <code class="docutils literal notranslate"><span class="pre">name</span></code> is critical for
handling the uncommon case of a directory containing multiple hardlinks
to the same file where all the names hash to the same value.</p></li>
<li><p>For each inode in the AG,</p>
<ol class="arabic simple">
<li><p>Scan the inode for parent pointers.
For each parent pointer found,</p>
<ol class="loweralpha simple">
<li><p>Validate the ondisk parent pointer.
If validation fails, move on to the next parent pointer in the
file.</p></li>
<li><p>If the name has already been stored in the xfblob, then use that
cookie and skip the next step.</p></li>
<li><p>Record the name in a per-file xfblob, and remember the xfblob
cookie.</p></li>
<li><p>Store <code class="docutils literal notranslate"><span class="pre">(parent_inum,</span> <span class="pre">parent_gen,</span> <span class="pre">name_hash,</span> <span class="pre">name_len,</span>
<span class="pre">name_cookie)</span></code> tuples in a per-file slab.</p></li>
</ol>
</li>
<li><p>Sort the per-file tuples in order of <code class="docutils literal notranslate"><span class="pre">parent_inum</span></code>, <code class="docutils literal notranslate"><span class="pre">name_hash</span></code>,
and <code class="docutils literal notranslate"><span class="pre">name_cookie</span></code>.</p></li>
<li><p>Position one slab cursor at the start of the inode’s records in the
per-AG tuple slab.
This should be trivial since the per-AG tuples are in child inumber
order.</p></li>
<li><p>Position a second slab cursor at the start of the per-file tuple slab.</p></li>
<li><p>Iterate the two cursors in lockstep, comparing the <code class="docutils literal notranslate"><span class="pre">parent_ino</span></code>,
<code class="docutils literal notranslate"><span class="pre">name_hash</span></code>, and <code class="docutils literal notranslate"><span class="pre">name_cookie</span></code> fields of the records under each
cursor:</p>
<ol class="loweralpha simple">
<li><p>If the per-AG cursor is at a lower point in the keyspace than the
per-file cursor, then the per-AG cursor points to a missing parent
pointer.
Add the parent pointer to the inode and advance the per-AG
cursor.</p></li>
<li><p>If the per-file cursor is at a lower point in the keyspace than
the per-AG cursor, then the per-file cursor points to a dangling
parent pointer.
Remove the parent pointer from the inode and advance the per-file
cursor.</p></li>
<li><p>Otherwise, both cursors point at the same parent pointer.
Update the parent_gen component if necessary.
Advance both cursors.</p></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Move on to examining link counts, as we do today.</p></li>
</ol>
<p>The proposed patchset is the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=pptrs-fsck">offline parent pointers repair</a>
series.</p>
<p>Rebuilding directories from parent pointers in offline repair would be very
challenging because xfs_repair currently uses two single-pass scans of the
filesystem during phases 3 and 4 to decide which files are corrupt enough to be
zapped.
This scan would have to be converted into a multi-pass scan:</p>
<ol class="arabic simple">
<li><p>The first pass of the scan zaps corrupt inodes, forks, and attributes
much as it does now.
Corrupt directories are noted but not zapped.</p></li>
<li><p>The next pass records parent pointers pointing to the directories noted
as being corrupt in the first pass.
This second pass may have to happen after the phase 4 scan for duplicate
blocks, if phase 4 is also capable of zapping directories.</p></li>
<li><p>The third pass resets corrupt directories to an empty shortform directory.
Free space metadata has not been ensured yet, so repair cannot yet use the
directory building code in libxfs.</p></li>
<li><p>At the start of phase 6, space metadata have been rebuilt.
Use the parent pointer information recorded during step 2 to reconstruct
the dirents and add them to the now-empty directories.</p></li>
</ol>
<p>This code has not yet been constructed.</p>
</section>
<section id="case-study-directory-tree-structure">
<span id="dirtree"></span><h5><a class="toc-backref" href="#id107" role="doc-backlink"><span class="section-number">4.5.14.2.4. </span>Case Study: Directory Tree Structure</a><a class="headerlink" href="#case-study-directory-tree-structure" title="Link to this heading">¶</a></h5>
<p>As mentioned earlier, the filesystem directory tree is supposed to be a
directed acylic graph structure.
However, each node in this graph is a separate <code class="docutils literal notranslate"><span class="pre">xfs_inode</span></code> object with its
own locks, which makes validating the tree qualities difficult.
Fortunately, non-directories are allowed to have multiple parents and cannot
have children, so only directories need to be scanned.
Directories typically constitute 5-10% of the files in a filesystem, which
reduces the amount of work dramatically.</p>
<p>If the directory tree could be frozen, it would be easy to discover cycles and
disconnected regions by running a depth (or breadth) first search downwards
from the root directory and marking a bitmap for each directory found.
At any point in the walk, trying to set an already set bit means there is a
cycle.
After the scan completes, XORing the marked inode bitmap with the inode
allocation bitmap reveals disconnected inodes.
However, one of online repair’s design goals is to avoid locking the entire
filesystem unless it’s absolutely necessary.
Directory tree updates can move subtrees across the scanner wavefront on a live
filesystem, so the bitmap algorithm cannot be applied.</p>
<p>Directory parent pointers enable an incremental approach to validation of the
tree structure.
Instead of using one thread to scan the entire filesystem, multiple threads can
walk from individual subdirectories upwards towards the root.
For this to work, all directory entries and parent pointers must be internally
consistent, each directory entry must have a parent pointer, and the link
counts of all directories must be correct.
Each scanner thread must be able to take the IOLOCK of an alleged parent
directory while holding the IOLOCK of the child directory to prevent either
directory from being moved within the tree.
This is not possible since the VFS does not take the IOLOCK of a child
subdirectory when moving that subdirectory, so instead the scanner stabilizes
the parent -&gt; child relationship by taking the ILOCKs and installing a dirent
update hook to detect changes.</p>
<p>The scanning process uses a dirent hook to detect changes to the directories
mentioned in the scan data.
The scan works as follows:</p>
<ol class="arabic simple">
<li><p>For each subdirectory in the filesystem,</p>
<ol class="loweralpha simple">
<li><p>For each parent pointer of that subdirectory,</p>
<ol class="arabic simple">
<li><p>Create a path object for that parent pointer, and mark the
subdirectory inode number in the path object’s bitmap.</p></li>
<li><p>Record the parent pointer name and inode number in a path structure.</p></li>
<li><p>If the alleged parent is the subdirectory being scrubbed, the path is
a cycle.
Mark the path for deletion and repeat step 1a with the next
subdirectory parent pointer.</p></li>
<li><p>Try to mark the alleged parent inode number in a bitmap in the path
object.
If the bit is already set, then there is a cycle in the directory
tree.
Mark the path as a cycle and repeat step 1a with the next subdirectory
parent pointer.</p></li>
<li><p>Load the alleged parent.
If the alleged parent is not a linked directory, abort the scan
because the parent pointer information is inconsistent.</p></li>
<li><p>For each parent pointer of this alleged ancestor directory,</p>
<ol class="loweralpha simple">
<li><p>Record the parent pointer name and inode number in the path object
if no parent has been set for that level.</p></li>
<li><p>If an ancestor has more than one parent, mark the path as corrupt.
Repeat step 1a with the next subdirectory parent pointer.</p></li>
<li><p>Repeat steps 1a3-1a6 for the ancestor identified in step 1a6a.
This repeats until the directory tree root is reached or no parents
are found.</p></li>
</ol>
</li>
<li><p>If the walk terminates at the root directory, mark the path as ok.</p></li>
<li><p>If the walk terminates without reaching the root, mark the path as
disconnected.</p></li>
</ol>
</li>
</ol>
</li>
<li><p>If the directory entry update hook triggers, check all paths already found
by the scan.
If the entry matches part of a path, mark that path and the scan stale.
When the scanner thread sees that the scan has been marked stale, it deletes
all scan data and starts over.</p></li>
</ol>
<p>Repairing the directory tree works as follows:</p>
<ol class="arabic simple">
<li><p>Walk each path of the target subdirectory.</p>
<ol class="loweralpha simple">
<li><p>Corrupt paths and cycle paths are counted as suspect.</p></li>
<li><p>Paths already marked for deletion are counted as bad.</p></li>
<li><p>Paths that reached the root are counted as good.</p></li>
</ol>
</li>
<li><p>If the subdirectory is either the root directory or has zero link count,
delete all incoming directory entries in the immediate parents.
Repairs are complete.</p></li>
<li><p>If the subdirectory has exactly one path, set the dotdot entry to the
parent and exit.</p></li>
<li><p>If the subdirectory has at least one good path, delete all the other
incoming directory entries in the immediate parents.</p></li>
<li><p>If the subdirectory has no good paths and more than one suspect path, delete
all the other incoming directory entries in the immediate parents.</p></li>
<li><p>If the subdirectory has zero paths, attach it to the lost and found.</p></li>
</ol>
<p>The proposed patches are in the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=scrub-directory-tree">directory tree repair</a>
series.</p>
</section>
</section>
</section>
<section id="the-orphanage">
<span id="orphanage"></span><h3><a class="toc-backref" href="#id108" role="doc-backlink"><span class="section-number">4.5.15. </span>The Orphanage</a><a class="headerlink" href="#the-orphanage" title="Link to this heading">¶</a></h3>
<p>Filesystems present files as a directed, and hopefully acyclic, graph.
In other words, a tree.
The root of the filesystem is a directory, and each entry in a directory points
downwards either to more subdirectories or to non-directory files.
Unfortunately, a disruption in the directory graph pointers result in a
disconnected graph, which makes files impossible to access via regular path
resolution.</p>
<p>Without parent pointers, the directory parent pointer online scrub code can
detect a dotdot entry pointing to a parent directory that doesn’t have a link
back to the child directory and the file link count checker can detect a file
that isn’t pointed to by any directory in the filesystem.
If such a file has a positive link count, the file is an orphan.</p>
<p>With parent pointers, directories can be rebuilt by scanning parent pointers
and parent pointers can be rebuilt by scanning directories.
This should reduce the incidence of files ending up in <code class="docutils literal notranslate"><span class="pre">/lost+found</span></code>.</p>
<p>When orphans are found, they should be reconnected to the directory tree.
Offline fsck solves the problem by creating a directory <code class="docutils literal notranslate"><span class="pre">/lost+found</span></code> to
serve as an orphanage, and linking orphan files into the orphanage by using the
inumber as the name.
Reparenting a file to the orphanage does not reset any of its permissions or
ACLs.</p>
<p>This process is more involved in the kernel than it is in userspace.
The directory and file link count repair setup functions must use the regular
VFS mechanisms to create the orphanage directory with all the necessary
security attributes and dentry cache entries, just like a regular directory
tree modification.</p>
<p>Orphaned files are adopted by the orphanage as follows:</p>
<ol class="arabic simple">
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xrep_orphanage_try_create</span></code> at the start of the scrub setup function
to try to ensure that the lost and found directory actually exists.
This also attaches the orphanage directory to the scrub context.</p></li>
<li><p>If the decision is made to reconnect a file, take the IOLOCK of both the
orphanage and the file being reattached.
The <code class="docutils literal notranslate"><span class="pre">xrep_orphanage_iolock_two</span></code> function follows the inode locking
strategy discussed earlier.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">xrep_adoption_trans_alloc</span></code> to reserve resources to the repair
transaction.</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xrep_orphanage_compute_name</span></code> to compute the new name in the
orphanage.</p></li>
<li><p>If the adoption is going to happen, call <code class="docutils literal notranslate"><span class="pre">xrep_adoption_reparent</span></code> to
reparent the orphaned file into the lost and found and invalidate the dentry
cache.</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">xrep_adoption_finish</span></code> to commit any filesystem updates, release the
orphanage ILOCK, and clean the scrub transaction.  Call
<code class="docutils literal notranslate"><span class="pre">xrep_adoption_commit</span></code> to commit the updates and the scrub transaction.</p></li>
<li><p>If a runtime error happens, call <code class="docutils literal notranslate"><span class="pre">xrep_adoption_cancel</span></code> to release all
resources.</p></li>
</ol>
<p>The proposed patches are in the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=repair-orphanage">orphanage adoption</a>
series.</p>
</section>
</section>
<section id="userspace-algorithms-and-data-structures">
<h2><a class="toc-backref" href="#id109" role="doc-backlink"><span class="section-number">4.6. </span>6. Userspace Algorithms and Data Structures</a><a class="headerlink" href="#userspace-algorithms-and-data-structures" title="Link to this heading">¶</a></h2>
<p>This section discusses the key algorithms and data structures of the userspace
program, <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code>, that provide the ability to drive metadata checks and
repairs in the kernel, verify file data, and look for other potential problems.</p>
<section id="checking-metadata">
<span id="scrubcheck"></span><h3><a class="toc-backref" href="#id110" role="doc-backlink"><span class="section-number">4.6.1. </span>Checking Metadata</a><a class="headerlink" href="#checking-metadata" title="Link to this heading">¶</a></h3>
<p>Recall the <a class="reference internal" href="#scrubphases"><span class="std std-ref">phases of fsck work</span></a> outlined earlier.
That structure follows naturally from the data dependencies designed into the
filesystem from its beginnings in 1993.
In XFS, there are several groups of metadata dependencies:</p>
<ol class="loweralpha simple">
<li><p>Filesystem summary counts depend on consistency within the inode indices,
the allocation group space btrees, and the realtime volume space
information.</p></li>
<li><p>Quota resource counts depend on consistency within the quota file data
forks, inode indices, inode records, and the forks of every file on the
system.</p></li>
<li><p>The naming hierarchy depends on consistency within the directory and
extended attribute structures.
This includes file link counts.</p></li>
<li><p>Directories, extended attributes, and file data depend on consistency within
the file forks that map directory and extended attribute data to physical
storage media.</p></li>
<li><p>The file forks depends on consistency within inode records and the space
metadata indices of the allocation groups and the realtime volume.
This includes quota and realtime metadata files.</p></li>
<li><p>Inode records depends on consistency within the inode metadata indices.</p></li>
<li><p>Realtime space metadata depend on the inode records and data forks of the
realtime metadata inodes.</p></li>
<li><p>The allocation group metadata indices (free space, inodes, reference count,
and reverse mapping btrees) depend on consistency within the AG headers and
between all the AG metadata btrees.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> depends on the filesystem being mounted and kernel support
for online fsck functionality.</p></li>
</ol>
<p>Therefore, a metadata dependency graph is a convenient way to schedule checking
operations in the <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> program:</p>
<ul class="simple">
<li><p>Phase 1 checks that the provided path maps to an XFS filesystem and detect
the kernel’s scrubbing abilities, which validates group (i).</p></li>
<li><p>Phase 2 scrubs groups (g) and (h) in parallel using a threaded workqueue.</p></li>
<li><p>Phase 3 scans inodes in parallel.
For each inode, groups (f), (e), and (d) are checked, in that order.</p></li>
<li><p>Phase 4 repairs everything in groups (i) through (d) so that phases 5 and 6
may run reliably.</p></li>
<li><p>Phase 5 starts by checking groups (b) and (c) in parallel before moving on
to checking names.</p></li>
<li><p>Phase 6 depends on groups (i) through (b) to find file data blocks to verify,
to read them, and to report which blocks of which files are affected.</p></li>
<li><p>Phase 7 checks group (a), having validated everything else.</p></li>
</ul>
<p>Notice that the data dependencies between groups are enforced by the structure
of the program flow.</p>
</section>
<section id="parallel-inode-scans">
<h3><a class="toc-backref" href="#id111" role="doc-backlink"><span class="section-number">4.6.2. </span>Parallel Inode Scans</a><a class="headerlink" href="#parallel-inode-scans" title="Link to this heading">¶</a></h3>
<p>An XFS filesystem can easily contain hundreds of millions of inodes.
Given that XFS targets installations with large high-performance storage,
it is desirable to scrub inodes in parallel to minimize runtime, particularly
if the program has been invoked manually from a command line.
This requires careful scheduling to keep the threads as evenly loaded as
possible.</p>
<p>Early iterations of the <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> inode scanner naïvely created a single
workqueue and scheduled a single workqueue item per AG.
Each workqueue item walked the inode btree (with <code class="docutils literal notranslate"><span class="pre">XFS_IOC_INUMBERS</span></code>) to find
inode chunks and then called bulkstat (<code class="docutils literal notranslate"><span class="pre">XFS_IOC_BULKSTAT</span></code>) to gather enough
information to construct file handles.
The file handle was then passed to a function to generate scrub items for each
metadata object of each inode.
This simple algorithm leads to thread balancing problems in phase 3 if the
filesystem contains one AG with a few large sparse files and the rest of the
AGs contain many smaller files.
The inode scan dispatch function was not sufficiently granular; it should have
been dispatching at the level of individual inodes, or, to constrain memory
consumption, inode btree records.</p>
<p>Thanks to Dave Chinner, bounded workqueues in userspace enable <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> to
avoid this problem with ease by adding a second workqueue.
Just like before, the first workqueue is seeded with one workqueue item per AG,
and it uses INUMBERS to find inode btree chunks.
The second workqueue, however, is configured with an upper bound on the number
of items that can be waiting to be run.
Each inode btree chunk found by the first workqueue’s workers are queued to the
second workqueue, and it is this second workqueue that queries BULKSTAT,
creates a file handle, and passes it to a function to generate scrub items for
each metadata object of each inode.
If the second workqueue is too full, the workqueue add function blocks the
first workqueue’s workers until the backlog eases.
This doesn’t completely solve the balancing problem, but reduces it enough to
move on to more pressing issues.</p>
<p>The proposed patchsets are the scrub
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=scrub-performance-tweaks">performance tweaks</a>
and the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=scrub-iscan-rebalance">inode scan rebalance</a>
series.</p>
</section>
<section id="scheduling-repairs">
<span id="scrubrepair"></span><h3><a class="toc-backref" href="#id112" role="doc-backlink"><span class="section-number">4.6.3. </span>Scheduling Repairs</a><a class="headerlink" href="#scheduling-repairs" title="Link to this heading">¶</a></h3>
<p>During phase 2, corruptions and inconsistencies reported in any AGI header or
inode btree are repaired immediately, because phase 3 relies on proper
functioning of the inode indices to find inodes to scan.
Failed repairs are rescheduled to phase 4.
Problems reported in any other space metadata are deferred to phase 4.
Optimization opportunities are always deferred to phase 4, no matter their
origin.</p>
<p>During phase 3, corruptions and inconsistencies reported in any part of a
file’s metadata are repaired immediately if all space metadata were validated
during phase 2.
Repairs that fail or cannot be repaired immediately are scheduled for phase 4.</p>
<p>In the original design of <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code>, it was thought that repairs would be
so infrequent that the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xfs_scrub_metadata</span></code> objects used to
communicate with the kernel could also be used as the primary object to
schedule repairs.
With recent increases in the number of optimizations possible for a given
filesystem object, it became much more memory-efficient to track all eligible
repairs for a given filesystem object with a single repair item.
Each repair item represents a single lockable object -- AGs, metadata files,
individual inodes, or a class of summary information.</p>
<p>Phase 4 is responsible for scheduling a lot of repair work in as quick a
manner as is practical.
The <a class="reference internal" href="#scrubcheck"><span class="std std-ref">data dependencies</span></a> outlined earlier still apply, which
means that <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> must try to complete the repair work scheduled by
phase 2 before trying repair work scheduled by phase 3.
The repair process is as follows:</p>
<ol class="arabic simple">
<li><p>Start a round of repair with a workqueue and enough workers to keep the CPUs
as busy as the user desires.</p>
<ol class="loweralpha simple">
<li><p>For each repair item queued by phase 2,</p>
<ol class="lowerroman simple">
<li><p>Ask the kernel to repair everything listed in the repair item for a
given filesystem object.</p></li>
<li><p>Make a note if the kernel made any progress in reducing the number
of repairs needed for this object.</p></li>
<li><p>If the object no longer requires repairs, revalidate all metadata
associated with this object.
If the revalidation succeeds, drop the repair item.
If not, requeue the item for more repairs.</p></li>
</ol>
</li>
<li><p>If any repairs were made, jump back to 1a to retry all the phase 2 items.</p></li>
<li><p>For each repair item queued by phase 3,</p>
<ol class="lowerroman simple">
<li><p>Ask the kernel to repair everything listed in the repair item for a
given filesystem object.</p></li>
<li><p>Make a note if the kernel made any progress in reducing the number
of repairs needed for this object.</p></li>
<li><p>If the object no longer requires repairs, revalidate all metadata
associated with this object.
If the revalidation succeeds, drop the repair item.
If not, requeue the item for more repairs.</p></li>
</ol>
</li>
<li><p>If any repairs were made, jump back to 1c to retry all the phase 3 items.</p></li>
</ol>
</li>
<li><p>If step 1 made any repair progress of any kind, jump back to step 1 to start
another round of repair.</p></li>
<li><p>If there are items left to repair, run them all serially one more time.
Complain if the repairs were not successful, since this is the last chance
to repair anything.</p></li>
</ol>
<p>Corruptions and inconsistencies encountered during phases 5 and 7 are repaired
immediately.
Corrupt file data blocks reported by phase 6 cannot be recovered by the
filesystem.</p>
<p>The proposed patchsets are the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=scrub-better-repair-warnings">repair warning improvements</a>,
refactoring of the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=scrub-repair-data-deps">repair data dependency</a>
and
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=scrub-object-tracking">object tracking</a>,
and the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=scrub-repair-scheduling">repair scheduling</a>
improvement series.</p>
</section>
<section id="checking-names-for-confusable-unicode-sequences">
<h3><a class="toc-backref" href="#id113" role="doc-backlink"><span class="section-number">4.6.4. </span>Checking Names for Confusable Unicode Sequences</a><a class="headerlink" href="#checking-names-for-confusable-unicode-sequences" title="Link to this heading">¶</a></h3>
<p>If <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> succeeds in validating the filesystem metadata by the end of
phase 4, it moves on to phase 5, which checks for suspicious looking names in
the filesystem.
These names consist of the filesystem label, names in directory entries, and
the names of extended attributes.
Like most Unix filesystems, XFS imposes the sparest of constraints on the
contents of a name:</p>
<ul class="simple">
<li><p>Slashes and null bytes are not allowed in directory entries.</p></li>
<li><p>Null bytes are not allowed in userspace-visible extended attributes.</p></li>
<li><p>Null bytes are not allowed in the filesystem label.</p></li>
</ul>
<p>Directory entries and attribute keys store the length of the name explicitly
ondisk, which means that nulls are not name terminators.
For this section, the term “naming domain” refers to any place where names are
presented together -- all the names in a directory, or all the attributes of a
file.</p>
<p>Although the Unix naming constraints are very permissive, the reality of most
modern-day Linux systems is that programs work with Unicode character code
points to support international languages.
These programs typically encode those code points in UTF-8 when interfacing
with the C library because the kernel expects null-terminated names.
In the common case, therefore, names found in an XFS filesystem are actually
UTF-8 encoded Unicode data.</p>
<p>To maximize its expressiveness, the Unicode standard defines separate control
points for various characters that render similarly or identically in writing
systems around the world.
For example, the character “Cyrillic Small Letter A” U+0430 “а” often renders
identically to “Latin Small Letter A” U+0061 “a”.</p>
<p>The standard also permits characters to be constructed in multiple ways --
either by using a defined code point, or by combining one code point with
various combining marks.
For example, the character “Angstrom Sign U+212B “Å” can also be expressed
as “Latin Capital Letter A” U+0041 “A” followed by “Combining Ring Above”
U+030A “◌̊”.
Both sequences render identically.</p>
<p>Like the standards that preceded it, Unicode also defines various control
characters to alter the presentation of text.
For example, the character “Right-to-Left Override” U+202E can trick some
programs into rendering “moo\xe2\x80\xaegnp.txt” as “mootxt.png”.
A second category of rendering problems involves whitespace characters.
If the character “Zero Width Space” U+200B is encountered in a file name, the
name will render identically to a name that does not have the zero width
space.</p>
<p>If two names within a naming domain have different byte sequences but render
identically, a user may be confused by it.
The kernel, in its indifference to upper level encoding schemes, permits this.
Most filesystem drivers persist the byte sequence names that are given to them
by the VFS.</p>
<p>Techniques for detecting confusable names are explained in great detail in
sections 4 and 5 of the
<a class="reference external" href="https://unicode.org/reports/tr39/">Unicode Security Mechanisms</a>
document.
When <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> detects UTF-8 encoding in use on a system, it uses the
Unicode normalization form NFD in conjunction with the confusable name
detection component of
<a class="reference external" href="https://github.com/unicode-org/icu">libicu</a>
to identify names with a directory or within a file’s extended attributes that
could be confused for each other.
Names are also checked for control characters, non-rendering characters, and
mixing of bidirectional characters.
All of these potential issues are reported to the system administrator during
phase 5.</p>
</section>
<section id="media-verification-of-file-data-extents">
<h3><a class="toc-backref" href="#id114" role="doc-backlink"><span class="section-number">4.6.5. </span>Media Verification of File Data Extents</a><a class="headerlink" href="#media-verification-of-file-data-extents" title="Link to this heading">¶</a></h3>
<p>The system administrator can elect to initiate a media scan of all file data
blocks.
This scan after validation of all filesystem metadata (except for the summary
counters) as phase 6.
The scan starts by calling <code class="docutils literal notranslate"><span class="pre">FS_IOC_GETFSMAP</span></code> to scan the filesystem space map
to find areas that are allocated to file data fork extents.
Gaps between data fork extents that are smaller than 64k are treated as if
they were data fork extents to reduce the command setup overhead.
When the space map scan accumulates a region larger than 32MB, a media
verification request is sent to the disk as a directio read of the raw block
device.</p>
<p>If the verification read fails, <code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> retries with single-block reads
to narrow down the failure to the specific region of the media and recorded.
When it has finished issuing verification requests, it again uses the space
mapping ioctl to map the recorded media errors back to metadata structures
and report what has been lost.
For media errors in blocks owned by files, parent pointers can be used to
construct file paths from inode numbers for user-friendly reporting.</p>
</section>
</section>
<section id="conclusion-and-future-work">
<h2><a class="toc-backref" href="#id115" role="doc-backlink"><span class="section-number">4.7. </span>7. Conclusion and Future Work</a><a class="headerlink" href="#conclusion-and-future-work" title="Link to this heading">¶</a></h2>
<p>It is hoped that the reader of this document has followed the designs laid out
in this document and now has some familiarity with how XFS performs online
rebuilding of its metadata indices, and how filesystem users can interact with
that functionality.
Although the scope of this work is daunting, it is hoped that this guide will
make it easier for code readers to understand what has been built, for whom it
has been built, and why.
Please feel free to contact the XFS mailing list with questions.</p>
<section id="xfs-ioc-exchange-range">
<h3><a class="toc-backref" href="#id116" role="doc-backlink"><span class="section-number">4.7.1. </span>XFS_IOC_EXCHANGE_RANGE</a><a class="headerlink" href="#xfs-ioc-exchange-range" title="Link to this heading">¶</a></h3>
<p>As discussed earlier, a second frontend to the atomic file mapping exchange
mechanism is a new ioctl call that userspace programs can use to commit updates
to files atomically.
This frontend has been out for review for several years now, though the
necessary refinements to online repair and lack of customer demand mean that
the proposal has not been pushed very hard.</p>
<section id="file-content-exchanges-with-regular-user-files">
<h4><a class="toc-backref" href="#id117" role="doc-backlink"><span class="section-number">4.7.1.1. </span>File Content Exchanges with Regular User Files</a><a class="headerlink" href="#file-content-exchanges-with-regular-user-files" title="Link to this heading">¶</a></h4>
<p>As mentioned earlier, XFS has long had the ability to swap extents between
files, which is used almost exclusively by <code class="docutils literal notranslate"><span class="pre">xfs_fsr</span></code> to defragment files.
The earliest form of this was the fork swap mechanism, where the entire
contents of data forks could be exchanged between two files by exchanging the
raw bytes in each inode fork’s immediate area.
When XFS v5 came along with self-describing metadata, this old mechanism grew
some log support to continue rewriting the owner fields of BMBT blocks during
log recovery.
When the reverse mapping btree was later added to XFS, the only way to maintain
the consistency of the fork mappings with the reverse mapping index was to
develop an iterative mechanism that used deferred bmap and rmap operations to
swap mappings one at a time.
This mechanism is identical to steps 2-3 from the procedure above except for
the new tracking items, because the atomic file mapping exchange mechanism is
an iteration of an existing mechanism and not something totally novel.
For the narrow case of file defragmentation, the file contents must be
identical, so the recovery guarantees are not much of a gain.</p>
<p>Atomic file content exchanges are much more flexible than the existing swapext
implementations because it can guarantee that the caller never sees a mix of
old and new contents even after a crash, and it can operate on two arbitrary
file fork ranges.
The extra flexibility enables several new use cases:</p>
<ul class="simple">
<li><p><strong>Atomic commit of file writes</strong>: A userspace process opens a file that it
wants to update.
Next, it opens a temporary file and calls the file clone operation to reflink
the first file’s contents into the temporary file.
Writes to the original file should instead be written to the temporary file.
Finally, the process calls the atomic file mapping exchange system call
(<code class="docutils literal notranslate"><span class="pre">XFS_IOC_EXCHANGE_RANGE</span></code>) to exchange the file contents, thereby
committing all of the updates to the original file, or none of them.</p></li>
</ul>
<ul class="simple" id="exchrange-if-unchanged">
<li><p><strong>Transactional file updates</strong>: The same mechanism as above, but the caller
only wants the commit to occur if the original file’s contents have not
changed.
To make this happen, the calling process snapshots the file modification and
change timestamps of the original file before reflinking its data to the
temporary file.
When the program is ready to commit the changes, it passes the timestamps
into the kernel as arguments to the atomic file mapping exchange system call.
The kernel only commits the changes if the provided timestamps match the
original file.
A new ioctl (<code class="docutils literal notranslate"><span class="pre">XFS_IOC_COMMIT_RANGE</span></code>) is provided to perform this.</p></li>
<li><p><strong>Emulation of atomic block device writes</strong>: Export a block device with a
logical sector size matching the filesystem block size to force all writes
to be aligned to the filesystem block size.
Stage all writes to a temporary file, and when that is complete, call the
atomic file mapping exchange system call with a flag to indicate that holes
in the temporary file should be ignored.
This emulates an atomic device write in software, and can support arbitrary
scattered writes.</p></li>
</ul>
</section>
</section>
<section id="vectorized-scrub">
<h3><a class="toc-backref" href="#id118" role="doc-backlink"><span class="section-number">4.7.2. </span>Vectorized Scrub</a><a class="headerlink" href="#vectorized-scrub" title="Link to this heading">¶</a></h3>
<p>As it turns out, the <a class="reference internal" href="#scrubrepair"><span class="std std-ref">refactoring</span></a> of repair items mentioned
earlier was a catalyst for enabling a vectorized scrub system call.
Since 2018, the cost of making a kernel call has increased considerably on some
systems to mitigate the effects of speculative execution attacks.
This incentivizes program authors to make as few system calls as possible to
reduce the number of times an execution path crosses a security boundary.</p>
<p>With vectorized scrub, userspace pushes to the kernel the identity of a
filesystem object, a list of scrub types to run against that object, and a
simple representation of the data dependencies between the selected scrub
types.
The kernel executes as much of the caller’s plan as it can until it hits a
dependency that cannot be satisfied due to a corruption, and tells userspace
how much was accomplished.
It is hoped that <code class="docutils literal notranslate"><span class="pre">io_uring</span></code> will pick up enough of this functionality that
online fsck can use that instead of adding a separate vectored scrub system
call to XFS.</p>
<p>The relevant patchsets are the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=vectorized-scrub">kernel vectorized scrub</a>
and
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=vectorized-scrub">userspace vectorized scrub</a>
series.</p>
</section>
<section id="quality-of-service-targets-for-scrub">
<h3><a class="toc-backref" href="#id119" role="doc-backlink"><span class="section-number">4.7.3. </span>Quality of Service Targets for Scrub</a><a class="headerlink" href="#quality-of-service-targets-for-scrub" title="Link to this heading">¶</a></h3>
<p>One serious shortcoming of the online fsck code is that the amount of time that
it can spend in the kernel holding resource locks is basically unbounded.
Userspace is allowed to send a fatal signal to the process which will cause
<code class="docutils literal notranslate"><span class="pre">xfs_scrub</span></code> to exit when it reaches a good stopping point, but there’s no way
for userspace to provide a time budget to the kernel.
Given that the scrub codebase has helpers to detect fatal signals, it shouldn’t
be too much work to allow userspace to specify a timeout for a scrub/repair
operation and abort the operation if it exceeds budget.
However, most repair functions have the property that once they begin to touch
ondisk metadata, the operation cannot be cancelled cleanly, after which a QoS
timeout is no longer useful.</p>
</section>
<section id="defragmenting-free-space">
<h3><a class="toc-backref" href="#id120" role="doc-backlink"><span class="section-number">4.7.4. </span>Defragmenting Free Space</a><a class="headerlink" href="#defragmenting-free-space" title="Link to this heading">¶</a></h3>
<p>Over the years, many XFS users have requested the creation of a program to
clear a portion of the physical storage underlying a filesystem so that it
becomes a contiguous chunk of free space.
Call this free space defragmenter <code class="docutils literal notranslate"><span class="pre">clearspace</span></code> for short.</p>
<p>The first piece the <code class="docutils literal notranslate"><span class="pre">clearspace</span></code> program needs is the ability to read the
reverse mapping index from userspace.
This already exists in the form of the <code class="docutils literal notranslate"><span class="pre">FS_IOC_GETFSMAP</span></code> ioctl.
The second piece it needs is a new fallocate mode
(<code class="docutils literal notranslate"><span class="pre">FALLOC_FL_MAP_FREE_SPACE</span></code>) that allocates the free space in a region and
maps it to a file.
Call this file the “space collector” file.
The third piece is the ability to force an online repair.</p>
<p>To clear all the metadata out of a portion of physical storage, clearspace
uses the new fallocate map-freespace call to map any free space in that region
to the space collector file.
Next, clearspace finds all metadata blocks in that region by way of
<code class="docutils literal notranslate"><span class="pre">GETFSMAP</span></code> and issues forced repair requests on the data structure.
This often results in the metadata being rebuilt somewhere that is not being
cleared.
After each relocation, clearspace calls the “map free space” function again to
collect any newly freed space in the region being cleared.</p>
<p>To clear all the file data out of a portion of the physical storage, clearspace
uses the FSMAP information to find relevant file data blocks.
Having identified a good target, it uses the <code class="docutils literal notranslate"><span class="pre">FICLONERANGE</span></code> call on that part
of the file to try to share the physical space with a dummy file.
Cloning the extent means that the original owners cannot overwrite the
contents; any changes will be written somewhere else via copy-on-write.
Clearspace makes its own copy of the frozen extent in an area that is not being
cleared, and uses <code class="docutils literal notranslate"><span class="pre">FIEDEUPRANGE</span></code> (or the <a class="reference internal" href="#exchrange-if-unchanged"><span class="std std-ref">atomic file content exchanges</span></a> feature) to change the target file’s data extent
mapping away from the area being cleared.
When all other mappings have been moved, clearspace reflinks the space into the
space collector file so that it becomes unavailable.</p>
<p>There are further optimizations that could apply to the above algorithm.
To clear a piece of physical storage that has a high sharing factor, it is
strongly desirable to retain this sharing factor.
In fact, these extents should be moved first to maximize sharing factor after
the operation completes.
To make this work smoothly, clearspace needs a new ioctl
(<code class="docutils literal notranslate"><span class="pre">FS_IOC_GETREFCOUNTS</span></code>) to report reference count information to userspace.
With the refcount information exposed, clearspace can quickly find the longest,
most shared data extents in the filesystem, and target them first.</p>
<p><strong>Future Work Question</strong>: How might the filesystem move inode chunks?</p>
<p><em>Answer</em>: To move inode chunks, Dave Chinner constructed a prototype program
that creates a new file with the old contents and then locklessly runs around
the filesystem updating directory entries.
The operation cannot complete if the filesystem goes down.
That problem isn’t totally insurmountable: create an inode remapping table
hidden behind a jump label, and a log item that tracks the kernel walking the
filesystem to update directory entries.
The trouble is, the kernel can’t do anything about open files, since it cannot
revoke them.</p>
<p><strong>Future Work Question</strong>: Can static keys be used to minimize the cost of
supporting <code class="docutils literal notranslate"><span class="pre">revoke()</span></code> on XFS files?</p>
<p><em>Answer</em>: Yes.
Until the first revocation, the bailout code need not be in the call path at
all.</p>
<p>The relevant patchsets are the
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfs-linux.git/log/?h=defrag-freespace">kernel freespace defrag</a>
and
<a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/djwong/xfsprogs-dev.git/log/?h=defrag-freespace">userspace freespace defrag</a>
series.</p>
</section>
<section id="shrinking-filesystems">
<h3><a class="toc-backref" href="#id121" role="doc-backlink"><span class="section-number">4.7.5. </span>Shrinking Filesystems</a><a class="headerlink" href="#shrinking-filesystems" title="Link to this heading">¶</a></h3>
<p>Removing the end of the filesystem ought to be a simple matter of evacuating
the data and metadata at the end of the filesystem, and handing the freed space
to the shrink code.
That requires an evacuation of the space at end of the filesystem, which is a
use of free space defragmentation!</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../../_sources/filesystems/xfs/xfs-online-fsck-design.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>