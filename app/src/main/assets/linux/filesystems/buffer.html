<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Buffer Heads &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Linux Journalling API" href="journalling.html" />
    <link rel="prev" title="Changes since 2.5.0:" href="porting.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.13.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/buffer.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="buffer-heads">
<h1>Buffer Heads<a class="headerlink" href="#buffer-heads" title="Link to this heading">¶</a></h1>
<p>Linux uses buffer heads to maintain state about individual filesystem blocks.
Buffer heads are deprecated and new filesystems should use iomap instead.</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.brelse">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">brelse</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bh</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.brelse" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release a buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>The buffer to release.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement a buffer_head’s reference count.  If <strong>bh</strong> is NULL, this
function is a no-op.</p>
<p>If all buffers on a folio have zero reference count, are clean
and unlocked, and if the folio is unlocked and not under writeback
then <a class="reference internal" href="#c.try_to_free_buffers" title="try_to_free_buffers"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_to_free_buffers()</span></code></a> may strip the buffers from the folio in
preparation for freeing it (sometimes, rarely, buffers are removed
from a folio but it ends up not being freed, and buffers may later
be reattached).</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bforget">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bforget</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bh</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bforget" title="Link to this definition">¶</a><br /></dt>
<dd><p>Discard any dirty data in a buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>The buffer to forget.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function instead of <a class="reference internal" href="#c.brelse" title="brelse"><code class="xref c c-func docutils literal notranslate"><span class="pre">brelse()</span></code></a> if the data written to a buffer
no longer needs to be written back.  It will clear the buffer’s dirty
flag so writeback of this buffer will be skipped.</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__bread">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__bread</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">block</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__bread" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read a block.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>The block device to read from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt><dd><p>Block number in units of block size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">size</span></code></dt><dd><p>The block size of this device in bytes.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read a specified block, and return the buffer head that refers
to it.  The memory is allocated from the movable area so that it can
be migrated.  The returned buffer head has its refcount increased.
The caller should call <a class="reference internal" href="#c.brelse" title="brelse"><code class="xref c c-func docutils literal notranslate"><span class="pre">brelse()</span></code></a> when it has finished with the buffer.</p>
<p><strong>Context</strong></p>
<p>May sleep waiting for I/O.</p>
<p><strong>Return</strong></p>
<p>NULL if the block was unreadable.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.get_nth_bh">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">get_nth_bh</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bh</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.get_nth_bh" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a reference on the n’th buffer after this one.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>The buffer to start counting from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>How many buffers to skip.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is primarily useful for finding the nth buffer in a folio; in
that case you pass the head buffer and the byte offset in the folio
divided by the block size.  It can be used for other purposes, but
it will wrap at the end of the folio rather than returning NULL or
proceeding to the next folio for you.</p>
<p><strong>Return</strong></p>
<p>The requested buffer with an elevated refcount.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.sync_mapping_buffers">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sync_mapping_buffers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_mapping_buffers" title="Link to this definition">¶</a><br /></dt>
<dd><p>write out &amp; wait upon a mapping’s “associated” buffers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>the mapping which wants those buffers written</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Starts I/O against the buffers at mapping-&gt;i_private_list, and waits upon
that I/O.</p>
<p>Basically, this is a convenience function for fsync().
<strong>mapping</strong> is a file or directory which needs those buffers to be written for
a successful fsync().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_buffers_fsync_noflush">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_buffers_fsync_noflush</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.generic_buffers_fsync_noflush" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">datasync</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_buffers_fsync_noflush" title="Link to this definition">¶</a><br /></dt>
<dd><p>generic buffer fsync implementation for simple filesystems with no inode lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file to synchronize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>start offset in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt><dd><p>end offset in bytes (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">datasync</span></code></dt><dd><p>only synchronize essential metadata if true</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a generic implementation of the fsync method for simple
filesystems which track all non-inode metadata in the buffers list
hanging off the address_space structure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.generic_buffers_fsync">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">generic_buffers_fsync</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.generic_buffers_fsync" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">loff_t</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">datasync</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_buffers_fsync" title="Link to this definition">¶</a><br /></dt>
<dd><p>generic buffer fsync implementation for simple filesystems with no inode lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file to synchronize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt><dd><p>start offset in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt><dd><p>end offset in bytes (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">datasync</span></code></dt><dd><p>only synchronize essential metadata if true</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a generic implementation of the fsync method for simple
filesystems which track all non-inode metadata in the buffers list
hanging off the address_space structure. This also makes sure that
a device cache flush operation is called at the end.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.block_dirty_folio">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">block_dirty_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.block_dirty_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.block_dirty_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Mark a folio as dirty.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space containing this folio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio to mark dirty.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filesystems which use buffer_heads can use this function as their
-&gt;dirty_folio implementation.  Some filesystems need to do a little
work before calling this function.  Filesystems which do not use
buffer_heads should call <a class="reference internal" href="../core-api/mm-api.html#c.filemap_dirty_folio" title="filemap_dirty_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_dirty_folio()</span></code></a> instead.</p>
<p>If the folio has buffers, the uptodate buffers are set dirty, to
preserve dirty-state coherency between the folio and the buffers.
Buffers added to a dirty folio are created dirty.</p>
<p>The buffers are dirtied before the folio is dirtied.  There’s a small
race window in which writeback may see the folio cleanness but not the
buffer dirtiness.  That’s fine.  If this code were to set the folio
dirty before the buffers, writeback could clear the folio dirty flag,
see a bunch of clean buffers and we’d end up with dirty buffers/clean
folio on the dirty folio list.</p>
<p>We use i_private_lock to lock against <a class="reference internal" href="#c.try_to_free_buffers" title="try_to_free_buffers"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_to_free_buffers()</span></code></a> while
using the folio’s buffer list.  This also prevents clean buffers
being added to the folio after it was set dirty.</p>
<p><strong>Context</strong></p>
<p>May only be called from process context.  Does not sleep.
Caller must ensure that <strong>folio</strong> cannot be truncated during this call,
typically by holding the folio lock or having a page in the folio
mapped and holding the page table lock.</p>
<p><strong>Return</strong></p>
<p>True if the folio was dirtied; false if it was already dirtied.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.mark_buffer_dirty">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mark_buffer_dirty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bh</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mark_buffer_dirty" title="Link to this definition">¶</a><br /></dt>
<dd><p>mark a buffer_head as needing writeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>the buffer_head to mark dirty</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mark_buffer_dirty" title="mark_buffer_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">mark_buffer_dirty()</span></code></a> will set the dirty bit against the buffer, then set
its backing page dirty, then tag the page as dirty in the page cache
and then attach the address_space’s inode to its superblock’s dirty
inode list.</p>
<p><a class="reference internal" href="#c.mark_buffer_dirty" title="mark_buffer_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">mark_buffer_dirty()</span></code></a> is atomic.  It takes bh-&gt;b_folio-&gt;mapping-&gt;i_private_lock,
i_pages lock and mapping-&gt;host-&gt;i_lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__brelse">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__brelse</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bh</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__brelse" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release a buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>The buffer to release.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.brelse" title="brelse"><code class="xref c c-func docutils literal notranslate"><span class="pre">brelse()</span></code></a> can be called if <strong>bh</strong> is guaranteed to not be NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__bforget">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__bforget</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bh</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__bforget" title="Link to this definition">¶</a><br /></dt>
<dd><p>Discard any dirty data in a buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>The buffer to forget.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.bforget" title="bforget"><code class="xref c c-func docutils literal notranslate"><span class="pre">bforget()</span></code></a> can be called if <strong>bh</strong> is guaranteed to not
be NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bdev_getblk">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">bdev_getblk</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">block</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bdev_getblk" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a buffer_head in a block device’s buffer cache.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>The block device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt><dd><p>The block number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">size</span></code></dt><dd><p>The size of buffer_heads for this <strong>bdev</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>The memory allocation flags to use.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned buffer head has its reference count incremented, but is
not locked.  The caller should call <a class="reference internal" href="#c.brelse" title="brelse"><code class="xref c c-func docutils literal notranslate"><span class="pre">brelse()</span></code></a> when it has finished
with the buffer.  The buffer may not be uptodate.  If needed, the
caller can bring it uptodate either by reading it or overwriting it.</p>
<p><strong>Return</strong></p>
<p>The buffer head, or NULL if memory could not be allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__bread_gfp">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">__bread_gfp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">block</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__bread_gfp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read a block.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>The block device to read from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt><dd><p>Block number in units of block size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">size</span></code></dt><dd><p>The block size of this device in bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Not page allocation flags; see below.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>You are not expected to call this function.  You should use one of
sb_bread(), sb_bread_unmovable() or <a class="reference internal" href="#c.__bread" title="__bread"><code class="xref c c-func docutils literal notranslate"><span class="pre">__bread()</span></code></a>.</p>
<p>Read a specified block, and return the buffer head that refers to it.
If <strong>gfp</strong> is 0, the memory will be allocated using the block device’s
default GFP flags.  If <strong>gfp</strong> is __GFP_MOVABLE, the memory may be
allocated from a movable area.  Do not pass in a complete set of
GFP flags.</p>
<p>The returned buffer head has its refcount increased.  The caller should
call <a class="reference internal" href="#c.brelse" title="brelse"><code class="xref c c-func docutils literal notranslate"><span class="pre">brelse()</span></code></a> when it has finished with the buffer.</p>
<p><strong>Context</strong></p>
<p>May sleep waiting for I/O.</p>
<p><strong>Return</strong></p>
<p>NULL if the block was unreadable.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.block_invalidate_folio">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">block_invalidate_folio</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.block_invalidate_folio" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">offset</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.block_invalidate_folio" title="Link to this definition">¶</a><br /></dt>
<dd><p>Invalidate part or all of a buffer-backed folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio which is affected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt><dd><p>start of the range to invalidate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of the range to invalidate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.block_invalidate_folio" title="block_invalidate_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">block_invalidate_folio()</span></code></a> is called when all or part of the folio has been
invalidated by a truncate operation.</p>
<p><a class="reference internal" href="#c.block_invalidate_folio" title="block_invalidate_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">block_invalidate_folio()</span></code></a> does not have to release all buffers, but it must
ensure that no dirty buffer is left outside <strong>offset</strong> and that no I/O
is underway against any of the blocks which are outside the truncation
point.  Because the caller is about to free (and possibly reuse) those
blocks on-disk.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.clean_bdev_aliases">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clean_bdev_aliases</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">block_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">block</span></span>, <span class="n"><span class="pre">sector_t</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.clean_bdev_aliases" title="Link to this definition">¶</a><br /></dt>
<dd><p>clean a range of buffers in block device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>Block device to clean buffers in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt><dd><p>Start of a range of blocks to clean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">len</span></code></dt><dd><p>Number of blocks to clean</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We are taking a range of blocks for data and we don’t want writeback of any
buffer-cache aliases starting from return from this function and until the
moment when something will explicitly mark the buffer dirty (hopefully that
will not happen until we will free that block ;-) We don’t even need to mark
it not-uptodate - nobody can expect anything from a newly allocated buffer
anyway. We used to use unmap_buffer() for such invalidation, but that was
wrong. We definitely don’t want to mark the alias unmapped, for example - it
would confuse anyone who might pick it with bread() afterwards...</p>
<p>Also..  Note that <a class="reference internal" href="#c.bforget" title="bforget"><code class="xref c c-func docutils literal notranslate"><span class="pre">bforget()</span></code></a> doesn’t lock the buffer.  So there can be
writeout I/O going on against recently-freed buffers.  We don’t wait on that
I/O in <a class="reference internal" href="#c.bforget" title="bforget"><code class="xref c c-func docutils literal notranslate"><span class="pre">bforget()</span></code></a> - it’s more efficient to wait on the I/O only if we really
need to.  That happens here.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.try_to_free_buffers">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">try_to_free_buffers</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.try_to_free_buffers" title="folio"><span class="n"><span class="pre">folio</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">folio</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_free_buffers" title="Link to this definition">¶</a><br /></dt>
<dd><p>Release buffers attached to this folio.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt><dd><p>The folio.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If any buffers are in use (dirty, under writeback, elevated refcount),
no buffers will be freed.</p>
<p>If the folio is dirty but all the buffers are clean then we need to
be sure to mark the folio clean as well.  This is because the folio
may be against a block device, and a later reattachment of buffers
to a dirty folio will set <em>all</em> buffers dirty.  Which would corrupt
filesystem data on the same device.</p>
<p>The same applies to regular filesystem folios: if all the buffers are
clean then we set the folio clean and proceed.  To do that, we require
total exclusion from <a class="reference internal" href="#c.block_dirty_folio" title="block_dirty_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">block_dirty_folio()</span></code></a>.  That is obtained with
i_private_lock.</p>
<p>Exclusion against try_to_free_buffers may be obtained by either
locking the folio or by holding its mapping’s i_private_lock.</p>
<p><strong>Context</strong></p>
<p>Process context.  <strong>folio</strong> must be locked.  Will not sleep.</p>
<p><strong>Return</strong></p>
<p>true if all buffers attached to this folio were freed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.bh_uptodate_or_lock">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bh_uptodate_or_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bh</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.bh_uptodate_or_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>Test whether the buffer is uptodate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>struct buffer_head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the buffer is up-to-date and false,
with the buffer locked, if not.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__bh_read">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__bh_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bh</span></span>, <span class="n"><span class="pre">blk_opf_t</span></span><span class="w"> </span><span class="n"><span class="pre">op_flags</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">wait</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__bh_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>Submit read for a locked buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bh</span></code></dt><dd><p>struct buffer_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">op_flags</span></code></dt><dd><p>appending REQ_OP_* flags besides REQ_OP_READ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wait</span></code></dt><dd><p>wait until reading finish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero on success or don’t wait, and -EIO on error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__bh_read_batch">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__bh_read_batch</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">buffer_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bhs</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="n"><span class="pre">blk_opf_t</span></span><span class="w"> </span><span class="n"><span class="pre">op_flags</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">force_lock</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__bh_read_batch" title="Link to this definition">¶</a><br /></dt>
<dd><p>Submit read for a batch of unlocked buffers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>entry number of the buffer batch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*bhs[]</span></code></dt><dd><p>a batch of struct buffer_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">op_flags</span></code></dt><dd><p>appending REQ_OP_* flags besides REQ_OP_READ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_lock</span></code></dt><dd><p>force to get a lock on the buffer if set, otherwise drops any
buffer that cannot lock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero on success or don’t wait, and -EIO on error.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/filesystems/buffer.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>