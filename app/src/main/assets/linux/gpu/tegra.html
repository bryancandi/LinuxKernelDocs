<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>drm/tegra NVIDIA Tegra GPU and display driver &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=3918102e" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="drm/tve200 Faraday TV Encoder 200" href="tve200.html" />
    <link rel="prev" title="drm/pl111 ARM PrimeCell PL110 and PL111 CLCD Driver" href="pl111.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.12.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../input/index.html">Input Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gpu/tegra.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="drm-tegra-nvidia-tegra-gpu-and-display-driver">
<h1>drm/tegra NVIDIA Tegra GPU and display driver<a class="headerlink" href="#drm-tegra-nvidia-tegra-gpu-and-display-driver" title="Link to this heading">¶</a></h1>
<p>NVIDIA Tegra SoCs support a set of display, graphics and video functions via
the host1x controller. host1x supplies command streams, gathered from a push
buffer provided directly by the CPU, to its clients via channels. Software,
or blocks amongst themselves, can use syncpoints for synchronization.</p>
<p>Up until, but not including, Tegra124 (aka Tegra K1) the drm/tegra driver
supports the built-in GPU, comprised of the gr2d and gr3d engines. Starting
with Tegra124 the GPU is based on the NVIDIA desktop GPU architecture and
supported by the drm/nouveau driver.</p>
<p>The drm/tegra driver supports NVIDIA Tegra SoC generations since Tegra20. It
has three parts:</p>
<blockquote>
<div><ul class="simple">
<li><p>A host1x driver that provides infrastructure and access to the host1x
services.</p></li>
<li><p>A KMS driver that supports the display controllers as well as a number of
outputs, such as RGB, HDMI, DSI, and DisplayPort.</p></li>
<li><p>A set of custom userspace IOCTLs that can be used to submit jobs to the
GPU and video engines via host1x.</p></li>
</ul>
</div></blockquote>
<section id="driver-infrastructure">
<h2>Driver Infrastructure<a class="headerlink" href="#driver-infrastructure" title="Link to this heading">¶</a></h2>
<p>The various host1x clients need to be bound together into a logical device in
order to expose their functionality to users. The infrastructure that supports
this is implemented in the host1x driver. When a driver is registered with the
infrastructure it provides a list of compatible strings specifying the devices
that it needs. The infrastructure creates a logical device and scan the device
tree for matching device nodes, adding the required clients to a list. Drivers
for individual clients register with the infrastructure as well and are added
to the logical host1x device.</p>
<p>Once all clients are available, the infrastructure will initialize the logical
device using a driver-provided function which will set up the bits specific to
the subsystem and in turn initialize each of its clients.</p>
<p>Similarly, when one of the clients is unregistered, the infrastructure will
destroy the logical device by calling back into the driver, which ensures that
the subsystem specific bits are torn down and the clients destroyed in turn.</p>
<section id="host1x-infrastructure-reference">
<h3>Host1x Infrastructure Reference<a class="headerlink" href="#host1x-infrastructure-reference" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.host1x_bo_cache">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_bo_cache</span></span></span><a class="headerlink" href="#c.host1x_bo_cache" title="Link to this definition">¶</a><br /></dt>
<dd><p>host1x buffer object cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct host1x_bo_cache {
    struct list_head mappings;
    struct mutex lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mappings</span></code></dt><dd><p>list of mappings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>synchronizes accesses to the list of mappings</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that entries are not periodically evicted from this cache and instead need to be
explicitly released. This is used primarily for DRM/KMS where the cache’s reference is
released when the last reference to a buffer object represented by a mapping in this
cache is dropped.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.host1x_client_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_client_ops</span></span></span><a class="headerlink" href="#c.host1x_client_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>host1x client operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct host1x_client_ops {
    int (*early_init)(struct host1x_client *client);
    int (*init)(struct host1x_client *client);
    int (*exit)(struct host1x_client *client);
    int (*late_exit)(struct host1x_client *client);
    int (*suspend)(struct host1x_client *client);
    int (*resume)(struct host1x_client *client);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">early_init</span></code></dt><dd><p>host1x client early initialization code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init</span></code></dt><dd><p>host1x client initialization code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exit</span></code></dt><dd><p>host1x client tear down code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">late_exit</span></code></dt><dd><p>host1x client late tear down code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>host1x client suspend code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>host1x client resume code</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.host1x_client">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_client</span></span></span><a class="headerlink" href="#c.host1x_client" title="Link to this definition">¶</a><br /></dt>
<dd><p>host1x client structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct host1x_client {
    struct list_head list;
    struct device *host;
    struct device *dev;
    struct iommu_group *group;
    const struct host1x_client_ops *ops;
    enum host1x_class class;
    struct host1x_channel *channel;
    struct host1x_syncpt **syncpts;
    unsigned int num_syncpts;
    struct host1x_client *parent;
    unsigned int usecount;
    struct mutex lock;
    struct host1x_bo_cache cache;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list node for the host1x client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">host</span></code></dt><dd><p>pointer to <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> representing the host1x controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>pointer to <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> backing this host1x client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">group</span></code></dt><dd><p>IOMMU group that this client is a member of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>host1x client operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class</span></code></dt><dd><p>host1x class represented by this client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>host1x channel associated with this client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syncpts</span></code></dt><dd><p>array of syncpoints requested for this client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_syncpts</span></code></dt><dd><p>number of syncpoints requested for this client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>pointer to parent structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usecount</span></code></dt><dd><p>reference count for this structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>mutex for mutually exclusive concurrency</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache</span></code></dt><dd><p>host1x buffer object cache</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.host1x_driver">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_driver</span></span></span><a class="headerlink" href="#c.host1x_driver" title="Link to this definition">¶</a><br /></dt>
<dd><p>host1x logical device driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct host1x_driver {
    struct device_driver driver;
    const struct of_device_id *subdevs;
    struct list_head list;
    int (*probe)(struct host1x_device *device);
    int (*remove)(struct host1x_device *device);
    void (*shutdown)(struct host1x_device *device);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>core driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subdevs</span></code></dt><dd><p>table of OF device IDs matching subdevices for this driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list node for the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>called when the host1x logical device is probed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>called when the host1x logical device is removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>called when the host1x logical device is shut down</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_device_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_device_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_device_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a host1x logical device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_device</span> <span class="pre">*device</span></code></dt><dd><p>host1x logical device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The driver for the host1x logical device can call this during execution of
its <a class="reference internal" href="#c.host1x_driver" title="host1x_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">host1x_driver.probe</span></code></a> implementation to initialize each of its clients.
The client drivers access the subsystem specific driver data using the
<a class="reference internal" href="#c.host1x_client" title="host1x_client"><code class="xref c c-type docutils literal notranslate"><span class="pre">host1x_client.parent</span></code></a> field and driver data associated with it (usually by
calling dev_get_drvdata()).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_device_exit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_device_exit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_device</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">device</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_device_exit" title="Link to this definition">¶</a><br /></dt>
<dd><p>uninitialize host1x logical device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_device</span> <span class="pre">*device</span></code></dt><dd><p>host1x logical device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the driver for a host1x logical device is unloaded, it can call this
function to tear down each of its clients. Typically this is done after a
subsystem-specific data structure is removed and the functionality can no
longer be used.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_driver_register_full">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_driver_register_full</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.host1x_driver" title="host1x_driver"><span class="n"><span class="pre">host1x_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">module</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_driver_register_full" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a host1x driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_driver</span> <span class="pre">*driver</span></code></dt><dd><p>host1x driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers for host1x logical devices call this function to register a driver
with the infrastructure. Note that since these drive logical devices, the
registration of the driver actually triggers tho logical device creation.
A logical device will be created for each host1x instance.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_driver_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_driver_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.host1x_driver" title="host1x_driver"><span class="n"><span class="pre">host1x_driver</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">driver</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_driver_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a host1x driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_driver</span> <span class="pre">*driver</span></code></dt><dd><p>host1x driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unbinds the driver from each of the host1x logical devices that it is
bound to, effectively removing the subsystem devices that they represent.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__host1x_client_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__host1x_client_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.host1x_client" title="host1x_client"><span class="n"><span class="pre">host1x_client</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">client</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">lock_class_key</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__host1x_client_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a host1x client</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_client</span> <span class="pre">*client</span></code></dt><dd><p>host1x client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*key</span></code></dt><dd><p>lock class key for the client-specific mutex</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_client_exit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_client_exit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.host1x_client" title="host1x_client"><span class="n"><span class="pre">host1x_client</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">client</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_client_exit" title="Link to this definition">¶</a><br /></dt>
<dd><p>uninitialize a host1x client</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_client</span> <span class="pre">*client</span></code></dt><dd><p>host1x client</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.__host1x_client_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">__host1x_client_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.host1x_client" title="host1x_client"><span class="n"><span class="pre">host1x_client</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">client</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__host1x_client_register" title="Link to this definition">¶</a><br /></dt>
<dd><p>register a host1x client</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_client</span> <span class="pre">*client</span></code></dt><dd><p>host1x client</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a host1x client with each host1x controller instance. Note that
each client will only match their parent host1x controller and will only be
associated with that instance. Once all clients have been registered with
their parent host1x controller, the infrastructure will set up the logical
device and call <a class="reference internal" href="#c.host1x_device_init" title="host1x_device_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">host1x_device_init()</span></code></a>, which will in turn call each client’s
<a class="reference internal" href="#c.host1x_client_ops" title="host1x_client_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">host1x_client_ops.init</span></code></a> implementation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_client_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_client_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.host1x_client" title="host1x_client"><span class="n"><span class="pre">host1x_client</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">client</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_client_unregister" title="Link to this definition">¶</a><br /></dt>
<dd><p>unregister a host1x client</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_client</span> <span class="pre">*client</span></code></dt><dd><p>host1x client</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a host1x client from its host1x controller instance. If a logical
device has already been initialized, it will be torn down.</p>
</div>
</section>
<section id="host1x-syncpoint-reference">
<h3>Host1x Syncpoint Reference<a class="headerlink" href="#host1x-syncpoint-reference" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">host</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a syncpoint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x</span> <span class="pre">*host</span></code></dt><dd><p>host1x device data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>bitfield of HOST1X_SYNCPT_* flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name for the syncpoint for use in debug prints</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a hardware syncpoint for the caller’s use. The caller then has
the sole authority to mutate the syncpoint’s value until it is freed again.</p>
<p>If no free syncpoints are available, or a NULL name was specified, returns
NULL.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_id">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_id</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>retrieve syncpoint ID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a pointer to a struct host1x_syncpt, retrieves its ID. This ID is
often used as a value to program into registers that control how hardware
blocks interact with syncpoints.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_incr_max">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_incr_max</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">incrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_incr_max" title="Link to this definition">¶</a><br /></dt>
<dd><p>update the value sent to hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">incrs</span></code></dt><dd><p>number of increments</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_incr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_incr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_incr" title="Link to this definition">¶</a><br /></dt>
<dd><p>increment syncpoint value from CPU, updating cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_wait">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_wait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">thresh</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_wait" title="Link to this definition">¶</a><br /></dt>
<dd><p>wait for a syncpoint to reach a given value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">thresh</span></code></dt><dd><p>threshold</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>maximum time to wait for the syncpoint to reach the given value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*value</span></code></dt><dd><p>return location for the syncpoint value</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_request">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_request</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.host1x_client" title="host1x_client"><span class="n"><span class="pre">host1x_client</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">client</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_request" title="Link to this definition">¶</a><br /></dt>
<dd><p>request a syncpoint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_client</span> <span class="pre">*client</span></code></dt><dd><p>client requesting the syncpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>host1x client drivers can use this function to allocate a syncpoint for
subsequent use. A syncpoint returned by this function will be reserved for
use by the client exclusively. When no longer using a syncpoint, a host1x
client driver needs to release it using <a class="reference internal" href="#c.host1x_syncpt_put" title="host1x_syncpt_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">host1x_syncpt_put()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a requested syncpoint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a syncpoint previously allocated using <a class="reference internal" href="#c.host1x_syncpt_request" title="host1x_syncpt_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">host1x_syncpt_request()</span></code></a>. A
host1x client driver should call this when the syncpoint is no longer in
use.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_read_max">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_read_max</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_read_max" title="Link to this definition">¶</a><br /></dt>
<dd><p>read maximum syncpoint value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The maximum syncpoint value indicates how many operations there are in
queue, either in channel or in a software thread.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_read_min">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_read_min</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_read_min" title="Link to this definition">¶</a><br /></dt>
<dd><p>read minimum syncpoint value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The minimum syncpoint value is a shadow of the current sync point value in
hardware.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_read">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_read</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>read the current syncpoint value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_get_by_id">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_get_by_id</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">host</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_get_by_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>obtain a syncpoint by ID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x</span> <span class="pre">*host</span></code></dt><dd><p>host1x controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>syncpoint ID</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_get_by_id_noref">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_get_by_id_noref</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">host</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_get_by_id_noref" title="Link to this definition">¶</a><br /></dt>
<dd><p>obtain a syncpoint by ID but don’t increase the refcount.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x</span> <span class="pre">*host</span></code></dt><dd><p>host1x controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>syncpoint ID</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>increment syncpoint refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>syncpoint</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_get_base">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt_base</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_get_base</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_get_base" title="Link to this definition">¶</a><br /></dt>
<dd><p>obtain the wait base associated with a syncpoint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt</span> <span class="pre">*sp</span></code></dt><dd><p>host1x syncpoint</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_base_id">
<span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_base_id</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">host1x_syncpt_base</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_base_id" title="Link to this definition">¶</a><br /></dt>
<dd><p>retrieve the ID of a syncpoint wait base</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_syncpt_base</span> <span class="pre">*base</span></code></dt><dd><p>host1x syncpoint wait base</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.host1x_syncpt_release_vblank_reservation">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">host1x_syncpt_release_vblank_reservation</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.host1x_client" title="host1x_client"><span class="n"><span class="pre">host1x_client</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">client</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">syncpt_id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.host1x_syncpt_release_vblank_reservation" title="Link to this definition">¶</a><br /></dt>
<dd><p>Make VBLANK syncpoint available for allocation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">host1x_client</span> <span class="pre">*client</span></code></dt><dd><p>host1x bus client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">syncpt_id</span></code></dt><dd><p>syncpoint ID to make available</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes VBLANK&lt;i&gt; syncpoint available for allocatation if it was
reserved at initialization time. This should be called by the display
driver after it has ensured that any VBLANK increment programming configured
by the boot chain has been disabled.</p>
</div>
</section>
</section>
<section id="kms-driver">
<h2>KMS driver<a class="headerlink" href="#kms-driver" title="Link to this heading">¶</a></h2>
<p>The display hardware has remained mostly backwards compatible over the various
Tegra SoC generations, up until Tegra186 which introduces several changes that
make it difficult to support with a parameterized driver.</p>
<section id="display-controllers">
<h3>Display Controllers<a class="headerlink" href="#display-controllers" title="Link to this heading">¶</a></h3>
<p>Tegra SoCs have two display controllers, each of which can be associated with
zero or more outputs. Outputs can also share a single display controller, but
only if they run with compatible display timings. Two display controllers can
also share a single framebuffer, allowing cloned configurations even if modes
on two outputs don’t match. A display controller is modelled as a CRTC in KMS
terms.</p>
<p>On Tegra186, the number of display controllers has been increased to three. A
display controller can no longer drive all of the outputs. While two of these
controllers can drive both DSI outputs and both SOR outputs, the third cannot
drive any DSI.</p>
<section id="windows">
<h4>Windows<a class="headerlink" href="#windows" title="Link to this heading">¶</a></h4>
<p>A display controller controls a set of windows that can be used to composite
multiple buffers onto the screen. While it is possible to assign arbitrary Z
ordering to individual windows (by programming the corresponding blending
registers), this is currently not supported by the driver. Instead, it will
assume a fixed Z ordering of the windows (window A is the root window, that
is, the lowest, while windows B and C are overlaid on top of window A). The
overlay windows support multiple pixel formats and can automatically convert
from YUV to RGB at scanout time. This makes them useful for displaying video
content. In KMS, each window is modelled as a plane. Each display controller
has a hardware cursor that is exposed as a cursor plane.</p>
</section>
</section>
<section id="outputs">
<h3>Outputs<a class="headerlink" href="#outputs" title="Link to this heading">¶</a></h3>
<p>The type and number of supported outputs varies between Tegra SoC generations.
All generations support at least HDMI. While earlier generations supported the
very simple RGB interfaces (one per display controller), recent generations no
longer do and instead provide standard interfaces such as DSI and eDP/DP.</p>
<p>Outputs are modelled as a composite encoder/connector pair.</p>
<section id="rgb-lvds">
<h4>RGB/LVDS<a class="headerlink" href="#rgb-lvds" title="Link to this heading">¶</a></h4>
<p>This interface is no longer available since Tegra124. It has been replaced by
the more standard DSI and eDP interfaces.</p>
</section>
<section id="hdmi">
<h4>HDMI<a class="headerlink" href="#hdmi" title="Link to this heading">¶</a></h4>
<p>HDMI is supported on all Tegra SoCs. Starting with Tegra210, HDMI is provided
by the versatile SOR output, which supports eDP, DP and HDMI. The SOR is able
to support HDMI 2.0, though support for this is currently not merged.</p>
</section>
<section id="dsi">
<h4>DSI<a class="headerlink" href="#dsi" title="Link to this heading">¶</a></h4>
<p>Although Tegra has supported DSI since Tegra30, the controller has changed in
several ways in Tegra114. Since none of the publicly available development
boards prior to Dalmore (Tegra114) have made use of DSI, only Tegra114 and
later are supported by the drm/tegra driver.</p>
</section>
<section id="edp-dp">
<h4>eDP/DP<a class="headerlink" href="#edp-dp" title="Link to this heading">¶</a></h4>
<p>eDP was first introduced in Tegra124 where it was used to drive the display
panel for notebook form factors. Tegra210 added support for full DisplayPort
support, though this is currently not implemented in the drm/tegra driver.</p>
</section>
</section>
</section>
<section id="userspace-interface">
<h2>Userspace Interface<a class="headerlink" href="#userspace-interface" title="Link to this heading">¶</a></h2>
<p>The userspace interface provided by drm/tegra allows applications to create
GEM buffers, access and control syncpoints as well as submit command streams
to host1x.</p>
<section id="gem-buffers">
<h3>GEM Buffers<a class="headerlink" href="#gem-buffers" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_GEM_CREATE</span></code> IOCTL is used to create a GEM buffer object
with Tegra-specific flags. This is useful for buffers that should be tiled, or
that are to be scanned out upside down (useful for 3D content).</p>
<p>After a GEM buffer object has been created, its memory can be mapped by an
application using the mmap offset returned by the <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_GEM_MMAP</span></code>
IOCTL.</p>
</section>
<section id="syncpoints">
<h3>Syncpoints<a class="headerlink" href="#syncpoints" title="Link to this heading">¶</a></h3>
<p>The current value of a syncpoint can be obtained by executing the
<code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_SYNCPT_READ</span></code> IOCTL. Incrementing the syncpoint is achieved
using the <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_SYNCPT_INCR</span></code> IOCTL.</p>
<p>Userspace can also request blocking on a syncpoint. To do so, it needs to
execute the <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_SYNCPT_WAIT</span></code> IOCTL, specifying the value of
the syncpoint to wait for. The kernel will release the application when the
syncpoint reaches that value or after a specified timeout.</p>
</section>
<section id="command-stream-submission">
<h3>Command Stream Submission<a class="headerlink" href="#command-stream-submission" title="Link to this heading">¶</a></h3>
<p>Before an application can submit command streams to host1x it needs to open a
channel to an engine using the <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_OPEN_CHANNEL</span></code> IOCTL. Client
IDs are used to identify the target of the channel. When a channel is no
longer needed, it can be closed using the <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_CLOSE_CHANNEL</span></code>
IOCTL. To retrieve the syncpoint associated with a channel, an application
can use the <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_GET_SYNCPT</span></code>.</p>
<p>After opening a channel, submitting command streams is easy. The application
writes commands into the memory backing a GEM buffer object and passes these
to the <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL_TEGRA_SUBMIT</span></code> IOCTL along with various other parameters,
such as the syncpoints or relocations used in the job submission.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/gpu/tegra.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>